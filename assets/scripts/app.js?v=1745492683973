(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a3, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a3, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a3, prop, b2[prop]);
      }
    return a3;
  };
  var __spreadProps = (a3, b2) => __defProps(a3, __getOwnPropDescs(b2));
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e4) {
          reject(e4);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e4) {
          reject(e4);
        }
      };
      var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/@barba/core/dist/barba.umd.js
  var require_barba_umd = __commonJS({
    "node_modules/@barba/core/dist/barba.umd.js"(exports, module) {
      !function(t3, n4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = n4() : "function" == typeof define && define.amd ? define(n4) : (t3 = t3 || self).barba = n4();
      }(exports, function() {
        function t3(t4, n5) {
          for (var r4 = 0; r4 < n5.length; r4++) {
            var e5 = n5[r4];
            e5.enumerable = e5.enumerable || false, e5.configurable = true, "value" in e5 && (e5.writable = true), Object.defineProperty(t4, e5.key, e5);
          }
        }
        function n4(n5, r4, e5) {
          return r4 && t3(n5.prototype, r4), e5 && t3(n5, e5), n5;
        }
        function r3() {
          return (r3 = Object.assign || function(t4) {
            for (var n5 = 1; n5 < arguments.length; n5++) {
              var r4 = arguments[n5];
              for (var e5 in r4) Object.prototype.hasOwnProperty.call(r4, e5) && (t4[e5] = r4[e5]);
            }
            return t4;
          }).apply(this, arguments);
        }
        function e4(t4, n5) {
          t4.prototype = Object.create(n5.prototype), t4.prototype.constructor = t4, t4.__proto__ = n5;
        }
        function i4(t4) {
          return (i4 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t5) {
            return t5.__proto__ || Object.getPrototypeOf(t5);
          })(t4);
        }
        function o4(t4, n5) {
          return (o4 = Object.setPrototypeOf || function(t5, n6) {
            return t5.__proto__ = n6, t5;
          })(t4, n5);
        }
        function u2(t4, n5, r4) {
          return (u2 = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (t5) {
              return false;
            }
          }() ? Reflect.construct : function(t5, n6, r5) {
            var e5 = [null];
            e5.push.apply(e5, n6);
            var i5 = new (Function.bind.apply(t5, e5))();
            return r5 && o4(i5, r5.prototype), i5;
          }).apply(null, arguments);
        }
        function f2(t4) {
          var n5 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return (f2 = function(t5) {
            if (null === t5 || -1 === Function.toString.call(t5).indexOf("[native code]")) return t5;
            if ("function" != typeof t5) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== n5) {
              if (n5.has(t5)) return n5.get(t5);
              n5.set(t5, r4);
            }
            function r4() {
              return u2(t5, arguments, i4(this).constructor);
            }
            return r4.prototype = Object.create(t5.prototype, { constructor: { value: r4, enumerable: false, writable: true, configurable: true } }), o4(r4, t5);
          })(t4);
        }
        function s4(t4, n5) {
          try {
            var r4 = t4();
          } catch (t5) {
            return n5(t5);
          }
          return r4 && r4.then ? r4.then(void 0, n5) : r4;
        }
        "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
        var c3, a3 = "2.9.7", h4 = function() {
        };
        !function(t4) {
          t4[t4.off = 0] = "off", t4[t4.error = 1] = "error", t4[t4.warning = 2] = "warning", t4[t4.info = 3] = "info", t4[t4.debug = 4] = "debug";
        }(c3 || (c3 = {}));
        var v2 = c3.off, l4 = function() {
          function t4(t5) {
            this.t = t5;
          }
          t4.getLevel = function() {
            return v2;
          }, t4.setLevel = function(t5) {
            return v2 = c3[t5];
          };
          var n5 = t4.prototype;
          return n5.error = function() {
            for (var t5 = arguments.length, n6 = new Array(t5), r4 = 0; r4 < t5; r4++) n6[r4] = arguments[r4];
            this.i(console.error, c3.error, n6);
          }, n5.warn = function() {
            for (var t5 = arguments.length, n6 = new Array(t5), r4 = 0; r4 < t5; r4++) n6[r4] = arguments[r4];
            this.i(console.warn, c3.warning, n6);
          }, n5.info = function() {
            for (var t5 = arguments.length, n6 = new Array(t5), r4 = 0; r4 < t5; r4++) n6[r4] = arguments[r4];
            this.i(console.info, c3.info, n6);
          }, n5.debug = function() {
            for (var t5 = arguments.length, n6 = new Array(t5), r4 = 0; r4 < t5; r4++) n6[r4] = arguments[r4];
            this.i(console.log, c3.debug, n6);
          }, n5.i = function(n6, r4, e5) {
            r4 <= t4.getLevel() && n6.apply(console, ["[" + this.t + "] "].concat(e5));
          }, t4;
        }(), d2 = O2, m2 = E2, p2 = g2, w2 = x2, b2 = T2, y2 = "/", P2 = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");
        function g2(t4, n5) {
          for (var r4, e5 = [], i5 = 0, o5 = 0, u3 = "", f3 = n5 && n5.delimiter || y2, s5 = n5 && n5.whitelist || void 0, c4 = false; null !== (r4 = P2.exec(t4)); ) {
            var a4 = r4[0], h5 = r4[1], v3 = r4.index;
            if (u3 += t4.slice(o5, v3), o5 = v3 + a4.length, h5) u3 += h5[1], c4 = true;
            else {
              var l5 = "", d3 = r4[2], m3 = r4[3], p3 = r4[4], w3 = r4[5];
              if (!c4 && u3.length) {
                var b3 = u3.length - 1, g3 = u3[b3];
                (!s5 || s5.indexOf(g3) > -1) && (l5 = g3, u3 = u3.slice(0, b3));
              }
              u3 && (e5.push(u3), u3 = "", c4 = false);
              var E3 = m3 || p3, x3 = l5 || f3;
              e5.push({ name: d3 || i5++, prefix: l5, delimiter: x3, optional: "?" === w3 || "*" === w3, repeat: "+" === w3 || "*" === w3, pattern: E3 ? A2(E3) : "[^" + k2(x3 === f3 ? x3 : x3 + f3) + "]+?" });
            }
          }
          return (u3 || o5 < t4.length) && e5.push(u3 + t4.substr(o5)), e5;
        }
        function E2(t4, n5) {
          return function(r4, e5) {
            var i5 = t4.exec(r4);
            if (!i5) return false;
            for (var o5 = i5[0], u3 = i5.index, f3 = {}, s5 = e5 && e5.decode || decodeURIComponent, c4 = 1; c4 < i5.length; c4++) if (void 0 !== i5[c4]) {
              var a4 = n5[c4 - 1];
              f3[a4.name] = a4.repeat ? i5[c4].split(a4.delimiter).map(function(t5) {
                return s5(t5, a4);
              }) : s5(i5[c4], a4);
            }
            return { path: o5, index: u3, params: f3 };
          };
        }
        function x2(t4, n5) {
          for (var r4 = new Array(t4.length), e5 = 0; e5 < t4.length; e5++) "object" == typeof t4[e5] && (r4[e5] = new RegExp("^(?:" + t4[e5].pattern + ")$", R2(n5)));
          return function(n6, e6) {
            for (var i5 = "", o5 = e6 && e6.encode || encodeURIComponent, u3 = !e6 || false !== e6.validate, f3 = 0; f3 < t4.length; f3++) {
              var s5 = t4[f3];
              if ("string" != typeof s5) {
                var c4, a4 = n6 ? n6[s5.name] : void 0;
                if (Array.isArray(a4)) {
                  if (!s5.repeat) throw new TypeError('Expected "' + s5.name + '" to not repeat, but got array');
                  if (0 === a4.length) {
                    if (s5.optional) continue;
                    throw new TypeError('Expected "' + s5.name + '" to not be empty');
                  }
                  for (var h5 = 0; h5 < a4.length; h5++) {
                    if (c4 = o5(a4[h5], s5), u3 && !r4[f3].test(c4)) throw new TypeError('Expected all "' + s5.name + '" to match "' + s5.pattern + '"');
                    i5 += (0 === h5 ? s5.prefix : s5.delimiter) + c4;
                  }
                } else if ("string" != typeof a4 && "number" != typeof a4 && "boolean" != typeof a4) {
                  if (!s5.optional) throw new TypeError('Expected "' + s5.name + '" to be ' + (s5.repeat ? "an array" : "a string"));
                } else {
                  if (c4 = o5(String(a4), s5), u3 && !r4[f3].test(c4)) throw new TypeError('Expected "' + s5.name + '" to match "' + s5.pattern + '", but got "' + c4 + '"');
                  i5 += s5.prefix + c4;
                }
              } else i5 += s5;
            }
            return i5;
          };
        }
        function k2(t4) {
          return t4.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
        }
        function A2(t4) {
          return t4.replace(/([=!:$/()])/g, "\\$1");
        }
        function R2(t4) {
          return t4 && t4.sensitive ? "" : "i";
        }
        function T2(t4, n5, r4) {
          for (var e5 = (r4 = r4 || {}).strict, i5 = false !== r4.start, o5 = false !== r4.end, u3 = r4.delimiter || y2, f3 = [].concat(r4.endsWith || []).map(k2).concat("$").join("|"), s5 = i5 ? "^" : "", c4 = 0; c4 < t4.length; c4++) {
            var a4 = t4[c4];
            if ("string" == typeof a4) s5 += k2(a4);
            else {
              var h5 = a4.repeat ? "(?:" + a4.pattern + ")(?:" + k2(a4.delimiter) + "(?:" + a4.pattern + "))*" : a4.pattern;
              n5 && n5.push(a4), s5 += a4.optional ? a4.prefix ? "(?:" + k2(a4.prefix) + "(" + h5 + "))?" : "(" + h5 + ")?" : k2(a4.prefix) + "(" + h5 + ")";
            }
          }
          if (o5) e5 || (s5 += "(?:" + k2(u3) + ")?"), s5 += "$" === f3 ? "$" : "(?=" + f3 + ")";
          else {
            var v3 = t4[t4.length - 1], l5 = "string" == typeof v3 ? v3[v3.length - 1] === u3 : void 0 === v3;
            e5 || (s5 += "(?:" + k2(u3) + "(?=" + f3 + "))?"), l5 || (s5 += "(?=" + k2(u3) + "|" + f3 + ")");
          }
          return new RegExp(s5, R2(r4));
        }
        function O2(t4, n5, r4) {
          return t4 instanceof RegExp ? function(t5, n6) {
            if (!n6) return t5;
            var r5 = t5.source.match(/\((?!\?)/g);
            if (r5) for (var e5 = 0; e5 < r5.length; e5++) n6.push({ name: e5, prefix: null, delimiter: null, optional: false, repeat: false, pattern: null });
            return t5;
          }(t4, n5) : Array.isArray(t4) ? function(t5, n6, r5) {
            for (var e5 = [], i5 = 0; i5 < t5.length; i5++) e5.push(O2(t5[i5], n6, r5).source);
            return new RegExp("(?:" + e5.join("|") + ")", R2(r5));
          }(t4, n5, r4) : function(t5, n6, r5) {
            return T2(g2(t5, r5), n6, r5);
          }(t4, n5, r4);
        }
        d2.match = function(t4, n5) {
          var r4 = [];
          return E2(O2(t4, r4, n5), r4);
        }, d2.regexpToFunction = m2, d2.parse = p2, d2.compile = function(t4, n5) {
          return x2(g2(t4, n5), n5);
        }, d2.tokensToFunction = w2, d2.tokensToRegExp = b2;
        var S2 = { container: "container", history: "history", namespace: "namespace", prefix: "data-barba", prevent: "prevent", wrapper: "wrapper" }, j2 = new (function() {
          function t4() {
            this.o = S2, this.u = new DOMParser();
          }
          var n5 = t4.prototype;
          return n5.toString = function(t5) {
            return t5.outerHTML;
          }, n5.toDocument = function(t5) {
            return this.u.parseFromString(t5, "text/html");
          }, n5.toElement = function(t5) {
            var n6 = document.createElement("div");
            return n6.innerHTML = t5, n6;
          }, n5.getHtml = function(t5) {
            return void 0 === t5 && (t5 = document), this.toString(t5.documentElement);
          }, n5.getWrapper = function(t5) {
            return void 0 === t5 && (t5 = document), t5.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]');
          }, n5.getContainer = function(t5) {
            return void 0 === t5 && (t5 = document), t5.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]');
          }, n5.removeContainer = function(t5) {
            document.body.contains(t5) && t5.parentNode.removeChild(t5);
          }, n5.addContainer = function(t5, n6) {
            var r4 = this.getContainer();
            r4 ? this.s(t5, r4) : n6.appendChild(t5);
          }, n5.getNamespace = function(t5) {
            void 0 === t5 && (t5 = document);
            var n6 = t5.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
            return n6 ? n6.getAttribute(this.o.prefix + "-" + this.o.namespace) : null;
          }, n5.getHref = function(t5) {
            if (t5.tagName && "a" === t5.tagName.toLowerCase()) {
              if ("string" == typeof t5.href) return t5.href;
              var n6 = t5.getAttribute("href") || t5.getAttribute("xlink:href");
              if (n6) return this.resolveUrl(n6.baseVal || n6);
            }
            return null;
          }, n5.resolveUrl = function() {
            for (var t5 = arguments.length, n6 = new Array(t5), r4 = 0; r4 < t5; r4++) n6[r4] = arguments[r4];
            var e5 = n6.length;
            if (0 === e5) throw new Error("resolveUrl requires at least one argument; got none.");
            var i5 = document.createElement("base");
            if (i5.href = arguments[0], 1 === e5) return i5.href;
            var o5 = document.getElementsByTagName("head")[0];
            o5.insertBefore(i5, o5.firstChild);
            for (var u3, f3 = document.createElement("a"), s5 = 1; s5 < e5; s5++) f3.href = arguments[s5], i5.href = u3 = f3.href;
            return o5.removeChild(i5), u3;
          }, n5.s = function(t5, n6) {
            n6.parentNode.insertBefore(t5, n6.nextSibling);
          }, t4;
        }())(), M2 = new (function() {
          function t4() {
            this.h = [], this.v = -1;
          }
          var e5 = t4.prototype;
          return e5.init = function(t5, n5) {
            this.l = "barba";
            var r4 = { ns: n5, scroll: { x: window.scrollX, y: window.scrollY }, url: t5 };
            this.h.push(r4), this.v = 0;
            var e6 = { from: this.l, index: 0, states: [].concat(this.h) };
            window.history && window.history.replaceState(e6, "", t5);
          }, e5.change = function(t5, n5, r4) {
            if (r4 && r4.state) {
              var e6 = r4.state, i5 = e6.index;
              n5 = this.m(this.v - i5), this.replace(e6.states), this.v = i5;
            } else this.add(t5, n5);
            return n5;
          }, e5.add = function(t5, n5) {
            var r4 = this.size, e6 = this.p(n5), i5 = { ns: "tmp", scroll: { x: window.scrollX, y: window.scrollY }, url: t5 };
            this.h.push(i5), this.v = r4;
            var o5 = { from: this.l, index: r4, states: [].concat(this.h) };
            switch (e6) {
              case "push":
                window.history && window.history.pushState(o5, "", t5);
                break;
              case "replace":
                window.history && window.history.replaceState(o5, "", t5);
            }
          }, e5.update = function(t5, n5) {
            var e6 = n5 || this.v, i5 = r3({}, this.get(e6), {}, t5);
            this.set(e6, i5);
          }, e5.remove = function(t5) {
            t5 ? this.h.splice(t5, 1) : this.h.pop(), this.v--;
          }, e5.clear = function() {
            this.h = [], this.v = -1;
          }, e5.replace = function(t5) {
            this.h = t5;
          }, e5.get = function(t5) {
            return this.h[t5];
          }, e5.set = function(t5, n5) {
            return this.h[t5] = n5;
          }, e5.p = function(t5) {
            var n5 = "push", r4 = t5, e6 = S2.prefix + "-" + S2.history;
            return r4.hasAttribute && r4.hasAttribute(e6) && (n5 = r4.getAttribute(e6)), n5;
          }, e5.m = function(t5) {
            return Math.abs(t5) > 1 ? t5 > 0 ? "forward" : "back" : 0 === t5 ? "popstate" : t5 > 0 ? "back" : "forward";
          }, n4(t4, [{ key: "current", get: function() {
            return this.h[this.v];
          } }, { key: "state", get: function() {
            return this.h[this.h.length - 1];
          } }, { key: "previous", get: function() {
            return this.v < 1 ? null : this.h[this.v - 1];
          } }, { key: "size", get: function() {
            return this.h.length;
          } }]), t4;
        }())(), L2 = function(t4, n5) {
          try {
            var r4 = function() {
              if (!n5.next.html) return Promise.resolve(t4).then(function(t5) {
                var r5 = n5.next;
                if (t5) {
                  var e5 = j2.toElement(t5);
                  r5.namespace = j2.getNamespace(e5), r5.container = j2.getContainer(e5), r5.html = t5, M2.update({ ns: r5.namespace });
                  var i5 = j2.toDocument(t5);
                  document.title = i5.title;
                }
              });
            }();
            return Promise.resolve(r4 && r4.then ? r4.then(function() {
            }) : void 0);
          } catch (t5) {
            return Promise.reject(t5);
          }
        }, $3 = d2, _2 = { __proto__: null, update: L2, nextTick: function() {
          return new Promise(function(t4) {
            window.requestAnimationFrame(t4);
          });
        }, pathToRegexp: $3 }, q2 = function() {
          return window.location.origin;
        }, B2 = function(t4) {
          return void 0 === t4 && (t4 = window.location.href), U2(t4).port;
        }, U2 = function(t4) {
          var n5, r4 = t4.match(/:\d+/);
          if (null === r4) /^http/.test(t4) && (n5 = 80), /^https/.test(t4) && (n5 = 443);
          else {
            var e5 = r4[0].substring(1);
            n5 = parseInt(e5, 10);
          }
          var i5, o5 = t4.replace(q2(), ""), u3 = {}, f3 = o5.indexOf("#");
          f3 >= 0 && (i5 = o5.slice(f3 + 1), o5 = o5.slice(0, f3));
          var s5 = o5.indexOf("?");
          return s5 >= 0 && (u3 = D2(o5.slice(s5 + 1)), o5 = o5.slice(0, s5)), { hash: i5, path: o5, port: n5, query: u3 };
        }, D2 = function(t4) {
          return t4.split("&").reduce(function(t5, n5) {
            var r4 = n5.split("=");
            return t5[r4[0]] = r4[1], t5;
          }, {});
        }, F2 = function(t4) {
          return void 0 === t4 && (t4 = window.location.href), t4.replace(/(\/#.*|\/|#.*)$/, "");
        }, H2 = { __proto__: null, getHref: function() {
          return window.location.href;
        }, getOrigin: q2, getPort: B2, getPath: function(t4) {
          return void 0 === t4 && (t4 = window.location.href), U2(t4).path;
        }, parse: U2, parseQuery: D2, clean: F2 };
        function I2(t4, n5, r4) {
          return void 0 === n5 && (n5 = 2e3), new Promise(function(e5, i5) {
            var o5 = new XMLHttpRequest();
            o5.onreadystatechange = function() {
              if (o5.readyState === XMLHttpRequest.DONE) {
                if (200 === o5.status) e5(o5.responseText);
                else if (o5.status) {
                  var n6 = { status: o5.status, statusText: o5.statusText };
                  r4(t4, n6), i5(n6);
                }
              }
            }, o5.ontimeout = function() {
              var e6 = new Error("Timeout error [" + n5 + "]");
              r4(t4, e6), i5(e6);
            }, o5.onerror = function() {
              var n6 = new Error("Fetch error");
              r4(t4, n6), i5(n6);
            }, o5.open("GET", t4), o5.timeout = n5, o5.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), o5.setRequestHeader("x-barba", "yes"), o5.send();
          });
        }
        var C2 = function(t4) {
          return !!t4 && ("object" == typeof t4 || "function" == typeof t4) && "function" == typeof t4.then;
        };
        function N2(t4, n5) {
          return void 0 === n5 && (n5 = {}), function() {
            for (var r4 = arguments.length, e5 = new Array(r4), i5 = 0; i5 < r4; i5++) e5[i5] = arguments[i5];
            var o5 = false, u3 = new Promise(function(r5, i6) {
              n5.async = function() {
                return o5 = true, function(t5, n6) {
                  t5 ? i6(t5) : r5(n6);
                };
              };
              var u4 = t4.apply(n5, e5);
              o5 || (C2(u4) ? u4.then(r5, i6) : r5(u4));
            });
            return u3;
          };
        }
        var X2 = new (function(t4) {
          function n5() {
            var n6;
            return (n6 = t4.call(this) || this).logger = new l4("@barba/core"), n6.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], n6.registered = /* @__PURE__ */ new Map(), n6.init(), n6;
          }
          e4(n5, t4);
          var r4 = n5.prototype;
          return r4.init = function() {
            var t5 = this;
            this.registered.clear(), this.all.forEach(function(n6) {
              t5[n6] || (t5[n6] = function(r5, e5) {
                t5.registered.has(n6) || t5.registered.set(n6, /* @__PURE__ */ new Set()), t5.registered.get(n6).add({ ctx: e5 || {}, fn: r5 });
              });
            });
          }, r4.do = function(t5) {
            for (var n6 = this, r5 = arguments.length, e5 = new Array(r5 > 1 ? r5 - 1 : 0), i5 = 1; i5 < r5; i5++) e5[i5 - 1] = arguments[i5];
            if (this.registered.has(t5)) {
              var o5 = Promise.resolve();
              return this.registered.get(t5).forEach(function(t6) {
                o5 = o5.then(function() {
                  return N2(t6.fn, t6.ctx).apply(void 0, e5);
                });
              }), o5.catch(function(r6) {
                n6.logger.debug("Hook error [" + t5 + "]"), n6.logger.error(r6);
              });
            }
            return Promise.resolve();
          }, r4.clear = function() {
            var t5 = this;
            this.all.forEach(function(n6) {
              delete t5[n6];
            }), this.init();
          }, r4.help = function() {
            this.logger.info("Available hooks: " + this.all.join(","));
            var t5 = [];
            this.registered.forEach(function(n6, r5) {
              return t5.push(r5);
            }), this.logger.info("Registered hooks: " + t5.join(","));
          }, n5;
        }(h4))(), z2 = function() {
          function t4(t5) {
            if (this.P = [], "boolean" == typeof t5) this.g = t5;
            else {
              var n5 = Array.isArray(t5) ? t5 : [t5];
              this.P = n5.map(function(t6) {
                return $3(t6);
              });
            }
          }
          return t4.prototype.checkHref = function(t5) {
            if ("boolean" == typeof this.g) return this.g;
            var n5 = U2(t5).path;
            return this.P.some(function(t6) {
              return null !== t6.exec(n5);
            });
          }, t4;
        }(), G2 = function(t4) {
          function n5(n6) {
            var r4;
            return (r4 = t4.call(this, n6) || this).k = /* @__PURE__ */ new Map(), r4;
          }
          e4(n5, t4);
          var i5 = n5.prototype;
          return i5.set = function(t5, n6, r4) {
            return this.k.set(t5, { action: r4, request: n6 }), { action: r4, request: n6 };
          }, i5.get = function(t5) {
            return this.k.get(t5);
          }, i5.getRequest = function(t5) {
            return this.k.get(t5).request;
          }, i5.getAction = function(t5) {
            return this.k.get(t5).action;
          }, i5.has = function(t5) {
            return !this.checkHref(t5) && this.k.has(t5);
          }, i5.delete = function(t5) {
            return this.k.delete(t5);
          }, i5.update = function(t5, n6) {
            var e5 = r3({}, this.k.get(t5), {}, n6);
            return this.k.set(t5, e5), e5;
          }, n5;
        }(z2), Q2 = function() {
          return !window.history.pushState;
        }, W2 = function(t4) {
          return !t4.el || !t4.href;
        }, J2 = function(t4) {
          var n5 = t4.event;
          return n5.which > 1 || n5.metaKey || n5.ctrlKey || n5.shiftKey || n5.altKey;
        }, K2 = function(t4) {
          var n5 = t4.el;
          return n5.hasAttribute("target") && "_blank" === n5.target;
        }, V2 = function(t4) {
          var n5 = t4.el;
          return void 0 !== n5.protocol && window.location.protocol !== n5.protocol || void 0 !== n5.hostname && window.location.hostname !== n5.hostname;
        }, Y2 = function(t4) {
          var n5 = t4.el;
          return void 0 !== n5.port && B2() !== B2(n5.href);
        }, Z2 = function(t4) {
          var n5 = t4.el;
          return n5.getAttribute && "string" == typeof n5.getAttribute("download");
        }, tt = function(t4) {
          return t4.el.hasAttribute(S2.prefix + "-" + S2.prevent);
        }, nt = function(t4) {
          return Boolean(t4.el.closest("[" + S2.prefix + "-" + S2.prevent + '="all"]'));
        }, rt = function(t4) {
          var n5 = t4.href;
          return F2(n5) === F2() && B2(n5) === B2();
        }, et = function(t4) {
          function n5(n6) {
            var r5;
            return (r5 = t4.call(this, n6) || this).suite = [], r5.tests = /* @__PURE__ */ new Map(), r5.init(), r5;
          }
          e4(n5, t4);
          var r4 = n5.prototype;
          return r4.init = function() {
            this.add("pushState", Q2), this.add("exists", W2), this.add("newTab", J2), this.add("blank", K2), this.add("corsDomain", V2), this.add("corsPort", Y2), this.add("download", Z2), this.add("preventSelf", tt), this.add("preventAll", nt), this.add("sameUrl", rt, false);
          }, r4.add = function(t5, n6, r5) {
            void 0 === r5 && (r5 = true), this.tests.set(t5, n6), r5 && this.suite.push(t5);
          }, r4.run = function(t5, n6, r5, e5) {
            return this.tests.get(t5)({ el: n6, event: r5, href: e5 });
          }, r4.checkLink = function(t5, n6, r5) {
            var e5 = this;
            return this.suite.some(function(i5) {
              return e5.run(i5, t5, n6, r5);
            });
          }, n5;
        }(z2), it = function(t4) {
          function n5(r4, e5) {
            var i5;
            void 0 === e5 && (e5 = "Barba error");
            for (var o5 = arguments.length, u3 = new Array(o5 > 2 ? o5 - 2 : 0), f3 = 2; f3 < o5; f3++) u3[f3 - 2] = arguments[f3];
            return (i5 = t4.call.apply(t4, [this].concat(u3)) || this).error = r4, i5.label = e5, Error.captureStackTrace && Error.captureStackTrace(function(t5) {
              if (void 0 === t5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t5;
            }(i5), n5), i5.name = "BarbaError", i5;
          }
          return e4(n5, t4), n5;
        }(f2(Error)), ot = function() {
          function t4(t5) {
            void 0 === t5 && (t5 = []), this.logger = new l4("@barba/core"), this.all = [], this.page = [], this.once = [], this.A = [{ name: "namespace", type: "strings" }, { name: "custom", type: "function" }], t5 && (this.all = this.all.concat(t5)), this.update();
          }
          var n5 = t4.prototype;
          return n5.add = function(t5, n6) {
            switch (t5) {
              case "rule":
                this.A.splice(n6.position || 0, 0, n6.value);
                break;
              case "transition":
              default:
                this.all.push(n6);
            }
            this.update();
          }, n5.resolve = function(t5, n6) {
            var r4 = this;
            void 0 === n6 && (n6 = {});
            var e5 = n6.once ? this.once : this.page;
            e5 = e5.filter(n6.self ? function(t6) {
              return t6.name && "self" === t6.name;
            } : function(t6) {
              return !t6.name || "self" !== t6.name;
            });
            var i5 = /* @__PURE__ */ new Map(), o5 = e5.find(function(e6) {
              var o6 = true, u4 = {};
              return !(!n6.self || "self" !== e6.name) || (r4.A.reverse().forEach(function(n7) {
                o6 && (o6 = r4.R(e6, n7, t5, u4), e6.from && e6.to && (o6 = r4.R(e6, n7, t5, u4, "from") && r4.R(e6, n7, t5, u4, "to")), e6.from && !e6.to && (o6 = r4.R(e6, n7, t5, u4, "from")), !e6.from && e6.to && (o6 = r4.R(e6, n7, t5, u4, "to")));
              }), i5.set(e6, u4), o6);
            }), u3 = i5.get(o5), f3 = [];
            if (f3.push(n6.once ? "once" : "page"), n6.self && f3.push("self"), u3) {
              var s5, c4 = [o5];
              Object.keys(u3).length > 0 && c4.push(u3), (s5 = this.logger).info.apply(s5, ["Transition found [" + f3.join(",") + "]"].concat(c4));
            } else this.logger.info("No transition found [" + f3.join(",") + "]");
            return o5;
          }, n5.update = function() {
            var t5 = this;
            this.all = this.all.map(function(n6) {
              return t5.T(n6);
            }).sort(function(t6, n6) {
              return t6.priority - n6.priority;
            }).reverse().map(function(t6) {
              return delete t6.priority, t6;
            }), this.page = this.all.filter(function(t6) {
              return void 0 !== t6.leave || void 0 !== t6.enter;
            }), this.once = this.all.filter(function(t6) {
              return void 0 !== t6.once;
            });
          }, n5.R = function(t5, n6, r4, e5, i5) {
            var o5 = true, u3 = false, f3 = t5, s5 = n6.name, c4 = s5, a4 = s5, h5 = s5, v3 = i5 ? f3[i5] : f3, l5 = "to" === i5 ? r4.next : r4.current;
            if (i5 ? v3 && v3[s5] : v3[s5]) {
              switch (n6.type) {
                case "strings":
                default:
                  var d3 = Array.isArray(v3[c4]) ? v3[c4] : [v3[c4]];
                  l5[c4] && -1 !== d3.indexOf(l5[c4]) && (u3 = true), -1 === d3.indexOf(l5[c4]) && (o5 = false);
                  break;
                case "object":
                  var m3 = Array.isArray(v3[a4]) ? v3[a4] : [v3[a4]];
                  l5[a4] ? (l5[a4].name && -1 !== m3.indexOf(l5[a4].name) && (u3 = true), -1 === m3.indexOf(l5[a4].name) && (o5 = false)) : o5 = false;
                  break;
                case "function":
                  v3[h5](r4) ? u3 = true : o5 = false;
              }
              u3 && (i5 ? (e5[i5] = e5[i5] || {}, e5[i5][s5] = f3[i5][s5]) : e5[s5] = f3[s5]);
            }
            return o5;
          }, n5.O = function(t5, n6, r4) {
            var e5 = 0;
            return (t5[n6] || t5.from && t5.from[n6] || t5.to && t5.to[n6]) && (e5 += Math.pow(10, r4), t5.from && t5.from[n6] && (e5 += 1), t5.to && t5.to[n6] && (e5 += 2)), e5;
          }, n5.T = function(t5) {
            var n6 = this;
            t5.priority = 0;
            var r4 = 0;
            return this.A.forEach(function(e5, i5) {
              r4 += n6.O(t5, e5.name, i5 + 1);
            }), t5.priority = r4, t5;
          }, t4;
        }(), ut = function() {
          function t4(t5) {
            void 0 === t5 && (t5 = []), this.logger = new l4("@barba/core"), this.S = false, this.store = new ot(t5);
          }
          var r4 = t4.prototype;
          return r4.get = function(t5, n5) {
            return this.store.resolve(t5, n5);
          }, r4.doOnce = function(t5) {
            var n5 = t5.data, r5 = t5.transition;
            try {
              var e5 = function() {
                i5.S = false;
              }, i5 = this, o5 = r5 || {};
              i5.S = true;
              var u3 = s4(function() {
                return Promise.resolve(i5.j("beforeOnce", n5, o5)).then(function() {
                  return Promise.resolve(i5.once(n5, o5)).then(function() {
                    return Promise.resolve(i5.j("afterOnce", n5, o5)).then(function() {
                    });
                  });
                });
              }, function(t6) {
                i5.S = false, i5.logger.debug("Transition error [before/after/once]"), i5.logger.error(t6);
              });
              return Promise.resolve(u3 && u3.then ? u3.then(e5) : e5());
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, r4.doPage = function(t5) {
            var n5 = t5.data, r5 = t5.transition, e5 = t5.page, i5 = t5.wrapper;
            try {
              var o5 = function(t6) {
                if (u3) return t6;
                f3.S = false;
              }, u3 = false, f3 = this, c4 = r5 || {}, a4 = true === c4.sync || false;
              f3.S = true;
              var h5 = s4(function() {
                function t6() {
                  return Promise.resolve(f3.j("before", n5, c4)).then(function() {
                    var t7 = false;
                    function r7(r8) {
                      return t7 ? r8 : Promise.resolve(f3.remove(n5)).then(function() {
                        return Promise.resolve(f3.j("after", n5, c4)).then(function() {
                        });
                      });
                    }
                    var o6 = function() {
                      if (a4) return s4(function() {
                        return Promise.resolve(f3.add(n5, i5)).then(function() {
                          return Promise.resolve(f3.j("beforeLeave", n5, c4)).then(function() {
                            return Promise.resolve(f3.j("beforeEnter", n5, c4)).then(function() {
                              return Promise.resolve(Promise.all([f3.leave(n5, c4), f3.enter(n5, c4)])).then(function() {
                                return Promise.resolve(f3.j("afterLeave", n5, c4)).then(function() {
                                  return Promise.resolve(f3.j("afterEnter", n5, c4)).then(function() {
                                  });
                                });
                              });
                            });
                          });
                        });
                      }, function(t8) {
                        if (f3.M(t8)) throw new it(t8, "Transition error [sync]");
                      });
                      var r8 = function(r9) {
                        return t7 ? r9 : s4(function() {
                          var t8 = function() {
                            if (false !== o7) return Promise.resolve(f3.add(n5, i5)).then(function() {
                              return Promise.resolve(f3.j("beforeEnter", n5, c4)).then(function() {
                                return Promise.resolve(f3.enter(n5, c4, o7)).then(function() {
                                  return Promise.resolve(f3.j("afterEnter", n5, c4)).then(function() {
                                  });
                                });
                              });
                            });
                          }();
                          if (t8 && t8.then) return t8.then(function() {
                          });
                        }, function(t8) {
                          if (f3.M(t8)) throw new it(t8, "Transition error [before/after/enter]");
                        });
                      }, o7 = false, u4 = s4(function() {
                        return Promise.resolve(f3.j("beforeLeave", n5, c4)).then(function() {
                          return Promise.resolve(Promise.all([f3.leave(n5, c4), L2(e5, n5)]).then(function(t8) {
                            return t8[0];
                          })).then(function(t8) {
                            return o7 = t8, Promise.resolve(f3.j("afterLeave", n5, c4)).then(function() {
                            });
                          });
                        });
                      }, function(t8) {
                        if (f3.M(t8)) throw new it(t8, "Transition error [before/after/leave]");
                      });
                      return u4 && u4.then ? u4.then(r8) : r8(u4);
                    }();
                    return o6 && o6.then ? o6.then(r7) : r7(o6);
                  });
                }
                var r6 = function() {
                  if (a4) return Promise.resolve(L2(e5, n5)).then(function() {
                  });
                }();
                return r6 && r6.then ? r6.then(t6) : t6();
              }, function(t6) {
                if (f3.S = false, t6.name && "BarbaError" === t6.name) throw f3.logger.debug(t6.label), f3.logger.error(t6.error), t6;
                throw f3.logger.debug("Transition error [page]"), f3.logger.error(t6), t6;
              });
              return Promise.resolve(h5 && h5.then ? h5.then(o5) : o5(h5));
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, r4.once = function(t5, n5) {
            try {
              return Promise.resolve(X2.do("once", t5, n5)).then(function() {
                return n5.once ? N2(n5.once, n5)(t5) : Promise.resolve();
              });
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, r4.leave = function(t5, n5) {
            try {
              return Promise.resolve(X2.do("leave", t5, n5)).then(function() {
                return n5.leave ? N2(n5.leave, n5)(t5) : Promise.resolve();
              });
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, r4.enter = function(t5, n5, r5) {
            try {
              return Promise.resolve(X2.do("enter", t5, n5)).then(function() {
                return n5.enter ? N2(n5.enter, n5)(t5, r5) : Promise.resolve();
              });
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, r4.add = function(t5, n5) {
            try {
              return j2.addContainer(t5.next.container, n5), X2.do("nextAdded", t5), Promise.resolve();
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, r4.remove = function(t5) {
            try {
              return j2.removeContainer(t5.current.container), X2.do("currentRemoved", t5), Promise.resolve();
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, r4.M = function(t5) {
            return t5.message ? !/Timeout error|Fetch error/.test(t5.message) : !t5.status;
          }, r4.j = function(t5, n5, r5) {
            try {
              return Promise.resolve(X2.do(t5, n5, r5)).then(function() {
                return r5[t5] ? N2(r5[t5], r5)(n5) : Promise.resolve();
              });
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, n4(t4, [{ key: "isRunning", get: function() {
            return this.S;
          }, set: function(t5) {
            this.S = t5;
          } }, { key: "hasOnce", get: function() {
            return this.store.once.length > 0;
          } }, { key: "hasSelf", get: function() {
            return this.store.all.some(function(t5) {
              return "self" === t5.name;
            });
          } }, { key: "shouldWait", get: function() {
            return this.store.all.some(function(t5) {
              return t5.to && !t5.to.route || t5.sync;
            });
          } }]), t4;
        }(), ft = function() {
          function t4(t5) {
            var n5 = this;
            this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = /* @__PURE__ */ new Map(), 0 !== t5.length && (t5.forEach(function(t6) {
              n5.byNamespace.set(t6.namespace, t6);
            }), this.names.forEach(function(t6) {
              X2[t6](n5.L(t6));
            }));
          }
          return t4.prototype.L = function(t5) {
            var n5 = this;
            return function(r4) {
              var e5 = t5.match(/enter/i) ? r4.next : r4.current, i5 = n5.byNamespace.get(e5.namespace);
              return i5 && i5[t5] ? N2(i5[t5], i5)(r4) : Promise.resolve();
            };
          }, t4;
        }();
        Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function(t4) {
          var n5 = this;
          do {
            if (n5.matches(t4)) return n5;
            n5 = n5.parentElement || n5.parentNode;
          } while (null !== n5 && 1 === n5.nodeType);
          return null;
        });
        var st = { container: null, html: "", namespace: "", url: { hash: "", href: "", path: "", port: null, query: {} } };
        return new (function() {
          function t4() {
            this.version = a3, this.schemaPage = st, this.Logger = l4, this.logger = new l4("@barba/core"), this.plugins = [], this.hooks = X2, this.dom = j2, this.helpers = _2, this.history = M2, this.request = I2, this.url = H2;
          }
          var e5 = t4.prototype;
          return e5.use = function(t5, n5) {
            var r4 = this.plugins;
            r4.indexOf(t5) > -1 ? this.logger.warn("Plugin [" + t5.name + "] already installed.") : "function" == typeof t5.install ? (t5.install(this, n5), r4.push(t5)) : this.logger.warn("Plugin [" + t5.name + '] has no "install" method.');
          }, e5.init = function(t5) {
            var n5 = void 0 === t5 ? {} : t5, e6 = n5.transitions, i5 = void 0 === e6 ? [] : e6, o5 = n5.views, u3 = void 0 === o5 ? [] : o5, f3 = n5.schema, s5 = void 0 === f3 ? S2 : f3, c4 = n5.requestError, a4 = n5.timeout, h5 = void 0 === a4 ? 2e3 : a4, v3 = n5.cacheIgnore, d3 = void 0 !== v3 && v3, m3 = n5.prefetchIgnore, p3 = void 0 !== m3 && m3, w3 = n5.preventRunning, b3 = void 0 !== w3 && w3, y3 = n5.prevent, P3 = void 0 === y3 ? null : y3, g3 = n5.debug, E3 = n5.logLevel;
            if (l4.setLevel(true === (void 0 !== g3 && g3) ? "debug" : void 0 === E3 ? "off" : E3), this.logger.info(this.version), Object.keys(s5).forEach(function(t6) {
              S2[t6] && (S2[t6] = s5[t6]);
            }), this.$ = c4, this.timeout = h5, this.cacheIgnore = d3, this.prefetchIgnore = p3, this.preventRunning = b3, this._ = this.dom.getWrapper(), !this._) throw new Error("[@barba/core] No Barba wrapper found");
            this._.setAttribute("aria-live", "polite"), this.q();
            var x3 = this.data.current;
            if (!x3.container) throw new Error("[@barba/core] No Barba container found");
            if (this.cache = new G2(d3), this.prevent = new et(p3), this.transitions = new ut(i5), this.views = new ft(u3), null !== P3) {
              if ("function" != typeof P3) throw new Error("[@barba/core] Prevent should be a function");
              this.prevent.add("preventCustom", P3);
            }
            this.history.init(x3.url.href, x3.namespace), this.B = this.B.bind(this), this.U = this.U.bind(this), this.D = this.D.bind(this), this.F(), this.plugins.forEach(function(t6) {
              return t6.init();
            });
            var k3 = this.data;
            k3.trigger = "barba", k3.next = k3.current, k3.current = r3({}, this.schemaPage), this.hooks.do("ready", k3), this.once(k3), this.q();
          }, e5.destroy = function() {
            this.q(), this.H(), this.history.clear(), this.hooks.clear(), this.plugins = [];
          }, e5.force = function(t5) {
            window.location.assign(t5);
          }, e5.go = function(t5, n5, r4) {
            var e6;
            if (void 0 === n5 && (n5 = "barba"), this.transitions.isRunning) this.force(t5);
            else if (!(e6 = "popstate" === n5 ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t5) : this.prevent.run("sameUrl", null, null, t5)) || this.transitions.hasSelf) return n5 = this.history.change(t5, n5, r4), r4 && (r4.stopPropagation(), r4.preventDefault()), this.page(t5, n5, e6);
          }, e5.once = function(t5) {
            try {
              var n5 = this;
              return Promise.resolve(n5.hooks.do("beforeEnter", t5)).then(function() {
                function r4() {
                  return Promise.resolve(n5.hooks.do("afterEnter", t5)).then(function() {
                  });
                }
                var e6 = function() {
                  if (n5.transitions.hasOnce) {
                    var r5 = n5.transitions.get(t5, { once: true });
                    return Promise.resolve(n5.transitions.doOnce({ transition: r5, data: t5 })).then(function() {
                    });
                  }
                }();
                return e6 && e6.then ? e6.then(r4) : r4();
              });
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, e5.page = function(t5, n5, e6) {
            try {
              var i5 = function() {
                var t6 = o5.data;
                return Promise.resolve(o5.hooks.do("page", t6)).then(function() {
                  var n6 = s4(function() {
                    var n7 = o5.transitions.get(t6, { once: false, self: e6 });
                    return Promise.resolve(o5.transitions.doPage({ data: t6, page: u3, transition: n7, wrapper: o5._ })).then(function() {
                      o5.q();
                    });
                  }, function() {
                    0 === l4.getLevel() && o5.force(t6.current.url.href);
                  });
                  if (n6 && n6.then) return n6.then(function() {
                  });
                });
              }, o5 = this;
              o5.data.next.url = r3({ href: t5 }, o5.url.parse(t5)), o5.data.trigger = n5;
              var u3 = o5.cache.has(t5) ? o5.cache.update(t5, { action: "click" }).request : o5.cache.set(t5, o5.request(t5, o5.timeout, o5.onRequestError.bind(o5, n5)), "click").request, f3 = function() {
                if (o5.transitions.shouldWait) return Promise.resolve(L2(u3, o5.data)).then(function() {
                });
              }();
              return Promise.resolve(f3 && f3.then ? f3.then(i5) : i5());
            } catch (t6) {
              return Promise.reject(t6);
            }
          }, e5.onRequestError = function(t5) {
            this.transitions.isRunning = false;
            for (var n5 = arguments.length, r4 = new Array(n5 > 1 ? n5 - 1 : 0), e6 = 1; e6 < n5; e6++) r4[e6 - 1] = arguments[e6];
            var i5 = r4[0], o5 = r4[1], u3 = this.cache.getAction(i5);
            return this.cache.delete(i5), !(this.$ && false === this.$(t5, u3, i5, o5) || ("click" === u3 && this.force(i5), 1));
          }, e5.prefetch = function(t5) {
            var n5 = this;
            this.cache.has(t5) || this.cache.set(t5, this.request(t5, this.timeout, this.onRequestError.bind(this, "barba")).catch(function(t6) {
              n5.logger.error(t6);
            }), "prefetch");
          }, e5.F = function() {
            true !== this.prefetchIgnore && (document.addEventListener("mouseover", this.B), document.addEventListener("touchstart", this.B)), document.addEventListener("click", this.U), window.addEventListener("popstate", this.D);
          }, e5.H = function() {
            true !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.B), document.removeEventListener("touchstart", this.B)), document.removeEventListener("click", this.U), window.removeEventListener("popstate", this.D);
          }, e5.B = function(t5) {
            var n5 = this, r4 = this.I(t5);
            if (r4) {
              var e6 = this.dom.getHref(r4);
              this.prevent.checkHref(e6) || this.cache.has(e6) || this.cache.set(e6, this.request(e6, this.timeout, this.onRequestError.bind(this, r4)).catch(function(t6) {
                n5.logger.error(t6);
              }), "enter");
            }
          }, e5.U = function(t5) {
            var n5 = this.I(t5);
            if (n5) return this.transitions.isRunning && this.preventRunning ? (t5.preventDefault(), void t5.stopPropagation()) : void this.go(this.dom.getHref(n5), n5, t5);
          }, e5.D = function(t5) {
            this.go(this.url.getHref(), "popstate", t5);
          }, e5.I = function(t5) {
            for (var n5 = t5.target; n5 && !this.dom.getHref(n5); ) n5 = n5.parentNode;
            if (n5 && !this.prevent.checkLink(n5, t5, this.dom.getHref(n5))) return n5;
          }, e5.q = function() {
            var t5 = this.url.getHref(), n5 = { container: this.dom.getContainer(), html: this.dom.getHtml(), namespace: this.dom.getNamespace(), url: r3({ href: t5 }, this.url.parse(t5)) };
            this.C = { current: n5, next: r3({}, this.schemaPage), trigger: void 0 }, this.hooks.do("reset", this.data);
          }, n4(t4, [{ key: "data", get: function() {
            return this.C;
          } }, { key: "wrapper", get: function() {
            return this._;
          } }]), t4;
        }())();
      });
    }
  });

  // node_modules/@vue/shared/dist/shared.cjs.js
  var require_shared_cjs = __commonJS({
    "node_modules/@vue/shared/dist/shared.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function makeMap(str, expectsLowerCase) {
        const map2 = /* @__PURE__ */ Object.create(null);
        const list = str.split(",");
        for (let i4 = 0; i4 < list.length; i4++) {
          map2[list[i4]] = true;
        }
        return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
      }
      var PatchFlagNames = {
        [
          1
          /* TEXT */
        ]: `TEXT`,
        [
          2
          /* CLASS */
        ]: `CLASS`,
        [
          4
          /* STYLE */
        ]: `STYLE`,
        [
          8
          /* PROPS */
        ]: `PROPS`,
        [
          16
          /* FULL_PROPS */
        ]: `FULL_PROPS`,
        [
          32
          /* HYDRATE_EVENTS */
        ]: `HYDRATE_EVENTS`,
        [
          64
          /* STABLE_FRAGMENT */
        ]: `STABLE_FRAGMENT`,
        [
          128
          /* KEYED_FRAGMENT */
        ]: `KEYED_FRAGMENT`,
        [
          256
          /* UNKEYED_FRAGMENT */
        ]: `UNKEYED_FRAGMENT`,
        [
          512
          /* NEED_PATCH */
        ]: `NEED_PATCH`,
        [
          1024
          /* DYNAMIC_SLOTS */
        ]: `DYNAMIC_SLOTS`,
        [
          2048
          /* DEV_ROOT_FRAGMENT */
        ]: `DEV_ROOT_FRAGMENT`,
        [
          -1
          /* HOISTED */
        ]: `HOISTED`,
        [
          -2
          /* BAIL */
        ]: `BAIL`
      };
      var slotFlagsText = {
        [
          1
          /* STABLE */
        ]: "STABLE",
        [
          2
          /* DYNAMIC */
        ]: "DYNAMIC",
        [
          3
          /* FORWARDED */
        ]: "FORWARDED"
      };
      var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
      var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
      var range = 2;
      function generateCodeFrame2(source, start = 0, end = source.length) {
        let lines = source.split(/(\r?\n)/);
        const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
        lines = lines.filter((_2, idx) => idx % 2 === 0);
        let count = 0;
        const res = [];
        for (let i4 = 0; i4 < lines.length; i4++) {
          count += lines[i4].length + (newlineSequences[i4] && newlineSequences[i4].length || 0);
          if (count >= start) {
            for (let j2 = i4 - range; j2 <= i4 + range || end > count; j2++) {
              if (j2 < 0 || j2 >= lines.length)
                continue;
              const line = j2 + 1;
              res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j2]}`);
              const lineLength = lines[j2].length;
              const newLineSeqLength = newlineSequences[j2] && newlineSequences[j2].length || 0;
              if (j2 === i4) {
                const pad = start - (count - (lineLength + newLineSeqLength));
                const length = Math.max(1, end > count ? lineLength - pad : end - start);
                res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
              } else if (j2 > i4) {
                if (end > count) {
                  const length = Math.max(Math.min(end - count, lineLength), 1);
                  res.push(`   |  ` + "^".repeat(length));
                }
                count += lineLength + newLineSeqLength;
              }
            }
            break;
          }
        }
        return res.join("\n");
      }
      var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      var isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
      var attrValidationCache = {};
      function isSSRSafeAttrName(name) {
        if (attrValidationCache.hasOwnProperty(name)) {
          return attrValidationCache[name];
        }
        const isUnsafe = unsafeAttrCharRE.test(name);
        if (isUnsafe) {
          console.error(`unsafe attribute name: ${name}`);
        }
        return attrValidationCache[name] = !isUnsafe;
      }
      var propsToAttrMap = {
        acceptCharset: "accept-charset",
        className: "class",
        htmlFor: "for",
        httpEquiv: "http-equiv"
      };
      var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
      var isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
      var isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
      function normalizeStyle(value) {
        if (isArray3(value)) {
          const res = {};
          for (let i4 = 0; i4 < value.length; i4++) {
            const item = value[i4];
            const normalized = isString2(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString2(value)) {
          return value;
        } else if (isObject3(value)) {
          return value;
        }
      }
      var listDelimiterRE = /;(?![^(]*\))/g;
      var propertyDelimiterRE = /:(.+)/;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function stringifyStyle(styles2) {
        let ret = "";
        if (!styles2 || isString2(styles2)) {
          return ret;
        }
        for (const key in styles2) {
          const value = styles2[key];
          const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
          if (isString2(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
            ret += `${normalizedKey}:${value};`;
          }
        }
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString2(value)) {
          res = value;
        } else if (isArray3(value)) {
          for (let i4 = 0; i4 < value.length; i4++) {
            const normalized = normalizeClass(value[i4]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject3(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      function normalizeProps(props) {
        if (!props)
          return null;
        let { class: klass, style } = props;
        if (klass && !isString2(klass)) {
          props.class = normalizeClass(klass);
        }
        if (style) {
          props.style = normalizeStyle(style);
        }
        return props;
      }
      var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
      var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
      var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
      var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
      var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
      var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
      var escapeRE = /["'&<>]/;
      function escapeHtml2(string) {
        const str = "" + string;
        const match = escapeRE.exec(str);
        if (!match) {
          return str;
        }
        let html3 = "";
        let escaped;
        let index2;
        let lastIndex = 0;
        for (index2 = match.index; index2 < str.length; index2++) {
          switch (str.charCodeAt(index2)) {
            case 34:
              escaped = "&quot;";
              break;
            case 38:
              escaped = "&amp;";
              break;
            case 39:
              escaped = "&#39;";
              break;
            case 60:
              escaped = "&lt;";
              break;
            case 62:
              escaped = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index2) {
            html3 += str.slice(lastIndex, index2);
          }
          lastIndex = index2 + 1;
          html3 += escaped;
        }
        return lastIndex !== index2 ? html3 + str.slice(lastIndex, index2) : html3;
      }
      var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
      function escapeHtmlComment(src) {
        return src.replace(commentStripRE, "");
      }
      function looseCompareArrays(a3, b2) {
        if (a3.length !== b2.length)
          return false;
        let equal = true;
        for (let i4 = 0; equal && i4 < a3.length; i4++) {
          equal = looseEqual(a3[i4], b2[i4]);
        }
        return equal;
      }
      function looseEqual(a3, b2) {
        if (a3 === b2)
          return true;
        let aValidType = isDate(a3);
        let bValidType = isDate(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? a3.getTime() === b2.getTime() : false;
        }
        aValidType = isSymbol(a3);
        bValidType = isSymbol(b2);
        if (aValidType || bValidType) {
          return a3 === b2;
        }
        aValidType = isArray3(a3);
        bValidType = isArray3(b2);
        if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a3, b2) : false;
        }
        aValidType = isObject3(a3);
        bValidType = isObject3(b2);
        if (aValidType || bValidType) {
          if (!aValidType || !bValidType) {
            return false;
          }
          const aKeysCount = Object.keys(a3).length;
          const bKeysCount = Object.keys(b2).length;
          if (aKeysCount !== bKeysCount) {
            return false;
          }
          for (const key in a3) {
            const aHasKey = a3.hasOwnProperty(key);
            const bHasKey = b2.hasOwnProperty(key);
            if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a3[key], b2[key])) {
              return false;
            }
          }
        }
        return String(a3) === String(b2);
      }
      function looseIndexOf(arr, val) {
        return arr.findIndex((item) => looseEqual(item, val));
      }
      var toDisplayString = (val) => {
        return isString2(val) ? val : val == null ? "" : isArray3(val) || isObject3(val) && (val.toString === objectToString2 || !isFunction2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      var replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
              entries[`${key} =>`] = val2;
              return entries;
            }, {})
          };
        } else if (isSet(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()]
          };
        } else if (isObject3(val) && !isArray3(val) && !isPlainObject(val)) {
          return String(val);
        }
        return val;
      };
      var EMPTY_OBJ = Object.freeze({});
      var EMPTY_ARR = Object.freeze([]);
      var NOOP2 = () => {
      };
      var NO = () => false;
      var onRE = /^on[^a-z]/;
      var isOn = (key) => onRE.test(key);
      var isModelListener = (key) => key.startsWith("onUpdate:");
      var extend4 = Object.assign;
      var remove2 = (arr, el) => {
        const i4 = arr.indexOf(el);
        if (i4 > -1) {
          arr.splice(i4, 1);
        }
      };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var hasOwn = (val, key) => hasOwnProperty.call(val, key);
      var isArray3 = Array.isArray;
      var isMap = (val) => toTypeString(val) === "[object Map]";
      var isSet = (val) => toTypeString(val) === "[object Set]";
      var isDate = (val) => toTypeString(val) === "[object Date]";
      var isFunction2 = (val) => typeof val === "function";
      var isString2 = (val) => typeof val === "string";
      var isSymbol = (val) => typeof val === "symbol";
      var isObject3 = (val) => val !== null && typeof val === "object";
      var isPromise = (val) => {
        return isObject3(val) && isFunction2(val.then) && isFunction2(val.catch);
      };
      var objectToString2 = Object.prototype.toString;
      var toTypeString = (value) => objectToString2.call(value);
      var toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      var isPlainObject = (val) => toTypeString(val) === "[object Object]";
      var isIntegerKey = (key) => isString2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      var isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      var isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
      var cacheStringFunction = (fn) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      };
      var camelizeRE = /-(\w)/g;
      var camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_2, c3) => c3 ? c3.toUpperCase() : "");
      });
      var hyphenateRE = /\B([A-Z])/g;
      var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
      var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
      var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
      var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      var invokeArrayFns = (fns, arg) => {
        for (let i4 = 0; i4 < fns.length; i4++) {
          fns[i4](arg);
        }
      };
      var def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      var toNumber = (val) => {
        const n4 = parseFloat(val);
        return isNaN(n4) ? val : n4;
      };
      var _globalThis;
      var getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      var identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
      function genPropsAccessExp(name) {
        return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
      }
      exports.EMPTY_ARR = EMPTY_ARR;
      exports.EMPTY_OBJ = EMPTY_OBJ;
      exports.NO = NO;
      exports.NOOP = NOOP2;
      exports.PatchFlagNames = PatchFlagNames;
      exports.camelize = camelize;
      exports.capitalize = capitalize;
      exports.def = def;
      exports.escapeHtml = escapeHtml2;
      exports.escapeHtmlComment = escapeHtmlComment;
      exports.extend = extend4;
      exports.genPropsAccessExp = genPropsAccessExp;
      exports.generateCodeFrame = generateCodeFrame2;
      exports.getGlobalThis = getGlobalThis;
      exports.hasChanged = hasChanged;
      exports.hasOwn = hasOwn;
      exports.hyphenate = hyphenate;
      exports.includeBooleanAttr = includeBooleanAttr;
      exports.invokeArrayFns = invokeArrayFns;
      exports.isArray = isArray3;
      exports.isBooleanAttr = isBooleanAttr;
      exports.isBuiltInDirective = isBuiltInDirective;
      exports.isDate = isDate;
      exports.isFunction = isFunction2;
      exports.isGloballyWhitelisted = isGloballyWhitelisted;
      exports.isHTMLTag = isHTMLTag;
      exports.isIntegerKey = isIntegerKey;
      exports.isKnownHtmlAttr = isKnownHtmlAttr;
      exports.isKnownSvgAttr = isKnownSvgAttr;
      exports.isMap = isMap;
      exports.isModelListener = isModelListener;
      exports.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;
      exports.isObject = isObject3;
      exports.isOn = isOn;
      exports.isPlainObject = isPlainObject;
      exports.isPromise = isPromise;
      exports.isReservedProp = isReservedProp;
      exports.isSSRSafeAttrName = isSSRSafeAttrName;
      exports.isSVGTag = isSVGTag;
      exports.isSet = isSet;
      exports.isSpecialBooleanAttr = isSpecialBooleanAttr;
      exports.isString = isString2;
      exports.isSymbol = isSymbol;
      exports.isVoidTag = isVoidTag;
      exports.looseEqual = looseEqual;
      exports.looseIndexOf = looseIndexOf;
      exports.makeMap = makeMap;
      exports.normalizeClass = normalizeClass;
      exports.normalizeProps = normalizeProps;
      exports.normalizeStyle = normalizeStyle;
      exports.objectToString = objectToString2;
      exports.parseStringStyle = parseStringStyle;
      exports.propsToAttrMap = propsToAttrMap;
      exports.remove = remove2;
      exports.slotFlagsText = slotFlagsText;
      exports.stringifyStyle = stringifyStyle;
      exports.toDisplayString = toDisplayString;
      exports.toHandlerKey = toHandlerKey;
      exports.toNumber = toNumber;
      exports.toRawType = toRawType;
      exports.toTypeString = toTypeString;
    }
  });

  // node_modules/@vue/shared/index.js
  var require_shared = __commonJS({
    "node_modules/@vue/shared/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_shared_cjs();
      }
    }
  });

  // node_modules/@vue/reactivity/dist/reactivity.cjs.js
  var require_reactivity_cjs = __commonJS({
    "node_modules/@vue/reactivity/dist/reactivity.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var shared = require_shared();
      function warn3(msg, ...args) {
        console.warn(`[Vue warn] ${msg}`, ...args);
      }
      var activeEffectScope;
      var EffectScope = class {
        constructor(detached = false) {
          this.active = true;
          this.effects = [];
          this.cleanups = [];
          if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
          }
        }
        run(fn) {
          if (this.active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          } else {
            warn3(`cannot run an inactive effect scope.`);
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          activeEffectScope = this;
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this.active) {
            let i4, l4;
            for (i4 = 0, l4 = this.effects.length; i4 < l4; i4++) {
              this.effects[i4].stop();
            }
            for (i4 = 0, l4 = this.cleanups.length; i4 < l4; i4++) {
              this.cleanups[i4]();
            }
            if (this.scopes) {
              for (i4 = 0, l4 = this.scopes.length; i4 < l4; i4++) {
                this.scopes[i4].stop(true);
              }
            }
            if (this.parent && !fromParent) {
              const last = this.parent.scopes.pop();
              if (last && last !== this) {
                this.parent.scopes[this.index] = last;
                last.index = this.index;
              }
            }
            this.active = false;
          }
        }
      };
      function effectScope(detached) {
        return new EffectScope(detached);
      }
      function recordEffectScope(effect2, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect2);
        }
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      function onScopeDispose(fn) {
        if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn);
        } else {
          warn3(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
        }
      }
      var createDep = (effects) => {
        const dep = new Set(effects);
        dep.w = 0;
        dep.n = 0;
        return dep;
      };
      var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
      var newTracked = (dep) => (dep.n & trackOpBit) > 0;
      var initDepMarkers = ({ deps }) => {
        if (deps.length) {
          for (let i4 = 0; i4 < deps.length; i4++) {
            deps[i4].w |= trackOpBit;
          }
        }
      };
      var finalizeDepMarkers = (effect2) => {
        const { deps } = effect2;
        if (deps.length) {
          let ptr = 0;
          for (let i4 = 0; i4 < deps.length; i4++) {
            const dep = deps[i4];
            if (wasTracked(dep) && !newTracked(dep)) {
              dep.delete(effect2);
            } else {
              deps[ptr++] = dep;
            }
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
          }
          deps.length = ptr;
        }
      };
      var targetMap = /* @__PURE__ */ new WeakMap();
      var effectTrackDepth = 0;
      var trackOpBit = 1;
      var maxMarkerBits = 30;
      var activeEffect;
      var ITERATE_KEY = Symbol("iterate");
      var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
      var ReactiveEffect = class {
        constructor(fn, scheduler2 = null, scope) {
          this.fn = fn;
          this.scheduler = scheduler2;
          this.active = true;
          this.deps = [];
          this.parent = void 0;
          recordEffectScope(this, scope);
        }
        run() {
          if (!this.active) {
            return this.fn();
          }
          let parent2 = activeEffect;
          let lastShouldTrack = shouldTrack;
          while (parent2) {
            if (parent2 === this) {
              return;
            }
            parent2 = parent2.parent;
          }
          try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
              initDepMarkers(this);
            } else {
              cleanupEffect(this);
            }
            return this.fn();
          } finally {
            if (effectTrackDepth <= maxMarkerBits) {
              finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = void 0;
            if (this.deferStop) {
              this.stop();
            }
          }
        }
        stop() {
          if (activeEffect === this) {
            this.deferStop = true;
          } else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
              this.onStop();
            }
            this.active = false;
          }
        }
      };
      function cleanupEffect(effect2) {
        const { deps } = effect2;
        if (deps.length) {
          for (let i4 = 0; i4 < deps.length; i4++) {
            deps[i4].delete(effect2);
          }
          deps.length = 0;
        }
      }
      function effect(fn, options) {
        if (fn.effect) {
          fn = fn.effect.fn;
        }
        const _effect = new ReactiveEffect(fn);
        if (options) {
          shared.extend(_effect, options);
          if (options.scope)
            recordEffectScope(_effect, options.scope);
        }
        if (!options || !options.lazy) {
          _effect.run();
        }
        const runner = _effect.run.bind(_effect);
        runner.effect = _effect;
        return runner;
      }
      function stop(runner) {
        runner.effect.stop();
      }
      var shouldTrack = true;
      var trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function enableTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = true;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function track(target, type, key) {
        if (shouldTrack && activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = createDep());
          }
          const eventInfo = { effect: activeEffect, target, type, key };
          trackEffects(dep, eventInfo);
        }
      }
      function trackEffects(dep, debuggerEventExtraInfo) {
        let shouldTrack2 = false;
        if (effectTrackDepth <= maxMarkerBits) {
          if (!newTracked(dep)) {
            dep.n |= trackOpBit;
            shouldTrack2 = !wasTracked(dep);
          }
        } else {
          shouldTrack2 = !dep.has(activeEffect);
        }
        if (shouldTrack2) {
          dep.add(activeEffect);
          activeEffect.deps.push(dep);
          if (activeEffect.onTrack) {
            activeEffect.onTrack(__spreadValues({
              effect: activeEffect
            }, debuggerEventExtraInfo));
          }
        }
      }
      function trigger2(target, type, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          return;
        }
        let deps = [];
        if (type === "clear") {
          deps = [...depsMap.values()];
        } else if (key === "length" && shared.isArray(target)) {
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || key2 >= newValue) {
              deps.push(dep);
            }
          });
        } else {
          if (key !== void 0) {
            deps.push(depsMap.get(key));
          }
          switch (type) {
            case "add":
              if (!shared.isArray(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (shared.isMap(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (shared.isIntegerKey(key)) {
                deps.push(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!shared.isArray(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (shared.isMap(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (shared.isMap(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
        const eventInfo = { target, type, key, newValue, oldValue, oldTarget };
        if (deps.length === 1) {
          if (deps[0]) {
            {
              triggerEffects(deps[0], eventInfo);
            }
          }
        } else {
          const effects = [];
          for (const dep of deps) {
            if (dep) {
              effects.push(...dep);
            }
          }
          {
            triggerEffects(createDep(effects), eventInfo);
          }
        }
      }
      function triggerEffects(dep, debuggerEventExtraInfo) {
        const effects = shared.isArray(dep) ? dep : [...dep];
        for (const effect2 of effects) {
          if (effect2.computed) {
            triggerEffect(effect2, debuggerEventExtraInfo);
          }
        }
        for (const effect2 of effects) {
          if (!effect2.computed) {
            triggerEffect(effect2, debuggerEventExtraInfo);
          }
        }
      }
      function triggerEffect(effect2, debuggerEventExtraInfo) {
        if (effect2 !== activeEffect || effect2.allowRecurse) {
          if (effect2.onTrigger) {
            effect2.onTrigger(shared.extend({ effect: effect2 }, debuggerEventExtraInfo));
          }
          if (effect2.scheduler) {
            effect2.scheduler();
          } else {
            effect2.run();
          }
        }
      }
      var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);
      var builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(shared.isSymbol)
      );
      var get = /* @__PURE__ */ createGetter();
      var shallowGet = /* @__PURE__ */ createGetter(false, true);
      var readonlyGet = /* @__PURE__ */ createGetter(true);
      var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
      var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      function createArrayInstrumentations() {
        const instrumentations = {};
        ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
          instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for (let i4 = 0, l4 = this.length; i4 < l4; i4++) {
              track(arr, "get", i4 + "");
            }
            const res = arr[key](...args);
            if (res === -1 || res === false) {
              return arr[key](...args.map(toRaw));
            } else {
              return res;
            }
          };
        });
        ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
          instrumentations[key] = function(...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
          };
        });
        return instrumentations;
      }
      function createGetter(isReadonly2 = false, shallow = false) {
        return function get2(target, key, receiver) {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return shallow;
          } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
            return target;
          }
          const targetIsArray = shared.isArray(target);
          if (!isReadonly2 && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          const res = Reflect.get(target, key, receiver);
          if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (shallow) {
            return res;
          }
          if (isRef(res)) {
            return targetIsArray && shared.isIntegerKey(key) ? res : res.value;
          }
          if (shared.isObject(res)) {
            return isReadonly2 ? readonly(res) : reactive2(res);
          }
          return res;
        };
      }
      var set2 = /* @__PURE__ */ createSetter();
      var shallowSet = /* @__PURE__ */ createSetter(true);
      function createSetter(shallow = false) {
        return function set3(target, key, value, receiver) {
          let oldValue = target[key];
          if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
          }
          if (!shallow && !isReadonly(value)) {
            if (!isShallow(value)) {
              value = toRaw(value);
              oldValue = toRaw(oldValue);
            }
            if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
            }
          }
          const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);
          const result = Reflect.set(target, key, value, receiver);
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger2(target, "add", key, value);
            } else if (shared.hasChanged(value, oldValue)) {
              trigger2(target, "set", key, value, oldValue);
            }
          }
          return result;
        };
      }
      function deleteProperty(target, key) {
        const hadKey = shared.hasOwn(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger2(target, "delete", key, void 0, oldValue);
        }
        return result;
      }
      function has(target, key) {
        const result = Reflect.has(target, key);
        if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      function ownKeys2(target) {
        track(target, "iterate", shared.isArray(target) ? "length" : ITERATE_KEY);
        return Reflect.ownKeys(target);
      }
      var mutableHandlers = {
        get,
        set: set2,
        deleteProperty,
        has,
        ownKeys: ownKeys2
      };
      var readonlyHandlers = {
        get: readonlyGet,
        set(target, key) {
          {
            warn3(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
          }
          return true;
        },
        deleteProperty(target, key) {
          {
            warn3(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
          }
          return true;
        }
      };
      var shallowReactiveHandlers = /* @__PURE__ */ shared.extend({}, mutableHandlers, {
        get: shallowGet,
        set: shallowSet
      });
      var shallowReadonlyHandlers = /* @__PURE__ */ shared.extend({}, readonlyHandlers, {
        get: shallowReadonlyGet
      });
      var toShallow = (value) => value;
      var getProto = (v2) => Reflect.getPrototypeOf(v2);
      function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
        target = target[
          "__v_raw"
          /* RAW */
        ];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has: has2 } = getProto(rawTarget);
        const wrap3 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap3(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap3(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      }
      function has$1(key, isReadonly2 = false) {
        const target = this[
          "__v_raw"
          /* RAW */
        ];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (key !== rawKey) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      }
      function size(target, isReadonly2 = false) {
        target = target[
          "__v_raw"
          /* RAW */
        ];
        !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      }
      function add(value) {
        value = toRaw(value);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger2(target, "add", value, value);
        }
        return this;
      }
      function set$1(key, value) {
        value = toRaw(value);
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        } else {
          checkIdentityKeys(target, has2, key);
        }
        const oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger2(target, "add", key, value);
        } else if (shared.hasChanged(value, oldValue)) {
          trigger2(target, "set", key, value, oldValue);
        }
        return this;
      }
      function deleteEntry(key) {
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        } else {
          checkIdentityKeys(target, has2, key);
        }
        const oldValue = get2 ? get2.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger2(target, "delete", key, void 0, oldValue);
        }
        return result;
      }
      function clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);
        const result = target.clear();
        if (hadItems) {
          trigger2(target, "clear", void 0, void 0, oldTarget);
        }
        return result;
      }
      function createForEach(isReadonly2, isShallow2) {
        return function forEach(callback, thisArg) {
          const observed = this;
          const target = observed[
            "__v_raw"
            /* RAW */
          ];
          const rawTarget = toRaw(target);
          const wrap3 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap3(value), wrap3(key), observed);
          });
        };
      }
      function createIterableMethod(method, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this[
            "__v_raw"
            /* RAW */
          ];
          const rawTarget = toRaw(target);
          const targetIsMap = shared.isMap(rawTarget);
          const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
          const isKeyOnly = method === "keys" && targetIsMap;
          const innerIterator = target[method](...args);
          const wrap3 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap3(value[0]), wrap3(value[1])] : wrap3(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type) {
        return function(...args) {
          {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
          }
          return type === "delete" ? false : this;
        };
      }
      function createInstrumentations() {
        const mutableInstrumentations2 = {
          get(key) {
            return get$1(this, key);
          },
          get size() {
            return size(this);
          },
          has: has$1,
          add,
          set: set$1,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
        };
        const shallowInstrumentations2 = {
          get(key) {
            return get$1(this, key, false, true);
          },
          get size() {
            return size(this);
          },
          has: has$1,
          add,
          set: set$1,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
        };
        const readonlyInstrumentations2 = {
          get(key) {
            return get$1(this, key, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has$1.call(this, key, true);
          },
          add: createReadonlyMethod(
            "add"
            /* ADD */
          ),
          set: createReadonlyMethod(
            "set"
            /* SET */
          ),
          delete: createReadonlyMethod(
            "delete"
            /* DELETE */
          ),
          clear: createReadonlyMethod(
            "clear"
            /* CLEAR */
          ),
          forEach: createForEach(true, false)
        };
        const shallowReadonlyInstrumentations2 = {
          get(key) {
            return get$1(this, key, true, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has$1.call(this, key, true);
          },
          add: createReadonlyMethod(
            "add"
            /* ADD */
          ),
          set: createReadonlyMethod(
            "set"
            /* SET */
          ),
          delete: createReadonlyMethod(
            "delete"
            /* DELETE */
          ),
          clear: createReadonlyMethod(
            "clear"
            /* CLEAR */
          ),
          forEach: createForEach(true, true)
        };
        const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
        iteratorMethods.forEach((method) => {
          mutableInstrumentations2[method] = createIterableMethod(method, false, false);
          readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
          shallowInstrumentations2[method] = createIterableMethod(method, false, true);
          shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
        });
        return [
          mutableInstrumentations2,
          readonlyInstrumentations2,
          shallowInstrumentations2,
          shallowReadonlyInstrumentations2
        ];
      }
      var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
        };
      }
      var mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      var shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      var readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      var shallowReadonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, true)
      };
      function checkIdentityKeys(target, has2, key) {
        const rawKey = toRaw(key);
        if (rawKey !== key && has2.call(target, rawKey)) {
          const type = shared.toRawType(target);
          console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
        }
      }
      var reactiveMap = /* @__PURE__ */ new WeakMap();
      var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      var readonlyMap = /* @__PURE__ */ new WeakMap();
      var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value[
          "__v_skip"
          /* SKIP */
        ] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));
      }
      function reactive2(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
      }
      function shallowReactive(target) {
        return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
      }
      function readonly(target) {
        return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
      }
      function shallowReadonly(target) {
        return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!shared.isObject(target)) {
          {
            console.warn(`value cannot be made reactive: ${String(target)}`);
          }
          return target;
        }
        if (target[
          "__v_raw"
          /* RAW */
        ] && !(isReadonly2 && target[
          "__v_isReactive"
          /* IS_REACTIVE */
        ])) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
        proxyMap.set(target, proxy);
        return proxy;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value[
            "__v_raw"
            /* RAW */
          ]);
        }
        return !!(value && value[
          "__v_isReactive"
          /* IS_REACTIVE */
        ]);
      }
      function isReadonly(value) {
        return !!(value && value[
          "__v_isReadonly"
          /* IS_READONLY */
        ]);
      }
      function isShallow(value) {
        return !!(value && value[
          "__v_isShallow"
          /* IS_SHALLOW */
        ]);
      }
      function isProxy(value) {
        return isReactive(value) || isReadonly(value);
      }
      function toRaw(observed) {
        const raw = observed && observed[
          "__v_raw"
          /* RAW */
        ];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        shared.def(value, "__v_skip", true);
        return value;
      }
      var toReactive = (value) => shared.isObject(value) ? reactive2(value) : value;
      var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;
      function trackRefValue(ref3) {
        if (shouldTrack && activeEffect) {
          ref3 = toRaw(ref3);
          {
            trackEffects(ref3.dep || (ref3.dep = createDep()), {
              target: ref3,
              type: "get",
              key: "value"
            });
          }
        }
      }
      function triggerRefValue(ref3, newVal) {
        ref3 = toRaw(ref3);
        if (ref3.dep) {
          {
            triggerEffects(ref3.dep, {
              target: ref3,
              type: "set",
              key: "value",
              newValue: newVal
            });
          }
        }
      }
      function isRef(r3) {
        return !!(r3 && r3.__v_isRef === true);
      }
      function ref2(value) {
        return createRef(value, false);
      }
      function shallowRef(value) {
        return createRef(value, true);
      }
      function createRef(rawValue2, shallow) {
        if (isRef(rawValue2)) {
          return rawValue2;
        }
        return new RefImpl(rawValue2, shallow);
      }
      var RefImpl = class {
        constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          newVal = this.__v_isShallow ? newVal : toRaw(newVal);
          if (shared.hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
          }
        }
      };
      function triggerRef(ref3) {
        triggerRefValue(ref3, ref3.value);
      }
      function unref(ref3) {
        return isRef(ref3) ? ref3.value : ref3;
      }
      var shallowUnwrapHandlers = {
        get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      var CustomRefImpl = class {
        constructor(factory) {
          this.dep = void 0;
          this.__v_isRef = true;
          const { get: get2, set: set3 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
          this._get = get2;
          this._set = set3;
        }
        get value() {
          return this._get();
        }
        set value(newVal) {
          this._set(newVal);
        }
      };
      function customRef(factory) {
        return new CustomRefImpl(factory);
      }
      function toRefs(object) {
        if (!isProxy(object)) {
          console.warn(`toRefs() expects a reactive object but received a plain one.`);
        }
        const ret = shared.isArray(object) ? new Array(object.length) : {};
        for (const key in object) {
          ret[key] = toRef(object, key);
        }
        return ret;
      }
      var ObjectRefImpl = class {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
        }
        get value() {
          const val = this._object[this._key];
          return val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
      };
      function toRef(object, key, defaultValue) {
        const val = object[key];
        return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
      }
      var ComputedRefImpl = class {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this._dirty = true;
          this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
              this._dirty = true;
              triggerRefValue(this);
            }
          });
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this[
            "__v_isReadonly"
            /* IS_READONLY */
          ] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          trackRefValue(self2);
          if (self2._dirty || !self2._cacheable) {
            self2._dirty = false;
            self2._value = self2.effect.run();
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
      };
      function computed(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = shared.isFunction(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = () => {
            console.warn("Write operation failed: computed value is readonly");
          };
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        if (debugOptions && !isSSR) {
          cRef.effect.onTrack = debugOptions.onTrack;
          cRef.effect.onTrigger = debugOptions.onTrigger;
        }
        return cRef;
      }
      var _a;
      var tick = /* @__PURE__ */ Promise.resolve();
      var queue = [];
      var queued = false;
      var scheduler = (fn) => {
        queue.push(fn);
        if (!queued) {
          queued = true;
          tick.then(flush);
        }
      };
      var flush = () => {
        for (let i4 = 0; i4 < queue.length; i4++) {
          queue[i4]();
        }
        queue.length = 0;
        queued = false;
      };
      var DeferredComputedRefImpl = class _DeferredComputedRefImpl {
        constructor(getter) {
          this.dep = void 0;
          this._dirty = true;
          this.__v_isRef = true;
          this[_a] = true;
          let compareTarget;
          let hasCompareTarget = false;
          let scheduled = false;
          this.effect = new ReactiveEffect(getter, (computedTrigger) => {
            if (this.dep) {
              if (computedTrigger) {
                compareTarget = this._value;
                hasCompareTarget = true;
              } else if (!scheduled) {
                const valueToCompare = hasCompareTarget ? compareTarget : this._value;
                scheduled = true;
                hasCompareTarget = false;
                scheduler(() => {
                  if (this.effect.active && this._get() !== valueToCompare) {
                    triggerRefValue(this);
                  }
                  scheduled = false;
                });
              }
              for (const e4 of this.dep) {
                if (e4.computed instanceof _DeferredComputedRefImpl) {
                  e4.scheduler(
                    true
                    /* computedTrigger */
                  );
                }
              }
            }
            this._dirty = true;
          });
          this.effect.computed = this;
        }
        _get() {
          if (this._dirty) {
            this._dirty = false;
            return this._value = this.effect.run();
          }
          return this._value;
        }
        get value() {
          trackRefValue(this);
          return toRaw(this)._get();
        }
      };
      _a = "__v_isReadonly";
      function deferredComputed(getter) {
        return new DeferredComputedRefImpl(getter);
      }
      exports.EffectScope = EffectScope;
      exports.ITERATE_KEY = ITERATE_KEY;
      exports.ReactiveEffect = ReactiveEffect;
      exports.computed = computed;
      exports.customRef = customRef;
      exports.deferredComputed = deferredComputed;
      exports.effect = effect;
      exports.effectScope = effectScope;
      exports.enableTracking = enableTracking;
      exports.getCurrentScope = getCurrentScope;
      exports.isProxy = isProxy;
      exports.isReactive = isReactive;
      exports.isReadonly = isReadonly;
      exports.isRef = isRef;
      exports.isShallow = isShallow;
      exports.markRaw = markRaw;
      exports.onScopeDispose = onScopeDispose;
      exports.pauseTracking = pauseTracking;
      exports.proxyRefs = proxyRefs;
      exports.reactive = reactive2;
      exports.readonly = readonly;
      exports.ref = ref2;
      exports.resetTracking = resetTracking;
      exports.shallowReactive = shallowReactive;
      exports.shallowReadonly = shallowReadonly;
      exports.shallowRef = shallowRef;
      exports.stop = stop;
      exports.toRaw = toRaw;
      exports.toRef = toRef;
      exports.toRefs = toRefs;
      exports.track = track;
      exports.trigger = trigger2;
      exports.triggerRef = triggerRef;
      exports.unref = unref;
    }
  });

  // node_modules/@vue/reactivity/index.js
  var require_reactivity = __commonJS({
    "node_modules/@vue/reactivity/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_reactivity_cjs();
      }
    }
  });

  // node_modules/@vue/runtime-core/dist/runtime-core.cjs.js
  var require_runtime_core_cjs = __commonJS({
    "node_modules/@vue/runtime-core/dist/runtime-core.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var reactivity = require_reactivity();
      var shared = require_shared();
      var stack = [];
      function pushWarningContext(vnode) {
        stack.push(vnode);
      }
      function popWarningContext() {
        stack.pop();
      }
      function warn3(msg, ...args) {
        reactivity.pauseTracking();
        const instance = stack.length ? stack[stack.length - 1].component : null;
        const appWarnHandler = instance && instance.appContext.config.warnHandler;
        const trace = getComponentTrace();
        if (appWarnHandler) {
          callWithErrorHandling(appWarnHandler, instance, 11, [
            msg + args.join(""),
            instance && instance.proxy,
            trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
            trace
          ]);
        } else {
          const warnArgs = [`[Vue warn]: ${msg}`, ...args];
          if (trace.length && // avoid spamming console during tests
          true) {
            warnArgs.push(`
`, ...formatTrace(trace));
          }
          console.warn(...warnArgs);
        }
        reactivity.resetTracking();
      }
      function getComponentTrace() {
        let currentVNode = stack[stack.length - 1];
        if (!currentVNode) {
          return [];
        }
        const normalizedStack = [];
        while (currentVNode) {
          const last = normalizedStack[0];
          if (last && last.vnode === currentVNode) {
            last.recurseCount++;
          } else {
            normalizedStack.push({
              vnode: currentVNode,
              recurseCount: 0
            });
          }
          const parentInstance = currentVNode.component && currentVNode.component.parent;
          currentVNode = parentInstance && parentInstance.vnode;
        }
        return normalizedStack;
      }
      function formatTrace(trace) {
        const logs = [];
        trace.forEach((entry, i4) => {
          logs.push(...i4 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
        });
        return logs;
      }
      function formatTraceEntry({ vnode, recurseCount }) {
        const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
        const isRoot = vnode.component ? vnode.component.parent == null : false;
        const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
        const close = `>` + postfix;
        return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
      }
      function formatProps(props) {
        const res = [];
        const keys = Object.keys(props);
        keys.slice(0, 3).forEach((key) => {
          res.push(...formatProp(key, props[key]));
        });
        if (keys.length > 3) {
          res.push(` ...`);
        }
        return res;
      }
      function formatProp(key, value, raw) {
        if (shared.isString(value)) {
          value = JSON.stringify(value);
          return raw ? value : [`${key}=${value}`];
        } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
          return raw ? value : [`${key}=${value}`];
        } else if (reactivity.isRef(value)) {
          value = formatProp(key, reactivity.toRaw(value.value), true);
          return raw ? value : [`${key}=Ref<`, value, `>`];
        } else if (shared.isFunction(value)) {
          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
        } else {
          value = reactivity.toRaw(value);
          return raw ? value : [`${key}=`, value];
        }
      }
      var ErrorTypeStrings = {
        [
          "sp"
          /* SERVER_PREFETCH */
        ]: "serverPrefetch hook",
        [
          "bc"
          /* BEFORE_CREATE */
        ]: "beforeCreate hook",
        [
          "c"
          /* CREATED */
        ]: "created hook",
        [
          "bm"
          /* BEFORE_MOUNT */
        ]: "beforeMount hook",
        [
          "m"
          /* MOUNTED */
        ]: "mounted hook",
        [
          "bu"
          /* BEFORE_UPDATE */
        ]: "beforeUpdate hook",
        [
          "u"
          /* UPDATED */
        ]: "updated",
        [
          "bum"
          /* BEFORE_UNMOUNT */
        ]: "beforeUnmount hook",
        [
          "um"
          /* UNMOUNTED */
        ]: "unmounted hook",
        [
          "a"
          /* ACTIVATED */
        ]: "activated hook",
        [
          "da"
          /* DEACTIVATED */
        ]: "deactivated hook",
        [
          "ec"
          /* ERROR_CAPTURED */
        ]: "errorCaptured hook",
        [
          "rtc"
          /* RENDER_TRACKED */
        ]: "renderTracked hook",
        [
          "rtg"
          /* RENDER_TRIGGERED */
        ]: "renderTriggered hook",
        [
          0
          /* SETUP_FUNCTION */
        ]: "setup function",
        [
          1
          /* RENDER_FUNCTION */
        ]: "render function",
        [
          2
          /* WATCH_GETTER */
        ]: "watcher getter",
        [
          3
          /* WATCH_CALLBACK */
        ]: "watcher callback",
        [
          4
          /* WATCH_CLEANUP */
        ]: "watcher cleanup function",
        [
          5
          /* NATIVE_EVENT_HANDLER */
        ]: "native event handler",
        [
          6
          /* COMPONENT_EVENT_HANDLER */
        ]: "component event handler",
        [
          7
          /* VNODE_HOOK */
        ]: "vnode hook",
        [
          8
          /* DIRECTIVE_HOOK */
        ]: "directive hook",
        [
          9
          /* TRANSITION_HOOK */
        ]: "transition hook",
        [
          10
          /* APP_ERROR_HANDLER */
        ]: "app errorHandler",
        [
          11
          /* APP_WARN_HANDLER */
        ]: "app warnHandler",
        [
          12
          /* FUNCTION_REF */
        ]: "ref function",
        [
          13
          /* ASYNC_COMPONENT_LOADER */
        ]: "async component loader",
        [
          14
          /* SCHEDULER */
        ]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
      };
      function callWithErrorHandling(fn, instance, type, args) {
        let res;
        try {
          res = args ? fn(...args) : fn();
        } catch (err) {
          handleError(err, instance, type);
        }
        return res;
      }
      function callWithAsyncErrorHandling(fn, instance, type, args) {
        if (shared.isFunction(fn)) {
          const res = callWithErrorHandling(fn, instance, type, args);
          if (res && shared.isPromise(res)) {
            res.catch((err) => {
              handleError(err, instance, type);
            });
          }
          return res;
        }
        const values = [];
        for (let i4 = 0; i4 < fn.length; i4++) {
          values.push(callWithAsyncErrorHandling(fn[i4], instance, type, args));
        }
        return values;
      }
      function handleError(err, instance, type, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = ErrorTypeStrings[type];
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i4 = 0; i4 < errorCapturedHooks.length; i4++) {
                if (errorCapturedHooks[i4](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
            return;
          }
        }
        logError(err, type, contextVNode, throwInDev);
      }
      function logError(err, type, contextVNode, throwInDev = true) {
        {
          const info = ErrorTypeStrings[type];
          if (contextVNode) {
            pushWarningContext(contextVNode);
          }
          warn3(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
          if (contextVNode) {
            popWarningContext();
          }
          if (throwInDev) {
            throw err;
          } else {
            console.error(err);
          }
        }
      }
      var isFlushing = false;
      var isFlushPending = false;
      var queue = [];
      var flushIndex = 0;
      var pendingPreFlushCbs = [];
      var activePreFlushCbs = null;
      var preFlushIndex = 0;
      var pendingPostFlushCbs = [];
      var activePostFlushCbs = null;
      var postFlushIndex = 0;
      var resolvedPromise = /* @__PURE__ */ Promise.resolve();
      var currentFlushPromise = null;
      var currentPreFlushParentJob = null;
      var RECURSION_LIMIT = 100;
      function nextTick2(fn) {
        const p2 = currentFlushPromise || resolvedPromise;
        return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
      }
      function findInsertionIndex(id) {
        let start = flushIndex + 1;
        let end = queue.length;
        while (start < end) {
          const middle = start + end >>> 1;
          const middleJobId = getId(queue[middle]);
          middleJobId < id ? start = middle + 1 : end = middle;
        }
        return start;
      }
      function queueJob(job) {
        if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
          if (job.id == null) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(job.id), 0, job);
          }
          queueFlush();
        }
      }
      function queueFlush() {
        if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function invalidateJob(job) {
        const i4 = queue.indexOf(job);
        if (i4 > flushIndex) {
          queue.splice(i4, 1);
        }
      }
      function queueCb(cb, activeQueue, pendingQueue, index2) {
        if (!shared.isArray(cb)) {
          if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
            pendingQueue.push(cb);
          }
        } else {
          pendingQueue.push(...cb);
        }
        queueFlush();
      }
      function queuePreFlushCb(cb) {
        queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
      }
      function queuePostFlushCb(cb) {
        queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
      }
      function flushPreFlushCbs(seen, parentJob = null) {
        if (pendingPreFlushCbs.length) {
          currentPreFlushParentJob = parentJob;
          activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
          pendingPreFlushCbs.length = 0;
          {
            seen = seen || /* @__PURE__ */ new Map();
          }
          for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
            if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
              continue;
            }
            activePreFlushCbs[preFlushIndex]();
          }
          activePreFlushCbs = null;
          preFlushIndex = 0;
          currentPreFlushParentJob = null;
          flushPreFlushCbs(seen, parentJob);
        }
      }
      function flushPostFlushCbs(seen) {
        flushPreFlushCbs();
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)];
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          {
            seen = seen || /* @__PURE__ */ new Map();
          }
          activePostFlushCbs.sort((a3, b2) => getId(a3) - getId(b2));
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
              continue;
            }
            activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      var getId = (job) => job.id == null ? Infinity : job.id;
      function flushJobs(seen) {
        isFlushPending = false;
        isFlushing = true;
        {
          seen = seen || /* @__PURE__ */ new Map();
        }
        flushPreFlushCbs(seen);
        queue.sort((a3, b2) => getId(a3) - getId(b2));
        const check = (job) => checkRecursiveUpdates(seen, job);
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
              if (check(job)) {
                continue;
              }
              callWithErrorHandling(
                job,
                null,
                14
                /* SCHEDULER */
              );
            }
          }
        } finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs(seen);
          isFlushing = false;
          currentFlushPromise = null;
          if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
            flushJobs(seen);
          }
        }
      }
      function checkRecursiveUpdates(seen, fn) {
        if (!seen.has(fn)) {
          seen.set(fn, 1);
        } else {
          const count = seen.get(fn);
          if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn3(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
            return true;
          } else {
            seen.set(fn, count + 1);
          }
        }
      }
      var isHmrUpdating = false;
      var hmrDirtyComponents = /* @__PURE__ */ new Set();
      {
        shared.getGlobalThis().__VUE_HMR_RUNTIME__ = {
          createRecord: tryWrap(createRecord),
          rerender: tryWrap(rerender),
          reload: tryWrap(reload)
        };
      }
      var map2 = /* @__PURE__ */ new Map();
      function registerHMR(instance) {
        const id = instance.type.__hmrId;
        let record = map2.get(id);
        if (!record) {
          createRecord(id, instance.type);
          record = map2.get(id);
        }
        record.instances.add(instance);
      }
      function unregisterHMR(instance) {
        map2.get(instance.type.__hmrId).instances.delete(instance);
      }
      function createRecord(id, initialDef) {
        if (map2.has(id)) {
          return false;
        }
        map2.set(id, {
          initialDef: normalizeClassComponent(initialDef),
          instances: /* @__PURE__ */ new Set()
        });
        return true;
      }
      function normalizeClassComponent(component) {
        return isClassComponent(component) ? component.__vccOpts : component;
      }
      function rerender(id, newRender) {
        const record = map2.get(id);
        if (!record) {
          return;
        }
        record.initialDef.render = newRender;
        [...record.instances].forEach((instance) => {
          if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
          }
          instance.renderCache = [];
          isHmrUpdating = true;
          instance.update();
          isHmrUpdating = false;
        });
      }
      function reload(id, newComp) {
        const record = map2.get(id);
        if (!record)
          return;
        newComp = normalizeClassComponent(newComp);
        updateComponentDef(record.initialDef, newComp);
        const instances = [...record.instances];
        for (const instance of instances) {
          const oldComp = normalizeClassComponent(instance.type);
          if (!hmrDirtyComponents.has(oldComp)) {
            if (oldComp !== record.initialDef) {
              updateComponentDef(oldComp, newComp);
            }
            hmrDirtyComponents.add(oldComp);
          }
          instance.appContext.optionsCache.delete(instance.type);
          if (instance.ceReload) {
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
          } else if (instance.parent) {
            queueJob(instance.parent.update);
            if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
              instance.parent.ceReload(newComp.styles);
            }
          } else if (instance.appContext.reload) {
            instance.appContext.reload();
          } else if (typeof window !== "undefined") {
            window.location.reload();
          } else {
            console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
          }
        }
        queuePostFlushCb(() => {
          for (const instance of instances) {
            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
          }
        });
      }
      function updateComponentDef(oldComp, newComp) {
        shared.extend(oldComp, newComp);
        for (const key in oldComp) {
          if (key !== "__file" && !(key in newComp)) {
            delete oldComp[key];
          }
        }
      }
      function tryWrap(fn) {
        return (id, arg) => {
          try {
            return fn(id, arg);
          } catch (e4) {
            console.error(e4);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
          }
        };
      }
      var buffer = [];
      var devtoolsNotInstalled = false;
      function emit(event2, ...args) {
        if (exports.devtools) {
          exports.devtools.emit(event2, ...args);
        } else if (!devtoolsNotInstalled) {
          buffer.push({ event: event2, args });
        }
      }
      function setDevtoolsHook(hook, target) {
        var _a, _b;
        exports.devtools = hook;
        if (exports.devtools) {
          exports.devtools.enabled = true;
          buffer.forEach(({ event: event2, args }) => exports.devtools.emit(event2, ...args));
          buffer = [];
        } else if (
          // handle late devtools injection - only do this if we are in an actual
          // browser environment to avoid the timer handle stalling test runner exit
          // (#4815)
          typeof window !== "undefined" && // some envs mock window but not fully
          window.HTMLElement && // also exclude jsdom
          !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))
        ) {
          const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
          replay.push((newHook) => {
            setDevtoolsHook(newHook, target);
          });
          setTimeout(() => {
            if (!exports.devtools) {
              target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
              devtoolsNotInstalled = true;
              buffer = [];
            }
          }, 3e3);
        } else {
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }
      function devtoolsInitApp(app2, version2) {
        emit("app:init", app2, version2, {
          Fragment,
          Text,
          Comment,
          Static
        });
      }
      function devtoolsUnmountApp(app2) {
        emit("app:unmount", app2);
      }
      var devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
        "component:added"
        /* COMPONENT_ADDED */
      );
      var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
        "component:updated"
        /* COMPONENT_UPDATED */
      );
      var devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
        "component:removed"
        /* COMPONENT_REMOVED */
      );
      function createDevtoolsComponentHook(hook) {
        return (component) => {
          emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
        };
      }
      var devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
        "perf:start"
        /* PERFORMANCE_START */
      );
      var devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
        "perf:end"
        /* PERFORMANCE_END */
      );
      function createDevtoolsPerformanceHook(hook) {
        return (component, type, time) => {
          emit(hook, component.appContext.app, component.uid, component, type, time);
        };
      }
      function devtoolsComponentEmit(component, event2, params) {
        emit("component:emit", component.appContext.app, component, event2, params);
      }
      function emit$1(instance, event2, ...rawArgs) {
        if (instance.isUnmounted)
          return;
        const props = instance.vnode.props || shared.EMPTY_OBJ;
        {
          const { emitsOptions, propsOptions: [propsOptions] } = instance;
          if (emitsOptions) {
            if (!(event2 in emitsOptions) && true) {
              if (!propsOptions || !(shared.toHandlerKey(event2) in propsOptions)) {
                warn3(`Component emitted event "${event2}" but it is neither declared in the emits option nor as an "${shared.toHandlerKey(event2)}" prop.`);
              }
            } else {
              const validator = emitsOptions[event2];
              if (shared.isFunction(validator)) {
                const isValid = validator(...rawArgs);
                if (!isValid) {
                  warn3(`Invalid event arguments: event validation failed for event "${event2}".`);
                }
              }
            }
          }
        }
        let args = rawArgs;
        const isModelListener = event2.startsWith("update:");
        const modelArg = isModelListener && event2.slice(7);
        if (modelArg && modelArg in props) {
          const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
          const { number, trim } = props[modifiersKey] || shared.EMPTY_OBJ;
          if (trim) {
            args = rawArgs.map((a3) => a3.trim());
          }
          if (number) {
            args = rawArgs.map(shared.toNumber);
          }
        }
        {
          devtoolsComponentEmit(instance, event2, args);
        }
        {
          const lowerCaseEvent = event2.toLowerCase();
          if (lowerCaseEvent !== event2 && props[shared.toHandlerKey(lowerCaseEvent)]) {
            warn3(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event2}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${shared.hyphenate(event2)}" instead of "${event2}".`);
          }
        }
        let handlerName;
        let handler = props[handlerName = shared.toHandlerKey(event2)] || // also try camelCase event handler (#2249)
        props[handlerName = shared.toHandlerKey(shared.camelize(event2))];
        if (!handler && isModelListener) {
          handler = props[handlerName = shared.toHandlerKey(shared.hyphenate(event2))];
        }
        if (handler) {
          callWithAsyncErrorHandling(handler, instance, 6, args);
        }
        const onceHandler = props[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(onceHandler, instance, 6, args);
        }
      }
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache = appContext.emitsCache;
        const cached = cache.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!shared.isFunction(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              shared.extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          cache.set(comp, null);
          return null;
        }
        if (shared.isArray(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          shared.extend(normalized, raw);
        }
        cache.set(comp, normalized);
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !shared.isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return shared.hasOwn(options, key[0].toLowerCase() + key.slice(1)) || shared.hasOwn(options, shared.hyphenate(key)) || shared.hasOwn(options, key);
      }
      var currentRenderingInstance = null;
      var currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev2 = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev2;
      }
      function pushScopeId(id) {
        currentScopeId = id;
      }
      function popScopeId() {
        currentScopeId = null;
      }
      var withScopeId = (_id) => withCtx;
      function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx)
          return fn;
        if (fn._n) {
          return fn;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          const res = fn(...args);
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
          {
            devtoolsComponentUpdated(ctx);
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      var accessedAttrs = false;
      function markAttrsAccessed() {
        accessedAttrs = true;
      }
      function renderComponentRoot(instance) {
        const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render6, renderCache, data, setupState, ctx, inheritAttrs } = instance;
        let result;
        let fallthroughAttrs;
        const prev2 = setCurrentRenderingInstance(instance);
        {
          accessedAttrs = false;
        }
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render6.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
          } else {
            const render7 = Component;
            if (attrs === props) {
              markAttrsAccessed();
            }
            result = normalizeVNode(render7.length > 1 ? render7(props, true ? {
              get attrs() {
                markAttrsAccessed();
                return attrs;
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }) : render7(
              props,
              null
              /* we know it doesn't need it */
            ));
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(
            err,
            instance,
            1
            /* RENDER_FUNCTION */
          );
          result = createVNode(Comment);
        }
        let root = result;
        let setRoot = void 0;
        if (result.patchFlag > 0 && result.patchFlag & 2048) {
          [root, setRoot] = getChildRoot(result);
        }
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root;
          if (keys.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys.some(shared.isModelListener)) {
                fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
              }
              root = cloneVNode(root, fallthroughAttrs);
            } else if (!accessedAttrs && root.type !== Comment) {
              const allAttrs = Object.keys(attrs);
              const eventAttrs = [];
              const extraAttrs = [];
              for (let i4 = 0, l4 = allAttrs.length; i4 < l4; i4++) {
                const key = allAttrs[i4];
                if (shared.isOn(key)) {
                  if (!shared.isModelListener(key)) {
                    eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                  }
                } else {
                  extraAttrs.push(key);
                }
              }
              if (extraAttrs.length) {
                warn3(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
              }
              if (eventAttrs.length) {
                warn3(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
              }
            }
          }
        }
        if (vnode.dirs) {
          if (!isElementRoot(root)) {
            warn3(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
          }
          root = cloneVNode(root);
          root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          if (!isElementRoot(root)) {
            warn3(`Component inside <Transition> renders non-element root node that cannot be animated.`);
          }
          root.transition = vnode.transition;
        }
        if (setRoot) {
          setRoot(root);
        } else {
          result = root;
        }
        setCurrentRenderingInstance(prev2);
        return result;
      }
      var getChildRoot = (vnode) => {
        const rawChildren = vnode.children;
        const dynamicChildren = vnode.dynamicChildren;
        const childRoot = filterSingleRoot(rawChildren);
        if (!childRoot) {
          return [vnode, void 0];
        }
        const index2 = rawChildren.indexOf(childRoot);
        const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
        const setRoot = (updatedRoot) => {
          rawChildren[index2] = updatedRoot;
          if (dynamicChildren) {
            if (dynamicIndex > -1) {
              dynamicChildren[dynamicIndex] = updatedRoot;
            } else if (updatedRoot.patchFlag > 0) {
              vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
          }
        };
        return [normalizeVNode(childRoot), setRoot];
      };
      function filterSingleRoot(children2) {
        let singleRoot;
        for (let i4 = 0; i4 < children2.length; i4++) {
          const child = children2[i4];
          if (isVNode(child)) {
            if (child.type !== Comment || child.children === "v-if") {
              if (singleRoot) {
                return;
              } else {
                singleRoot = child;
              }
            }
          } else {
            return;
          }
        }
        return singleRoot;
      }
      var getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || shared.isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      var filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!shared.isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      var isElementRoot = (vnode) => {
        return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if ((prevChildren || nextChildren) && isHmrUpdating) {
          return true;
        }
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i4 = 0; i4 < dynamicProps.length; i4++) {
              const key = dynamicProps[i4];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i4 = 0; i4 < nextKeys.length; i4++) {
          const key = nextKeys[i4];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent: parent2 }, el) {
        while (parent2 && parent2.subTree === vnode) {
          (vnode = parent2.vnode).el = el;
          parent2 = parent2.parent;
        }
      }
      var isSuspense = (type) => type.__isSuspense;
      var SuspenseImpl = {
        name: "Suspense",
        // In order to make Suspense tree-shakable, we need to avoid importing it
        // directly in the renderer. The renderer checks for the __isSuspense flag
        // on a vnode's type and calls the `process` method, passing in renderer
        // internals.
        __isSuspense: true,
        process(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
          if (n1 == null) {
            mountSuspense(n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
          } else {
            patchSuspense(n1, n22, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
          }
        },
        hydrate: hydrateSuspense,
        create: createSuspenseBoundary,
        normalize: normalizeSuspenseChildren
      };
      var Suspense = SuspenseImpl;
      function triggerEvent(vnode, name) {
        const eventListener = vnode.props && vnode.props[name];
        if (shared.isFunction(eventListener)) {
          eventListener();
        }
      }
      function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
        const { p: patch, o: { createElement } } = rendererInternals;
        const hiddenContainer = createElement("div");
        const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
        patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
        if (suspense.deps > 0) {
          triggerEvent(vnode, "onPending");
          triggerEvent(vnode, "onFallback");
          patch(
            null,
            vnode.ssFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            isSVG,
            slotScopeIds
          );
          setActiveBranch(suspense, vnode.ssFallback);
        } else {
          suspense.resolve();
        }
      }
      function patchSuspense(n1, n22, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
        const suspense = n22.suspense = n1.suspense;
        suspense.vnode = n22;
        n22.el = n1.el;
        const newBranch = n22.ssContent;
        const newFallback = n22.ssFallback;
        const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
        if (pendingBranch) {
          suspense.pendingBranch = newBranch;
          if (isSameVNodeType(newBranch, pendingBranch)) {
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else if (isInFallback) {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                isSVG,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          } else {
            suspense.pendingId++;
            if (isHydrating) {
              suspense.isHydrating = false;
              suspense.activeBranch = pendingBranch;
            } else {
              unmount(pendingBranch, parentComponent, suspense);
            }
            suspense.deps = 0;
            suspense.effects.length = 0;
            suspense.hiddenContainer = createElement("div");
            if (isInFallback) {
              patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
              if (suspense.deps <= 0) {
                suspense.resolve();
              } else {
                patch(
                  activeBranch,
                  newFallback,
                  container,
                  anchor,
                  parentComponent,
                  null,
                  // fallback tree will not have suspense context
                  isSVG,
                  slotScopeIds,
                  optimized
                );
                setActiveBranch(suspense, newFallback);
              }
            } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
              patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
              suspense.resolve(true);
            } else {
              patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
              if (suspense.deps <= 0) {
                suspense.resolve();
              }
            }
          }
        } else {
          if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newBranch);
          } else {
            triggerEvent(n22, "onPending");
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else {
              const { timeout, pendingId } = suspense;
              if (timeout > 0) {
                setTimeout(() => {
                  if (suspense.pendingId === pendingId) {
                    suspense.fallback(newFallback);
                  }
                }, timeout);
              } else if (timeout === 0) {
                suspense.fallback(newFallback);
              }
            }
          }
        }
      }
      var hasWarned = false;
      function createSuspenseBoundary(vnode, parent2, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
        if (!hasWarned) {
          hasWarned = true;
          console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
        }
        const { p: patch, m: move, um: unmount, n: next2, o: { parentNode, remove: remove2 } } = rendererInternals;
        const timeout = shared.toNumber(vnode.props && vnode.props.timeout);
        const suspense = {
          vnode,
          parent: parent2,
          parentComponent,
          isSVG,
          container,
          hiddenContainer,
          anchor,
          deps: 0,
          pendingId: 0,
          timeout: typeof timeout === "number" ? timeout : -1,
          activeBranch: null,
          pendingBranch: null,
          isInFallback: true,
          isHydrating,
          isUnmounted: false,
          effects: [],
          resolve(resume = false) {
            {
              if (!resume && !suspense.pendingBranch) {
                throw new Error(`suspense.resolve() is called without a pending branch.`);
              }
              if (suspense.isUnmounted) {
                throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
              }
            }
            const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
            if (suspense.isHydrating) {
              suspense.isHydrating = false;
            } else if (!resume) {
              const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
              if (delayEnter) {
                activeBranch.transition.afterLeave = () => {
                  if (pendingId === suspense.pendingId) {
                    move(
                      pendingBranch,
                      container2,
                      anchor2,
                      0
                      /* ENTER */
                    );
                  }
                };
              }
              let { anchor: anchor2 } = suspense;
              if (activeBranch) {
                anchor2 = next2(activeBranch);
                unmount(activeBranch, parentComponent2, suspense, true);
              }
              if (!delayEnter) {
                move(
                  pendingBranch,
                  container2,
                  anchor2,
                  0
                  /* ENTER */
                );
              }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            let parent3 = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent3) {
              if (parent3.pendingBranch) {
                parent3.effects.push(...effects);
                hasUnresolvedAncestor = true;
                break;
              }
              parent3 = parent3.parent;
            }
            if (!hasUnresolvedAncestor) {
              queuePostFlushCb(effects);
            }
            suspense.effects = [];
            triggerEvent(vnode2, "onResolve");
          },
          fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
              return;
            }
            const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
            triggerEvent(vnode2, "onFallback");
            const anchor2 = next2(activeBranch);
            const mountFallback = () => {
              if (!suspense.isInFallback) {
                return;
              }
              patch(
                null,
                fallbackVNode,
                container2,
                anchor2,
                parentComponent2,
                null,
                // fallback tree will not have suspense context
                isSVG2,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
            if (delayEnter) {
              activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            unmount(
              activeBranch,
              parentComponent2,
              null,
              // no suspense so unmount hooks fire now
              true
              // shouldRemove
            );
            if (!delayEnter) {
              mountFallback();
            }
          },
          move(container2, anchor2, type) {
            suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
            suspense.container = container2;
          },
          next() {
            return suspense.activeBranch && next2(suspense.activeBranch);
          },
          registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
              suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance.asyncDep.catch((err) => {
              handleError(
                err,
                instance,
                0
                /* SETUP_FUNCTION */
              );
            }).then((asyncSetupResult) => {
              if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
                return;
              }
              instance.asyncResolved = true;
              const { vnode: vnode2 } = instance;
              {
                pushWarningContext(vnode2);
              }
              handleSetupResult(instance, asyncSetupResult, false);
              if (hydratedEl) {
                vnode2.el = hydratedEl;
              }
              const placeholder = !hydratedEl && instance.subTree.el;
              setupRenderEffect(
                instance,
                vnode2,
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el),
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next2(instance.subTree),
                suspense,
                isSVG,
                optimized
              );
              if (placeholder) {
                remove2(placeholder);
              }
              updateHOCHostEl(instance, vnode2.el);
              {
                popWarningContext();
              }
              if (isInPendingSuspense && --suspense.deps === 0) {
                suspense.resolve();
              }
            });
          },
          unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
              unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
              unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
          }
        };
        return suspense;
      }
      function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
        const suspense = vnode.suspense = createSuspenseBoundary(
          vnode,
          parentSuspense,
          parentComponent,
          node.parentNode,
          document.createElement("div"),
          null,
          isSVG,
          slotScopeIds,
          optimized,
          rendererInternals,
          true
          /* hydrating */
        );
        const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
        if (suspense.deps === 0) {
          suspense.resolve();
        }
        return result;
      }
      function normalizeSuspenseChildren(vnode) {
        const { shapeFlag, children: children2 } = vnode;
        const isSlotChildren = shapeFlag & 32;
        vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children2.default : children2);
        vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children2.fallback) : createVNode(Comment);
      }
      function normalizeSuspenseSlot(s4) {
        let block;
        if (shared.isFunction(s4)) {
          const trackBlock = isBlockTreeEnabled && s4._c;
          if (trackBlock) {
            s4._d = false;
            openBlock();
          }
          s4 = s4();
          if (trackBlock) {
            s4._d = true;
            block = currentBlock;
            closeBlock();
          }
        }
        if (shared.isArray(s4)) {
          const singleChild = filterSingleRoot(s4);
          if (!singleChild) {
            warn3(`<Suspense> slots expect a single root node.`);
          }
          s4 = singleChild;
        }
        s4 = normalizeVNode(s4);
        if (block && !s4.dynamicChildren) {
          s4.dynamicChildren = block.filter((c3) => c3 !== s4);
        }
        return s4;
      }
      function queueEffectWithSuspense(fn, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (shared.isArray(fn)) {
            suspense.effects.push(...fn);
          } else {
            suspense.effects.push(fn);
          }
        } else {
          queuePostFlushCb(fn);
        }
      }
      function setActiveBranch(suspense, branch) {
        suspense.activeBranch = branch;
        const { vnode, parentComponent } = suspense;
        const el = vnode.el = branch.el;
        if (parentComponent && parentComponent.subTree === vnode) {
          parentComponent.vnode.el = el;
          updateHOCHostEl(parentComponent, el);
        }
      }
      function provide(key, value) {
        if (!currentInstance) {
          {
            warn3(`provide() can only be used inside setup().`);
          }
        } else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = currentInstance || currentRenderingInstance;
        if (instance) {
          const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && shared.isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
          } else {
            warn3(`injection "${String(key)}" not found.`);
          }
        } else {
          warn3(`inject() can only be used inside setup() or functional components.`);
        }
      }
      function watchEffect(effect, options) {
        return doWatch(effect, null, options);
      }
      function watchPostEffect(effect, options) {
        return doWatch(effect, null, __spreadProps(__spreadValues({}, options), { flush: "post" }));
      }
      function watchSyncEffect(effect, options) {
        return doWatch(effect, null, __spreadProps(__spreadValues({}, options), { flush: "sync" }));
      }
      var INITIAL_WATCHER_VALUE = {};
      function watch(source, cb, options) {
        if (!shared.isFunction(cb)) {
          warn3(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
        }
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared.EMPTY_OBJ) {
        if (!cb) {
          if (immediate !== void 0) {
            warn3(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
          }
          if (deep !== void 0) {
            warn3(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
          }
        }
        const warnInvalidSource = (s4) => {
          warn3(`Invalid watch source: `, s4, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
        };
        const instance = currentInstance;
        let getter;
        let forceTrigger = false;
        let isMultiSource = false;
        if (reactivity.isRef(source)) {
          getter = () => source.value;
          forceTrigger = reactivity.isShallow(source);
        } else if (reactivity.isReactive(source)) {
          getter = () => source;
          deep = true;
        } else if (shared.isArray(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s4) => reactivity.isReactive(s4) || reactivity.isShallow(s4));
          getter = () => source.map((s4) => {
            if (reactivity.isRef(s4)) {
              return s4.value;
            } else if (reactivity.isReactive(s4)) {
              return traverse(s4);
            } else if (shared.isFunction(s4)) {
              return callWithErrorHandling(
                s4,
                instance,
                2
                /* WATCH_GETTER */
              );
            } else {
              warnInvalidSource(s4);
            }
          });
        } else if (shared.isFunction(source)) {
          if (cb) {
            getter = () => callWithErrorHandling(
              source,
              instance,
              2
              /* WATCH_GETTER */
            );
          } else {
            getter = () => {
              if (instance && instance.isUnmounted) {
                return;
              }
              if (cleanup) {
                cleanup();
              }
              return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
            };
          }
        } else {
          getter = shared.NOOP;
          warnInvalidSource(source);
        }
        if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
        }
        let cleanup;
        let onCleanup = (fn) => {
          cleanup = effect.onStop = () => {
            callWithErrorHandling(
              fn,
              instance,
              4
              /* WATCH_CLEANUP */
            );
          };
        };
        if (isInSSRComponentSetup) {
          onCleanup = shared.NOOP;
          if (!cb) {
            getter();
          } else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3, [
              getter(),
              isMultiSource ? [] : void 0,
              onCleanup
            ]);
          }
          return shared.NOOP;
        }
        let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
        const job = () => {
          if (!effect.active) {
            return;
          }
          if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i4) => shared.hasChanged(v2, oldValue[i4])) : shared.hasChanged(newValue, oldValue)) || false) {
              if (cleanup) {
                cleanup();
              }
              callWithAsyncErrorHandling(cb, instance, 3, [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
                onCleanup
              ]);
              oldValue = newValue;
            }
          } else {
            effect.run();
          }
        };
        job.allowRecurse = !!cb;
        let scheduler;
        if (flush === "sync") {
          scheduler = job;
        } else if (flush === "post") {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
        } else {
          scheduler = () => queuePreFlushCb(job);
        }
        const effect = new reactivity.ReactiveEffect(getter, scheduler);
        {
          effect.onTrack = onTrack;
          effect.onTrigger = onTrigger;
        }
        if (cb) {
          if (immediate) {
            job();
          } else {
            oldValue = effect.run();
          }
        } else if (flush === "post") {
          queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
        } else {
          effect.run();
        }
        return () => {
          effect.stop();
          if (instance && instance.scope) {
            shared.remove(instance.scope.effects, effect);
          }
        };
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = shared.isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (shared.isFunction(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const cur = currentInstance;
        setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        if (cur) {
          setCurrentInstance(cur);
        } else {
          unsetCurrentInstance();
        }
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i4 = 0; i4 < segments.length && cur; i4++) {
            cur = cur[segments[i4]];
          }
          return cur;
        };
      }
      function traverse(value, seen) {
        if (!shared.isObject(value) || value[
          "__v_skip"
          /* SKIP */
        ]) {
          return value;
        }
        seen = seen || /* @__PURE__ */ new Set();
        if (seen.has(value)) {
          return value;
        }
        seen.add(value);
        if (reactivity.isRef(value)) {
          traverse(value.value, seen);
        } else if (shared.isArray(value)) {
          for (let i4 = 0; i4 < value.length; i4++) {
            traverse(value[i4], seen);
          }
        } else if (shared.isSet(value) || shared.isMap(value)) {
          value.forEach((v2) => {
            traverse(v2, seen);
          });
        } else if (shared.isPlainObject(value)) {
          for (const key in value) {
            traverse(value[key], seen);
          }
        }
        return value;
      }
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted2(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      var TransitionHookValidator = [Function, Array];
      var BaseTransitionImpl = {
        name: `BaseTransition`,
        props: {
          mode: String,
          appear: Boolean,
          persisted: Boolean,
          // enter
          onBeforeEnter: TransitionHookValidator,
          onEnter: TransitionHookValidator,
          onAfterEnter: TransitionHookValidator,
          onEnterCancelled: TransitionHookValidator,
          // leave
          onBeforeLeave: TransitionHookValidator,
          onLeave: TransitionHookValidator,
          onAfterLeave: TransitionHookValidator,
          onLeaveCancelled: TransitionHookValidator,
          // appear
          onBeforeAppear: TransitionHookValidator,
          onAppear: TransitionHookValidator,
          onAfterAppear: TransitionHookValidator,
          onAppearCancelled: TransitionHookValidator
        },
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
            const children2 = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children2 || !children2.length) {
              return;
            }
            let child = children2[0];
            if (children2.length > 1) {
              let hasFound = false;
              for (const c3 of children2) {
                if (c3.type !== Comment) {
                  if (hasFound) {
                    warn3("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                    break;
                  }
                  child = c3;
                  hasFound = true;
                }
              }
            }
            const rawProps = reactivity.toRaw(props);
            const { mode } = rawProps;
            if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
              warn3(`invalid <transition> mode: ${mode}`);
            }
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
              const key = getTransitionKey();
              if (prevTransitionKey === void 0) {
                prevTransitionKey = key;
              } else if (key !== prevTransitionKey) {
                prevTransitionKey = key;
                transitionKeyChanged = true;
              }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
              const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  instance.update();
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el._leaveCb = () => {
                    earlyRemove();
                    el._leaveCb = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      var BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props, state, instance) {
        const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(hook, instance, 9, args);
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (shared.isArray(hook)) {
            if (hook.every((hook2) => hook2.length <= 1))
              done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el._leaveCb) {
              el._leaveCb(
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
              leavingVNode.el._leaveCb();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el._enterCb = (cancelled) => {
              if (called)
                return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el._enterCb = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove2) {
            const key2 = String(vnode.key);
            if (el._enterCb) {
              el._enterCb(
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove2();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el._leaveCb = (cancelled) => {
              if (called)
                return;
              called = true;
              remove2();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el._leaveCb = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getKeepAliveChild(vnode) {
        return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children2, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i4 = 0; i4 < children2.length; i4++) {
          let child = children2[i4];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i4);
          if (child.type === Fragment) {
            if (child.patchFlag & 128)
              keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i4 = 0; i4 < ret.length; i4++) {
            ret[i4].patchFlag = -2;
          }
        }
        return ret;
      }
      function defineComponent2(options) {
        return shared.isFunction(options) ? { setup: options, name: options.name } : options;
      }
      var isAsyncWrapper = (i4) => !!i4.type.__asyncLoader;
      function defineAsyncComponent(source) {
        if (shared.isFunction(source)) {
          source = { loader: source };
        }
        const {
          loader,
          loadingComponent,
          errorComponent,
          delay: delay3 = 200,
          timeout,
          // undefined = never times out
          suspensible = true,
          onError: userOnError
        } = source;
        let pendingRequest = null;
        let resolvedComp;
        let retries = 0;
        const retry = () => {
          retries++;
          pendingRequest = null;
          return load();
        };
        const load = () => {
          let thisRequest;
          return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
            err = err instanceof Error ? err : new Error(String(err));
            if (userOnError) {
              return new Promise((resolve2, reject) => {
                const userRetry = () => resolve2(retry());
                const userFail = () => reject(err);
                userOnError(err, userRetry, userFail, retries + 1);
              });
            } else {
              throw err;
            }
          }).then((comp) => {
            if (thisRequest !== pendingRequest && pendingRequest) {
              return pendingRequest;
            }
            if (!comp) {
              warn3(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
            }
            if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
              comp = comp.default;
            }
            if (comp && !shared.isObject(comp) && !shared.isFunction(comp)) {
              throw new Error(`Invalid async component load result: ${comp}`);
            }
            resolvedComp = comp;
            return comp;
          }));
        };
        return defineComponent2({
          name: "AsyncComponentWrapper",
          __asyncLoader: load,
          get __asyncResolved() {
            return resolvedComp;
          },
          setup() {
            const instance = currentInstance;
            if (resolvedComp) {
              return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
              pendingRequest = null;
              handleError(
                err,
                instance,
                13,
                !errorComponent
                /* do not throw in dev if user provided error component */
              );
            };
            if (suspensible && instance.suspense || isInSSRComponentSetup) {
              return load().then((comp) => {
                return () => createInnerComp(comp, instance);
              }).catch((err) => {
                onError(err);
                return () => errorComponent ? createVNode(errorComponent, {
                  error: err
                }) : null;
              });
            }
            const loaded = reactivity.ref(false);
            const error = reactivity.ref();
            const delayed = reactivity.ref(!!delay3);
            if (delay3) {
              setTimeout(() => {
                delayed.value = false;
              }, delay3);
            }
            if (timeout != null) {
              setTimeout(() => {
                if (!loaded.value && !error.value) {
                  const err = new Error(`Async component timed out after ${timeout}ms.`);
                  onError(err);
                  error.value = err;
                }
              }, timeout);
            }
            load().then(() => {
              loaded.value = true;
              if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                queueJob(instance.parent.update);
              }
            }).catch((err) => {
              onError(err);
              error.value = err;
            });
            return () => {
              if (loaded.value && resolvedComp) {
                return createInnerComp(resolvedComp, instance);
              } else if (error.value && errorComponent) {
                return createVNode(errorComponent, {
                  error: error.value
                });
              } else if (loadingComponent && !delayed.value) {
                return createVNode(loadingComponent);
              }
            };
          }
        });
      }
      function createInnerComp(comp, { vnode: { ref: ref2, props, children: children2, shapeFlag }, parent: parent2 }) {
        const vnode = createVNode(comp, props, children2);
        vnode.ref = ref2;
        return vnode;
      }
      var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      var KeepAliveImpl = {
        name: `KeepAlive`,
        // Marker for special handling inside the renderer. We are not using a ===
        // check directly on KeepAlive in the renderer, because importing it directly
        // would prevent it from being tree-shaken.
        __isKeepAlive: true,
        props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number]
        },
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const sharedContext = instance.ctx;
          if (!sharedContext.renderer) {
            return () => {
              const children2 = slots.default && slots.default();
              return children2 && children2.length === 1 ? children2[0] : children2;
            };
          }
          const cache = /* @__PURE__ */ new Map();
          const keys = /* @__PURE__ */ new Set();
          let current = null;
          {
            instance.__v_cache = cache;
          }
          const parentSuspense = instance.suspense;
          const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
          const storageContainer = createElement("div");
          sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
              instance2.isDeactivated = false;
              if (instance2.a) {
                shared.invokeArrayFns(instance2.a);
              }
              const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
              if (vnodeHook) {
                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
              }
            }, parentSuspense);
            {
              devtoolsComponentAdded(instance2);
            }
          };
          sharedContext.deactivate = (vnode) => {
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(() => {
              if (instance2.da) {
                shared.invokeArrayFns(instance2.da);
              }
              const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
              if (vnodeHook) {
                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
              }
              instance2.isDeactivated = true;
            }, parentSuspense);
            {
              devtoolsComponentAdded(instance2);
            }
          };
          function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
          }
          function pruneCache(filter2) {
            cache.forEach((vnode, key) => {
              const name = getComponentName(vnode.type);
              if (name && (!filter2 || !filter2(name))) {
                pruneCacheEntry(key);
              }
            });
          }
          function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
              unmount(cached);
            } else if (current) {
              resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
          }
          watch(
            () => [props.include, props.exclude],
            ([include, exclude]) => {
              include && pruneCache((name) => matches2(include, name));
              exclude && pruneCache((name) => !matches2(exclude, name));
            },
            // prune post-render after `current` has been updated
            { flush: "post", deep: true }
          );
          let pendingCacheKey = null;
          const cacheSubtree = () => {
            if (pendingCacheKey != null) {
              cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
          };
          onMounted2(cacheSubtree);
          onUpdated(cacheSubtree);
          onBeforeUnmount(() => {
            cache.forEach((cached) => {
              const { subTree, suspense } = instance;
              const vnode = getInnerChild(subTree);
              if (cached.type === vnode.type) {
                resetShapeFlag(vnode);
                const da = vnode.component.da;
                da && queuePostRenderEffect(da, suspense);
                return;
              }
              unmount(cached);
            });
          });
          return () => {
            pendingCacheKey = null;
            if (!slots.default) {
              return null;
            }
            const children2 = slots.default();
            const rawVNode = children2[0];
            if (children2.length > 1) {
              {
                warn3(`KeepAlive should contain exactly one component child.`);
              }
              current = null;
              return children2;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
              current = null;
              return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include, exclude, max } = props;
            if (include && (!name || !matches2(include, name)) || exclude && name && matches2(exclude, name)) {
              current = vnode;
              return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            if (vnode.el) {
              vnode = cloneVNode(vnode);
              if (rawVNode.shapeFlag & 128) {
                rawVNode.ssContent = vnode;
              }
            }
            pendingCacheKey = key;
            if (cachedVNode) {
              vnode.el = cachedVNode.el;
              vnode.component = cachedVNode.component;
              if (vnode.transition) {
                setTransitionHooks(vnode, vnode.transition);
              }
              vnode.shapeFlag |= 512;
              keys.delete(key);
              keys.add(key);
            } else {
              keys.add(key);
              if (max && keys.size > parseInt(max, 10)) {
                pruneCacheEntry(keys.values().next().value);
              }
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
          };
        }
      };
      var KeepAlive = KeepAliveImpl;
      function matches2(pattern, name) {
        if (shared.isArray(pattern)) {
          return pattern.some((p2) => matches2(p2, name));
        } else if (shared.isString(pattern)) {
          return pattern.split(",").includes(name);
        } else if (pattern.test) {
          return pattern.test(name);
        }
        return false;
      }
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
        const injected = injectHook(
          type,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          shared.remove(keepAliveRoot[type], injected);
        }, target);
      }
      function resetShapeFlag(vnode) {
        let shapeFlag = vnode.shapeFlag;
        if (shapeFlag & 256) {
          shapeFlag -= 256;
        }
        if (shapeFlag & 512) {
          shapeFlag -= 512;
        }
        vnode.shapeFlag = shapeFlag;
      }
      function getInnerChild(vnode) {
        return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
      }
      function injectHook(type, hook, target = currentInstance, prepend2 = false) {
        if (target) {
          const hooks = target[type] || (target[type] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            if (target.isUnmounted) {
              return;
            }
            reactivity.pauseTracking();
            setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            unsetCurrentInstance();
            reactivity.resetTracking();
            return res;
          });
          if (prepend2) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        } else {
          const apiName = shared.toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
          warn3(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
        }
      }
      var createHook = (lifecycle) => (hook, target = currentInstance) => (
        // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target)
      );
      var onBeforeMount = createHook(
        "bm"
        /* BEFORE_MOUNT */
      );
      var onMounted2 = createHook(
        "m"
        /* MOUNTED */
      );
      var onBeforeUpdate = createHook(
        "bu"
        /* BEFORE_UPDATE */
      );
      var onUpdated = createHook(
        "u"
        /* UPDATED */
      );
      var onBeforeUnmount = createHook(
        "bum"
        /* BEFORE_UNMOUNT */
      );
      var onUnmounted = createHook(
        "um"
        /* UNMOUNTED */
      );
      var onServerPrefetch = createHook(
        "sp"
        /* SERVER_PREFETCH */
      );
      var onRenderTriggered = createHook(
        "rtg"
        /* RENDER_TRIGGERED */
      );
      var onRenderTracked = createHook(
        "rtc"
        /* RENDER_TRACKED */
      );
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      function validateDirectiveName(name) {
        if (shared.isBuiltInDirective(name)) {
          warn3("Do not use built-in directive ids as custom directive id: " + name);
        }
      }
      function withDirectives(vnode, directives) {
        const internalInstance = currentRenderingInstance;
        if (internalInstance === null) {
          warn3(`withDirectives can only be used inside render functions.`);
          return vnode;
        }
        const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i4 = 0; i4 < directives.length; i4++) {
          let [dir, value, arg, modifiers = shared.EMPTY_OBJ] = directives[i4];
          if (shared.isFunction(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i4 = 0; i4 < bindings.length; i4++) {
          const binding = bindings[i4];
          if (oldBindings) {
            binding.oldValue = oldBindings[i4].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            reactivity.pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            reactivity.resetTracking();
          }
        }
      }
      var COMPONENTS = "components";
      var DIRECTIVES = "directives";
      function resolveComponent(name, maybeSelfReference) {
        return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
      }
      var NULL_DYNAMIC_COMPONENT = Symbol();
      function resolveDynamicComponent(component) {
        if (shared.isString(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
        } else {
          return component || NULL_DYNAMIC_COMPONENT;
        }
      }
      function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
      }
      function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
        const instance = currentRenderingInstance || currentInstance;
        if (instance) {
          const Component = instance.type;
          if (type === COMPONENTS) {
            const selfName = getComponentName(
              Component,
              false
              /* do not include inferred name to avoid breaking existing code */
            );
            if (selfName && (selfName === name || selfName === shared.camelize(name) || selfName === shared.capitalize(shared.camelize(name)))) {
              return Component;
            }
          }
          const res = (
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type] || Component[type], name) || // global registration
            resolve(instance.appContext[type], name)
          );
          if (!res && maybeSelfReference) {
            return Component;
          }
          if (warnMissing && !res) {
            const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
            warn3(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
          }
          return res;
        } else {
          warn3(`resolve${shared.capitalize(type.slice(0, -1))} can only be used in render() or setup().`);
        }
      }
      function resolve(registry, name) {
        return registry && (registry[name] || registry[shared.camelize(name)] || registry[shared.capitalize(shared.camelize(name))]);
      }
      function renderList(source, renderItem, cache, index2) {
        let ret;
        const cached = cache && cache[index2];
        if (shared.isArray(source) || shared.isString(source)) {
          ret = new Array(source.length);
          for (let i4 = 0, l4 = source.length; i4 < l4; i4++) {
            ret[i4] = renderItem(source[i4], i4, void 0, cached && cached[i4]);
          }
        } else if (typeof source === "number") {
          if (!Number.isInteger(source)) {
            warn3(`The v-for range expect an integer value but got ${source}.`);
          }
          ret = new Array(source);
          for (let i4 = 0; i4 < source; i4++) {
            ret[i4] = renderItem(i4 + 1, i4, void 0, cached && cached[i4]);
          }
        } else if (shared.isObject(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(source, (item, i4) => renderItem(item, i4, void 0, cached && cached[i4]));
          } else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i4 = 0, l4 = keys.length; i4 < l4; i4++) {
              const key = keys[i4];
              ret[i4] = renderItem(source[key], key, i4, cached && cached[i4]);
            }
          }
        } else {
          ret = [];
        }
        if (cache) {
          cache[index2] = ret;
        }
        return ret;
      }
      function createSlots(slots, dynamicSlots) {
        for (let i4 = 0; i4 < dynamicSlots.length; i4++) {
          const slot = dynamicSlots[i4];
          if (shared.isArray(slot)) {
            for (let j2 = 0; j2 < slot.length; j2++) {
              slots[slot[j2].name] = slot[j2].fn;
            }
          } else if (slot) {
            slots[slot.name] = slot.fn;
          }
        }
        return slots;
      }
      function renderSlot(slots, name, props = {}, fallback, noSlotted) {
        if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
          return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
        }
        let slot = slots[name];
        if (slot && slot.length > 1) {
          warn3(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
          slot = () => [];
        }
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props));
        const rendered = createBlock(
          Fragment,
          { key: props.key || `_${name}` },
          validSlotContent || (fallback ? fallback() : []),
          validSlotContent && slots._ === 1 ? 64 : -2
          /* BAIL */
        );
        if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + "-s"];
        }
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child))
            return true;
          if (child.type === Comment)
            return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      function toHandlers(obj) {
        const ret = {};
        if (!shared.isObject(obj)) {
          warn3(`v-on with no argument expects an object value.`);
          return ret;
        }
        for (const key in obj) {
          ret[shared.toHandlerKey(key)] = obj[key];
        }
        return ret;
      }
      var getPublicInstance = (i4) => {
        if (!i4)
          return null;
        if (isStatefulComponent(i4))
          return getExposeProxy(i4) || i4.proxy;
        return getPublicInstance(i4.parent);
      };
      var publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ shared.extend(/* @__PURE__ */ Object.create(null), {
          $: (i4) => i4,
          $el: (i4) => i4.vnode.el,
          $data: (i4) => i4.data,
          $props: (i4) => reactivity.shallowReadonly(i4.props),
          $attrs: (i4) => reactivity.shallowReadonly(i4.attrs),
          $slots: (i4) => reactivity.shallowReadonly(i4.slots),
          $refs: (i4) => reactivity.shallowReadonly(i4.refs),
          $parent: (i4) => getPublicInstance(i4.parent),
          $root: (i4) => getPublicInstance(i4.root),
          $emit: (i4) => i4.emit,
          $options: (i4) => resolveMergedOptions(i4),
          $forceUpdate: (i4) => i4.f || (i4.f = () => queueJob(i4.update)),
          $nextTick: (i4) => i4.n || (i4.n = nextTick2.bind(i4.proxy)),
          $watch: (i4) => instanceWatch.bind(i4)
        })
      );
      var isReservedPrefix = (key) => key === "_" || key === "$";
      var PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          if (key === "__isVue") {
            return true;
          }
          if (setupState !== shared.EMPTY_OBJ && setupState.__isScriptSetup && shared.hasOwn(setupState, key)) {
            return setupState[key];
          }
          let normalizedProps;
          if (key[0] !== "$") {
            const n4 = accessCache[key];
            if (n4 !== void 0) {
              switch (n4) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (setupState !== shared.EMPTY_OBJ && shared.hasOwn(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && shared.hasOwn(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              reactivity.track(instance, "get", key);
              markAttrsAccessed();
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, shared.hasOwn(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else if (currentRenderingInstance && (!shared.isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
          // to infinite warning loop
          key.indexOf("__v") !== 0)) {
            if (data !== shared.EMPTY_OBJ && isReservedPrefix(key[0]) && shared.hasOwn(data, key)) {
              warn3(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            } else if (instance === currentRenderingInstance) {
              warn3(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
            }
          }
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (setupState !== shared.EMPTY_OBJ && shared.hasOwn(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (shared.hasOwn(instance.props, key)) {
            warn3(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            warn3(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`, instance);
            return false;
          } else {
            if (key in instance.appContext.config.globalProperties) {
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                value
              });
            } else {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== shared.EMPTY_OBJ && shared.hasOwn(data, key) || setupState !== shared.EMPTY_OBJ && shared.hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && shared.hasOwn(normalizedProps, key) || shared.hasOwn(ctx, key) || shared.hasOwn(publicPropertiesMap, key) || shared.hasOwn(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (shared.hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      {
        PublicInstanceProxyHandlers.ownKeys = (target) => {
          warn3(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
          return Reflect.ownKeys(target);
        };
      }
      var RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ shared.extend({}, PublicInstanceProxyHandlers, {
        get(target, key) {
          if (key === Symbol.unscopables) {
            return;
          }
          return PublicInstanceProxyHandlers.get(target, key, target);
        },
        has(_2, key) {
          const has = key[0] !== "_" && !shared.isGloballyWhitelisted(key);
          if (!has && PublicInstanceProxyHandlers.has(_2, key)) {
            warn3(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
          }
          return has;
        }
      });
      function createDevRenderContext(instance) {
        const target = {};
        Object.defineProperty(target, `_`, {
          configurable: true,
          enumerable: false,
          get: () => instance
        });
        Object.keys(publicPropertiesMap).forEach((key) => {
          Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: shared.NOOP
          });
        });
        return target;
      }
      function exposePropsOnRenderContext(instance) {
        const { ctx, propsOptions: [propsOptions] } = instance;
        if (propsOptions) {
          Object.keys(propsOptions).forEach((key) => {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => instance.props[key],
              set: shared.NOOP
            });
          });
        }
      }
      function exposeSetupStateOnRenderContext(instance) {
        const { ctx, setupState } = instance;
        Object.keys(reactivity.toRaw(setupState)).forEach((key) => {
          if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
              warn3(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
              return;
            }
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => setupState[key],
              set: shared.NOOP
            });
          }
        });
      }
      function createDuplicateChecker() {
        const cache = /* @__PURE__ */ Object.create(null);
        return (type, key) => {
          if (cache[key]) {
            warn3(`${type} property "${key}" is already defined in ${cache[key]}.`);
          } else {
            cache[key] = type;
          }
        };
      }
      var shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook(
            options.beforeCreate,
            instance,
            "bc"
            /* BEFORE_CREATE */
          );
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted,
          beforeUpdate,
          updated,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted,
          render: render6,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = createDuplicateChecker();
        {
          const [propsOptions] = instance.propsOptions;
          if (propsOptions) {
            for (const key in propsOptions) {
              checkDuplicateProperties("Props", key);
            }
          }
        }
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (shared.isFunction(methodHandler)) {
              {
                Object.defineProperty(ctx, key, {
                  value: methodHandler.bind(publicThis),
                  configurable: true,
                  enumerable: true,
                  writable: true
                });
              }
              {
                checkDuplicateProperties("Methods", key);
              }
            } else {
              warn3(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
            }
          }
        }
        if (dataOptions) {
          if (!shared.isFunction(dataOptions)) {
            warn3(`The data option must be a function. Plain object usage is no longer supported.`);
          }
          const data = dataOptions.call(publicThis, publicThis);
          if (shared.isPromise(data)) {
            warn3(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
          }
          if (!shared.isObject(data)) {
            warn3(`data() should return an object.`);
          } else {
            instance.data = reactivity.reactive(data);
            {
              for (const key in data) {
                checkDuplicateProperties("Data", key);
                if (!isReservedPrefix(key[0])) {
                  Object.defineProperty(ctx, key, {
                    configurable: true,
                    enumerable: true,
                    get: () => data[key],
                    set: shared.NOOP
                  });
                }
              }
            }
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = shared.isFunction(opt) ? opt.bind(publicThis, publicThis) : shared.isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : shared.NOOP;
            if (get === shared.NOOP) {
              warn3(`Computed property "${key}" has no getter.`);
            }
            const set2 = !shared.isFunction(opt) && shared.isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
              warn3(`Write operation failed: computed property "${key}" is readonly.`);
            };
            const c3 = computed({
              get,
              set: set2
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c3.value,
              set: (v2) => c3.value = v2
            });
            {
              checkDuplicateProperties("Computed", key);
            }
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = shared.isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook(
            created,
            instance,
            "c"
            /* CREATED */
          );
        }
        function registerLifecycleHook(register, hook) {
          if (shared.isArray(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted2, mounted);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate);
        registerLifecycleHook(onUpdated, updated);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (shared.isArray(expose)) {
          if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render6 && instance.render === shared.NOOP) {
          instance.render = render6;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components)
          instance.components = components;
        if (directives)
          instance.directives = directives;
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = shared.NOOP, unwrapRef = false) {
        if (shared.isArray(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (shared.isObject(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
                /* treat default function as factory */
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (reactivity.isRef(injected)) {
            if (unwrapRef) {
              Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => injected.value,
                set: (v2) => injected.value = v2
              });
            } else {
              {
                warn3(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
              }
              ctx[key] = injected;
            }
          } else {
            ctx[key] = injected;
          }
          {
            checkDuplicateProperties("Inject", key);
          }
        }
      }
      function callHook(hook, instance, type) {
        callWithAsyncErrorHandling(shared.isArray(hook) ? hook.map((h5) => h5.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
      }
      function createWatcher(raw, ctx, publicThis, key) {
        const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (shared.isString(raw)) {
          const handler = ctx[raw];
          if (shared.isFunction(handler)) {
            watch(getter, handler);
          } else {
            warn3(`Invalid watch handler specified by key "${raw}"`, handler);
          }
        } else if (shared.isFunction(raw)) {
          watch(getter, raw.bind(publicThis));
        } else if (shared.isObject(raw)) {
          if (shared.isArray(raw)) {
            raw.forEach((r3) => createWatcher(r3, ctx, publicThis, key));
          } else {
            const handler = shared.isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (shared.isFunction(handler)) {
              watch(getter, handler, raw);
            } else {
              warn3(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
          }
        } else {
          warn3(`Invalid watch option: "${key}"`, raw);
        }
      }
      function resolveMergedOptions(instance) {
        const base = instance.type;
        const { mixins, extends: extendsOptions } = base;
        const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
        const cached = cache.get(base);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach((m2) => mergeOptions(resolved, m2, optionMergeStrategies, true));
          }
          mergeOptions(resolved, base, optionMergeStrategies);
        }
        cache.set(base, resolved);
        return resolved;
      }
      function mergeOptions(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach((m2) => mergeOptions(to, m2, strats, true));
        }
        for (const key in from) {
          if (asMixin && key === "expose") {
            warn3(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
          } else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      var internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeObjectOptions,
        emits: mergeObjectOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return shared.extend(shared.isFunction(to) ? to.call(this, this) : to, shared.isFunction(from) ? from.call(this, this) : from);
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (shared.isArray(raw)) {
          const res = {};
          for (let i4 = 0; i4 < raw.length; i4++) {
            res[raw[i4]] = raw[i4];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? shared.extend(shared.extend(/* @__PURE__ */ Object.create(null), to), from) : from;
      }
      function mergeWatchOptions(to, from) {
        if (!to)
          return from;
        if (!from)
          return to;
        const merged = shared.extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props = {};
        const attrs = {};
        shared.def(attrs, InternalObjectKey, 1);
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
            props[key] = void 0;
          }
        }
        {
          validateProps(rawProps || {}, props, instance);
        }
        if (isStateful) {
          instance.props = isSSR ? props : reactivity.shallowReactive(props);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props;
          }
        }
        instance.attrs = attrs;
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const { props, attrs, vnode: { patchFlag } } = instance;
        const rawCurrentProps = reactivity.toRaw(props);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          !(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i4 = 0; i4 < propsToUpdate.length; i4++) {
              let key = propsToUpdate[i4];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (shared.hasOwn(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = shared.camelize(key);
                  props[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                    /* isAbsent */
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !shared.hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = shared.hyphenate(key)) === key || !shared.hasOwn(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                    /* isAbsent */
                  );
                }
              } else {
                delete props[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !shared.hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          reactivity.trigger(instance, "set", "$attrs");
        }
        {
          validateProps(rawProps || {}, props, instance);
        }
      }
      function setFullProps(instance, rawProps, props, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (shared.isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && shared.hasOwn(options, camelKey = shared.camelize(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = reactivity.toRaw(props);
          const castValues = rawCastValues || shared.EMPTY_OBJ;
          for (let i4 = 0; i4 < needCastKeys.length; i4++) {
            const key = needCastKeys[i4];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !shared.hasOwn(castValues, key));
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = shared.hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && shared.isFunction(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(null, props);
                unsetCurrentInstance();
              }
            } else {
              value = defaultValue;
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === shared.hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache = appContext.propsCache;
        const cached = cache.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!shared.isFunction(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw2, appContext, true);
            shared.extend(normalized, props);
            if (keys)
              needCastKeys.push(...keys);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          cache.set(comp, shared.EMPTY_ARR);
          return shared.EMPTY_ARR;
        }
        if (shared.isArray(raw)) {
          for (let i4 = 0; i4 < raw.length; i4++) {
            if (!shared.isString(raw[i4])) {
              warn3(`props must be strings when using array syntax.`, raw[i4]);
            }
            const normalizedKey = shared.camelize(raw[i4]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = shared.EMPTY_OBJ;
            }
          }
        } else if (raw) {
          if (!shared.isObject(raw)) {
            warn3(`invalid props options`, raw);
          }
          for (const key in raw) {
            const normalizedKey = shared.camelize(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = shared.isArray(opt) || shared.isFunction(opt) ? { type: opt } : opt;
              if (prop) {
                const booleanIndex = getTypeIndex(Boolean, prop.type);
                const stringIndex = getTypeIndex(String, prop.type);
                prop[
                  0
                  /* shouldCast */
                ] = booleanIndex > -1;
                prop[
                  1
                  /* shouldCastTrue */
                ] = stringIndex < 0 || booleanIndex < stringIndex;
                if (booleanIndex > -1 || shared.hasOwn(prop, "default")) {
                  needCastKeys.push(normalizedKey);
                }
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        cache.set(comp, res);
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$") {
          return true;
        } else {
          warn3(`Invalid prop name: "${key}" is a reserved property.`);
        }
        return false;
      }
      function getType(ctor) {
        const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
        return match ? match[1] : ctor === null ? "null" : "";
      }
      function isSameType(a3, b2) {
        return getType(a3) === getType(b2);
      }
      function getTypeIndex(type, expectedTypes) {
        if (shared.isArray(expectedTypes)) {
          return expectedTypes.findIndex((t3) => isSameType(t3, type));
        } else if (shared.isFunction(expectedTypes)) {
          return isSameType(expectedTypes, type) ? 0 : -1;
        }
        return -1;
      }
      function validateProps(rawProps, props, instance) {
        const resolvedValues = reactivity.toRaw(props);
        const options = instance.propsOptions[0];
        for (const key in options) {
          let opt = options[key];
          if (opt == null)
            continue;
          validateProp(key, resolvedValues[key], opt, !shared.hasOwn(rawProps, key) && !shared.hasOwn(rawProps, shared.hyphenate(key)));
        }
      }
      function validateProp(name, value, prop, isAbsent) {
        const { type, required, validator } = prop;
        if (required && isAbsent) {
          warn3('Missing required prop: "' + name + '"');
          return;
        }
        if (value == null && !prop.required) {
          return;
        }
        if (type != null && type !== true) {
          let isValid = false;
          const types = shared.isArray(type) ? type : [type];
          const expectedTypes = [];
          for (let i4 = 0; i4 < types.length && !isValid; i4++) {
            const { valid, expectedType } = assertType(value, types[i4]);
            expectedTypes.push(expectedType || "");
            isValid = valid;
          }
          if (!isValid) {
            warn3(getInvalidTypeMessage(name, value, expectedTypes));
            return;
          }
        }
        if (validator && !validator(value)) {
          warn3('Invalid prop: custom validator check failed for prop "' + name + '".');
        }
      }
      var isSimpleType = /* @__PURE__ */ shared.makeMap("String,Number,Boolean,Function,Symbol,BigInt");
      function assertType(value, type) {
        let valid;
        const expectedType = getType(type);
        if (isSimpleType(expectedType)) {
          const t3 = typeof value;
          valid = t3 === expectedType.toLowerCase();
          if (!valid && t3 === "object") {
            valid = value instanceof type;
          }
        } else if (expectedType === "Object") {
          valid = shared.isObject(value);
        } else if (expectedType === "Array") {
          valid = shared.isArray(value);
        } else if (expectedType === "null") {
          valid = value === null;
        } else {
          valid = value instanceof type;
        }
        return {
          valid,
          expectedType
        };
      }
      function getInvalidTypeMessage(name, value, expectedTypes) {
        let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(shared.capitalize).join(" | ")}`;
        const expectedType = expectedTypes[0];
        const receivedType = shared.toRawType(value);
        const expectedValue = styleValue(value, expectedType);
        const receivedValue = styleValue(value, receivedType);
        if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
          message += ` with value ${expectedValue}`;
        }
        message += `, got ${receivedType} `;
        if (isExplicable(receivedType)) {
          message += `with value ${receivedValue}.`;
        }
        return message;
      }
      function styleValue(value, type) {
        if (type === "String") {
          return `"${value}"`;
        } else if (type === "Number") {
          return `${Number(value)}`;
        } else {
          return `${value}`;
        }
      }
      function isExplicable(type) {
        const explicitTypes = ["string", "number", "boolean"];
        return explicitTypes.some((elem) => type.toLowerCase() === elem);
      }
      function isBoolean(...args) {
        return args.some((elem) => elem.toLowerCase() === "boolean");
      }
      var isInternalKey = (key) => key[0] === "_" || key === "$stable";
      var normalizeSlotValue = (value) => shared.isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      var normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (currentInstance) {
            warn3(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
          }
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      var normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key))
            continue;
          const value = rawSlots[key];
          if (shared.isFunction(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            {
              warn3(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      var normalizeVNodeSlots = (instance, children2) => {
        if (!isKeepAlive(instance.vnode) && true) {
          warn3(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
        }
        const normalized = normalizeSlotValue(children2);
        instance.slots.default = () => normalized;
      };
      var initSlots = (instance, children2) => {
        if (instance.vnode.shapeFlag & 32) {
          const type = children2._;
          if (type) {
            instance.slots = reactivity.toRaw(children2);
            shared.def(children2, "_", type);
          } else {
            normalizeObjectSlots(children2, instance.slots = {});
          }
        } else {
          instance.slots = {};
          if (children2) {
            normalizeVNodeSlots(instance, children2);
          }
        }
        shared.def(instance.slots, InternalObjectKey, 1);
      };
      var updateSlots = (instance, children2, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = shared.EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type = children2._;
          if (type) {
            if (isHmrUpdating) {
              shared.extend(slots, children2);
            } else if (optimized && type === 1) {
              needDeletionCheck = false;
            } else {
              shared.extend(slots, children2);
              if (!optimized && type === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children2.$stable;
            normalizeObjectSlots(children2, slots);
          }
          deletionComparisonTarget = children2;
        } else if (children2) {
          normalizeVNodeSlots(instance, children2);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
              delete slots[key];
            }
          }
        }
      };
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: shared.NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      var uid = 0;
      function createAppAPI(render6, hydrate) {
        return function createApp2(rootComponent, rootProps = null) {
          if (!shared.isFunction(rootComponent)) {
            rootComponent = __spreadValues({}, rootComponent);
          }
          if (rootProps != null && !shared.isObject(rootProps)) {
            warn3(`root props passed to app.mount() must be an object.`);
            rootProps = null;
          }
          const context3 = createAppContext();
          const installedPlugins = /* @__PURE__ */ new Set();
          let isMounted = false;
          const app2 = context3.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context3,
            _instance: null,
            version,
            get config() {
              return context3.config;
            },
            set config(v2) {
              {
                warn3(`app.config cannot be replaced. Modify individual options instead.`);
              }
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin)) {
                warn3(`Plugin has already been applied to target app.`);
              } else if (plugin && shared.isFunction(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app2, ...options);
              } else if (shared.isFunction(plugin)) {
                installedPlugins.add(plugin);
                plugin(app2, ...options);
              } else {
                warn3(`A plugin must either be a function or an object with an "install" function.`);
              }
              return app2;
            },
            mixin(mixin) {
              {
                if (!context3.mixins.includes(mixin)) {
                  context3.mixins.push(mixin);
                } else {
                  warn3("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
                }
              }
              return app2;
            },
            component(name, component) {
              {
                validateComponentName(name, context3.config);
              }
              if (!component) {
                return context3.components[name];
              }
              if (context3.components[name]) {
                warn3(`Component "${name}" has already been registered in target app.`);
              }
              context3.components[name] = component;
              return app2;
            },
            directive(name, directive) {
              {
                validateDirectiveName(name);
              }
              if (!directive) {
                return context3.directives[name];
              }
              if (context3.directives[name]) {
                warn3(`Directive "${name}" has already been registered in target app.`);
              }
              context3.directives[name] = directive;
              return app2;
            },
            mount(rootContainer, isHydrate, isSVG) {
              if (!isMounted) {
                if (rootContainer.__vue_app__) {
                  warn3(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
                }
                const vnode = createVNode(rootComponent, rootProps);
                vnode.appContext = context3;
                {
                  context3.reload = () => {
                    render6(cloneVNode(vnode), rootContainer, isSVG);
                  };
                }
                if (isHydrate && hydrate) {
                  hydrate(vnode, rootContainer);
                } else {
                  render6(vnode, rootContainer, isSVG);
                }
                isMounted = true;
                app2._container = rootContainer;
                rootContainer.__vue_app__ = app2;
                {
                  app2._instance = vnode.component;
                  devtoolsInitApp(app2, version);
                }
                return getExposeProxy(vnode.component) || vnode.component.proxy;
              } else {
                warn3(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
              }
            },
            unmount() {
              if (isMounted) {
                render6(null, app2._container);
                {
                  app2._instance = null;
                  devtoolsUnmountApp(app2);
                }
                delete app2._container.__vue_app__;
              } else {
                warn3(`Cannot unmount an app that is not mounted.`);
              }
            },
            provide(key, value) {
              if (key in context3.provides) {
                warn3(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
              }
              context3.provides[key] = value;
              return app2;
            }
          };
          return app2;
        };
      }
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (shared.isArray(rawRef)) {
          rawRef.forEach((r3, i4) => setRef(r3, oldRawRef && (shared.isArray(oldRawRef) ? oldRawRef[i4] : oldRawRef), parentSuspense, vnode, isUnmount));
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref2 } = rawRef;
        if (!owner) {
          warn3(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
          return;
        }
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === shared.EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        if (oldRef != null && oldRef !== ref2) {
          if (shared.isString(oldRef)) {
            refs[oldRef] = null;
            if (shared.hasOwn(setupState, oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (reactivity.isRef(oldRef)) {
            oldRef.value = null;
          }
        }
        if (shared.isFunction(ref2)) {
          callWithErrorHandling(ref2, owner, 12, [value, refs]);
        } else {
          const _isString3 = shared.isString(ref2);
          const _isRef = reactivity.isRef(ref2);
          if (_isString3 || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString3 ? refs[ref2] : ref2.value;
                if (isUnmount) {
                  shared.isArray(existing) && shared.remove(existing, refValue);
                } else {
                  if (!shared.isArray(existing)) {
                    if (_isString3) {
                      refs[ref2] = [refValue];
                      if (shared.hasOwn(setupState, ref2)) {
                        setupState[ref2] = refs[ref2];
                      }
                    } else {
                      ref2.value = [refValue];
                      if (rawRef.k)
                        refs[rawRef.k] = ref2.value;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString3) {
                refs[ref2] = value;
                if (shared.hasOwn(setupState, ref2)) {
                  setupState[ref2] = value;
                }
              } else if (_isRef) {
                ref2.value = value;
                if (rawRef.k)
                  refs[rawRef.k] = value;
              } else {
                warn3("Invalid template ref type:", ref2, `(${typeof ref2})`);
              }
            };
            if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
            } else {
              doSet();
            }
          } else {
            warn3("Invalid template ref type:", ref2, `(${typeof ref2})`);
          }
        }
      }
      var hasMismatch = false;
      var isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
      var isComment = (node) => node.nodeType === 8;
      function createHydrationFunctions(rendererInternals) {
        const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove: remove2, insert, createComment } } = rendererInternals;
        const hydrate = (vnode, container) => {
          if (!container.hasChildNodes()) {
            warn3(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
          }
          hasMismatch = false;
          hydrateNode(container.firstChild, vnode, null, null, null);
          flushPostFlushCbs();
          container._vnode = vnode;
          if (hasMismatch && true) {
            console.error(`Hydration completed but contains mismatches.`);
          }
        };
        const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
          const isFragmentStart = isComment(node) && node.data === "[";
          const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
          const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
          const domType = node.nodeType;
          vnode.el = node;
          if (patchFlag === -2) {
            optimized = false;
            vnode.dynamicChildren = null;
          }
          let nextNode = null;
          switch (type) {
            case Text:
              if (domType !== 3) {
                if (vnode.children === "") {
                  insert(vnode.el = createText(""), parentNode(node), node);
                  nextNode = node;
                } else {
                  nextNode = onMismatch();
                }
              } else {
                if (node.data !== vnode.children) {
                  hasMismatch = true;
                  warn3(`Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`);
                  node.data = vnode.children;
                }
                nextNode = nextSibling(node);
              }
              break;
            case Comment:
              if (domType !== 8 || isFragmentStart) {
                nextNode = onMismatch();
              } else {
                nextNode = nextSibling(node);
              }
              break;
            case Static:
              if (domType !== 1 && domType !== 3) {
                nextNode = onMismatch();
              } else {
                nextNode = node;
                const needToAdoptContent = !vnode.children.length;
                for (let i4 = 0; i4 < vnode.staticCount; i4++) {
                  if (needToAdoptContent)
                    vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                  if (i4 === vnode.staticCount - 1) {
                    vnode.anchor = nextNode;
                  }
                  nextNode = nextSibling(nextNode);
                }
                return nextNode;
              }
              break;
            case Fragment:
              if (!isFragmentStart) {
                nextNode = onMismatch();
              } else {
                nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
              }
              break;
            default:
              if (shapeFlag & 1) {
                if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
                  nextNode = onMismatch();
                } else {
                  nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
              } else if (shapeFlag & 6) {
                vnode.slotScopeIds = slotScopeIds;
                const container = parentNode(node);
                mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
                if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
                  nextNode = nextSibling(nextNode);
                }
                if (isAsyncWrapper(vnode)) {
                  let subTree;
                  if (isFragmentStart) {
                    subTree = createVNode(Fragment);
                    subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                  } else {
                    subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                  }
                  subTree.el = node;
                  vnode.component.subTree = subTree;
                }
              } else if (shapeFlag & 64) {
                if (domType !== 8) {
                  nextNode = onMismatch();
                } else {
                  nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                }
              } else if (shapeFlag & 128) {
                nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
              } else {
                warn3("Invalid HostVNode type:", type, `(${typeof type})`);
              }
          }
          if (ref2 != null) {
            setRef(ref2, null, parentSuspense, vnode);
          }
          return nextNode;
        };
        const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          optimized = optimized || !!vnode.dynamicChildren;
          const { type, props, patchFlag, shapeFlag, dirs } = vnode;
          const forcePatchValue = type === "input" && dirs || type === "option";
          {
            if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "created");
            }
            if (props) {
              if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
                for (const key in props) {
                  if (forcePatchValue && key.endsWith("value") || shared.isOn(key) && !shared.isReservedProp(key)) {
                    patchProp(el, key, null, props[key], false, void 0, parentComponent);
                  }
                }
              } else if (props.onClick) {
                patchProp(el, "onClick", null, props.onClick, false, void 0, parentComponent);
              }
            }
            let vnodeHooks;
            if (vnodeHooks = props && props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
              queueEffectWithSuspense(() => {
                vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
              }, parentSuspense);
            }
            if (shapeFlag & 16 && // skip if element has innerHTML / textContent
            !(props && (props.innerHTML || props.textContent))) {
              let next2 = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
              let hasWarned2 = false;
              while (next2) {
                hasMismatch = true;
                if (!hasWarned2) {
                  warn3(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
                  hasWarned2 = true;
                }
                const cur = next2;
                next2 = next2.nextSibling;
                remove2(cur);
              }
            } else if (shapeFlag & 8) {
              if (el.textContent !== vnode.children) {
                hasMismatch = true;
                warn3(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`);
                el.textContent = vnode.children;
              }
            }
          }
          return el.nextSibling;
        };
        const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          optimized = optimized || !!parentVNode.dynamicChildren;
          const children2 = parentVNode.children;
          const l4 = children2.length;
          let hasWarned2 = false;
          for (let i4 = 0; i4 < l4; i4++) {
            const vnode = optimized ? children2[i4] : children2[i4] = normalizeVNode(children2[i4]);
            if (node) {
              node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            } else if (vnode.type === Text && !vnode.children) {
              continue;
            } else {
              hasMismatch = true;
              if (!hasWarned2) {
                warn3(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
                hasWarned2 = true;
              }
              patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
          }
          return node;
        };
        const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          const { slotScopeIds: fragmentSlotScopeIds } = vnode;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          const container = parentNode(node);
          const next2 = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
          if (next2 && isComment(next2) && next2.data === "]") {
            return nextSibling(vnode.anchor = next2);
          } else {
            hasMismatch = true;
            insert(vnode.anchor = createComment(`]`), container, next2);
            return next2;
          }
        };
        const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
          hasMismatch = true;
          warn3(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
          vnode.el = null;
          if (isFragment) {
            const end = locateClosingAsyncAnchor(node);
            while (true) {
              const next3 = nextSibling(node);
              if (next3 && next3 !== end) {
                remove2(next3);
              } else {
                break;
              }
            }
          }
          const next2 = nextSibling(node);
          const container = parentNode(node);
          remove2(node);
          patch(null, vnode, container, next2, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
          return next2;
        };
        const locateClosingAsyncAnchor = (node) => {
          let match = 0;
          while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
              if (node.data === "[")
                match++;
              if (node.data === "]") {
                if (match === 0) {
                  return nextSibling(node);
                } else {
                  match--;
                }
              }
            }
          }
          return node;
        };
        return [hydrate, hydrateNode];
      }
      var supported;
      var perf;
      function startMeasure(instance, type) {
        if (instance.appContext.config.performance && isSupported()) {
          perf.mark(`vue-${type}-${instance.uid}`);
        }
        {
          devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
        }
      }
      function endMeasure(instance, type) {
        if (instance.appContext.config.performance && isSupported()) {
          const startTag = `vue-${type}-${instance.uid}`;
          const endTag = startTag + `:end`;
          perf.mark(endTag);
          perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
          perf.clearMarks(startTag);
          perf.clearMarks(endTag);
        }
        {
          devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
        }
      }
      function isSupported() {
        if (supported !== void 0) {
          return supported;
        }
        if (typeof window !== "undefined" && window.performance) {
          supported = true;
          perf = window.performance;
        } else {
          supported = false;
        }
        return supported;
      }
      var queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function createHydrationRenderer(options) {
        return baseCreateRenderer(options, createHydrationFunctions);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = shared.getGlobalThis();
        target.__VUE__ = true;
        {
          setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
        }
        const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = shared.NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
        const patch = (n1, n22, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n22.dynamicChildren) => {
          if (n1 === n22) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n22)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n22.patchFlag === -2) {
            optimized = false;
            n22.dynamicChildren = null;
          }
          const { type, ref: ref2, shapeFlag } = n22;
          switch (type) {
            case Text:
              processText(n1, n22, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n22, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n22, container, anchor, isSVG);
              } else {
                patchStaticNode(n1, n22, container, isSVG);
              }
              break;
            case Fragment:
              processFragment(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              break;
            default:
              if (shapeFlag & 1) {
                processElement(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              } else if (shapeFlag & 6) {
                processComponent(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              } else if (shapeFlag & 64) {
                type.process(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
              } else if (shapeFlag & 128) {
                type.process(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
              } else {
                warn3("Invalid VNode type:", type, `(${typeof type})`);
              }
          }
          if (ref2 != null && parentComponent) {
            setRef(ref2, n1 && n1.ref, parentSuspense, n22 || n1, !n22);
          }
        };
        const processText = (n1, n22, container, anchor) => {
          if (n1 == null) {
            hostInsert(n22.el = hostCreateText(n22.children), container, anchor);
          } else {
            const el = n22.el = n1.el;
            if (n22.children !== n1.children) {
              hostSetText(el, n22.children);
            }
          }
        };
        const processCommentNode = (n1, n22, container, anchor) => {
          if (n1 == null) {
            hostInsert(n22.el = hostCreateComment(n22.children || ""), container, anchor);
          } else {
            n22.el = n1.el;
          }
        };
        const mountStaticNode = (n22, container, anchor, isSVG) => {
          [n22.el, n22.anchor] = hostInsertStaticContent(n22.children, container, anchor, isSVG, n22.el, n22.anchor);
        };
        const patchStaticNode = (n1, n22, container, isSVG) => {
          if (n22.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            removeStaticNode(n1);
            [n22.el, n22.anchor] = hostInsertStaticContent(n22.children, container, anchor, isSVG);
          } else {
            n22.el = n1.el;
            n22.anchor = n1.anchor;
          }
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next2;
          while (el && el !== anchor) {
            next2 = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next2;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next2;
          while (el && el !== anchor) {
            next2 = hostNextSibling(el);
            hostRemove(el);
            el = next2;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          isSVG = isSVG || n22.type === "svg";
          if (n1 == null) {
            mountElement(n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            patchElement(n1, n22, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { type, props, shapeFlag, transition: transition2, patchFlag, dirs } = vnode;
          {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
            if (shapeFlag & 8) {
              hostSetElementText(el, vnode.children);
            } else if (shapeFlag & 16) {
              mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
            }
            if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "created");
            }
            if (props) {
              for (const key in props) {
                if (key !== "value" && !shared.isReservedProp(key)) {
                  hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
              }
              if ("value" in props) {
                hostPatchProp(el, "value", null, props.value);
              }
              if (vnodeHook = props.onVnodeBeforeMount) {
                invokeVNodeHook(vnodeHook, parentComponent, vnode);
              }
            }
            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          }
          {
            Object.defineProperty(el, "__vnode", {
              value: vnode,
              enumerable: false
            });
            Object.defineProperty(el, "__vueParentComponent", {
              value: parentComponent,
              enumerable: false
            });
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition2 && !transition2.persisted;
          if (needCallTransitionHooks) {
            transition2.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition2.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i4 = 0; i4 < slotScopeIds.length; i4++) {
              hostSetScopeId(el, slotScopeIds[i4]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
              subTree = filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
              const parentVNode = parentComponent.vnode;
              setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
          }
        };
        const mountChildren = (children2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
          for (let i4 = start; i4 < children2.length; i4++) {
            const child = children2[i4] = optimized ? cloneIfMounted(children2[i4]) : normalizeVNode(children2[i4]);
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        };
        const patchElement = (n1, n22, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const el = n22.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n22;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || shared.EMPTY_OBJ;
          const newProps = n22.props || shared.EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n22, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n22, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          if (isHmrUpdating) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
          }
          const areChildrenSVG = isSVG && n22.type !== "foreignObject";
          if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (parentComponent && parentComponent.type.__hmrId) {
              traverseStaticChildren(n1, n22);
            }
          } else if (!optimized) {
            patchChildren(n1, n22, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(el, n22, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, isSVG);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n22.dynamicProps;
                for (let i4 = 0; i4 < propsToUpdate.length; i4++) {
                  const key = propsToUpdate[i4];
                  const prev2 = oldProps[key];
                  const next2 = newProps[key];
                  if (next2 !== prev2 || key === "value") {
                    hostPatchProp(el, key, prev2, next2, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n22.children) {
                hostSetElementText(el, n22.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(el, n22, oldProps, newProps, parentComponent, parentSuspense, isSVG);
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n22, n1);
              dirs && invokeDirectiveHook(n22, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
          for (let i4 = 0; i4 < newChildren.length; i4++) {
            const oldVNode = oldChildren[i4];
            const newVNode = newChildren[i4];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
          }
        };
        const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
          if (oldProps !== newProps) {
            for (const key in newProps) {
              if (shared.isReservedProp(key))
                continue;
              const next2 = newProps[key];
              const prev2 = oldProps[key];
              if (next2 !== prev2 && key !== "value") {
                hostPatchProp(el, key, prev2, next2, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
            if (oldProps !== shared.EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!shared.isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value);
            }
          }
        };
        const processFragment = (n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n22.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n22.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n22;
          if (
            // #5523 dev root fragment may inherit directives
            isHmrUpdating || patchFlag & 2048
          ) {
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
          }
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(n22.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
              if (parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n22);
              } else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n22.key != null || parentComponent && n22 === parentComponent.subTree
              ) {
                traverseStaticChildren(
                  n1,
                  n22,
                  true
                  /* shallow */
                );
              }
            } else {
              patchChildren(n1, n22, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
          }
        };
        const processComponent = (n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          n22.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n22.shapeFlag & 512) {
              parentComponent.ctx.activate(n22, container, anchor, isSVG, optimized);
            } else {
              mountComponent(n22, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
          } else {
            updateComponent(n1, n22, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
          if (instance.type.__hmrId) {
            registerHMR(instance);
          }
          {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
          }
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            {
              startMeasure(instance, `init`);
            }
            setupComponent(instance);
            {
              endMeasure(instance, `init`);
            }
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
            }
            return;
          }
          setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
          {
            popWarningContext();
            endMeasure(instance, `mount`);
          }
        };
        const updateComponent = (n1, n22, optimized) => {
          const instance = n22.component = n1.component;
          if (shouldUpdateComponent(n1, n22, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              {
                pushWarningContext(n22);
              }
              updateComponentPreRender(instance, n22, optimized);
              {
                popWarningContext();
              }
              return;
            } else {
              instance.next = n22;
              invalidateJob(instance.update);
              instance.update();
            }
          } else {
            n22.el = n1.el;
            instance.vnode = n22;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props } = initialVNode;
              const { bm, m: m2, parent: parent2 } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                shared.invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent2, initialVNode);
              }
              toggleRecurse(instance, true);
              if (el && hydrateNode) {
                const hydrateSubTree = () => {
                  {
                    startMeasure(instance, `render`);
                  }
                  instance.subTree = renderComponentRoot(instance);
                  {
                    endMeasure(instance, `render`);
                  }
                  {
                    startMeasure(instance, `hydrate`);
                  }
                  hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                  {
                    endMeasure(instance, `hydrate`);
                  }
                };
                if (isAsyncWrapperVNode) {
                  initialVNode.type.__asyncLoader().then(
                    // note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    () => !instance.isUnmounted && hydrateSubTree()
                  );
                } else {
                  hydrateSubTree();
                }
              } else {
                {
                  startMeasure(instance, `render`);
                }
                const subTree = instance.subTree = renderComponentRoot(instance);
                {
                  endMeasure(instance, `render`);
                }
                {
                  startMeasure(instance, `patch`);
                }
                patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                {
                  endMeasure(instance, `patch`);
                }
                initialVNode.el = subTree.el;
              }
              if (m2) {
                queuePostRenderEffect(m2, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode), parentSuspense);
              }
              if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              {
                devtoolsComponentAdded(instance);
              }
              initialVNode = container = anchor = null;
            } else {
              let { next: next2, bu, u: u2, parent: parent2, vnode } = instance;
              let originNext = next2;
              let vnodeHook;
              {
                pushWarningContext(next2 || instance.vnode);
              }
              toggleRecurse(instance, false);
              if (next2) {
                next2.el = vnode.el;
                updateComponentPreRender(instance, next2, optimized);
              } else {
                next2 = vnode;
              }
              if (bu) {
                shared.invokeArrayFns(bu);
              }
              if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent2, next2, vnode);
              }
              toggleRecurse(instance, true);
              {
                startMeasure(instance, `render`);
              }
              const nextTree = renderComponentRoot(instance);
              {
                endMeasure(instance, `render`);
              }
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              {
                startMeasure(instance, `patch`);
              }
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                isSVG
              );
              {
                endMeasure(instance, `patch`);
              }
              next2.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u2) {
                queuePostRenderEffect(u2, parentSuspense);
              }
              if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
                queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent2, next2, vnode), parentSuspense);
              }
              {
                devtoolsComponentUpdated(instance);
              }
              {
                popWarningContext();
              }
            }
          };
          const effect = instance.effect = new reactivity.ReactiveEffect(
            componentUpdateFn,
            () => queueJob(update),
            instance.scope
            // track it in component's effect scope
          );
          const update = instance.update = () => effect.run();
          update.id = instance.uid;
          toggleRecurse(instance, true);
          {
            effect.onTrack = instance.rtc ? (e4) => shared.invokeArrayFns(instance.rtc, e4) : void 0;
            effect.onTrigger = instance.rtg ? (e4) => shared.invokeArrayFns(instance.rtg, e4) : void 0;
            update.ownerInstance = instance;
          }
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          reactivity.pauseTracking();
          flushPreFlushCbs(void 0, instance.update);
          reactivity.resetTracking();
        };
        const patchChildren = (n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c22 = n22.children;
          const { patchFlag, shapeFlag } = n22;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c22 !== c1) {
              hostSetElementText(container, c22);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(c1, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          c1 = c1 || shared.EMPTY_ARR;
          c22 = c22 || shared.EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c22.length;
          const commonLength = Math.min(oldLength, newLength);
          let i4;
          for (i4 = 0; i4 < commonLength; i4++) {
            const nextChild = c22[i4] = optimized ? cloneIfMounted(c22[i4]) : normalizeVNode(c22[i4]);
            patch(c1[i4], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
          if (oldLength > newLength) {
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
          } else {
            mountChildren(c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
          }
        };
        const patchKeyedChildren = (c1, c22, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let i4 = 0;
          const l22 = c22.length;
          let e1 = c1.length - 1;
          let e22 = l22 - 1;
          while (i4 <= e1 && i4 <= e22) {
            const n1 = c1[i4];
            const n22 = c22[i4] = optimized ? cloneIfMounted(c22[i4]) : normalizeVNode(c22[i4]);
            if (isSameVNodeType(n1, n22)) {
              patch(n1, n22, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else {
              break;
            }
            i4++;
          }
          while (i4 <= e1 && i4 <= e22) {
            const n1 = c1[e1];
            const n22 = c22[e22] = optimized ? cloneIfMounted(c22[e22]) : normalizeVNode(c22[e22]);
            if (isSameVNodeType(n1, n22)) {
              patch(n1, n22, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else {
              break;
            }
            e1--;
            e22--;
          }
          if (i4 > e1) {
            if (i4 <= e22) {
              const nextPos = e22 + 1;
              const anchor = nextPos < l22 ? c22[nextPos].el : parentAnchor;
              while (i4 <= e22) {
                patch(null, c22[i4] = optimized ? cloneIfMounted(c22[i4]) : normalizeVNode(c22[i4]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                i4++;
              }
            }
          } else if (i4 > e22) {
            while (i4 <= e1) {
              unmount(c1[i4], parentComponent, parentSuspense, true);
              i4++;
            }
          } else {
            const s1 = i4;
            const s22 = i4;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i4 = s22; i4 <= e22; i4++) {
              const nextChild = c22[i4] = optimized ? cloneIfMounted(c22[i4]) : normalizeVNode(c22[i4]);
              if (nextChild.key != null) {
                if (keyToNewIndexMap.has(nextChild.key)) {
                  warn3(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                }
                keyToNewIndexMap.set(nextChild.key, i4);
              }
            }
            let j2;
            let patched = 0;
            const toBePatched = e22 - s22 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i4 = 0; i4 < toBePatched; i4++)
              newIndexToOldIndexMap[i4] = 0;
            for (i4 = s1; i4 <= e1; i4++) {
              const prevChild = c1[i4];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j2 = s22; j2 <= e22; j2++) {
                  if (newIndexToOldIndexMap[j2 - s22] === 0 && isSameVNodeType(prevChild, c22[j2])) {
                    newIndex = j2;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s22] = i4 + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(prevChild, c22[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : shared.EMPTY_ARR;
            j2 = increasingNewIndexSequence.length - 1;
            for (i4 = toBePatched - 1; i4 >= 0; i4--) {
              const nextIndex = s22 + i4;
              const nextChild = c22[nextIndex];
              const anchor = nextIndex + 1 < l22 ? c22[nextIndex + 1].el : parentAnchor;
              if (newIndexToOldIndexMap[i4] === 0) {
                patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              } else if (moved) {
                if (j2 < 0 || i4 !== increasingNewIndexSequence[j2]) {
                  move(
                    nextChild,
                    container,
                    anchor,
                    2
                    /* REORDER */
                  );
                } else {
                  j2--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type, transition: transition2, children: children2, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
          }
          if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i4 = 0; i4 < children2.length; i4++) {
              move(children2[i4], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition = moveType !== 2 && shapeFlag & 1 && transition2;
          if (needTransition) {
            if (moveType === 0) {
              transition2.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition2.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition2;
              const remove3 = () => hostInsert(el, container, anchor);
              const performLeave = () => {
                leave(el, () => {
                  remove3();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove3, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const { type, props, ref: ref2, children: children2, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
          if (ref2 != null) {
            setRef(ref2, null, parentSuspense, vnode, true);
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children2, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove2(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove2 = (vnode) => {
          const { type, el, anchor, transition: transition2 } = vnode;
          if (type === Fragment) {
            if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition2 && !transition2.persisted) {
              vnode.children.forEach((child) => {
                if (child.type === Comment) {
                  hostRemove(child.el);
                } else {
                  remove2(child);
                }
              });
            } else {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition2 && !transition2.persisted && transition2.afterLeave) {
              transition2.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition2 && !transition2.persisted) {
            const { leave, delayLeave } = transition2;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end) => {
          let next2;
          while (cur !== end) {
            next2 = hostNextSibling(cur);
            hostRemove(cur);
            cur = next2;
          }
          hostRemove(end);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          if (instance.type.__hmrId) {
            unregisterHMR(instance);
          }
          const { bum, scope, update, subTree, um } = instance;
          if (bum) {
            shared.invokeArrayFns(bum);
          }
          scope.stop();
          if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
          if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
              parentSuspense.resolve();
            }
          }
          {
            devtoolsComponentRemoved(instance);
          }
        };
        const unmountChildren = (children2, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i4 = start; i4 < children2.length; i4++) {
            unmount(children2[i4], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          return hostNextSibling(vnode.anchor || vnode.el);
        };
        const render6 = (vnode, container, isSVG) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
          }
          flushPostFlushCbs();
          container._vnode = vnode;
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove2,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        let hydrateNode;
        if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(internals);
        }
        return {
          render: render6,
          hydrate,
          createApp: createAppAPI(render6, hydrate)
        };
      }
      function toggleRecurse({ effect, update }, allowed) {
        effect.allowRecurse = update.allowRecurse = allowed;
      }
      function traverseStaticChildren(n1, n22, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n22.children;
        if (shared.isArray(ch1) && shared.isArray(ch2)) {
          for (let i4 = 0; i4 < ch1.length; i4++) {
            const c1 = ch1[i4];
            let c22 = ch2[i4];
            if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
              if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
                c22 = ch2[i4] = cloneIfMounted(ch2[i4]);
                c22.el = c1.el;
              }
              if (!shallow)
                traverseStaticChildren(c1, c22);
            }
            if (c22.type === Comment && !c22.el) {
              c22.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p2 = arr.slice();
        const result = [0];
        let i4, j2, u2, v2, c3;
        const len = arr.length;
        for (i4 = 0; i4 < len; i4++) {
          const arrI = arr[i4];
          if (arrI !== 0) {
            j2 = result[result.length - 1];
            if (arr[j2] < arrI) {
              p2[i4] = j2;
              result.push(i4);
              continue;
            }
            u2 = 0;
            v2 = result.length - 1;
            while (u2 < v2) {
              c3 = u2 + v2 >> 1;
              if (arr[result[c3]] < arrI) {
                u2 = c3 + 1;
              } else {
                v2 = c3;
              }
            }
            if (arrI < arr[result[u2]]) {
              if (u2 > 0) {
                p2[i4] = result[u2 - 1];
              }
              result[u2] = i4;
            }
          }
        }
        u2 = result.length;
        v2 = result[u2 - 1];
        while (u2-- > 0) {
          result[u2] = v2;
          v2 = p2[v2];
        }
        return result;
      }
      var isTeleport = (type) => type.__isTeleport;
      var isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
      var isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      var resolveTarget = (props, select) => {
        const targetSelector = props && props.to;
        if (shared.isString(targetSelector)) {
          if (!select) {
            warn3(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
          } else {
            const target = select(targetSelector);
            if (!target) {
              warn3(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            }
            return target;
          }
        } else {
          if (!targetSelector && !isTeleportDisabled(props)) {
            warn3(`Invalid Teleport target: ${targetSelector}`);
          }
          return targetSelector;
        }
      };
      var TeleportImpl = {
        __isTeleport: true,
        process(n1, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
          const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
          const disabled = isTeleportDisabled(n22.props);
          let { shapeFlag, children: children2, dynamicChildren } = n22;
          if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
          }
          if (n1 == null) {
            const placeholder = n22.el = createComment("teleport start");
            const mainAnchor = n22.anchor = createComment("teleport end");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n22.target = resolveTarget(n22.props, querySelector);
            const targetAnchor = n22.targetAnchor = createText("");
            if (target) {
              insert(targetAnchor, target);
              isSVG = isSVG || isTargetSVG(target);
            } else if (!disabled) {
              warn3("Invalid Teleport target on mount:", target, `(${typeof target})`);
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(children2, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target) {
              mount(target, targetAnchor);
            }
          } else {
            n22.el = n1.el;
            const mainAnchor = n22.anchor = n1.anchor;
            const target = n22.target = n1.target;
            const targetAnchor = n22.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
              patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
              traverseStaticChildren(n1, n22, true);
            } else if (!optimized) {
              patchChildren(n1, n22, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(
                  n22,
                  container,
                  mainAnchor,
                  internals,
                  1
                  /* TOGGLE */
                );
              }
            } else {
              if ((n22.props && n22.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n22.target = resolveTarget(n22.props, querySelector);
                if (nextTarget) {
                  moveTeleport(
                    n22,
                    nextTarget,
                    null,
                    internals,
                    0
                    /* TARGET_CHANGE */
                  );
                } else {
                  warn3("Invalid Teleport target on update:", target, `(${typeof target})`);
                }
              } else if (wasDisabled) {
                moveTeleport(
                  n22,
                  target,
                  targetAnchor,
                  internals,
                  1
                  /* TOGGLE */
                );
              }
            }
          }
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children: children2, anchor, targetAnchor, target, props } = vnode;
          if (target) {
            hostRemove(targetAnchor);
          }
          if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16) {
              for (let i4 = 0; i4 < children2.length; i4++) {
                const child = children2[i4];
                unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
              }
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
        if (moveType === 0) {
          insert(vnode.targetAnchor, container, parentAnchor);
        }
        const { el, anchor, shapeFlag, children: children2, props } = vnode;
        const isReorder = moveType === 2;
        if (isReorder) {
          insert(el, container, parentAnchor);
        }
        if (!isReorder || isTeleportDisabled(props)) {
          if (shapeFlag & 16) {
            for (let i4 = 0; i4 < children2.length; i4++) {
              move(
                children2[i4],
                container,
                parentAnchor,
                2
                /* REORDER */
              );
            }
          }
        }
        if (isReorder) {
          insert(anchor, container, parentAnchor);
        }
      }
      function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
        const target = vnode.target = resolveTarget(vnode.props, querySelector);
        if (target) {
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
              vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
              vnode.targetAnchor = targetNode;
            } else {
              vnode.anchor = nextSibling(node);
              let targetAnchor = targetNode;
              while (targetAnchor) {
                targetAnchor = nextSibling(targetAnchor);
                if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
          }
        }
        return vnode.anchor && nextSibling(vnode.anchor);
      }
      var Teleport = TeleportImpl;
      var Fragment = Symbol("Fragment");
      var Text = Symbol("Text");
      var Comment = Symbol("Comment");
      var Static = Symbol("Static");
      var blockStack = [];
      var currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      var isBlockTreeEnabled = 1;
      function setBlockTracking(value) {
        isBlockTreeEnabled += value;
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || shared.EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type, props, children2, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(createBaseVNode(
          type,
          props,
          children2,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
          /* isBlock */
        ));
      }
      function createBlock(type, props, children2, patchFlag, dynamicProps) {
        return setupBlock(createVNode(
          type,
          props,
          children2,
          patchFlag,
          dynamicProps,
          true
          /* isBlock: prevent a block from tracking itself */
        ));
      }
      function isVNode(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n22) {
        if (n22.shapeFlag & 6 && hmrDirtyComponents.has(n22.type)) {
          return false;
        }
        return n1.type === n22.type && n1.key === n22.key;
      }
      var vnodeArgsTransformer;
      function transformVNodeArgs(transformer) {
        vnodeArgsTransformer = transformer;
      }
      var createVNodeWithArgsTransform = (...args) => {
        return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
      };
      var InternalObjectKey = `__vInternal`;
      var normalizeKey = ({ key }) => key != null ? key : null;
      var normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
        return ref2 != null ? shared.isString(ref2) || reactivity.isRef(ref2) || shared.isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
      };
      function createBaseVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children: children2,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children2);
          if (shapeFlag & 128) {
            type.normalize(vnode);
          }
        } else if (children2) {
          vnode.shapeFlag |= shared.isString(children2) ? 8 : 16;
        }
        if (vnode.key !== vnode.key) {
          warn3(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      var createVNode = createVNodeWithArgsTransform;
      function _createVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type || type === NULL_DYNAMIC_COMPONENT) {
          if (!type) {
            warn3(`Invalid vnode type when creating vnode: ${type}.`);
          }
          type = Comment;
        }
        if (isVNode(type)) {
          const cloned = cloneVNode(
            type,
            props,
            true
            /* mergeRef: true */
          );
          if (children2) {
            normalizeChildren(cloned, children2);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag |= -2;
          return cloned;
        }
        if (isClassComponent(type)) {
          type = type.__vccOpts;
        }
        if (props) {
          props = guardReactiveProps(props);
          let { class: klass, style } = props;
          if (klass && !shared.isString(klass)) {
            props.class = shared.normalizeClass(klass);
          }
          if (shared.isObject(style)) {
            if (reactivity.isProxy(style) && !shared.isArray(style)) {
              style = shared.extend({}, style);
            }
            props.style = shared.normalizeStyle(style);
          }
        }
        const shapeFlag = shared.isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : shared.isObject(type) ? 4 : shared.isFunction(type) ? 2 : 0;
        if (shapeFlag & 4 && reactivity.isProxy(type)) {
          type = reactivity.toRaw(type);
          warn3(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
        }
        return createBaseVNode(type, props, children2, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
      }
      function guardReactiveProps(props) {
        if (!props)
          return null;
        return reactivity.isProxy(props) || InternalObjectKey in props ? shared.extend({}, props) : props;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false) {
        const { props, ref: ref2, patchFlag, children: children2 } = vnode;
        const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref2 ? shared.isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref2,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children: patchFlag === -1 && shared.isArray(children2) ? children2.map(deepCloneVNode) : children2,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor
        };
        return cloned;
      }
      function deepCloneVNode(vnode) {
        const cloned = cloneVNode(vnode);
        if (shared.isArray(vnode.children)) {
          cloned.children = vnode.children.map(deepCloneVNode);
        }
        return cloned;
      }
      function createTextVNode(text2 = " ", flag = 0) {
        return createVNode(Text, null, text2, flag);
      }
      function createStaticVNode(content, numberOfNodes) {
        const vnode = createVNode(Static, null, content);
        vnode.staticCount = numberOfNodes;
        return vnode;
      }
      function createCommentVNode(text2 = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (shared.isArray(child)) {
          return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (typeof child === "object") {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children2) {
        let type = 0;
        const { shapeFlag } = vnode;
        if (children2 == null) {
          children2 = null;
        } else if (shared.isArray(children2)) {
          type = 16;
        } else if (typeof children2 === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children2.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type = 32;
            const slotFlag = children2._;
            if (!slotFlag && !(InternalObjectKey in children2)) {
              children2._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children2._ = 1;
              } else {
                children2._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (shared.isFunction(children2)) {
          children2 = { default: children2, _ctx: currentRenderingInstance };
          type = 32;
        } else {
          children2 = String(children2);
          if (shapeFlag & 64) {
            type = 16;
            children2 = [createTextVNode(children2)];
          } else {
            type = 8;
          }
        }
        vnode.children = children2;
        vnode.shapeFlag |= type;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i4 = 0; i4 < args.length; i4++) {
          const toMerge = args[i4];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = shared.normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = shared.normalizeStyle([ret.style, toMerge.style]);
            } else if (shared.isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(shared.isArray(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      var emptyAppContext = createAppContext();
      var uid$1 = 0;
      function createComponentInstance(vnode, parent2, suspense) {
        const type = vnode.type;
        const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid$1++,
          vnode,
          type,
          parent: parent2,
          appContext,
          root: null,
          next: null,
          subTree: null,
          effect: null,
          update: null,
          scope: new reactivity.EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent2 ? parent2.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type, appContext),
          emitsOptions: normalizeEmitsOptions(type, appContext),
          // emit
          emit: null,
          emitted: null,
          // props default value
          propsDefaults: shared.EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type.inheritAttrs,
          // state
          ctx: shared.EMPTY_OBJ,
          data: shared.EMPTY_OBJ,
          props: shared.EMPTY_OBJ,
          attrs: shared.EMPTY_OBJ,
          slots: shared.EMPTY_OBJ,
          refs: shared.EMPTY_OBJ,
          setupState: shared.EMPTY_OBJ,
          setupContext: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = createDevRenderContext(instance);
        }
        instance.root = parent2 ? parent2.root : instance;
        instance.emit = emit$1.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      var currentInstance = null;
      var getCurrentInstance = () => currentInstance || currentRenderingInstance;
      var setCurrentInstance = (instance) => {
        currentInstance = instance;
        instance.scope.on();
      };
      var unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        currentInstance = null;
      };
      var isBuiltInTag = /* @__PURE__ */ shared.makeMap("slot,component");
      function validateComponentName(name, config3) {
        const appIsNativeTag = config3.isNativeTag || shared.NO;
        if (isBuiltInTag(name) || appIsNativeTag(name)) {
          warn3("Do not use built-in or reserved HTML elements as component id: " + name);
        }
      }
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      var isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false) {
        isInSSRComponentSetup = isSSR;
        const { props, children: children2 } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props, isStateful, isSSR);
        initSlots(instance, children2);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isInSSRComponentSetup = false;
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        var _a;
        const Component = instance.type;
        {
          if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
          }
          if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i4 = 0; i4 < names.length; i4++) {
              validateComponentName(names[i4], instance.appContext.config);
            }
          }
          if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i4 = 0; i4 < names.length; i4++) {
              validateDirectiveName(names[i4]);
            }
          }
          if (Component.compilerOptions && isRuntimeOnly()) {
            warn3(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
          }
        }
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = reactivity.markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
        {
          exposePropsOnRenderContext(instance);
        }
        const { setup: setup2 } = Component;
        if (setup2) {
          const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
          setCurrentInstance(instance);
          reactivity.pauseTracking();
          const setupResult = callWithErrorHandling(setup2, instance, 0, [reactivity.shallowReadonly(instance.props), setupContext]);
          reactivity.resetTracking();
          unsetCurrentInstance();
          if (shared.isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult, isSSR);
              }).catch((e4) => {
                handleError(
                  e4,
                  instance,
                  0
                  /* SETUP_FUNCTION */
                );
              });
            } else {
              instance.asyncDep = setupResult;
              if (!instance.suspense) {
                const name = (_a = Component.name) !== null && _a !== void 0 ? _a : "Anonymous";
                warn3(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
              }
            }
          } else {
            handleSetupResult(instance, setupResult, isSSR);
          }
        } else {
          finishComponentSetup(instance, isSSR);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (shared.isFunction(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (shared.isObject(setupResult)) {
          if (isVNode(setupResult)) {
            warn3(`setup() should not return VNodes directly - return a render function instead.`);
          }
          {
            instance.devtoolsRawSetupState = setupResult;
          }
          instance.setupState = reactivity.proxyRefs(setupResult);
          {
            exposeSetupStateOnRenderContext(instance);
          }
        } else if (setupResult !== void 0) {
          warn3(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
        }
        finishComponentSetup(instance, isSSR);
      }
      var compile3;
      var installWithProxy;
      function registerRuntimeCompiler2(_compile) {
        compile3 = _compile;
        installWithProxy = (i4) => {
          if (i4.render._rc) {
            i4.withProxy = new Proxy(i4.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
          }
        };
      }
      var isRuntimeOnly = () => !compile3;
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          if (!isSSR && compile3 && !Component.render) {
            const template2 = Component.template;
            if (template2) {
              {
                startMeasure(instance, `compile`);
              }
              const { isCustomElement, compilerOptions } = instance.appContext.config;
              const { delimiters, compilerOptions: componentCompilerOptions } = Component;
              const finalCompilerOptions = shared.extend(shared.extend({
                isCustomElement,
                delimiters
              }, compilerOptions), componentCompilerOptions);
              Component.render = compile3(template2, finalCompilerOptions);
              {
                endMeasure(instance, `compile`);
              }
            }
          }
          instance.render = Component.render || shared.NOOP;
          if (installWithProxy) {
            installWithProxy(instance);
          }
        }
        {
          setCurrentInstance(instance);
          reactivity.pauseTracking();
          applyOptions(instance);
          reactivity.resetTracking();
          unsetCurrentInstance();
        }
        if (!Component.render && instance.render === shared.NOOP && !isSSR) {
          if (!compile3 && Component.template) {
            warn3(
              `Component provided template option but runtime compilation is not supported in this build of Vue.`
              /* should not happen */
            );
          } else {
            warn3(`Component is missing template or render function.`);
          }
        }
      }
      function createAttrsProxy(instance) {
        return new Proxy(
          instance.attrs,
          {
            get(target, key) {
              markAttrsAccessed();
              reactivity.track(instance, "get", "$attrs");
              return target[key];
            },
            set() {
              warn3(`setupContext.attrs is readonly.`);
              return false;
            },
            deleteProperty() {
              warn3(`setupContext.attrs is readonly.`);
              return false;
            }
          }
        );
      }
      function createSetupContext(instance) {
        const expose = (exposed) => {
          if (instance.exposed) {
            warn3(`expose() should be called only once per setup().`);
          }
          instance.exposed = exposed || {};
        };
        let attrs;
        {
          return Object.freeze({
            get attrs() {
              return attrs || (attrs = createAttrsProxy(instance));
            },
            get slots() {
              return reactivity.shallowReadonly(instance.slots);
            },
            get emit() {
              return (event2, ...args) => instance.emit(event2, ...args);
            },
            expose
          });
        }
      }
      function getExposeProxy(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(reactivity.proxyRefs(reactivity.markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            }
          }));
        }
      }
      var classifyRE = /(?:^|[-_])(\w)/g;
      var classify = (str) => str.replace(classifyRE, (c3) => c3.toUpperCase()).replace(/[-_]/g, "");
      function getComponentName(Component, includeInferred = true) {
        return shared.isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function formatComponentName(instance, Component, isRoot = false) {
        let name = getComponentName(Component);
        if (!name && Component.__file) {
          const match = Component.__file.match(/([^/\\]+)\.\w+$/);
          if (match) {
            name = match[1];
          }
        }
        if (!name && instance && instance.parent) {
          const inferFromRegistry = (registry) => {
            for (const key in registry) {
              if (registry[key] === Component) {
                return key;
              }
            }
          };
          name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
        }
        return name ? classify(name) : isRoot ? `App` : `Anonymous`;
      }
      function isClassComponent(value) {
        return shared.isFunction(value) && "__vccOpts" in value;
      }
      var computed = (getterOrOptions, debugOptions) => {
        return reactivity.computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
      };
      var warnRuntimeUsage = (method) => warn3(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
      function defineProps() {
        {
          warnRuntimeUsage(`defineProps`);
        }
        return null;
      }
      function defineEmits() {
        {
          warnRuntimeUsage(`defineEmits`);
        }
        return null;
      }
      function defineExpose(exposed) {
        {
          warnRuntimeUsage(`defineExpose`);
        }
      }
      function withDefaults(props, defaults2) {
        {
          warnRuntimeUsage(`withDefaults`);
        }
        return null;
      }
      function useSlots() {
        return getContext().slots;
      }
      function useAttrs() {
        return getContext().attrs;
      }
      function getContext() {
        const i4 = getCurrentInstance();
        if (!i4) {
          warn3(`useContext() called without active instance.`);
        }
        return i4.setupContext || (i4.setupContext = createSetupContext(i4));
      }
      function mergeDefaults(raw, defaults2) {
        const props = shared.isArray(raw) ? raw.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw;
        for (const key in defaults2) {
          const opt = props[key];
          if (opt) {
            if (shared.isArray(opt) || shared.isFunction(opt)) {
              props[key] = { type: opt, default: defaults2[key] };
            } else {
              opt.default = defaults2[key];
            }
          } else if (opt === null) {
            props[key] = { default: defaults2[key] };
          } else {
            warn3(`props default key "${key}" has no corresponding declaration.`);
          }
        }
        return props;
      }
      function createPropsRestProxy(props, excludedKeys) {
        const ret = {};
        for (const key in props) {
          if (!excludedKeys.includes(key)) {
            Object.defineProperty(ret, key, {
              enumerable: true,
              get: () => props[key]
            });
          }
        }
        return ret;
      }
      function withAsyncContext(getAwaitable) {
        const ctx = getCurrentInstance();
        if (!ctx) {
          warn3(`withAsyncContext called without active current instance. This is likely a bug.`);
        }
        let awaitable = getAwaitable();
        unsetCurrentInstance();
        if (shared.isPromise(awaitable)) {
          awaitable = awaitable.catch((e4) => {
            setCurrentInstance(ctx);
            throw e4;
          });
        }
        return [awaitable, () => setCurrentInstance(ctx)];
      }
      function h4(type, propsOrChildren, children2) {
        const l4 = arguments.length;
        if (l4 === 2) {
          if (shared.isObject(propsOrChildren) && !shared.isArray(propsOrChildren)) {
            if (isVNode(propsOrChildren)) {
              return createVNode(type, null, [propsOrChildren]);
            }
            return createVNode(type, propsOrChildren);
          } else {
            return createVNode(type, null, propsOrChildren);
          }
        } else {
          if (l4 > 3) {
            children2 = Array.prototype.slice.call(arguments, 2);
          } else if (l4 === 3 && isVNode(children2)) {
            children2 = [children2];
          }
          return createVNode(type, propsOrChildren, children2);
        }
      }
      var ssrContextKey = Symbol(`ssrContext`);
      var useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          if (!ctx) {
            warn3(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
          }
          return ctx;
        }
      };
      function isShallow(value) {
        return !!(value && value[
          "__v_isShallow"
          /* IS_SHALLOW */
        ]);
      }
      function initCustomFormatter3() {
        if (typeof window === "undefined") {
          return;
        }
        const vueStyle = { style: "color:#3ba776" };
        const numberStyle = { style: "color:#0b1bc9" };
        const stringStyle = { style: "color:#b62e24" };
        const keywordStyle = { style: "color:#9d288c" };
        const formatter = {
          header(obj) {
            if (!shared.isObject(obj)) {
              return null;
            }
            if (obj.__isVue) {
              return ["div", vueStyle, `VueInstance`];
            } else if (reactivity.isRef(obj)) {
              return [
                "div",
                {},
                ["span", vueStyle, genRefFlag(obj)],
                "<",
                formatValue(obj.value),
                `>`
              ];
            } else if (reactivity.isReactive(obj)) {
              return [
                "div",
                {},
                ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
                "<",
                formatValue(obj),
                `>${reactivity.isReadonly(obj) ? ` (readonly)` : ``}`
              ];
            } else if (reactivity.isReadonly(obj)) {
              return [
                "div",
                {},
                ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
                "<",
                formatValue(obj),
                ">"
              ];
            }
            return null;
          },
          hasBody(obj) {
            return obj && obj.__isVue;
          },
          body(obj) {
            if (obj && obj.__isVue) {
              return [
                "div",
                {},
                ...formatInstance(obj.$)
              ];
            }
          }
        };
        function formatInstance(instance) {
          const blocks = [];
          if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock("props", reactivity.toRaw(instance.props)));
          }
          if (instance.setupState !== shared.EMPTY_OBJ) {
            blocks.push(createInstanceBlock("setup", instance.setupState));
          }
          if (instance.data !== shared.EMPTY_OBJ) {
            blocks.push(createInstanceBlock("data", reactivity.toRaw(instance.data)));
          }
          const computed2 = extractKeys(instance, "computed");
          if (computed2) {
            blocks.push(createInstanceBlock("computed", computed2));
          }
          const injected = extractKeys(instance, "inject");
          if (injected) {
            blocks.push(createInstanceBlock("injected", injected));
          }
          blocks.push([
            "div",
            {},
            [
              "span",
              {
                style: keywordStyle.style + ";opacity:0.66"
              },
              "$ (internal): "
            ],
            ["object", { object: instance }]
          ]);
          return blocks;
        }
        function createInstanceBlock(type, target) {
          target = shared.extend({}, target);
          if (!Object.keys(target).length) {
            return ["span", {}];
          }
          return [
            "div",
            { style: "line-height:1.25em;margin-bottom:0.6em" },
            [
              "div",
              {
                style: "color:#476582"
              },
              type
            ],
            [
              "div",
              {
                style: "padding-left:1.25em"
              },
              ...Object.keys(target).map((key) => {
                return [
                  "div",
                  {},
                  ["span", keywordStyle, key + ": "],
                  formatValue(target[key], false)
                ];
              })
            ]
          ];
        }
        function formatValue(v2, asRaw = true) {
          if (typeof v2 === "number") {
            return ["span", numberStyle, v2];
          } else if (typeof v2 === "string") {
            return ["span", stringStyle, JSON.stringify(v2)];
          } else if (typeof v2 === "boolean") {
            return ["span", keywordStyle, v2];
          } else if (shared.isObject(v2)) {
            return ["object", { object: asRaw ? reactivity.toRaw(v2) : v2 }];
          } else {
            return ["span", stringStyle, String(v2)];
          }
        }
        function extractKeys(instance, type) {
          const Comp = instance.type;
          if (shared.isFunction(Comp)) {
            return;
          }
          const extracted = {};
          for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
              extracted[key] = instance.ctx[key];
            }
          }
          return extracted;
        }
        function isKeyOfType(Comp, key, type) {
          const opts = Comp[type];
          if (shared.isArray(opts) && opts.includes(key) || shared.isObject(opts) && key in opts) {
            return true;
          }
          if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
          }
          if (Comp.mixins && Comp.mixins.some((m2) => isKeyOfType(m2, key, type))) {
            return true;
          }
        }
        function genRefFlag(v2) {
          if (isShallow(v2)) {
            return `ShallowRef`;
          }
          if (v2.effect) {
            return `ComputedRef`;
          }
          return `Ref`;
        }
        if (window.devtoolsFormatters) {
          window.devtoolsFormatters.push(formatter);
        } else {
          window.devtoolsFormatters = [formatter];
        }
      }
      function withMemo(memo, render6, cache, index2) {
        const cached = cache[index2];
        if (cached && isMemoSame(cached, memo)) {
          return cached;
        }
        const ret = render6();
        ret.memo = memo.slice();
        return cache[index2] = ret;
      }
      function isMemoSame(cached, memo) {
        const prev2 = cached.memo;
        if (prev2.length != memo.length) {
          return false;
        }
        for (let i4 = 0; i4 < prev2.length; i4++) {
          if (shared.hasChanged(prev2[i4], memo[i4])) {
            return false;
          }
        }
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(cached);
        }
        return true;
      }
      var version = "3.2.37";
      var _ssrUtils = {
        createComponentInstance,
        setupComponent,
        renderComponentRoot,
        setCurrentRenderingInstance,
        isVNode,
        normalizeVNode
      };
      var ssrUtils = _ssrUtils;
      var resolveFilter = null;
      var compatUtils = null;
      exports.EffectScope = reactivity.EffectScope;
      exports.ReactiveEffect = reactivity.ReactiveEffect;
      exports.customRef = reactivity.customRef;
      exports.effect = reactivity.effect;
      exports.effectScope = reactivity.effectScope;
      exports.getCurrentScope = reactivity.getCurrentScope;
      exports.isProxy = reactivity.isProxy;
      exports.isReactive = reactivity.isReactive;
      exports.isReadonly = reactivity.isReadonly;
      exports.isRef = reactivity.isRef;
      exports.isShallow = reactivity.isShallow;
      exports.markRaw = reactivity.markRaw;
      exports.onScopeDispose = reactivity.onScopeDispose;
      exports.proxyRefs = reactivity.proxyRefs;
      exports.reactive = reactivity.reactive;
      exports.readonly = reactivity.readonly;
      exports.ref = reactivity.ref;
      exports.shallowReactive = reactivity.shallowReactive;
      exports.shallowReadonly = reactivity.shallowReadonly;
      exports.shallowRef = reactivity.shallowRef;
      exports.stop = reactivity.stop;
      exports.toRaw = reactivity.toRaw;
      exports.toRef = reactivity.toRef;
      exports.toRefs = reactivity.toRefs;
      exports.triggerRef = reactivity.triggerRef;
      exports.unref = reactivity.unref;
      exports.camelize = shared.camelize;
      exports.capitalize = shared.capitalize;
      exports.normalizeClass = shared.normalizeClass;
      exports.normalizeProps = shared.normalizeProps;
      exports.normalizeStyle = shared.normalizeStyle;
      exports.toDisplayString = shared.toDisplayString;
      exports.toHandlerKey = shared.toHandlerKey;
      exports.BaseTransition = BaseTransition;
      exports.Comment = Comment;
      exports.Fragment = Fragment;
      exports.KeepAlive = KeepAlive;
      exports.Static = Static;
      exports.Suspense = Suspense;
      exports.Teleport = Teleport;
      exports.Text = Text;
      exports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;
      exports.callWithErrorHandling = callWithErrorHandling;
      exports.cloneVNode = cloneVNode;
      exports.compatUtils = compatUtils;
      exports.computed = computed;
      exports.createBlock = createBlock;
      exports.createCommentVNode = createCommentVNode;
      exports.createElementBlock = createElementBlock;
      exports.createElementVNode = createBaseVNode;
      exports.createHydrationRenderer = createHydrationRenderer;
      exports.createPropsRestProxy = createPropsRestProxy;
      exports.createRenderer = createRenderer;
      exports.createSlots = createSlots;
      exports.createStaticVNode = createStaticVNode;
      exports.createTextVNode = createTextVNode;
      exports.createVNode = createVNode;
      exports.defineAsyncComponent = defineAsyncComponent;
      exports.defineComponent = defineComponent2;
      exports.defineEmits = defineEmits;
      exports.defineExpose = defineExpose;
      exports.defineProps = defineProps;
      exports.getCurrentInstance = getCurrentInstance;
      exports.getTransitionRawChildren = getTransitionRawChildren;
      exports.guardReactiveProps = guardReactiveProps;
      exports.h = h4;
      exports.handleError = handleError;
      exports.initCustomFormatter = initCustomFormatter3;
      exports.inject = inject;
      exports.isMemoSame = isMemoSame;
      exports.isRuntimeOnly = isRuntimeOnly;
      exports.isVNode = isVNode;
      exports.mergeDefaults = mergeDefaults;
      exports.mergeProps = mergeProps;
      exports.nextTick = nextTick2;
      exports.onActivated = onActivated;
      exports.onBeforeMount = onBeforeMount;
      exports.onBeforeUnmount = onBeforeUnmount;
      exports.onBeforeUpdate = onBeforeUpdate;
      exports.onDeactivated = onDeactivated;
      exports.onErrorCaptured = onErrorCaptured;
      exports.onMounted = onMounted2;
      exports.onRenderTracked = onRenderTracked;
      exports.onRenderTriggered = onRenderTriggered;
      exports.onServerPrefetch = onServerPrefetch;
      exports.onUnmounted = onUnmounted;
      exports.onUpdated = onUpdated;
      exports.openBlock = openBlock;
      exports.popScopeId = popScopeId;
      exports.provide = provide;
      exports.pushScopeId = pushScopeId;
      exports.queuePostFlushCb = queuePostFlushCb;
      exports.registerRuntimeCompiler = registerRuntimeCompiler2;
      exports.renderList = renderList;
      exports.renderSlot = renderSlot;
      exports.resolveComponent = resolveComponent;
      exports.resolveDirective = resolveDirective;
      exports.resolveDynamicComponent = resolveDynamicComponent;
      exports.resolveFilter = resolveFilter;
      exports.resolveTransitionHooks = resolveTransitionHooks;
      exports.setBlockTracking = setBlockTracking;
      exports.setDevtoolsHook = setDevtoolsHook;
      exports.setTransitionHooks = setTransitionHooks;
      exports.ssrContextKey = ssrContextKey;
      exports.ssrUtils = ssrUtils;
      exports.toHandlers = toHandlers;
      exports.transformVNodeArgs = transformVNodeArgs;
      exports.useAttrs = useAttrs;
      exports.useSSRContext = useSSRContext;
      exports.useSlots = useSlots;
      exports.useTransitionState = useTransitionState;
      exports.version = version;
      exports.warn = warn3;
      exports.watch = watch;
      exports.watchEffect = watchEffect;
      exports.watchPostEffect = watchPostEffect;
      exports.watchSyncEffect = watchSyncEffect;
      exports.withAsyncContext = withAsyncContext;
      exports.withCtx = withCtx;
      exports.withDefaults = withDefaults;
      exports.withDirectives = withDirectives;
      exports.withMemo = withMemo;
      exports.withScopeId = withScopeId;
    }
  });

  // node_modules/@vue/runtime-core/index.js
  var require_runtime_core = __commonJS({
    "node_modules/@vue/runtime-core/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_runtime_core_cjs();
      }
    }
  });

  // node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.js
  var require_runtime_dom_cjs = __commonJS({
    "node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var runtimeCore = require_runtime_core();
      var shared = require_shared();
      var svgNS = "http://www.w3.org/2000/svg";
      var doc = typeof document !== "undefined" ? document : null;
      var templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      var nodeOps = {
        insert: (child, parent2, anchor) => {
          parent2.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent2 = child.parentNode;
          if (parent2) {
            parent2.removeChild(child);
          }
        },
        createElement: (tag, isSVG, is2, props) => {
          const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text2) => doc.createTextNode(text2),
        createComment: (text2) => doc.createComment(text2),
        setText: (node, text2) => {
          node.nodeValue = text2;
        },
        setElementText: (el, text2) => {
          el.textContent = text2;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector3) => doc.querySelector(selector3),
        setScopeId(el, id) {
          el.setAttribute(id, "");
        },
        cloneNode(el) {
          const cloned = el.cloneNode(true);
          if (`_value` in el) {
            cloned._value = el._value;
          }
          return cloned;
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent2, anchor, isSVG, start, end) {
          const before = anchor ? anchor.previousSibling : parent2.lastChild;
          if (start && (start === end || start.nextSibling)) {
            while (true) {
              parent2.insertBefore(start.cloneNode(true), anchor);
              if (start === end || !(start = start.nextSibling))
                break;
            }
          } else {
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template2 = templateContainer.content;
            if (isSVG) {
              const wrapper = template2.firstChild;
              while (wrapper.firstChild) {
                template2.appendChild(wrapper.firstChild);
              }
              template2.removeChild(wrapper);
            }
            parent2.insertBefore(template2, anchor);
          }
          return [
            // first
            before ? before.nextSibling : parent2.firstChild,
            // last
            anchor ? anchor.previousSibling : parent2.lastChild
          ];
        }
      };
      function patchClass(el, value, isSVG) {
        const transitionClasses = el._vtc;
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      function patchStyle(el, prev2, next2) {
        const style = el.style;
        const isCssString = shared.isString(next2);
        if (next2 && !isCssString) {
          for (const key in next2) {
            setStyle(style, key, next2[key]);
          }
          if (prev2 && !shared.isString(prev2)) {
            for (const key in prev2) {
              if (next2[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
        } else {
          const currentDisplay = style.display;
          if (isCssString) {
            if (prev2 !== next2) {
              style.cssText = next2;
            }
          } else if (prev2) {
            el.removeAttribute("style");
          }
          if ("_vod" in el) {
            style.display = currentDisplay;
          }
        }
      }
      var importantRE = /\s*!important$/;
      function setStyle(style, name, val) {
        if (shared.isArray(val)) {
          val.forEach((v2) => setStyle(style, name, v2));
        } else {
          if (val == null)
            val = "";
          if (name.startsWith("--")) {
            style.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
              style.setProperty(shared.hyphenate(prefixed), val.replace(importantRE, ""), "important");
            } else {
              style[prefixed] = val;
            }
          }
        }
      }
      var prefixes = ["Webkit", "Moz", "ms"];
      var prefixCache = {};
      function autoPrefix(style, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = runtimeCore.camelize(rawName);
        if (name !== "filter" && name in style) {
          return prefixCache[rawName] = name;
        }
        name = shared.capitalize(name);
        for (let i4 = 0; i4 < prefixes.length; i4++) {
          const prefixed = prefixes[i4] + name;
          if (prefixed in style) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      var xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          const isBoolean = shared.isSpecialBooleanAttr(key);
          if (value == null || isBoolean && !shared.includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(key, isBoolean ? "" : value);
          }
        }
      }
      function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
        if (key === "innerHTML" || key === "textContent") {
          if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? "" : value;
          return;
        }
        if (key === "value" && el.tagName !== "PROGRESS" && // custom elements may use _value internally
        !el.tagName.includes("-")) {
          el._value = value;
          const newValue = value == null ? "" : value;
          if (el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
          // textContent if no value attribute is present. And setting .value for
          // OPTION has no side effect
          el.tagName === "OPTION") {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type = typeof el[key];
          if (type === "boolean") {
            value = shared.includeBooleanAttr(value);
          } else if (value == null && type === "string") {
            value = "";
            needRemove = true;
          } else if (type === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e4) {
          {
            runtimeCore.warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e4);
          }
        }
        needRemove && el.removeAttribute(key);
      }
      var [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
        let _getNow2 = Date.now;
        let skipTimestampCheck2 = false;
        if (typeof window !== "undefined") {
          if (Date.now() > document.createEvent("Event").timeStamp) {
            _getNow2 = performance.now.bind(performance);
          }
          const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
          skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
        }
        return [_getNow2, skipTimestampCheck2];
      })();
      var cachedNow = 0;
      var p2 = /* @__PURE__ */ Promise.resolve();
      var reset = () => {
        cachedNow = 0;
      };
      var getNow = () => cachedNow || (p2.then(reset), cachedNow = _getNow());
      function addEventListener2(el, event2, handler, options) {
        el.addEventListener(event2, handler, options);
      }
      function removeEventListener2(el, event2, handler, options) {
        el.removeEventListener(event2, handler, options);
      }
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el._vei || (el._vei = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener2(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener2(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      var optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m2;
          while (m2 = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m2[0].length);
            options[m2[0].toLowerCase()] = true;
          }
        }
        return [shared.hyphenate(name.slice(2)), options];
      }
      function createInvoker(initialValue, instance) {
        const invoker = (e4) => {
          const timeStamp = e4.timeStamp || _getNow();
          if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
            runtimeCore.callWithAsyncErrorHandling(patchStopImmediatePropagation(e4, invoker.value), instance, 5, [e4]);
          }
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e4, value) {
        if (shared.isArray(value)) {
          const originalStop = e4.stopImmediatePropagation;
          e4.stopImmediatePropagation = () => {
            originalStop.call(e4);
            e4._stopped = true;
          };
          return value.map((fn) => (e5) => !e5._stopped && fn && fn(e5));
        } else {
          return value;
        }
      }
      var nativeOnRE = /^on[a-z]/;
      var patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (shared.isOn(key)) {
          if (!shared.isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && nativeOnRE.test(key) && shared.isFunction(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (nativeOnRE.test(key) && shared.isString(value)) {
          return false;
        }
        return key in el;
      }
      function defineCustomElement(options, hydrate2) {
        const Comp = runtimeCore.defineComponent(options);
        class VueCustomElement extends VueElement {
          constructor(initialProps) {
            super(Comp, initialProps, hydrate2);
          }
        }
        VueCustomElement.def = Comp;
        return VueCustomElement;
      }
      var defineSSRCustomElement = (options) => {
        return defineCustomElement(options, hydrate);
      };
      var BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
      };
      var VueElement = class _VueElement extends BaseClass {
        constructor(_def, _props = {}, hydrate2) {
          super();
          this._def = _def;
          this._props = _props;
          this._instance = null;
          this._connected = false;
          this._resolved = false;
          this._numberProps = null;
          if (this.shadowRoot && hydrate2) {
            hydrate2(this._createVNode(), this.shadowRoot);
          } else {
            if (this.shadowRoot) {
              runtimeCore.warn(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            }
            this.attachShadow({ mode: "open" });
          }
        }
        connectedCallback() {
          this._connected = true;
          if (!this._instance) {
            this._resolveDef();
          }
        }
        disconnectedCallback() {
          this._connected = false;
          runtimeCore.nextTick(() => {
            if (!this._connected) {
              render6(null, this.shadowRoot);
              this._instance = null;
            }
          });
        }
        /**
         * resolve inner component definition (handle possible async component)
         */
        _resolveDef() {
          if (this._resolved) {
            return;
          }
          this._resolved = true;
          for (let i4 = 0; i4 < this.attributes.length; i4++) {
            this._setAttr(this.attributes[i4].name);
          }
          new MutationObserver((mutations) => {
            for (const m2 of mutations) {
              this._setAttr(m2.attributeName);
            }
          }).observe(this, { attributes: true });
          const resolve = (def) => {
            const { props, styles: styles2 } = def;
            const hasOptions = !shared.isArray(props);
            const rawKeys = props ? hasOptions ? Object.keys(props) : props : [];
            let numberProps;
            if (hasOptions) {
              for (const key in this._props) {
                const opt = props[key];
                if (opt === Number || opt && opt.type === Number) {
                  this._props[key] = shared.toNumber(this._props[key]);
                  (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[key] = true;
                }
              }
            }
            this._numberProps = numberProps;
            for (const key of Object.keys(this)) {
              if (key[0] !== "_") {
                this._setProp(key, this[key], true, false);
              }
            }
            for (const key of rawKeys.map(shared.camelize)) {
              Object.defineProperty(this, key, {
                get() {
                  return this._getProp(key);
                },
                set(val) {
                  this._setProp(key, val);
                }
              });
            }
            this._applyStyles(styles2);
            this._update();
          };
          const asyncDef = this._def.__asyncLoader;
          if (asyncDef) {
            asyncDef().then(resolve);
          } else {
            resolve(this._def);
          }
        }
        _setAttr(key) {
          let value = this.getAttribute(key);
          if (this._numberProps && this._numberProps[key]) {
            value = shared.toNumber(value);
          }
          this._setProp(shared.camelize(key), value, false);
        }
        /**
         * @internal
         */
        _getProp(key) {
          return this._props[key];
        }
        /**
         * @internal
         */
        _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
          if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
              this._update();
            }
            if (shouldReflect) {
              if (val === true) {
                this.setAttribute(shared.hyphenate(key), "");
              } else if (typeof val === "string" || typeof val === "number") {
                this.setAttribute(shared.hyphenate(key), val + "");
              } else if (!val) {
                this.removeAttribute(shared.hyphenate(key));
              }
            }
          }
        }
        _update() {
          render6(this._createVNode(), this.shadowRoot);
        }
        _createVNode() {
          const vnode = runtimeCore.createVNode(this._def, shared.extend({}, this._props));
          if (!this._instance) {
            vnode.ce = (instance) => {
              this._instance = instance;
              instance.isCE = true;
              {
                instance.ceReload = (newStyles) => {
                  if (this._styles) {
                    this._styles.forEach((s4) => this.shadowRoot.removeChild(s4));
                    this._styles.length = 0;
                  }
                  this._applyStyles(newStyles);
                  if (!this._def.__asyncLoader) {
                    this._instance = null;
                    this._update();
                  }
                };
              }
              instance.emit = (event2, ...args) => {
                this.dispatchEvent(new CustomEvent(event2, {
                  detail: args
                }));
              };
              let parent2 = this;
              while (parent2 = parent2 && (parent2.parentNode || parent2.host)) {
                if (parent2 instanceof _VueElement) {
                  instance.parent = parent2._instance;
                  break;
                }
              }
            };
          }
          return vnode;
        }
        _applyStyles(styles2) {
          if (styles2) {
            styles2.forEach((css2) => {
              const s4 = document.createElement("style");
              s4.textContent = css2;
              this.shadowRoot.appendChild(s4);
              {
                (this._styles || (this._styles = [])).push(s4);
              }
            });
          }
        }
      };
      function useCssModule(name = "$style") {
        {
          const instance = runtimeCore.getCurrentInstance();
          if (!instance) {
            runtimeCore.warn(`useCssModule must be called inside setup()`);
            return shared.EMPTY_OBJ;
          }
          const modules = instance.type.__cssModules;
          if (!modules) {
            runtimeCore.warn(`Current instance does not have CSS modules injected.`);
            return shared.EMPTY_OBJ;
          }
          const mod = modules[name];
          if (!mod) {
            runtimeCore.warn(`Current instance does not have CSS module named "${name}".`);
            return shared.EMPTY_OBJ;
          }
          return mod;
        }
      }
      function useCssVars(getter) {
        return;
      }
      var TRANSITION = "transition";
      var ANIMATION = "animation";
      var Transition = (props, { slots }) => runtimeCore.h(runtimeCore.BaseTransition, resolveTransitionProps(props), slots);
      Transition.displayName = "Transition";
      var DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      var TransitionPropsValidators = Transition.props = /* @__PURE__ */ shared.extend({}, runtimeCore.BaseTransition.props, DOMTransitionPropsValidators);
      var callHook = (hook, args = []) => {
        if (shared.isArray(hook)) {
          hook.forEach((h4) => h4(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      var hasExplicitCallback = (hook) => {
        return hook ? shared.isArray(hook) ? hook.some((h4) => h4.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
        const finishEnter = (el, isAppear, done) => {
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type, enterDuration, resolve);
              }
            });
          };
        };
        return shared.extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type, leaveDuration, resolve);
              }
            });
            callHook(onLeave, [el, resolve]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (shared.isObject(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n4 = NumberOf(duration);
          return [n4, n4];
        }
      }
      function NumberOf(val) {
        const res = shared.toNumber(val);
        validateDuration(res);
        return res;
      }
      function validateDuration(val) {
        if (typeof val !== "number") {
          runtimeCore.warn(`<transition> explicit duration is not a valid number - got ${JSON.stringify(val)}.`);
        } else if (isNaN(val)) {
          runtimeCore.warn(`<transition> explicit duration is NaN - the duration expression might be incorrect.`);
        }
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c3) => c3 && el.classList.add(c3));
        (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c3) => c3 && el.classList.remove(c3));
        const { _vtc } = el;
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el._vtc = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      var endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
        const id = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id === el._endId) {
            resolve();
          }
        };
        if (explicitTimeout) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type) {
          return resolve();
        }
        const endEvent = type + "end";
        let ended = 0;
        const end = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e4) => {
          if (e4.target === el && ++ended >= propCount) {
            end();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles2 = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles2[key] || "").split(", ");
        const transitionDelays = getStyleProperties(TRANSITION + "Delay");
        const transitionDurations = getStyleProperties(TRANSITION + "Duration");
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(ANIMATION + "Delay");
        const animationDurations = getStyleProperties(ANIMATION + "Duration");
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles2[TRANSITION + "Property"]);
        return {
          type,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d2, i4) => toMs(d2) + toMs(delays[i4])));
      }
      function toMs(s4) {
        return Number(s4.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      var positionMap = /* @__PURE__ */ new WeakMap();
      var newPositionMap = /* @__PURE__ */ new WeakMap();
      var TransitionGroupImpl = {
        name: "TransitionGroup",
        props: /* @__PURE__ */ shared.extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
        }),
        setup(props, { slots }) {
          const instance = runtimeCore.getCurrentInstance();
          const state = runtimeCore.useTransitionState();
          let prevChildren;
          let children2;
          runtimeCore.onUpdated(() => {
            if (!prevChildren.length) {
              return;
            }
            const moveClass = props.moveClass || `${props.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
              return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c3) => {
              const el = c3.el;
              const style = el.style;
              addTransitionClass(el, moveClass);
              style.transform = style.webkitTransform = style.transitionDuration = "";
              const cb = el._moveCb = (e4) => {
                if (e4 && e4.target !== el) {
                  return;
                }
                if (!e4 || /transform$/.test(e4.propertyName)) {
                  el.removeEventListener("transitionend", cb);
                  el._moveCb = null;
                  removeTransitionClass(el, moveClass);
                }
              };
              el.addEventListener("transitionend", cb);
            });
          });
          return () => {
            const rawProps = runtimeCore.toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || runtimeCore.Fragment;
            prevChildren = children2;
            children2 = slots.default ? runtimeCore.getTransitionRawChildren(slots.default()) : [];
            for (let i4 = 0; i4 < children2.length; i4++) {
              const child = children2[i4];
              if (child.key != null) {
                runtimeCore.setTransitionHooks(child, runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance));
              } else {
                runtimeCore.warn(`<TransitionGroup> children must be keyed.`);
              }
            }
            if (prevChildren) {
              for (let i4 = 0; i4 < prevChildren.length; i4++) {
                const child = prevChildren[i4];
                runtimeCore.setTransitionHooks(child, runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance));
                positionMap.set(child, child.el.getBoundingClientRect());
              }
            }
            return runtimeCore.createVNode(tag, null, children2);
          };
        }
      };
      var TransitionGroup = TransitionGroupImpl;
      function callPendingCbs(c3) {
        const el = c3.el;
        if (el._moveCb) {
          el._moveCb();
        }
        if (el._enterCb) {
          el._enterCb();
        }
      }
      function recordPosition(c3) {
        newPositionMap.set(c3, c3.el.getBoundingClientRect());
      }
      function applyTranslation(c3) {
        const oldPos = positionMap.get(c3);
        const newPos = newPositionMap.get(c3);
        const dx = oldPos.left - newPos.left;
        const dy = oldPos.top - newPos.top;
        if (dx || dy) {
          const s4 = c3.el.style;
          s4.transform = s4.webkitTransform = `translate(${dx}px,${dy}px)`;
          s4.transitionDuration = "0s";
          return c3;
        }
      }
      function hasCSSTransform(el, root, moveClass) {
        const clone2 = el.cloneNode();
        if (el._vtc) {
          el._vtc.forEach((cls) => {
            cls.split(/\s+/).forEach((c3) => c3 && clone2.classList.remove(c3));
          });
        }
        moveClass.split(/\s+/).forEach((c3) => c3 && clone2.classList.add(c3));
        clone2.style.display = "none";
        const container = root.nodeType === 1 ? root : root.parentNode;
        container.appendChild(clone2);
        const { hasTransform } = getTransitionInfo(clone2);
        container.removeChild(clone2);
        return hasTransform;
      }
      var getModelAssigner = (vnode) => {
        const fn = vnode.props["onUpdate:modelValue"] || false;
        return shared.isArray(fn) ? (value) => shared.invokeArrayFns(fn, value) : fn;
      };
      function onCompositionStart(e4) {
        e4.target.composing = true;
      }
      function onCompositionEnd(e4) {
        const target = e4.target;
        if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event("input"));
        }
      }
      var vModelText = {
        created(el, { modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          const castToNumber = number || vnode.props && vnode.props.type === "number";
          addEventListener2(el, lazy ? "change" : "input", (e4) => {
            if (e4.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = shared.toNumber(domValue);
            }
            el._assign(domValue);
          });
          if (trim) {
            addEventListener2(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener2(el, "compositionstart", onCompositionStart);
            addEventListener2(el, "compositionend", onCompositionEnd);
            addEventListener2(el, "change", onCompositionEnd);
          }
        },
        // set value on mounted so it's after min/max for type="range"
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (el.composing)
            return;
          if (document.activeElement === el && el.type !== "range") {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === value) {
              return;
            }
            if ((number || el.type === "number") && shared.toNumber(el.value) === value) {
              return;
            }
          }
          const newValue = value == null ? "" : value;
          if (el.value !== newValue) {
            el.value = newValue;
          }
        }
      };
      var vModelCheckbox = {
        // #4096 array checkboxes need to be deep traversed
        deep: true,
        created(el, _2, vnode) {
          el._assign = getModelAssigner(vnode);
          addEventListener2(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if (shared.isArray(modelValue)) {
              const index2 = shared.looseIndexOf(modelValue, elementValue);
              const found = index2 !== -1;
              if (checked && !found) {
                assign(modelValue.concat(elementValue));
              } else if (!checked && found) {
                const filtered = [...modelValue];
                filtered.splice(index2, 1);
                assign(filtered);
              }
            } else if (shared.isSet(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign(cloned);
            } else {
              assign(getCheckboxValue(el, checked));
            }
          });
        },
        // set initial checked on mount to wait for true-value/false-value
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el._assign = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      function setChecked(el, { value, oldValue }, vnode) {
        el._modelValue = value;
        if (shared.isArray(value)) {
          el.checked = shared.looseIndexOf(value, vnode.props.value) > -1;
        } else if (shared.isSet(value)) {
          el.checked = value.has(vnode.props.value);
        } else if (value !== oldValue) {
          el.checked = shared.looseEqual(value, getCheckboxValue(el, true));
        }
      }
      var vModelRadio = {
        created(el, { value }, vnode) {
          el.checked = shared.looseEqual(value, vnode.props.value);
          el._assign = getModelAssigner(vnode);
          addEventListener2(el, "change", () => {
            el._assign(getValue(el));
          });
        },
        beforeUpdate(el, { value, oldValue }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (value !== oldValue) {
            el.checked = shared.looseEqual(value, vnode.props.value);
          }
        }
      };
      var vModelSelect = {
        // <select multiple> value need to be deep traversed
        deep: true,
        created(el, { value, modifiers: { number } }, vnode) {
          const isSetModel = shared.isSet(value);
          addEventListener2(el, "change", () => {
            const selectedVal = Array.prototype.filter.call(el.options, (o4) => o4.selected).map((o4) => number ? shared.toNumber(getValue(o4)) : getValue(o4));
            el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
          });
          el._assign = getModelAssigner(vnode);
        },
        // set value in mounted & updated because <select> relies on its children
        // <option>s.
        mounted(el, { value }) {
          setSelected(el, value);
        },
        beforeUpdate(el, _binding, vnode) {
          el._assign = getModelAssigner(vnode);
        },
        updated(el, { value }) {
          setSelected(el, value);
        }
      };
      function setSelected(el, value) {
        const isMultiple = el.multiple;
        if (isMultiple && !shared.isArray(value) && !shared.isSet(value)) {
          runtimeCore.warn(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
          return;
        }
        for (let i4 = 0, l4 = el.options.length; i4 < l4; i4++) {
          const option2 = el.options[i4];
          const optionValue = getValue(option2);
          if (isMultiple) {
            if (shared.isArray(value)) {
              option2.selected = shared.looseIndexOf(value, optionValue) > -1;
            } else {
              option2.selected = value.has(optionValue);
            }
          } else {
            if (shared.looseEqual(getValue(option2), value)) {
              if (el.selectedIndex !== i4)
                el.selectedIndex = i4;
              return;
            }
          }
        }
        if (!isMultiple && el.selectedIndex !== -1) {
          el.selectedIndex = -1;
        }
      }
      function getValue(el) {
        return "_value" in el ? el._value : el.value;
      }
      function getCheckboxValue(el, checked) {
        const key = checked ? "_trueValue" : "_falseValue";
        return key in el ? el[key] : checked;
      }
      var vModelDynamic = {
        created(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, "created");
        },
        mounted(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, "mounted");
        },
        beforeUpdate(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
        },
        updated(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, "updated");
        }
      };
      function resolveDynamicModel(tagName, type) {
        switch (tagName) {
          case "SELECT":
            return vModelSelect;
          case "TEXTAREA":
            return vModelText;
          default:
            switch (type) {
              case "checkbox":
                return vModelCheckbox;
              case "radio":
                return vModelRadio;
              default:
                return vModelText;
            }
        }
      }
      function callModelHook(el, binding, vnode, prevVNode, hook) {
        const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
        const fn = modelToUse[hook];
        fn && fn(el, binding, vnode, prevVNode);
      }
      function initVModelForSSR() {
        vModelText.getSSRProps = ({ value }) => ({ value });
        vModelRadio.getSSRProps = ({ value }, vnode) => {
          if (vnode.props && shared.looseEqual(vnode.props.value, value)) {
            return { checked: true };
          }
        };
        vModelCheckbox.getSSRProps = ({ value }, vnode) => {
          if (shared.isArray(value)) {
            if (vnode.props && shared.looseIndexOf(value, vnode.props.value) > -1) {
              return { checked: true };
            }
          } else if (shared.isSet(value)) {
            if (vnode.props && value.has(vnode.props.value)) {
              return { checked: true };
            }
          } else if (value) {
            return { checked: true };
          }
        };
        vModelDynamic.getSSRProps = (binding, vnode) => {
          if (typeof vnode.type !== "string") {
            return;
          }
          const modelToUse = resolveDynamicModel(
            // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
            vnode.type.toUpperCase(),
            vnode.props && vnode.props.type
          );
          if (modelToUse.getSSRProps) {
            return modelToUse.getSSRProps(binding, vnode);
          }
        };
      }
      var systemModifiers = ["ctrl", "shift", "alt", "meta"];
      var modifierGuards = {
        stop: (e4) => e4.stopPropagation(),
        prevent: (e4) => e4.preventDefault(),
        self: (e4) => e4.target !== e4.currentTarget,
        ctrl: (e4) => !e4.ctrlKey,
        shift: (e4) => !e4.shiftKey,
        alt: (e4) => !e4.altKey,
        meta: (e4) => !e4.metaKey,
        left: (e4) => "button" in e4 && e4.button !== 0,
        middle: (e4) => "button" in e4 && e4.button !== 1,
        right: (e4) => "button" in e4 && e4.button !== 2,
        exact: (e4, modifiers) => systemModifiers.some((m2) => e4[`${m2}Key`] && !modifiers.includes(m2))
      };
      var withModifiers = (fn, modifiers) => {
        return (event2, ...args) => {
          for (let i4 = 0; i4 < modifiers.length; i4++) {
            const guard = modifierGuards[modifiers[i4]];
            if (guard && guard(event2, modifiers))
              return;
          }
          return fn(event2, ...args);
        };
      };
      var keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      var withKeys = (fn, modifiers) => {
        return (event2) => {
          if (!("key" in event2)) {
            return;
          }
          const eventKey = shared.hyphenate(event2.key);
          if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
            return fn(event2);
          }
        };
      };
      var vShow = {
        beforeMount(el, { value }, { transition: transition2 }) {
          el._vod = el.style.display === "none" ? "" : el.style.display;
          if (transition2 && value) {
            transition2.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition: transition2 }) {
          if (transition2 && value) {
            transition2.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition: transition2 }) {
          if (!value === !oldValue)
            return;
          if (transition2) {
            if (value) {
              transition2.beforeEnter(el);
              setDisplay(el, true);
              transition2.enter(el);
            } else {
              transition2.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      function setDisplay(el, value) {
        el.style.display = value ? el._vod : "none";
      }
      function initVShowForSSR() {
        vShow.getSSRProps = ({ value }) => {
          if (!value) {
            return { style: { display: "none" } };
          }
        };
      }
      var rendererOptions = /* @__PURE__ */ shared.extend({ patchProp }, nodeOps);
      var renderer;
      var enabledHydration = false;
      function ensureRenderer() {
        return renderer || (renderer = runtimeCore.createRenderer(rendererOptions));
      }
      function ensureHydrationRenderer() {
        renderer = enabledHydration ? renderer : runtimeCore.createHydrationRenderer(rendererOptions);
        enabledHydration = true;
        return renderer;
      }
      var render6 = (...args) => {
        ensureRenderer().render(...args);
      };
      var hydrate = (...args) => {
        ensureHydrationRenderer().hydrate(...args);
      };
      var createApp2 = (...args) => {
        const app2 = ensureRenderer().createApp(...args);
        {
          injectNativeTagCheck(app2);
          injectCompilerOptionsCheck(app2);
        }
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app2._component;
          if (!shared.isFunction(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy = mount(container, false, container instanceof SVGElement);
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app2;
      };
      var createSSRApp = (...args) => {
        const app2 = ensureHydrationRenderer().createApp(...args);
        {
          injectNativeTagCheck(app2);
          injectCompilerOptionsCheck(app2);
        }
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (container) {
            return mount(container, true, container instanceof SVGElement);
          }
        };
        return app2;
      };
      function injectNativeTagCheck(app2) {
        Object.defineProperty(app2.config, "isNativeTag", {
          value: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
          writable: false
        });
      }
      function injectCompilerOptionsCheck(app2) {
        if (runtimeCore.isRuntimeOnly()) {
          const isCustomElement = app2.config.isCustomElement;
          Object.defineProperty(app2.config, "isCustomElement", {
            get() {
              return isCustomElement;
            },
            set() {
              runtimeCore.warn(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
            }
          });
          const compilerOptions = app2.config.compilerOptions;
          const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
          Object.defineProperty(app2.config, "compilerOptions", {
            get() {
              runtimeCore.warn(msg);
              return compilerOptions;
            },
            set() {
              runtimeCore.warn(msg);
            }
          });
        }
      }
      function normalizeContainer(container) {
        if (shared.isString(container)) {
          const res = document.querySelector(container);
          if (!res) {
            runtimeCore.warn(`Failed to mount app: mount target selector "${container}" returned null.`);
          }
          return res;
        }
        if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
          runtimeCore.warn(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
        }
        return container;
      }
      var ssrDirectiveInitialized = false;
      var initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
          ssrDirectiveInitialized = true;
          initVModelForSSR();
          initVShowForSSR();
        }
      };
      Object.keys(runtimeCore).forEach(function(k2) {
        if (k2 !== "default") exports[k2] = runtimeCore[k2];
      });
      exports.Transition = Transition;
      exports.TransitionGroup = TransitionGroup;
      exports.VueElement = VueElement;
      exports.createApp = createApp2;
      exports.createSSRApp = createSSRApp;
      exports.defineCustomElement = defineCustomElement;
      exports.defineSSRCustomElement = defineSSRCustomElement;
      exports.hydrate = hydrate;
      exports.initDirectivesForSSR = initDirectivesForSSR;
      exports.render = render6;
      exports.useCssModule = useCssModule;
      exports.useCssVars = useCssVars;
      exports.vModelCheckbox = vModelCheckbox;
      exports.vModelDynamic = vModelDynamic;
      exports.vModelRadio = vModelRadio;
      exports.vModelSelect = vModelSelect;
      exports.vModelText = vModelText;
      exports.vShow = vShow;
      exports.withKeys = withKeys;
      exports.withModifiers = withModifiers;
    }
  });

  // node_modules/@vue/runtime-dom/index.js
  var require_runtime_dom = __commonJS({
    "node_modules/@vue/runtime-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_runtime_dom_cjs();
      }
    }
  });

  // node_modules/@babel/parser/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@babel/parser/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null) return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i4;
        for (i4 = 0; i4 < sourceKeys.length; i4++) {
          key = sourceKeys[i4];
          if (excluded.indexOf(key) >= 0) continue;
          target[key] = source[key];
        }
        return target;
      }
      var Position = class {
        constructor(line, col, index2) {
          this.line = void 0;
          this.column = void 0;
          this.index = void 0;
          this.line = line;
          this.column = col;
          this.index = index2;
        }
      };
      var SourceLocation = class {
        constructor(start, end) {
          this.start = void 0;
          this.end = void 0;
          this.filename = void 0;
          this.identifierName = void 0;
          this.start = start;
          this.end = end;
        }
      };
      function createPositionWithColumnOffset(position, columnOffset) {
        const {
          line,
          column,
          index: index2
        } = position;
        return new Position(line, column + columnOffset, index2 + columnOffset);
      }
      var ParseErrorCode = {
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      };
      var reflect = (keys, last = keys.length - 1) => ({
        get() {
          return keys.reduce((object, key) => object[key], this);
        },
        set(value) {
          keys.reduce((item, key, i4) => i4 === last ? item[key] = value : item[key], this);
        }
      });
      var instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map((key) => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === "function" ? {
        value: descriptor,
        enumerable: false
      } : typeof descriptor.reflect === "string" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
        configurable: true
      }, descriptor)), Object.assign(new constructor(), properties));
      var ModuleErrors = {
        ImportMetaOutsideModule: {
          message: `import.meta may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        },
        ImportOutsideModule: {
          message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
          code: ParseErrorCode.SourceTypeModuleError
        }
      };
      var NodeDescriptions = {
        ArrayPattern: "array destructuring pattern",
        AssignmentExpression: "assignment expression",
        AssignmentPattern: "assignment expression",
        ArrowFunctionExpression: "arrow function expression",
        ConditionalExpression: "conditional expression",
        CatchClause: "catch clause",
        ForOfStatement: "for-of statement",
        ForInStatement: "for-in statement",
        ForStatement: "for-loop",
        FormalParameters: "function parameter list",
        Identifier: "identifier",
        ImportSpecifier: "import specifier",
        ImportDefaultSpecifier: "import default specifier",
        ImportNamespaceSpecifier: "import namespace specifier",
        ObjectPattern: "object destructuring pattern",
        ParenthesizedExpression: "parenthesized expression",
        RestElement: "rest element",
        UpdateExpression: {
          true: "prefix operation",
          false: "postfix operation"
        },
        VariableDeclarator: "variable declaration",
        YieldExpression: "yield expression"
      };
      var toNodeDescription = ({
        type,
        prefix: prefix2
      }) => type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(prefix2)] : NodeDescriptions[type];
      var StandardErrors = {
        AccessorIsGenerator: ({
          kind
        }) => `A ${kind}ter cannot be a generator.`,
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accesor must not have any formal parameters.",
        BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
        BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
        ConstructorClassField: "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: "Class constructor may not be an accessor.",
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: ({
          kind
        }) => `Missing initializer in ${kind} declaration.`,
        DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: "Deleting a private field is not allowed.",
        DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class.",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: ({
          exportName
        }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
        DuplicateProto: "Redefinition of __proto__ property.",
        DuplicateRegExpFlags: "Duplicate regular expression flag.",
        ElementAfterRest: "Rest element must be last element.",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
        ExportBindingIsString: ({
          localName,
          exportName
        }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: ({
          type
        }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
        IllegalBreakContinue: ({
          type
        }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportBindingIsString: ({
          importName
        }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
        ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
        ImportCallArity: ({
          maxArgumentCount
        }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
        ImportCallNotNewExpression: "Cannot use new with import(...).",
        ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
        ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
        IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
        InvalidBigIntLiteral: "Invalid BigIntLiteral.",
        InvalidCodePoint: "Code point out of bounds.",
        InvalidCoverInitializedName: "Invalid shorthand property initializer.",
        InvalidDecimal: "Invalid decimal.",
        InvalidDigit: ({
          radix
        }) => `Expected number in radix ${radix}.`,
        InvalidEscapeSequence: "Bad character escape sequence.",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
        InvalidEscapedReservedWord: ({
          reservedWord
        }) => `Escape sequence in keyword ${reservedWord}.`,
        InvalidIdentifier: ({
          identifierName
        }) => `Invalid identifier ${identifierName}.`,
        InvalidLhs: ({
          ancestor
        }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidLhsBinding: ({
          ancestor
        }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
        InvalidNumber: "Invalid number.",
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: ({
          unexpected
        }) => `Unexpected character '${unexpected}'.`,
        InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
        InvalidPrivateFieldResolution: ({
          identifierName
        }) => `Private name #${identifierName} is not defined.`,
        InvalidPropertyBindingPattern: "Binding member expression.",
        InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: ({
          labelName
        }) => `Label '${labelName}' is already declared.`,
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: "Invalid regular expression flag.",
        MissingClassName: "A class name is required.",
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: "Missing semicolon.",
        MissingPlugin: ({
          missingPlugin
        }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
        MissingOneOfPlugins: ({
          missingPlugin
        }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
        MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
        ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
        ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
        ModuleAttributesWithDuplicateKeys: ({
          key
        }) => `Duplicate key "${key}" is not allowed in module attributes.`,
        ModuleExportNameHasLoneSurrogate: ({
          surrogateCharCode
        }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
        ModuleExportUndefined: ({
          localName
        }) => `Export '${localName}' is not defined.`,
        MultipleDefaultsInSwitch: "Multiple default clauses.",
        NewlineAfterThrow: "Illegal newline after throw.",
        NoCatchOrFinally: "Missing catch or finally clause.",
        NumberIdentifier: "Identifier directly after number.",
        NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
        ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
        OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
        OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: "Argument name clash.",
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PrivateInExpectedIn: ({
          identifierName
        }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
        PrivateNameRedeclaration: ({
          identifierName
        }) => `Duplicate private name #${identifierName}.`,
        RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: "Unexpected trailing comma after rest element.",
        SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
        StaticPrototype: "Classes may not have static property named prototype.",
        SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: "Decorators must be attached to a class element.",
        TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
        UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: ({
          keyword
        }) => `Unexpected keyword '${keyword}'.`,
        UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
        UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
        UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
        UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
        UnexpectedPrivateField: "Unexpected private name.",
        UnexpectedReservedWord: ({
          reservedWord
        }) => `Unexpected reserved word '${reservedWord}'.`,
        UnexpectedSuper: "'super' is only allowed in object methods and classes.",
        UnexpectedToken: ({
          expected,
          unexpected
        }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
        UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
        UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
        UnsupportedMetaProperty: ({
          target,
          onlyValidPropertyName
        }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
        UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
        UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
        UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: "Unterminated comment.",
        UnterminatedRegExp: "Unterminated regular expression.",
        UnterminatedString: "Unterminated string constant.",
        UnterminatedTemplate: "Unterminated template.",
        VarRedeclaration: ({
          identifierName
        }) => `Identifier '${identifierName}' has already been declared.`,
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter: "Yield expression is not allowed in formal parameters.",
        ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
      };
      var StrictModeErrors = {
        StrictDelete: "Deleting local variable in strict mode.",
        StrictEvalArguments: ({
          referenceName
        }) => `Assigning to '${referenceName}' in strict mode.`,
        StrictEvalArgumentsBinding: ({
          bindingName
        }) => `Binding '${bindingName}' in strict mode.`,
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
        StrictWith: "'with' in strict mode."
      };
      var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
      var PipelineOperatorErrors = {
        PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
        PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
        PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
        PipeTopicUnconfiguredToken: ({
          token
        }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
        PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
        PipeUnparenthesizedBody: ({
          type
        }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
          type
        })}; please wrap it in parentheses.`,
        PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
        PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
        PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
        PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
        PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
      };
      var _excluded$1 = ["toMessage"];
      var _excluded2$1 = ["message"];
      function toParseErrorConstructor(_ref) {
        let {
          toMessage
        } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
        return function constructor({
          loc,
          details
        }) {
          return instantiate(SyntaxError, Object.assign({}, properties, {
            loc
          }), {
            clone(overrides = {}) {
              const loc2 = overrides.loc || {};
              return constructor({
                loc: new Position("line" in loc2 ? loc2.line : this.loc.line, "column" in loc2 ? loc2.column : this.loc.column, "index" in loc2 ? loc2.index : this.loc.index),
                details: Object.assign({}, this.details, overrides.details)
              });
            },
            details: {
              value: details,
              enumerable: false
            },
            message: {
              get() {
                return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
              },
              set(value) {
                Object.defineProperty(this, "message", {
                  value
                });
              }
            },
            pos: {
              reflect: "loc.index",
              enumerable: true
            },
            missingPlugin: "missingPlugin" in details && {
              reflect: "details.missingPlugin",
              enumerable: true
            }
          });
        };
      }
      function ParseErrorEnum(argument, syntaxPlugin) {
        if (Array.isArray(argument)) {
          return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
        }
        const ParseErrorConstructors = {};
        for (const reasonCode of Object.keys(argument)) {
          const template2 = argument[reasonCode];
          const _ref2 = typeof template2 === "string" ? {
            message: () => template2
          } : typeof template2 === "function" ? {
            message: template2
          } : template2, {
            message
          } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);
          const toMessage = typeof message === "string" ? () => message : message;
          ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
            code: ParseErrorCode.SyntaxError,
            reasonCode,
            toMessage
          }, syntaxPlugin ? {
            syntaxPlugin
          } : {}, rest));
        }
        return ParseErrorConstructors;
      }
      var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
      var {
        defineProperty
      } = Object;
      var toUnenumerable = (object, key) => defineProperty(object, key, {
        enumerable: false,
        value: object[key]
      });
      function toESTreeLocation(node) {
        node.loc.start && toUnenumerable(node.loc.start, "index");
        node.loc.end && toUnenumerable(node.loc.end, "index");
        return node;
      }
      var estree = (superClass) => class ESTreeParserMixin extends superClass {
        parse() {
          const file = toESTreeLocation(super.parse());
          if (this.options.tokens) {
            file.tokens = file.tokens.map(toESTreeLocation);
          }
          return file;
        }
        parseRegExpLiteral({
          pattern,
          flags
        }) {
          let regex = null;
          try {
            regex = new RegExp(pattern, flags);
          } catch (e4) {
          }
          const node = this.estreeParseLiteral(regex);
          node.regex = {
            pattern,
            flags
          };
          return node;
        }
        parseBigIntLiteral(value) {
          let bigInt;
          try {
            bigInt = BigInt(value);
          } catch (_unused) {
            bigInt = null;
          }
          const node = this.estreeParseLiteral(bigInt);
          node.bigint = String(node.value || value);
          return node;
        }
        parseDecimalLiteral(value) {
          const decimal = null;
          const node = this.estreeParseLiteral(decimal);
          node.decimal = String(node.value || value);
          return node;
        }
        estreeParseLiteral(value) {
          return this.parseLiteral(value, "Literal");
        }
        parseStringLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNumericLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        parseNullLiteral() {
          return this.estreeParseLiteral(null);
        }
        parseBooleanLiteral(value) {
          return this.estreeParseLiteral(value);
        }
        directiveToStmt(directive) {
          const directiveLiteral = directive.value;
          const stmt = this.startNodeAt(directive.start, directive.loc.start);
          const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
          expression.value = directiveLiteral.extra.expressionValue;
          expression.raw = directiveLiteral.extra.raw;
          stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.loc.end);
          stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
          return this.finishNodeAt(stmt, "ExpressionStatement", directive.loc.end);
        }
        initFunction(node, isAsync) {
          super.initFunction(node, isAsync);
          node.expression = false;
        }
        checkDeclaration(node) {
          if (node != null && this.isObjectProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            super.checkDeclaration(node);
          }
        }
        getObjectOrClassMethodParams(method) {
          return method.value.params;
        }
        isValidDirective(stmt) {
          var _stmt$expression$extr;
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
          const directiveStatements = node.directives.map((d2) => this.directiveToStmt(d2));
          node.body = directiveStatements.concat(node.body);
          delete node.directives;
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }
          classBody.body.push(method);
        }
        parsePrivateName() {
          const node = super.parsePrivateName();
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return node;
            }
          }
          return this.convertPrivateNameToPrivateIdentifier(node);
        }
        convertPrivateNameToPrivateIdentifier(node) {
          const name = super.getPrivateNameSV(node);
          node = node;
          delete node.id;
          node.name = name;
          node.type = "PrivateIdentifier";
          return node;
        }
        isPrivateName(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.isPrivateName(node);
            }
          }
          return node.type === "PrivateIdentifier";
        }
        getPrivateNameSV(node) {
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return super.getPrivateNameSV(node);
            }
          }
          return node.name;
        }
        parseLiteral(value, type) {
          const node = super.parseLiteral(value, type);
          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          super.parseFunctionBody(node, allowExpression, isMethod);
          node.expression = node.body.type !== "BlockStatement";
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          let funcNode = this.startNode();
          funcNode.kind = node.kind;
          funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          funcNode.type = "FunctionExpression";
          delete funcNode.kind;
          node.value = funcNode;
          if (type === "ClassPrivateMethod") {
            node.computed = false;
          }
          return this.finishNode(node, "MethodDefinition");
        }
        parseClassProperty(...args) {
          const propertyNode = super.parseClassProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          return propertyNode;
        }
        parseClassPrivateProperty(...args) {
          const propertyNode = super.parseClassPrivateProperty(...args);
          {
            if (!this.getPluginOption("estree", "classFeatures")) {
              return propertyNode;
            }
          }
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
          return propertyNode;
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
          if (node) {
            node.type = "Property";
            if (node.kind === "method") {
              node.kind = "init";
            }
            node.shorthand = false;
          }
          return node;
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          if (node) {
            node.kind = "init";
            node.type = "Property";
          }
          return node;
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        isAssignable(node, isBinding) {
          if (node != null && this.isObjectProperty(node)) {
            return this.isAssignable(node.value, isBinding);
          }
          return super.isAssignable(node, isBinding);
        }
        toAssignable(node, isLHS = false) {
          if (node != null && this.isObjectProperty(node)) {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(Errors.PatternHasAccessor, {
              at: prop.key
            });
          } else if (prop.method) {
            this.raise(Errors.PatternHasMethod, {
              at: prop.key
            });
          } else {
            super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
          }
        }
        finishCallExpression(unfinished, optional) {
          const node = super.finishCallExpression(unfinished, optional);
          if (node.callee.type === "Import") {
            node.type = "ImportExpression";
            node.source = node.arguments[0];
            if (this.hasPlugin("importAssertions")) {
              var _node$arguments$;
              node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
            }
            delete node.arguments;
            delete node.callee;
          }
          return node;
        }
        toReferencedArguments(node) {
          if (node.type === "ImportExpression") {
            return;
          }
          super.toReferencedArguments(node);
        }
        parseExport(unfinished) {
          const node = super.parseExport(unfinished);
          switch (node.type) {
            case "ExportAllDeclaration":
              node.exported = null;
              break;
            case "ExportNamedDeclaration":
              if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
                node.type = "ExportAllDeclaration";
                node.exported = node.specifiers[0].exported;
                delete node.specifiers;
              }
              break;
          }
          return node;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);
          if (state.optionalChainMember) {
            if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
              node.type = node.type.substring(8);
            }
            if (state.stop) {
              const chain = this.startNodeAtNode(node);
              chain.expression = node;
              return this.finishNode(chain, "ChainExpression");
            }
          } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
            node.optional = false;
          }
          return node;
        }
        hasPropertyAsPrivateName(node) {
          if (node.type === "ChainExpression") {
            node = node.expression;
          }
          return super.hasPropertyAsPrivateName(node);
        }
        isOptionalChain(node) {
          return node.type === "ChainExpression";
        }
        isObjectProperty(node) {
          return node.type === "Property" && node.kind === "init" && !node.method;
        }
        isObjectMethod(node) {
          return node.method || node.kind === "get" || node.kind === "set";
        }
        finishNodeAt(node, type, endLoc) {
          return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
        }
        resetStartLocation(node, start, startLoc) {
          super.resetStartLocation(node, start, startLoc);
          toESTreeLocation(node);
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          super.resetEndLocation(node, endLoc);
          toESTreeLocation(node);
        }
      };
      var TokContext = class {
        constructor(token, preserveSpace) {
          this.token = void 0;
          this.preserveSpace = void 0;
          this.token = token;
          this.preserveSpace = !!preserveSpace;
        }
      };
      var types = {
        brace: new TokContext("{"),
        j_oTag: new TokContext("<tag"),
        j_cTag: new TokContext("</tag"),
        j_expr: new TokContext("<tag>...</tag>", true)
      };
      {
        types.template = new TokContext("`", true);
      }
      var beforeExpr = true;
      var startsExpr = true;
      var isLoop = true;
      var isAssign = true;
      var prefix = true;
      var postfix = true;
      var ExportedTokenType = class {
        constructor(label, conf = {}) {
          this.label = void 0;
          this.keyword = void 0;
          this.beforeExpr = void 0;
          this.startsExpr = void 0;
          this.rightAssociative = void 0;
          this.isLoop = void 0;
          this.isAssign = void 0;
          this.prefix = void 0;
          this.postfix = void 0;
          this.binop = void 0;
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.rightAssociative = !!conf.rightAssociative;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop != null ? conf.binop : null;
          {
            this.updateContext = null;
          }
        }
      };
      var keywords$1 = /* @__PURE__ */ new Map();
      function createKeyword(name, options = {}) {
        options.keyword = name;
        const token = createToken(name, options);
        keywords$1.set(name, token);
        return token;
      }
      function createBinop(name, binop) {
        return createToken(name, {
          beforeExpr,
          binop
        });
      }
      var tokenTypeCounter = -1;
      var tokenTypes = [];
      var tokenLabels = [];
      var tokenBinops = [];
      var tokenBeforeExprs = [];
      var tokenStartsExprs = [];
      var tokenPrefixes = [];
      function createToken(name, options = {}) {
        var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
        ++tokenTypeCounter;
        tokenLabels.push(name);
        tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
        tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
        tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
        tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
        tokenTypes.push(new ExportedTokenType(name, options));
        return tokenTypeCounter;
      }
      function createKeywordLike(name, options = {}) {
        var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
        ++tokenTypeCounter;
        keywords$1.set(name, tokenTypeCounter);
        tokenLabels.push(name);
        tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
        tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
        tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
        tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
        tokenTypes.push(new ExportedTokenType("name", options));
        return tokenTypeCounter;
      }
      var tt = {
        bracketL: createToken("[", {
          beforeExpr,
          startsExpr
        }),
        bracketHashL: createToken("#[", {
          beforeExpr,
          startsExpr
        }),
        bracketBarL: createToken("[|", {
          beforeExpr,
          startsExpr
        }),
        bracketR: createToken("]"),
        bracketBarR: createToken("|]"),
        braceL: createToken("{", {
          beforeExpr,
          startsExpr
        }),
        braceBarL: createToken("{|", {
          beforeExpr,
          startsExpr
        }),
        braceHashL: createToken("#{", {
          beforeExpr,
          startsExpr
        }),
        braceR: createToken("}"),
        braceBarR: createToken("|}"),
        parenL: createToken("(", {
          beforeExpr,
          startsExpr
        }),
        parenR: createToken(")"),
        comma: createToken(",", {
          beforeExpr
        }),
        semi: createToken(";", {
          beforeExpr
        }),
        colon: createToken(":", {
          beforeExpr
        }),
        doubleColon: createToken("::", {
          beforeExpr
        }),
        dot: createToken("."),
        question: createToken("?", {
          beforeExpr
        }),
        questionDot: createToken("?."),
        arrow: createToken("=>", {
          beforeExpr
        }),
        template: createToken("template"),
        ellipsis: createToken("...", {
          beforeExpr
        }),
        backQuote: createToken("`", {
          startsExpr
        }),
        dollarBraceL: createToken("${", {
          beforeExpr,
          startsExpr
        }),
        templateTail: createToken("...`", {
          startsExpr
        }),
        templateNonTail: createToken("...${", {
          beforeExpr,
          startsExpr
        }),
        at: createToken("@"),
        hash: createToken("#", {
          startsExpr
        }),
        interpreterDirective: createToken("#!..."),
        eq: createToken("=", {
          beforeExpr,
          isAssign
        }),
        assign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        slashAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        xorAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        moduloAssign: createToken("_=", {
          beforeExpr,
          isAssign
        }),
        incDec: createToken("++/--", {
          prefix,
          postfix,
          startsExpr
        }),
        bang: createToken("!", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        tilde: createToken("~", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        doubleCaret: createToken("^^", {
          startsExpr
        }),
        doubleAt: createToken("@@", {
          startsExpr
        }),
        pipeline: createBinop("|>", 0),
        nullishCoalescing: createBinop("??", 1),
        logicalOR: createBinop("||", 1),
        logicalAND: createBinop("&&", 2),
        bitwiseOR: createBinop("|", 3),
        bitwiseXOR: createBinop("^", 4),
        bitwiseAND: createBinop("&", 5),
        equality: createBinop("==/!=/===/!==", 6),
        lt: createBinop("</>/<=/>=", 7),
        gt: createBinop("</>/<=/>=", 7),
        relational: createBinop("</>/<=/>=", 7),
        bitShift: createBinop("<</>>/>>>", 8),
        bitShiftL: createBinop("<</>>/>>>", 8),
        bitShiftR: createBinop("<</>>/>>>", 8),
        plusMin: createToken("+/-", {
          beforeExpr,
          binop: 9,
          prefix,
          startsExpr
        }),
        modulo: createToken("%", {
          binop: 10,
          startsExpr
        }),
        star: createToken("*", {
          binop: 10
        }),
        slash: createBinop("/", 10),
        exponent: createToken("**", {
          beforeExpr,
          binop: 11,
          rightAssociative: true
        }),
        _in: createKeyword("in", {
          beforeExpr,
          binop: 7
        }),
        _instanceof: createKeyword("instanceof", {
          beforeExpr,
          binop: 7
        }),
        _break: createKeyword("break"),
        _case: createKeyword("case", {
          beforeExpr
        }),
        _catch: createKeyword("catch"),
        _continue: createKeyword("continue"),
        _debugger: createKeyword("debugger"),
        _default: createKeyword("default", {
          beforeExpr
        }),
        _else: createKeyword("else", {
          beforeExpr
        }),
        _finally: createKeyword("finally"),
        _function: createKeyword("function", {
          startsExpr
        }),
        _if: createKeyword("if"),
        _return: createKeyword("return", {
          beforeExpr
        }),
        _switch: createKeyword("switch"),
        _throw: createKeyword("throw", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _try: createKeyword("try"),
        _var: createKeyword("var"),
        _const: createKeyword("const"),
        _with: createKeyword("with"),
        _new: createKeyword("new", {
          beforeExpr,
          startsExpr
        }),
        _this: createKeyword("this", {
          startsExpr
        }),
        _super: createKeyword("super", {
          startsExpr
        }),
        _class: createKeyword("class", {
          startsExpr
        }),
        _extends: createKeyword("extends", {
          beforeExpr
        }),
        _export: createKeyword("export"),
        _import: createKeyword("import", {
          startsExpr
        }),
        _null: createKeyword("null", {
          startsExpr
        }),
        _true: createKeyword("true", {
          startsExpr
        }),
        _false: createKeyword("false", {
          startsExpr
        }),
        _typeof: createKeyword("typeof", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _void: createKeyword("void", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _delete: createKeyword("delete", {
          beforeExpr,
          prefix,
          startsExpr
        }),
        _do: createKeyword("do", {
          isLoop,
          beforeExpr
        }),
        _for: createKeyword("for", {
          isLoop
        }),
        _while: createKeyword("while", {
          isLoop
        }),
        _as: createKeywordLike("as", {
          startsExpr
        }),
        _assert: createKeywordLike("assert", {
          startsExpr
        }),
        _async: createKeywordLike("async", {
          startsExpr
        }),
        _await: createKeywordLike("await", {
          startsExpr
        }),
        _from: createKeywordLike("from", {
          startsExpr
        }),
        _get: createKeywordLike("get", {
          startsExpr
        }),
        _let: createKeywordLike("let", {
          startsExpr
        }),
        _meta: createKeywordLike("meta", {
          startsExpr
        }),
        _of: createKeywordLike("of", {
          startsExpr
        }),
        _sent: createKeywordLike("sent", {
          startsExpr
        }),
        _set: createKeywordLike("set", {
          startsExpr
        }),
        _static: createKeywordLike("static", {
          startsExpr
        }),
        _yield: createKeywordLike("yield", {
          startsExpr
        }),
        _asserts: createKeywordLike("asserts", {
          startsExpr
        }),
        _checks: createKeywordLike("checks", {
          startsExpr
        }),
        _exports: createKeywordLike("exports", {
          startsExpr
        }),
        _global: createKeywordLike("global", {
          startsExpr
        }),
        _implements: createKeywordLike("implements", {
          startsExpr
        }),
        _intrinsic: createKeywordLike("intrinsic", {
          startsExpr
        }),
        _infer: createKeywordLike("infer", {
          startsExpr
        }),
        _is: createKeywordLike("is", {
          startsExpr
        }),
        _mixins: createKeywordLike("mixins", {
          startsExpr
        }),
        _proto: createKeywordLike("proto", {
          startsExpr
        }),
        _require: createKeywordLike("require", {
          startsExpr
        }),
        _keyof: createKeywordLike("keyof", {
          startsExpr
        }),
        _readonly: createKeywordLike("readonly", {
          startsExpr
        }),
        _unique: createKeywordLike("unique", {
          startsExpr
        }),
        _abstract: createKeywordLike("abstract", {
          startsExpr
        }),
        _declare: createKeywordLike("declare", {
          startsExpr
        }),
        _enum: createKeywordLike("enum", {
          startsExpr
        }),
        _module: createKeywordLike("module", {
          startsExpr
        }),
        _namespace: createKeywordLike("namespace", {
          startsExpr
        }),
        _interface: createKeywordLike("interface", {
          startsExpr
        }),
        _type: createKeywordLike("type", {
          startsExpr
        }),
        _opaque: createKeywordLike("opaque", {
          startsExpr
        }),
        name: createToken("name", {
          startsExpr
        }),
        string: createToken("string", {
          startsExpr
        }),
        num: createToken("num", {
          startsExpr
        }),
        bigint: createToken("bigint", {
          startsExpr
        }),
        decimal: createToken("decimal", {
          startsExpr
        }),
        regexp: createToken("regexp", {
          startsExpr
        }),
        privateName: createToken("#name", {
          startsExpr
        }),
        eof: createToken("eof"),
        jsxName: createToken("jsxName"),
        jsxText: createToken("jsxText", {
          beforeExpr: true
        }),
        jsxTagStart: createToken("jsxTagStart", {
          startsExpr: true
        }),
        jsxTagEnd: createToken("jsxTagEnd"),
        placeholder: createToken("%%", {
          startsExpr: true
        })
      };
      function tokenIsIdentifier(token) {
        return token >= 93 && token <= 128;
      }
      function tokenKeywordOrIdentifierIsKeyword(token) {
        return token <= 92;
      }
      function tokenIsKeywordOrIdentifier(token) {
        return token >= 58 && token <= 128;
      }
      function tokenIsLiteralPropertyName(token) {
        return token >= 58 && token <= 132;
      }
      function tokenComesBeforeExpression(token) {
        return tokenBeforeExprs[token];
      }
      function tokenCanStartExpression(token) {
        return tokenStartsExprs[token];
      }
      function tokenIsAssignment(token) {
        return token >= 29 && token <= 33;
      }
      function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
        return token >= 125 && token <= 127;
      }
      function tokenIsLoop(token) {
        return token >= 90 && token <= 92;
      }
      function tokenIsKeyword(token) {
        return token >= 58 && token <= 92;
      }
      function tokenIsOperator(token) {
        return token >= 39 && token <= 59;
      }
      function tokenIsPostfix(token) {
        return token === 34;
      }
      function tokenIsPrefix(token) {
        return tokenPrefixes[token];
      }
      function tokenIsTSTypeOperator(token) {
        return token >= 117 && token <= 119;
      }
      function tokenIsTSDeclarationStart(token) {
        return token >= 120 && token <= 126;
      }
      function tokenLabelName(token) {
        return tokenLabels[token];
      }
      function tokenOperatorPrecedence(token) {
        return tokenBinops[token];
      }
      function tokenIsRightAssociative(token) {
        return token === 57;
      }
      function tokenIsTemplate(token) {
        return token >= 24 && token <= 25;
      }
      function getExportedToken(token) {
        return tokenTypes[token];
      }
      {
        tokenTypes[8].updateContext = (context3) => {
          context3.pop();
        };
        tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context3) => {
          context3.push(types.brace);
        };
        tokenTypes[22].updateContext = (context3) => {
          if (context3[context3.length - 1] === types.template) {
            context3.pop();
          } else {
            context3.push(types.template);
          }
        };
        tokenTypes[138].updateContext = (context3) => {
          context3.push(types.j_expr, types.j_oTag);
        };
      }
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code, set2) {
        let pos = 65536;
        for (let i4 = 0, length = set2.length; i4 < length; i4 += 2) {
          pos += set2[i4];
          if (pos > code) return false;
          pos += set2[i4 + 1];
          if (pos >= code) return true;
        }
        return false;
      }
      function isIdentifierStart(code) {
        if (code < 65) return code === 36;
        if (code <= 90) return true;
        if (code < 97) return code === 95;
        if (code <= 122) return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code) {
        if (code < 48) return code === 36;
        if (code < 58) return true;
        if (code < 65) return false;
        if (code <= 90) return true;
        if (code < 97) return code === 95;
        if (code <= 122) return true;
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var reservedWords = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
      };
      var keywords = new Set(reservedWords.keyword);
      var reservedWordsStrictSet = new Set(reservedWords.strict);
      var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
      function isReservedWord(word, inModule) {
        return inModule && word === "await" || word === "enum";
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
      function isStrictBindReservedWord(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }
      function isKeyword(word) {
        return keywords.has(word);
      }
      function isIteratorStart(current, next2, next22) {
        return current === 64 && next2 === 64 && isIdentifierStart(next22);
      }
      var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
      function canBeReservedWord(word) {
        return reservedWordLikeSet.has(word);
      }
      var SCOPE_OTHER = 0;
      var SCOPE_PROGRAM = 1;
      var SCOPE_FUNCTION = 2;
      var SCOPE_ARROW = 4;
      var SCOPE_SIMPLE_CATCH = 8;
      var SCOPE_SUPER = 16;
      var SCOPE_DIRECT_SUPER = 32;
      var SCOPE_CLASS = 64;
      var SCOPE_STATIC_BLOCK = 128;
      var SCOPE_TS_MODULE = 256;
      var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
      var BIND_KIND_VALUE = 1;
      var BIND_KIND_TYPE = 2;
      var BIND_SCOPE_VAR = 4;
      var BIND_SCOPE_LEXICAL = 8;
      var BIND_SCOPE_FUNCTION = 16;
      var BIND_FLAGS_NONE = 64;
      var BIND_FLAGS_CLASS = 128;
      var BIND_FLAGS_TS_ENUM = 256;
      var BIND_FLAGS_TS_CONST_ENUM = 512;
      var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
      var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
      var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
      var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
      var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
      var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
      var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
      var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
      var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
      var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
      var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
      var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
      var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
      var CLASS_ELEMENT_FLAG_STATIC = 4;
      var CLASS_ELEMENT_KIND_GETTER = 2;
      var CLASS_ELEMENT_KIND_SETTER = 1;
      var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
      var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
      var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
      var CLASS_ELEMENT_OTHER = 0;
      var BaseParser = class {
        constructor() {
          this.sawUnambiguousESM = false;
          this.ambiguousScriptDifferentAst = false;
        }
        hasPlugin(pluginConfig) {
          if (typeof pluginConfig === "string") {
            return this.plugins.has(pluginConfig);
          } else {
            const [pluginName, pluginOptions] = pluginConfig;
            if (!this.hasPlugin(pluginName)) {
              return false;
            }
            const actualOptions = this.plugins.get(pluginName);
            for (const key of Object.keys(pluginOptions)) {
              if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
                return false;
              }
            }
            return true;
          }
        }
        getPluginOption(plugin, name) {
          var _this$plugins$get;
          return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
        }
      };
      function setTrailingComments(node, comments) {
        if (node.trailingComments === void 0) {
          node.trailingComments = comments;
        } else {
          node.trailingComments.unshift(...comments);
        }
      }
      function setLeadingComments(node, comments) {
        if (node.leadingComments === void 0) {
          node.leadingComments = comments;
        } else {
          node.leadingComments.unshift(...comments);
        }
      }
      function setInnerComments(node, comments) {
        if (node.innerComments === void 0) {
          node.innerComments = comments;
        } else {
          node.innerComments.unshift(...comments);
        }
      }
      function adjustInnerComments(node, elements, commentWS) {
        let lastElement = null;
        let i4 = elements.length;
        while (lastElement === null && i4 > 0) {
          lastElement = elements[--i4];
        }
        if (lastElement === null || lastElement.start > commentWS.start) {
          setInnerComments(node, commentWS.comments);
        } else {
          setTrailingComments(lastElement, commentWS.comments);
        }
      }
      var CommentsParser = class extends BaseParser {
        addComment(comment) {
          if (this.filename) comment.loc.filename = this.filename;
          this.state.comments.push(comment);
        }
        processComment(node) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0) return;
          let i4 = commentStackLength - 1;
          const lastCommentWS = commentStack[i4];
          if (lastCommentWS.start === node.end) {
            lastCommentWS.leadingNode = node;
            i4--;
          }
          const {
            start: nodeStart
          } = node;
          for (; i4 >= 0; i4--) {
            const commentWS = commentStack[i4];
            const commentEnd = commentWS.end;
            if (commentEnd > nodeStart) {
              commentWS.containingNode = node;
              this.finalizeComment(commentWS);
              commentStack.splice(i4, 1);
            } else {
              if (commentEnd === nodeStart) {
                commentWS.trailingNode = node;
              }
              break;
            }
          }
        }
        finalizeComment(commentWS) {
          const {
            comments
          } = commentWS;
          if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
            if (commentWS.leadingNode !== null) {
              setTrailingComments(commentWS.leadingNode, comments);
            }
            if (commentWS.trailingNode !== null) {
              setLeadingComments(commentWS.trailingNode, comments);
            }
          } else {
            const {
              containingNode: node,
              start: commentStart
            } = commentWS;
            if (this.input.charCodeAt(commentStart - 1) === 44) {
              switch (node.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  adjustInnerComments(node, node.properties, commentWS);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  adjustInnerComments(node, node.arguments, commentWS);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  adjustInnerComments(node, node.params, commentWS);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  adjustInnerComments(node, node.elements, commentWS);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  adjustInnerComments(node, node.specifiers, commentWS);
                  break;
                default: {
                  setInnerComments(node, comments);
                }
              }
            } else {
              setInnerComments(node, comments);
            }
          }
        }
        finalizeRemainingComments() {
          const {
            commentStack
          } = this.state;
          for (let i4 = commentStack.length - 1; i4 >= 0; i4--) {
            this.finalizeComment(commentStack[i4]);
          }
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(node) {
          const {
            commentStack
          } = this.state;
          const {
            length
          } = commentStack;
          if (length === 0) return;
          const commentWS = commentStack[length - 1];
          if (commentWS.leadingNode === node) {
            commentWS.leadingNode = null;
          }
        }
        takeSurroundingComments(node, start, end) {
          const {
            commentStack
          } = this.state;
          const commentStackLength = commentStack.length;
          if (commentStackLength === 0) return;
          let i4 = commentStackLength - 1;
          for (; i4 >= 0; i4--) {
            const commentWS = commentStack[i4];
            const commentEnd = commentWS.end;
            const commentStart = commentWS.start;
            if (commentStart === end) {
              commentWS.leadingNode = node;
            } else if (commentEnd === start) {
              commentWS.trailingNode = node;
            } else if (commentEnd < start) {
              break;
            }
          }
        }
      };
      var lineBreak = /\r\n?|[\n\u2028\u2029]/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        switch (code) {
          case 10:
          case 13:
          case 8232:
          case 8233:
            return true;
          default:
            return false;
        }
      }
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
      var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
      function isWhitespace2(code) {
        switch (code) {
          case 9:
          case 11:
          case 12:
          case 32:
          case 160:
          case 5760:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }
      var State = class _State {
        constructor() {
          this.strict = void 0;
          this.curLine = void 0;
          this.lineStart = void 0;
          this.startLoc = void 0;
          this.endLoc = void 0;
          this.errors = [];
          this.potentialArrowAt = -1;
          this.noArrowAt = [];
          this.noArrowParamsConversionAt = [];
          this.maybeInArrowParameters = false;
          this.inType = false;
          this.noAnonFunctionType = false;
          this.hasFlowComment = false;
          this.isAmbientContext = false;
          this.inAbstractClass = false;
          this.inDisallowConditionalTypesContext = false;
          this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          this.soloAwait = false;
          this.inFSharpPipelineDirectBody = false;
          this.labels = [];
          this.decoratorStack = [[]];
          this.comments = [];
          this.commentStack = [];
          this.pos = 0;
          this.type = 135;
          this.value = null;
          this.start = 0;
          this.end = 0;
          this.lastTokEndLoc = null;
          this.lastTokStartLoc = null;
          this.lastTokStart = 0;
          this.context = [types.brace];
          this.canStartJSXElement = true;
          this.containsEsc = false;
          this.strictErrors = /* @__PURE__ */ new Map();
          this.tokensLength = 0;
        }
        init({
          strictMode,
          sourceType,
          startLine,
          startColumn
        }) {
          this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
          this.curLine = startLine;
          this.lineStart = -startColumn;
          this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
        }
        curPosition() {
          return new Position(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(skipArrays) {
          const state = new _State();
          const keys = Object.keys(this);
          for (let i4 = 0, length = keys.length; i4 < length; i4++) {
            const key = keys[i4];
            let val = this[key];
            if (!skipArrays && Array.isArray(val)) {
              val = val.slice();
            }
            state[key] = val;
          }
          return state;
        }
      };
      var _isDigit = function isDigit(code) {
        return code >= 48 && code <= 57;
      };
      var forbiddenNumericSeparatorSiblings = {
        decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
        hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
      };
      var isAllowedNumericSeparatorSibling = {
        bin: (ch) => ch === 48 || ch === 49,
        oct: (ch) => ch >= 48 && ch <= 55,
        dec: (ch) => ch >= 48 && ch <= 57,
        hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      function readStringContents(type, input, pos, lineStart, curLine, errors) {
        const initialPos = pos;
        const initialLineStart = lineStart;
        const initialCurLine = curLine;
        let out = "";
        let containsInvalid = false;
        let chunkStart = pos;
        const {
          length
        } = input;
        for (; ; ) {
          if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
          }
          const ch = input.charCodeAt(pos);
          if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
          }
          if (ch === 92) {
            out += input.slice(chunkStart, pos);
            let escaped;
            ({
              ch: escaped,
              pos,
              lineStart,
              curLine
            } = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors));
            if (escaped === null) {
              containsInvalid = true;
            } else {
              out += escaped;
            }
            chunkStart = pos;
          } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
          } else if (ch === 10 || ch === 13) {
            if (type === "template") {
              out += input.slice(chunkStart, pos) + "\n";
              ++pos;
              if (ch === 13 && input.charCodeAt(pos) === 10) {
                ++pos;
              }
              ++curLine;
              chunkStart = lineStart = pos;
            } else {
              errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
          } else {
            ++pos;
          }
        }
        return {
          pos,
          str: out,
          containsInvalid,
          lineStart,
          curLine
        };
      }
      function isStringEnd(type, ch, input, pos) {
        if (type === "template") {
          return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
        }
        return ch === (type === "double" ? 34 : 39);
      }
      function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
        const throwOnInvalid = !inTemplate;
        pos++;
        const res = (ch2) => ({
          pos,
          ch: ch2,
          lineStart,
          curLine
        });
        const ch = input.charCodeAt(pos++);
        switch (ch) {
          case 110:
            return res("\n");
          case 114:
            return res("\r");
          case 120: {
            let code;
            ({
              code,
              pos
            } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCharCode(code));
          }
          case 117: {
            let code;
            ({
              code,
              pos
            } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
            return res(code === null ? null : String.fromCodePoint(code));
          }
          case 116:
            return res("	");
          case 98:
            return res("\b");
          case 118:
            return res("\v");
          case 102:
            return res("\f");
          case 13:
            if (input.charCodeAt(pos) === 10) {
              ++pos;
            }
          case 10:
            lineStart = pos;
            ++curLine;
          case 8232:
          case 8233:
            return res("");
          case 56:
          case 57:
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const startPos = pos - 1;
              const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              pos += octalStr.length - 1;
              const next2 = input.charCodeAt(pos);
              if (octalStr !== "0" || next2 === 56 || next2 === 57) {
                if (inTemplate) {
                  return res(null);
                } else {
                  errors.strictNumericEscape(startPos, lineStart, curLine);
                }
              }
              return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
        }
      }
      function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
        const initialPos = pos;
        let n4;
        ({
          n: n4,
          pos
        } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors));
        if (n4 === null) {
          if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
          } else {
            pos = initialPos - 1;
          }
        }
        return {
          code: n4,
          pos
        };
      }
      function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors) {
        const start = pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
        let invalid = false;
        let total = 0;
        for (let i4 = 0, e4 = len == null ? Infinity : len; i4 < e4; ++i4) {
          const code = input.charCodeAt(pos);
          let val;
          if (code === 95 && allowNumSeparator !== "bail") {
            const prev2 = input.charCodeAt(pos - 1);
            const next2 = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
              errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next2) || !isAllowedSibling(next2) || forbiddenSiblings.has(prev2) || forbiddenSiblings.has(next2)) {
              errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
              val = 0;
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++pos;
          total = total * radix + val;
        }
        if (pos === start || len != null && pos - start !== len || invalid) {
          return {
            n: null,
            pos
          };
        }
        return {
          n: total,
          pos
        };
      }
      function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
        const ch = input.charCodeAt(pos);
        let code;
        if (ch === 123) {
          ++pos;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
          ++pos;
          if (code !== null && code > 1114111) {
            if (throwOnInvalid) {
              errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
              return {
                code: null,
                pos
              };
            }
          }
        } else {
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
        }
        return {
          code,
          pos
        };
      }
      var _excluded = ["at"];
      var _excluded2 = ["at"];
      function buildPosition(pos, lineStart, curLine) {
        return new Position(curLine, pos - lineStart, pos);
      }
      var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
      var Token = class {
        constructor(state) {
          this.type = state.type;
          this.value = state.value;
          this.start = state.start;
          this.end = state.end;
          this.loc = new SourceLocation(state.startLoc, state.endLoc);
        }
      };
      var Tokenizer = class extends CommentsParser {
        constructor(options, input) {
          super();
          this.isLookahead = void 0;
          this.tokens = [];
          this.errorHandlers_readInt = {
            invalidDigit: (pos, lineStart, curLine, radix) => {
              if (!this.options.errorRecovery) return false;
              this.raise(Errors.InvalidDigit, {
                at: buildPosition(pos, lineStart, curLine),
                radix
              });
              return true;
            },
            numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
            unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
          };
          this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
            invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
            invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
          });
          this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: (pos, lineStart, curLine) => {
              this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                at: buildPosition(pos, lineStart, curLine)
              });
            },
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedString, {
                at: buildPosition(pos - 1, lineStart, curLine)
              });
            }
          });
          this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
            strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
            unterminated: (pos, lineStart, curLine) => {
              throw this.raise(Errors.UnterminatedTemplate, {
                at: buildPosition(pos, lineStart, curLine)
              });
            }
          });
          this.state = new State();
          this.state.init(options);
          this.input = input;
          this.length = input.length;
          this.isLookahead = false;
        }
        pushToken(token) {
          this.tokens.length = this.state.tokensLength;
          this.tokens.push(token);
          ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes();
          if (this.options.tokens) {
            this.pushToken(new Token(this.state));
          }
          this.state.lastTokStart = this.state.start;
          this.state.lastTokEndLoc = this.state.endLoc;
          this.state.lastTokStartLoc = this.state.startLoc;
          this.nextToken();
        }
        eat(type) {
          if (this.match(type)) {
            this.next();
            return true;
          } else {
            return false;
          }
        }
        match(type) {
          return this.state.type === type;
        }
        createLookaheadState(state) {
          return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [this.curContext()],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition
          };
        }
        lookahead() {
          const old = this.state;
          this.state = this.createLookaheadState(old);
          this.isLookahead = true;
          this.nextToken();
          this.isLookahead = false;
          const curr = this.state;
          this.state = old;
          return curr;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(pos) {
          skipWhiteSpace.lastIndex = pos;
          return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        codePointAtPos(pos) {
          let cp = this.input.charCodeAt(pos);
          if ((cp & 64512) === 55296 && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            if ((trail & 64512) === 56320) {
              cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
            }
          }
          return cp;
        }
        setStrict(strict) {
          this.state.strict = strict;
          if (strict) {
            this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {
              at
            }));
            this.state.strictErrors.clear();
          }
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          this.skipSpace();
          this.state.start = this.state.pos;
          if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
          if (this.state.pos >= this.length) {
            this.finishToken(135);
            return;
          }
          this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment() {
          let startLoc;
          if (!this.isLookahead) startLoc = this.state.curPosition();
          const start = this.state.pos;
          const end = this.input.indexOf("*/", start + 2);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
          this.state.pos = end + 2;
          lineBreakG.lastIndex = start + 2;
          while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
            ++this.state.curLine;
            this.state.lineStart = lineBreakG.lastIndex;
          }
          if (this.isLookahead) return;
          const comment = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + 2,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens) this.pushToken(comment);
          return comment;
        }
        skipLineComment(startSkip) {
          const start = this.state.pos;
          let startLoc;
          if (!this.isLookahead) startLoc = this.state.curPosition();
          let ch = this.input.charCodeAt(this.state.pos += startSkip);
          if (this.state.pos < this.length) {
            while (!isNewLine(ch) && ++this.state.pos < this.length) {
              ch = this.input.charCodeAt(this.state.pos);
            }
          }
          if (this.isLookahead) return;
          const end = this.state.pos;
          const value = this.input.slice(start + startSkip, end);
          const comment = {
            type: "CommentLine",
            value,
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          if (this.options.tokens) this.pushToken(comment);
          return comment;
        }
        skipSpace() {
          const spaceStart = this.state.pos;
          const comments = [];
          loop: while (this.state.pos < this.length) {
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                  ++this.state.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    const comment = this.skipBlockComment();
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment) comments.push(comment);
                    }
                    break;
                  }
                  case 47: {
                    const comment = this.skipLineComment(2);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment) comments.push(comment);
                    }
                    break;
                  }
                  default:
                    break loop;
                }
                break;
              default:
                if (isWhitespace2(ch)) {
                  ++this.state.pos;
                } else if (ch === 45 && !this.inModule) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                    const comment = this.skipLineComment(3);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment) comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else if (ch === 60 && !this.inModule) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                    const comment = this.skipLineComment(4);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment) comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else {
                  break loop;
                }
            }
          }
          if (comments.length > 0) {
            const end = this.state.pos;
            const commentWhitespace = {
              start: spaceStart,
              end,
              comments,
              leadingNode: null,
              trailingNode: null,
              containingNode: null
            };
            this.state.commentStack.push(commentWhitespace);
          }
        }
        finishToken(type, val) {
          this.state.end = this.state.pos;
          this.state.endLoc = this.state.curPosition();
          const prevType = this.state.type;
          this.state.type = type;
          this.state.value = val;
          if (!this.isLookahead) {
            this.updateContext(prevType);
          }
        }
        replaceToken(type) {
          this.state.type = type;
          this.updateContext();
        }
        readToken_numberSign() {
          if (this.state.pos === 0 && this.readToken_interpreter()) {
            return;
          }
          const nextPos = this.state.pos + 1;
          const next2 = this.codePointAtPos(nextPos);
          if (next2 >= 48 && next2 <= 57) {
            throw this.raise(Errors.UnexpectedDigitAfterHash, {
              at: this.state.curPosition()
            });
          }
          if (next2 === 123 || next2 === 91 && this.hasPlugin("recordAndTuple")) {
            this.expectPlugin("recordAndTuple");
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
              throw this.raise(next2 === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            if (next2 === 123) {
              this.finishToken(7);
            } else {
              this.finishToken(1);
            }
          } else if (isIdentifierStart(next2)) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1(next2));
          } else if (next2 === 92) {
            ++this.state.pos;
            this.finishToken(134, this.readWord1());
          } else {
            this.finishOp(27, 1);
          }
        }
        readToken_dot() {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (next2 >= 48 && next2 <= 57) {
            this.readNumber(true);
            return;
          }
          if (next2 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
            this.state.pos += 3;
            this.finishToken(21);
          } else {
            ++this.state.pos;
            this.finishToken(16);
          }
        }
        readToken_slash() {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (next2 === 61) {
            this.finishOp(31, 2);
          } else {
            this.finishOp(56, 1);
          }
        }
        readToken_interpreter() {
          if (this.state.pos !== 0 || this.length < 2) return false;
          let ch = this.input.charCodeAt(this.state.pos + 1);
          if (ch !== 33) return false;
          const start = this.state.pos;
          this.state.pos += 1;
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
          const value = this.input.slice(start + 2, this.state.pos);
          this.finishToken(28, value);
          return true;
        }
        readToken_mult_modulo(code) {
          let type = code === 42 ? 55 : 54;
          let width = 1;
          let next2 = this.input.charCodeAt(this.state.pos + 1);
          if (code === 42 && next2 === 42) {
            width++;
            next2 = this.input.charCodeAt(this.state.pos + 2);
            type = 57;
          }
          if (next2 === 61 && !this.state.inType) {
            width++;
            type = code === 37 ? 33 : 30;
          }
          this.finishOp(type, width);
        }
        readToken_pipe_amp(code) {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (next2 === code) {
            if (this.input.charCodeAt(this.state.pos + 2) === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(code === 124 ? 41 : 42, 2);
            }
            return;
          }
          if (code === 124) {
            if (next2 === 62) {
              this.finishOp(39, 2);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next2 === 125) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(9);
              return;
            }
            if (this.hasPlugin("recordAndTuple") && next2 === 93) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(4);
              return;
            }
          }
          if (next2 === 61) {
            this.finishOp(30, 2);
            return;
          }
          this.finishOp(code === 124 ? 43 : 45, 1);
        }
        readToken_caret() {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (next2 === 61 && !this.state.inType) {
            this.finishOp(32, 2);
          } else if (next2 === 94 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "^^"
          }])) {
            this.finishOp(37, 2);
            const lookaheadCh = this.input.codePointAt(this.state.pos);
            if (lookaheadCh === 94) {
              throw this.unexpected();
            }
          } else {
            this.finishOp(44, 1);
          }
        }
        readToken_atSign() {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (next2 === 64 && this.hasPlugin(["pipelineOperator", {
            proposal: "hack",
            topicToken: "@@"
          }])) {
            this.finishOp(38, 2);
          } else {
            this.finishOp(26, 1);
          }
        }
        readToken_plus_min(code) {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (next2 === code) {
            this.finishOp(34, 2);
            return;
          }
          if (next2 === 61) {
            this.finishOp(30, 2);
          } else {
            this.finishOp(53, 1);
          }
        }
        readToken_lt() {
          const {
            pos
          } = this.state;
          const next2 = this.input.charCodeAt(pos + 1);
          if (next2 === 60) {
            if (this.input.charCodeAt(pos + 2) === 61) {
              this.finishOp(30, 3);
              return;
            }
            this.finishOp(51, 2);
            return;
          }
          if (next2 === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(47, 1);
        }
        readToken_gt() {
          const {
            pos
          } = this.state;
          const next2 = this.input.charCodeAt(pos + 1);
          if (next2 === 62) {
            const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(pos + size) === 61) {
              this.finishOp(30, size + 1);
              return;
            }
            this.finishOp(52, size);
            return;
          }
          if (next2 === 61) {
            this.finishOp(49, 2);
            return;
          }
          this.finishOp(48, 1);
        }
        readToken_eq_excl(code) {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (next2 === 61) {
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
            return;
          }
          if (code === 61 && next2 === 62) {
            this.state.pos += 2;
            this.finishToken(19);
            return;
          }
          this.finishOp(code === 61 ? 29 : 35, 1);
        }
        readToken_question() {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          const next22 = this.input.charCodeAt(this.state.pos + 2);
          if (next2 === 63) {
            if (next22 === 61) {
              this.finishOp(30, 3);
            } else {
              this.finishOp(40, 2);
            }
          } else if (next2 === 46 && !(next22 >= 48 && next22 <= 57)) {
            this.state.pos += 2;
            this.finishToken(18);
          } else {
            ++this.state.pos;
            this.finishToken(17);
          }
        }
        getTokenFromCode(code) {
          switch (code) {
            case 46:
              this.readToken_dot();
              return;
            case 40:
              ++this.state.pos;
              this.finishToken(10);
              return;
            case 41:
              ++this.state.pos;
              this.finishToken(11);
              return;
            case 59:
              ++this.state.pos;
              this.finishToken(13);
              return;
            case 44:
              ++this.state.pos;
              this.finishToken(12);
              return;
            case 91:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(2);
              } else {
                ++this.state.pos;
                this.finishToken(0);
              }
              return;
            case 93:
              ++this.state.pos;
              this.finishToken(3);
              return;
            case 123:
              if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                  throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                    at: this.state.curPosition()
                  });
                }
                this.state.pos += 2;
                this.finishToken(6);
              } else {
                ++this.state.pos;
                this.finishToken(5);
              }
              return;
            case 125:
              ++this.state.pos;
              this.finishToken(8);
              return;
            case 58:
              if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                this.finishOp(15, 2);
              } else {
                ++this.state.pos;
                this.finishToken(14);
              }
              return;
            case 63:
              this.readToken_question();
              return;
            case 96:
              this.readTemplateToken();
              return;
            case 48: {
              const next2 = this.input.charCodeAt(this.state.pos + 1);
              if (next2 === 120 || next2 === 88) {
                this.readRadixNumber(16);
                return;
              }
              if (next2 === 111 || next2 === 79) {
                this.readRadixNumber(8);
                return;
              }
              if (next2 === 98 || next2 === 66) {
                this.readRadixNumber(2);
                return;
              }
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              this.readNumber(false);
              return;
            case 34:
            case 39:
              this.readString(code);
              return;
            case 47:
              this.readToken_slash();
              return;
            case 37:
            case 42:
              this.readToken_mult_modulo(code);
              return;
            case 124:
            case 38:
              this.readToken_pipe_amp(code);
              return;
            case 94:
              this.readToken_caret();
              return;
            case 43:
            case 45:
              this.readToken_plus_min(code);
              return;
            case 60:
              this.readToken_lt();
              return;
            case 62:
              this.readToken_gt();
              return;
            case 61:
            case 33:
              this.readToken_eq_excl(code);
              return;
            case 126:
              this.finishOp(36, 1);
              return;
            case 64:
              this.readToken_atSign();
              return;
            case 35:
              this.readToken_numberSign();
              return;
            case 92:
              this.readWord();
              return;
            default:
              if (isIdentifierStart(code)) {
                this.readWord(code);
                return;
              }
          }
          throw this.raise(Errors.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(code)
          });
        }
        finishOp(type, size) {
          const str = this.input.slice(this.state.pos, this.state.pos + size);
          this.state.pos += size;
          this.finishToken(type, str);
        }
        readRegexp() {
          const startLoc = this.state.startLoc;
          const start = this.state.start + 1;
          let escaped, inClass;
          let {
            pos
          } = this.state;
          for (; ; ++pos) {
            if (pos >= this.length) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) {
              throw this.raise(Errors.UnterminatedRegExp, {
                at: createPositionWithColumnOffset(startLoc, 1)
              });
            }
            if (escaped) {
              escaped = false;
            } else {
              if (ch === 91) {
                inClass = true;
              } else if (ch === 93 && inClass) {
                inClass = false;
              } else if (ch === 47 && !inClass) {
                break;
              }
              escaped = ch === 92;
            }
          }
          const content = this.input.slice(start, pos);
          ++pos;
          let mods = "";
          const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
          while (pos < this.length) {
            const cp = this.codePointAtPos(pos);
            const char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) {
              if (cp === 118) {
                this.expectPlugin("regexpUnicodeSets", nextPos());
                if (mods.includes("u")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              } else if (cp === 117) {
                if (mods.includes("v")) {
                  this.raise(Errors.IncompatibleRegExpUVFlags, {
                    at: nextPos()
                  });
                }
              }
              if (mods.includes(char)) {
                this.raise(Errors.DuplicateRegExpFlags, {
                  at: nextPos()
                });
              }
            } else if (isIdentifierChar(cp) || cp === 92) {
              this.raise(Errors.MalformedRegExpFlags, {
                at: nextPos()
              });
            } else {
              break;
            }
            ++pos;
            mods += char;
          }
          this.state.pos = pos;
          this.finishToken(133, {
            pattern: content,
            flags: mods
          });
        }
        readInt(radix, len, forceLen = false, allowNumSeparator = true) {
          const {
            n: n4,
            pos
          } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt);
          this.state.pos = pos;
          return n4;
        }
        readRadixNumber(radix) {
          const startLoc = this.state.curPosition();
          let isBigInt = false;
          this.state.pos += 2;
          const val = this.readInt(radix);
          if (val == null) {
            this.raise(Errors.InvalidDigit, {
              at: createPositionWithColumnOffset(startLoc, 2),
              radix
            });
          }
          const next2 = this.input.charCodeAt(this.state.pos);
          if (next2 === 110) {
            ++this.state.pos;
            isBigInt = true;
          } else if (next2 === 109) {
            throw this.raise(Errors.InvalidDecimal, {
              at: startLoc
            });
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          if (isBigInt) {
            const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(131, str);
            return;
          }
          this.finishToken(130, val);
        }
        readNumber(startsWithDot) {
          const start = this.state.pos;
          const startLoc = this.state.curPosition();
          let isFloat = false;
          let isBigInt = false;
          let isDecimal = false;
          let hasExponent = false;
          let isOctal = false;
          if (!startsWithDot && this.readInt(10) === null) {
            this.raise(Errors.InvalidNumber, {
              at: this.state.curPosition()
            });
          }
          const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
          if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
              at: startLoc
            });
            if (!this.state.strict) {
              const underscorePos = integer.indexOf("_");
              if (underscorePos > 0) {
                this.raise(Errors.ZeroDigitNumericSeparator, {
                  at: createPositionWithColumnOffset(startLoc, underscorePos)
                });
              }
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer);
          }
          let next2 = this.input.charCodeAt(this.state.pos);
          if (next2 === 46 && !isOctal) {
            ++this.state.pos;
            this.readInt(10);
            isFloat = true;
            next2 = this.input.charCodeAt(this.state.pos);
          }
          if ((next2 === 69 || next2 === 101) && !isOctal) {
            next2 = this.input.charCodeAt(++this.state.pos);
            if (next2 === 43 || next2 === 45) {
              ++this.state.pos;
            }
            if (this.readInt(10) === null) {
              this.raise(Errors.InvalidOrMissingExponent, {
                at: startLoc
              });
            }
            isFloat = true;
            hasExponent = true;
            next2 = this.input.charCodeAt(this.state.pos);
          }
          if (next2 === 110) {
            if (isFloat || hasLeadingZero) {
              this.raise(Errors.InvalidBigIntLiteral, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isBigInt = true;
          }
          if (next2 === 109) {
            this.expectPlugin("decimal", this.state.curPosition());
            if (hasExponent || hasLeadingZero) {
              this.raise(Errors.InvalidDecimal, {
                at: startLoc
              });
            }
            ++this.state.pos;
            isDecimal = true;
          }
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
            throw this.raise(Errors.NumberIdentifier, {
              at: this.state.curPosition()
            });
          }
          const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
          if (isBigInt) {
            this.finishToken(131, str);
            return;
          }
          if (isDecimal) {
            this.finishToken(132, str);
            return;
          }
          const val = isOctal ? parseInt(str, 8) : parseFloat(str);
          this.finishToken(130, val);
        }
        readCodePoint(throwOnInvalid) {
          const {
            code,
            pos
          } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
          this.state.pos = pos;
          return code;
        }
        readString(quote) {
          const {
            str,
            pos,
            curLine,
            lineStart
          } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          this.finishToken(129, str);
        }
        readTemplateContinuation() {
          if (!this.match(8)) {
            this.unexpected(null, 8);
          }
          this.state.pos--;
          this.readTemplateToken();
        }
        readTemplateToken() {
          const opening = this.input[this.state.pos];
          const {
            str,
            containsInvalid,
            pos,
            curLine,
            lineStart
          } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
          this.state.pos = pos + 1;
          this.state.lineStart = lineStart;
          this.state.curLine = curLine;
          if (this.input.codePointAt(pos) === 96) {
            this.finishToken(24, containsInvalid ? null : opening + str + "`");
          } else {
            this.state.pos++;
            this.finishToken(25, containsInvalid ? null : opening + str + "${");
          }
        }
        recordStrictModeErrors(toParseError, {
          at
        }) {
          const index2 = at.index;
          if (this.state.strict && !this.state.strictErrors.has(index2)) {
            this.raise(toParseError, {
              at
            });
          } else {
            this.state.strictErrors.set(index2, [toParseError, at]);
          }
        }
        readWord1(firstCode) {
          this.state.containsEsc = false;
          let word = "";
          const start = this.state.pos;
          let chunkStart = this.state.pos;
          if (firstCode !== void 0) {
            this.state.pos += firstCode <= 65535 ? 1 : 2;
          }
          while (this.state.pos < this.length) {
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) {
              this.state.pos += ch <= 65535 ? 1 : 2;
            } else if (ch === 92) {
              this.state.containsEsc = true;
              word += this.input.slice(chunkStart, this.state.pos);
              const escStart = this.state.curPosition();
              const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
              if (this.input.charCodeAt(++this.state.pos) !== 117) {
                this.raise(Errors.MissingUnicodeEscape, {
                  at: this.state.curPosition()
                });
                chunkStart = this.state.pos - 1;
                continue;
              }
              ++this.state.pos;
              const esc = this.readCodePoint(true);
              if (esc !== null) {
                if (!identifierCheck(esc)) {
                  this.raise(Errors.EscapedCharNotAnIdentifier, {
                    at: escStart
                  });
                }
                word += String.fromCodePoint(esc);
              }
              chunkStart = this.state.pos;
            } else {
              break;
            }
          }
          return word + this.input.slice(chunkStart, this.state.pos);
        }
        readWord(firstCode) {
          const word = this.readWord1(firstCode);
          const type = keywords$1.get(word);
          if (type !== void 0) {
            this.finishToken(type, tokenLabelName(type));
          } else {
            this.finishToken(128, word);
          }
        }
        checkKeywordEscapes() {
          const {
            type
          } = this.state;
          if (tokenIsKeyword(type) && this.state.containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.startLoc,
              reservedWord: tokenLabelName(type)
            });
          }
        }
        raise(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);
          const loc = at instanceof Position ? at : at.loc.start;
          const error = toParseError({
            loc,
            details
          });
          if (!this.options.errorRecovery) throw error;
          if (!this.isLookahead) this.state.errors.push(error);
          return error;
        }
        raiseOverwrite(toParseError, raiseProperties) {
          const {
            at
          } = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);
          const loc = at instanceof Position ? at : at.loc.start;
          const pos = loc.index;
          const errors = this.state.errors;
          for (let i4 = errors.length - 1; i4 >= 0; i4--) {
            const error = errors[i4];
            if (error.loc.index === pos) {
              return errors[i4] = toParseError({
                loc,
                details
              });
            }
            if (error.loc.index < pos) break;
          }
          return this.raise(toParseError, raiseProperties);
        }
        updateContext(prevType) {
        }
        unexpected(loc, type) {
          throw this.raise(Errors.UnexpectedToken, {
            expected: type ? tokenLabelName(type) : null,
            at: loc != null ? loc : this.state.startLoc
          });
        }
        expectPlugin(pluginName, loc) {
          if (this.hasPlugin(pluginName)) {
            return true;
          }
          throw this.raise(Errors.MissingPlugin, {
            at: loc != null ? loc : this.state.startLoc,
            missingPlugin: [pluginName]
          });
        }
        expectOnePlugin(pluginNames) {
          if (!pluginNames.some((name) => this.hasPlugin(name))) {
            throw this.raise(Errors.MissingOneOfPlugins, {
              at: this.state.startLoc,
              missingPlugin: pluginNames
            });
          }
        }
        errorBuilder(error) {
          return (pos, lineStart, curLine) => {
            this.raise(error, {
              at: buildPosition(pos, lineStart, curLine)
            });
          };
        }
      };
      var Scope = class {
        constructor(flags) {
          this.var = /* @__PURE__ */ new Set();
          this.lexical = /* @__PURE__ */ new Set();
          this.functions = /* @__PURE__ */ new Set();
          this.flags = flags;
        }
      };
      var ScopeHandler = class {
        constructor(parser, inModule) {
          this.parser = void 0;
          this.scopeStack = [];
          this.inModule = void 0;
          this.undefinedExports = /* @__PURE__ */ new Map();
          this.parser = parser;
          this.inModule = inModule;
        }
        get inFunction() {
          return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get allowSuper() {
          return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
        }
        get allowDirectSuper() {
          return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
        }
        get inClass() {
          return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          const flags = this.currentThisScopeFlags();
          return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
        }
        get inStaticBlock() {
          for (let i4 = this.scopeStack.length - 1; ; i4--) {
            const {
              flags
            } = this.scopeStack[i4];
            if (flags & SCOPE_STATIC_BLOCK) {
              return true;
            }
            if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
              return false;
            }
          }
        }
        get inNonArrowFunction() {
          return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(flags) {
          return new Scope(flags);
        }
        enter(flags) {
          this.scopeStack.push(this.createScope(flags));
        }
        exit() {
          this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(scope) {
          return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);
        }
        declareName(name, bindingType, loc) {
          let scope = this.currentScope();
          if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            if (bindingType & BIND_SCOPE_FUNCTION) {
              scope.functions.add(name);
            } else {
              scope.lexical.add(name);
            }
            if (bindingType & BIND_SCOPE_LEXICAL) {
              this.maybeExportDefined(scope, name);
            }
          } else if (bindingType & BIND_SCOPE_VAR) {
            for (let i4 = this.scopeStack.length - 1; i4 >= 0; --i4) {
              scope = this.scopeStack[i4];
              this.checkRedeclarationInScope(scope, name, bindingType, loc);
              scope.var.add(name);
              this.maybeExportDefined(scope, name);
              if (scope.flags & SCOPE_VAR) break;
            }
          }
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name);
          }
        }
        maybeExportDefined(scope, name) {
          if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {
            this.undefinedExports.delete(name);
          }
        }
        checkRedeclarationInScope(scope, name, bindingType, loc) {
          if (this.isRedeclaredInScope(scope, name, bindingType)) {
            this.parser.raise(Errors.VarRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (!(bindingType & BIND_KIND_VALUE)) return false;
          if (bindingType & BIND_SCOPE_LEXICAL) {
            return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
          }
          if (bindingType & BIND_SCOPE_FUNCTION) {
            return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
          }
          return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
        }
        checkLocalExport(id) {
          const {
            name
          } = id;
          const topLevelScope = this.scopeStack[0];
          if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
            this.undefinedExports.set(name, id.loc.start);
          }
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let i4 = this.scopeStack.length - 1; ; i4--) {
            const {
              flags
            } = this.scopeStack[i4];
            if (flags & SCOPE_VAR) {
              return flags;
            }
          }
        }
        currentThisScopeFlags() {
          for (let i4 = this.scopeStack.length - 1; ; i4--) {
            const {
              flags
            } = this.scopeStack[i4];
            if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
              return flags;
            }
          }
        }
      };
      var FlowScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.declareFunctions = /* @__PURE__ */ new Set();
        }
      };
      var FlowScopeHandler = class extends ScopeHandler {
        createScope(flags) {
          return new FlowScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
            scope.declareFunctions.add(name);
            return;
          }
          super.declareName(name, bindingType, loc);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
          if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
            return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
          }
          return false;
        }
        checkLocalExport(id) {
          if (!this.scopeStack[0].declareFunctions.has(id.name)) {
            super.checkLocalExport(id);
          }
        }
      };
      var ClassScope = class {
        constructor() {
          this.privateNames = /* @__PURE__ */ new Set();
          this.loneAccessors = /* @__PURE__ */ new Map();
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        }
      };
      var ClassScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [];
          this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          this.parser = parser;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new ClassScope());
        }
        exit() {
          const oldClassScope = this.stack.pop();
          const current = this.current();
          for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
            if (current) {
              if (!current.undefinedPrivateNames.has(name)) {
                current.undefinedPrivateNames.set(name, loc);
              }
            } else {
              this.parser.raise(Errors.InvalidPrivateFieldResolution, {
                at: loc,
                identifierName: name
              });
            }
          }
        }
        declarePrivateName(name, elementType, loc) {
          const {
            privateNames,
            loneAccessors,
            undefinedPrivateNames
          } = this.current();
          let redefined = privateNames.has(name);
          if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
            const accessor = redefined && loneAccessors.get(name);
            if (accessor) {
              const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
              const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
              const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
              const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
              redefined = oldKind === newKind || oldStatic !== newStatic;
              if (!redefined) loneAccessors.delete(name);
            } else if (!redefined) {
              loneAccessors.set(name, elementType);
            }
          }
          if (redefined) {
            this.parser.raise(Errors.PrivateNameRedeclaration, {
              at: loc,
              identifierName: name
            });
          }
          privateNames.add(name);
          undefinedPrivateNames.delete(name);
        }
        usePrivateName(name, loc) {
          let classScope;
          for (classScope of this.stack) {
            if (classScope.privateNames.has(name)) return;
          }
          if (classScope) {
            classScope.undefinedPrivateNames.set(name, loc);
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, {
              at: loc,
              identifierName: name
            });
          }
        }
      };
      var kExpression = 0;
      var kMaybeArrowParameterDeclaration = 1;
      var kMaybeAsyncArrowParameterDeclaration = 2;
      var kParameterDeclaration = 3;
      var ExpressionScope = class {
        constructor(type = kExpression) {
          this.type = void 0;
          this.type = type;
        }
        canBeArrowParameterDeclaration() {
          return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
        }
        isCertainlyParameterDeclaration() {
          return this.type === kParameterDeclaration;
        }
      };
      var ArrowHeadParsingScope = class extends ExpressionScope {
        constructor(type) {
          super(type);
          this.declarationErrors = /* @__PURE__ */ new Map();
        }
        recordDeclarationError(ParsingErrorClass, {
          at
        }) {
          const index2 = at.index;
          this.declarationErrors.set(index2, [ParsingErrorClass, at]);
        }
        clearDeclarationError(index2) {
          this.declarationErrors.delete(index2);
        }
        iterateErrors(iterator) {
          this.declarationErrors.forEach(iterator);
        }
      };
      var ExpressionScopeHandler = class {
        constructor(parser) {
          this.parser = void 0;
          this.stack = [new ExpressionScope()];
          this.parser = parser;
        }
        enter(scope) {
          this.stack.push(scope);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(toParseError, {
          at: node
        }) {
          const origin = {
            at: node.loc.start
          };
          const {
            stack
          } = this;
          let i4 = stack.length - 1;
          let scope = stack[i4];
          while (!scope.isCertainlyParameterDeclaration()) {
            if (scope.canBeArrowParameterDeclaration()) {
              scope.recordDeclarationError(toParseError, origin);
            } else {
              return;
            }
            scope = stack[--i4];
          }
          this.parser.raise(toParseError, origin);
        }
        recordArrowParemeterBindingError(error, {
          at: node
        }) {
          const {
            stack
          } = this;
          const scope = stack[stack.length - 1];
          const origin = {
            at: node.loc.start
          };
          if (scope.isCertainlyParameterDeclaration()) {
            this.parser.raise(error, origin);
          } else if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(error, origin);
          } else {
            return;
          }
        }
        recordAsyncArrowParametersError({
          at
        }) {
          const {
            stack
          } = this;
          let i4 = stack.length - 1;
          let scope = stack[i4];
          while (scope.canBeArrowParameterDeclaration()) {
            if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
              scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
                at
              });
            }
            scope = stack[--i4];
          }
        }
        validateAsPattern() {
          const {
            stack
          } = this;
          const currentScope = stack[stack.length - 1];
          if (!currentScope.canBeArrowParameterDeclaration()) return;
          currentScope.iterateErrors(([toParseError, loc]) => {
            this.parser.raise(toParseError, {
              at: loc
            });
            let i4 = stack.length - 2;
            let scope = stack[i4];
            while (scope.canBeArrowParameterDeclaration()) {
              scope.clearDeclarationError(loc.index);
              scope = stack[--i4];
            }
          });
        }
      };
      function newParameterDeclarationScope() {
        return new ExpressionScope(kParameterDeclaration);
      }
      function newArrowHeadScope() {
        return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
      }
      function newAsyncArrowScope() {
        return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
      }
      function newExpressionScope() {
        return new ExpressionScope();
      }
      var PARAM = 0;
      var PARAM_YIELD = 1;
      var PARAM_AWAIT = 2;
      var PARAM_RETURN = 4;
      var PARAM_IN = 8;
      var ProductionParameterHandler = class {
        constructor() {
          this.stacks = [];
        }
        enter(flags) {
          this.stacks.push(flags);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (this.currentFlags() & PARAM_AWAIT) > 0;
        }
        get hasYield() {
          return (this.currentFlags() & PARAM_YIELD) > 0;
        }
        get hasReturn() {
          return (this.currentFlags() & PARAM_RETURN) > 0;
        }
        get hasIn() {
          return (this.currentFlags() & PARAM_IN) > 0;
        }
      };
      function functionFlags(isAsync, isGenerator) {
        return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
      }
      var UtilParser = class extends Tokenizer {
        addExtra(node, key, value, enumerable = true) {
          if (!node) return;
          const extra = node.extra = node.extra || {};
          if (enumerable) {
            extra[key] = value;
          } else {
            Object.defineProperty(extra, key, {
              enumerable,
              value
            });
          }
        }
        isContextual(token) {
          return this.state.type === token && !this.state.containsEsc;
        }
        isUnparsedContextual(nameStart, name) {
          const nameEnd = nameStart + name.length;
          if (this.input.slice(nameStart, nameEnd) === name) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
          }
          return false;
        }
        isLookaheadContextual(name) {
          const next2 = this.nextTokenStart();
          return this.isUnparsedContextual(next2, name);
        }
        eatContextual(token) {
          if (this.isContextual(token)) {
            this.next();
            return true;
          }
          return false;
        }
        expectContextual(token, toParseError) {
          if (!this.eatContextual(token)) {
            if (toParseError != null) {
              throw this.raise(toParseError, {
                at: this.state.startLoc
              });
            }
            throw this.unexpected(null, token);
          }
        }
        canInsertSemicolon() {
          return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
          return skipWhiteSpaceToLineBreak.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(allowAsi = true) {
          if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
          this.raise(Errors.MissingSemicolon, {
            at: this.state.lastTokEndLoc
          });
        }
        expect(type, loc) {
          this.eat(type) || this.unexpected(loc, type);
        }
        tryParse(fn, oldState = this.state.clone()) {
          const abortSignal = {
            node: null
          };
          try {
            const node = fn((node2 = null) => {
              abortSignal.node = node2;
              throw abortSignal;
            });
            if (this.state.errors.length > oldState.errors.length) {
              const failState = this.state;
              this.state = oldState;
              this.state.tokensLength = failState.tokensLength;
              return {
                node,
                error: failState.errors[oldState.errors.length],
                thrown: false,
                aborted: false,
                failState
              };
            }
            return {
              node,
              error: null,
              thrown: false,
              aborted: false,
              failState: null
            };
          } catch (error) {
            const failState = this.state;
            this.state = oldState;
            if (error instanceof SyntaxError) {
              return {
                node: null,
                error,
                thrown: true,
                aborted: false,
                failState
              };
            }
            if (error === abortSignal) {
              return {
                node: abortSignal.node,
                error: null,
                thrown: false,
                aborted: true,
                failState
              };
            }
            throw error;
          }
        }
        checkExpressionErrors(refExpressionErrors, andThrow) {
          if (!refExpressionErrors) return false;
          const {
            shorthandAssignLoc,
            doubleProtoLoc,
            privateKeyLoc,
            optionalParametersLoc
          } = refExpressionErrors;
          const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
          if (!andThrow) {
            return hasErrors;
          }
          if (shorthandAssignLoc != null) {
            this.raise(Errors.InvalidCoverInitializedName, {
              at: shorthandAssignLoc
            });
          }
          if (doubleProtoLoc != null) {
            this.raise(Errors.DuplicateProto, {
              at: doubleProtoLoc
            });
          }
          if (privateKeyLoc != null) {
            this.raise(Errors.UnexpectedPrivateField, {
              at: privateKeyLoc
            });
          }
          if (optionalParametersLoc != null) {
            this.unexpected(optionalParametersLoc);
          }
        }
        isLiteralPropertyName() {
          return tokenIsLiteralPropertyName(this.state.type);
        }
        isPrivateName(node) {
          return node.type === "PrivateName";
        }
        getPrivateNameSV(node) {
          return node.id.name;
        }
        hasPropertyAsPrivateName(node) {
          return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
        }
        isOptionalChain(node) {
          return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
        }
        isObjectProperty(node) {
          return node.type === "ObjectProperty";
        }
        isObjectMethod(node) {
          return node.type === "ObjectMethod";
        }
        initializeScopes(inModule = this.options.sourceType === "module") {
          const oldLabels = this.state.labels;
          this.state.labels = [];
          const oldExportedIdentifiers = this.exportedIdentifiers;
          this.exportedIdentifiers = /* @__PURE__ */ new Set();
          const oldInModule = this.inModule;
          this.inModule = inModule;
          const oldScope = this.scope;
          const ScopeHandler2 = this.getScopeHandler();
          this.scope = new ScopeHandler2(this, inModule);
          const oldProdParam = this.prodParam;
          this.prodParam = new ProductionParameterHandler();
          const oldClassScope = this.classScope;
          this.classScope = new ClassScopeHandler(this);
          const oldExpressionScope = this.expressionScope;
          this.expressionScope = new ExpressionScopeHandler(this);
          return () => {
            this.state.labels = oldLabels;
            this.exportedIdentifiers = oldExportedIdentifiers;
            this.inModule = oldInModule;
            this.scope = oldScope;
            this.prodParam = oldProdParam;
            this.classScope = oldClassScope;
            this.expressionScope = oldExpressionScope;
          };
        }
        enterInitialScopes() {
          let paramFlags = PARAM;
          if (this.inModule) {
            paramFlags |= PARAM_AWAIT;
          }
          this.scope.enter(SCOPE_PROGRAM);
          this.prodParam.enter(paramFlags);
        }
        checkDestructuringPrivate(refExpressionErrors) {
          const {
            privateKeyLoc
          } = refExpressionErrors;
          if (privateKeyLoc !== null) {
            this.expectPlugin("destructuringPrivate", privateKeyLoc);
          }
        }
      };
      var ExpressionErrors = class {
        constructor() {
          this.shorthandAssignLoc = null;
          this.doubleProtoLoc = null;
          this.privateKeyLoc = null;
          this.optionalParametersLoc = null;
        }
      };
      var Node = class {
        constructor(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          this.loc = new SourceLocation(loc);
          if (parser != null && parser.options.ranges) this.range = [pos, 0];
          if (parser != null && parser.filename) this.loc.filename = parser.filename;
        }
      };
      var NodePrototype = Node.prototype;
      {
        NodePrototype.__clone = function() {
          const newNode = new Node();
          const keys = Object.keys(this);
          for (let i4 = 0, length = keys.length; i4 < length; i4++) {
            const key = keys[i4];
            if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
              newNode[key] = this[key];
            }
          }
          return newNode;
        };
      }
      function clonePlaceholder(node) {
        return cloneIdentifier(node);
      }
      function cloneIdentifier(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra,
          name
        } = node;
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.extra = extra;
        cloned.name = name;
        if (type === "Placeholder") {
          cloned.expectedNode = node.expectedNode;
        }
        return cloned;
      }
      function cloneStringLiteral(node) {
        const {
          type,
          start,
          end,
          loc,
          range,
          extra
        } = node;
        if (type === "Placeholder") {
          return clonePlaceholder(node);
        }
        const cloned = Object.create(NodePrototype);
        cloned.type = type;
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        if (node.raw !== void 0) {
          cloned.raw = node.raw;
        } else {
          cloned.extra = extra;
        }
        cloned.value = node.value;
        return cloned;
      }
      var NodeUtils = class extends UtilParser {
        startNode() {
          return new Node(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(pos, loc) {
          return new Node(this, pos, loc);
        }
        startNodeAtNode(type) {
          return this.startNodeAt(type.start, type.loc.start);
        }
        finishNode(node, type) {
          return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
        }
        finishNodeAt(node, type, endLoc) {
          node.type = type;
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges) node.range[1] = endLoc.index;
          if (this.options.attachComment) this.processComment(node);
          return node;
        }
        resetStartLocation(node, start, startLoc) {
          node.start = start;
          node.loc.start = startLoc;
          if (this.options.ranges) node.range[0] = start;
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          node.end = endLoc.index;
          node.loc.end = endLoc;
          if (this.options.ranges) node.range[1] = endLoc.index;
        }
        resetStartLocationFromNode(node, locationNode) {
          this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
        }
      };
      var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
      var FlowErrors = ParseErrorEnum`flow`({
        AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
        AssignReservedType: ({
          reservedType
        }) => `Cannot overwrite reserved type ${reservedType}.`,
        DeclareClassElement: "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
        EnumBooleanMemberNotInitialized: ({
          memberName,
          enumName
        }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
        EnumDuplicateMemberName: ({
          memberName,
          enumName
        }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
        EnumInconsistentMemberValues: ({
          enumName
        }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
        EnumInvalidExplicitType: ({
          invalidEnumType,
          enumName
        }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidExplicitTypeUnknownSupplied: ({
          enumName
        }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerPrimaryType: ({
          enumName,
          memberName,
          explicitType
        }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
        EnumInvalidMemberInitializerSymbolType: ({
          enumName,
          memberName
        }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
        EnumInvalidMemberInitializerUnknownType: ({
          enumName,
          memberName
        }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
        EnumInvalidMemberName: ({
          enumName,
          memberName,
          suggestion
        }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
        EnumNumberMemberNotInitialized: ({
          enumName,
          memberName
        }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
        EnumStringMemberInconsistentlyInitailized: ({
          enumName
        }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
        GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
        ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
        InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
        InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
        InexactVariance: "Explicit inexact syntax cannot have variance.",
        InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
        MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
        NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
        PatternIsOptional: Object.assign({
          message: "A binding pattern parameter cannot be optional in an implementation signature."
        }, {
          reasonCode: "OptionalBindingPattern"
        }),
        SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
        SpreadVariance: "Spread properties cannot have variance.",
        ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
        ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
        ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
        ThisParamNoDefault: "The `this` parameter may not have a default value.",
        TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
        UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
        UnexpectedReservedType: ({
          reservedType
        }) => `Unexpected reserved type ${reservedType}.`,
        UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
        UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
        UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
        UnsupportedDeclareExportKind: ({
          unsupportedExportKind,
          suggestion
        }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
        UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
        UnterminatedFlowComment: "Unterminated flow-comment."
      });
      function isEsModuleType(bodyElement) {
        return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
      }
      function hasTypeImportKind(node) {
        return node.importKind === "type" || node.importKind === "typeof";
      }
      function isMaybeDefaultImport(type) {
        return tokenIsKeywordOrIdentifier(type) && type !== 97;
      }
      var exportSuggestions = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
      };
      function partition(list, test) {
        const list1 = [];
        const list2 = [];
        for (let i4 = 0; i4 < list.length; i4++) {
          (test(list[i4], i4, list) ? list1 : list2).push(list[i4]);
        }
        return [list1, list2];
      }
      var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
      var flow = (superClass) => class FlowParserMixin extends superClass {
        constructor(...args) {
          super(...args);
          this.flowPragma = void 0;
        }
        getScopeHandler() {
          return FlowScopeHandler;
        }
        shouldParseTypes() {
          return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }
        shouldParseEnums() {
          return !!this.getPluginOption("flow", "enums");
        }
        finishToken(type, val) {
          if (type !== 129 && type !== 13 && type !== 28) {
            if (this.flowPragma === void 0) {
              this.flowPragma = null;
            }
          }
          return super.finishToken(type, val);
        }
        addComment(comment) {
          if (this.flowPragma === void 0) {
            const matches2 = FLOW_PRAGMA_REGEX.exec(comment.value);
            if (!matches2) ;
            else if (matches2[1] === "flow") {
              this.flowPragma = "flow";
            } else if (matches2[1] === "noflow") {
              this.flowPragma = "noflow";
            } else {
              throw new Error("Unexpected flow pragma");
            }
          }
          return super.addComment(comment);
        }
        flowParseTypeInitialiser(tok) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(tok || 14);
          const type = this.flowParseType();
          this.state.inType = oldInType;
          return type;
        }
        flowParsePredicate() {
          const node = this.startNode();
          const moduloLoc = this.state.startLoc;
          this.next();
          this.expectContextual(107);
          if (this.state.lastTokStart > moduloLoc.index + 1) {
            this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
              at: moduloLoc
            });
          }
          if (this.eat(10)) {
            node.value = super.parseExpression();
            this.expect(11);
            return this.finishNode(node, "DeclaredPredicate");
          } else {
            return this.finishNode(node, "InferredPredicate");
          }
        }
        flowParseTypeAndPredicateInitialiser() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          this.expect(14);
          let type = null;
          let predicate = null;
          if (this.match(54)) {
            this.state.inType = oldInType;
            predicate = this.flowParsePredicate();
          } else {
            type = this.flowParseType();
            this.state.inType = oldInType;
            if (this.match(54)) {
              predicate = this.flowParsePredicate();
            }
          }
          return [type, predicate];
        }
        flowParseDeclareClass(node) {
          this.next();
          this.flowParseInterfaceish(node, true);
          return this.finishNode(node, "DeclareClass");
        }
        flowParseDeclareFunction(node) {
          this.next();
          const id = node.id = this.parseIdentifier();
          const typeNode = this.startNode();
          const typeContainer = this.startNode();
          if (this.match(47)) {
            typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            typeNode.typeParameters = null;
          }
          this.expect(10);
          const tmp = this.flowParseFunctionTypeParams();
          typeNode.params = tmp.params;
          typeNode.rest = tmp.rest;
          typeNode.this = tmp._this;
          this.expect(11);
          [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
          id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
          this.resetEndLocation(id);
          this.semicolon();
          this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
          return this.finishNode(node, "DeclareFunction");
        }
        flowParseDeclare(node, insideModule) {
          if (this.match(80)) {
            return this.flowParseDeclareClass(node);
          } else if (this.match(68)) {
            return this.flowParseDeclareFunction(node);
          } else if (this.match(74)) {
            return this.flowParseDeclareVariable(node);
          } else if (this.eatContextual(123)) {
            if (this.match(16)) {
              return this.flowParseDeclareModuleExports(node);
            } else {
              if (insideModule) {
                this.raise(FlowErrors.NestedDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.flowParseDeclareModule(node);
            }
          } else if (this.isContextual(126)) {
            return this.flowParseDeclareTypeAlias(node);
          } else if (this.isContextual(127)) {
            return this.flowParseDeclareOpaqueType(node);
          } else if (this.isContextual(125)) {
            return this.flowParseDeclareInterface(node);
          } else if (this.match(82)) {
            return this.flowParseDeclareExportDeclaration(node, insideModule);
          } else {
            throw this.unexpected();
          }
        }
        flowParseDeclareVariable(node) {
          this.next();
          node.id = this.flowParseTypeAnnotatableIdentifier(true);
          this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
          this.semicolon();
          return this.finishNode(node, "DeclareVariable");
        }
        flowParseDeclareModule(node) {
          this.scope.enter(SCOPE_OTHER);
          if (this.match(129)) {
            node.id = super.parseExprAtom();
          } else {
            node.id = this.parseIdentifier();
          }
          const bodyNode = node.body = this.startNode();
          const body2 = bodyNode.body = [];
          this.expect(5);
          while (!this.match(8)) {
            let bodyNode2 = this.startNode();
            if (this.match(83)) {
              this.next();
              if (!this.isContextual(126) && !this.match(87)) {
                this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                  at: this.state.lastTokStartLoc
                });
              }
              super.parseImport(bodyNode2);
            } else {
              this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);
              bodyNode2 = this.flowParseDeclare(bodyNode2, true);
            }
            body2.push(bodyNode2);
          }
          this.scope.exit();
          this.expect(8);
          this.finishNode(bodyNode, "BlockStatement");
          let kind = null;
          let hasModuleExport = false;
          body2.forEach((bodyElement) => {
            if (isEsModuleType(bodyElement)) {
              if (kind === "CommonJS") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "ES";
            } else if (bodyElement.type === "DeclareModuleExports") {
              if (hasModuleExport) {
                this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                  at: bodyElement
                });
              }
              if (kind === "ES") {
                this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                  at: bodyElement
                });
              }
              kind = "CommonJS";
              hasModuleExport = true;
            }
          });
          node.kind = kind || "CommonJS";
          return this.finishNode(node, "DeclareModule");
        }
        flowParseDeclareExportDeclaration(node, insideModule) {
          this.expect(82);
          if (this.eat(65)) {
            if (this.match(68) || this.match(80)) {
              node.declaration = this.flowParseDeclare(this.startNode());
            } else {
              node.declaration = this.flowParseType();
              this.semicolon();
            }
            node.default = true;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else {
            if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {
              const label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: label,
                suggestion: exportSuggestions[label]
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node.default = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) {
              node = this.parseExport(node);
              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node.default = false;
                delete node.exportKind;
              }
              node.type = "Declare" + node.type;
              return node;
            }
          }
          throw this.unexpected();
        }
        flowParseDeclareModuleExports(node) {
          this.next();
          this.expectContextual(108);
          node.typeAnnotation = this.flowParseTypeAnnotation();
          this.semicolon();
          return this.finishNode(node, "DeclareModuleExports");
        }
        flowParseDeclareTypeAlias(node) {
          this.next();
          const finished = this.flowParseTypeAlias(node);
          finished.type = "DeclareTypeAlias";
          return finished;
        }
        flowParseDeclareOpaqueType(node) {
          this.next();
          const finished = this.flowParseOpaqueType(node, true);
          finished.type = "DeclareOpaqueType";
          return finished;
        }
        flowParseDeclareInterface(node) {
          this.next();
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "DeclareInterface");
        }
        flowParseInterfaceish(node, isClass = false) {
          node.id = this.flowParseRestrictedIdentifier(!isClass, true);
          this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.extends = [];
          node.implements = [];
          node.mixins = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(12));
          }
          if (this.isContextual(114)) {
            this.next();
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.isContextual(110)) {
            this.next();
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: isClass,
            allowExact: false,
            allowSpread: false,
            allowProto: isClass,
            allowInexact: false
          });
        }
        flowParseInterfaceExtends() {
          const node = this.startNode();
          node.id = this.flowParseQualifiedTypeIdentifier();
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }
          return this.finishNode(node, "InterfaceExtends");
        }
        flowParseInterface(node) {
          this.flowParseInterfaceish(node);
          return this.finishNode(node, "InterfaceDeclaration");
        }
        checkNotUnderscore(word) {
          if (word === "_") {
            this.raise(FlowErrors.UnexpectedReservedUnderscore, {
              at: this.state.startLoc
            });
          }
        }
        checkReservedType(word, startLoc, declaration) {
          if (!reservedTypes.has(word)) return;
          this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
            at: startLoc,
            reservedType: word
          });
        }
        flowParseRestrictedIdentifier(liberal, declaration) {
          this.checkReservedType(this.state.value, this.state.startLoc, declaration);
          return this.parseIdentifier(liberal);
        }
        flowParseTypeAlias(node) {
          node.id = this.flowParseRestrictedIdentifier(false, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.right = this.flowParseTypeInitialiser(29);
          this.semicolon();
          return this.finishNode(node, "TypeAlias");
        }
        flowParseOpaqueType(node, declare) {
          this.expectContextual(126);
          node.id = this.flowParseRestrictedIdentifier(true, true);
          this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          } else {
            node.typeParameters = null;
          }
          node.supertype = null;
          if (this.match(14)) {
            node.supertype = this.flowParseTypeInitialiser(14);
          }
          node.impltype = null;
          if (!declare) {
            node.impltype = this.flowParseTypeInitialiser(29);
          }
          this.semicolon();
          return this.finishNode(node, "OpaqueType");
        }
        flowParseTypeParameter(requireDefault = false) {
          const nodeStartLoc = this.state.startLoc;
          const node = this.startNode();
          const variance = this.flowParseVariance();
          const ident = this.flowParseTypeAnnotatableIdentifier();
          node.name = ident.name;
          node.variance = variance;
          node.bound = ident.typeAnnotation;
          if (this.match(29)) {
            this.eat(29);
            node.default = this.flowParseType();
          } else {
            if (requireDefault) {
              this.raise(FlowErrors.MissingTypeParamDefault, {
                at: nodeStartLoc
              });
            }
          }
          return this.finishNode(node, "TypeParameter");
        }
        flowParseTypeParameterDeclaration() {
          const oldInType = this.state.inType;
          const node = this.startNode();
          node.params = [];
          this.state.inType = true;
          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }
          let defaultRequired = false;
          do {
            const typeParameter = this.flowParseTypeParameter(defaultRequired);
            node.params.push(typeParameter);
            if (typeParameter.default) {
              defaultRequired = true;
            }
            if (!this.match(48)) {
              this.expect(12);
            }
          } while (!this.match(48));
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterDeclaration");
        }
        flowParseTypeParameterInstantiation() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseTypeParameterInstantiationCallOrNew() {
          const node = this.startNode();
          const oldInType = this.state.inType;
          node.params = [];
          this.state.inType = true;
          this.expect(47);
          while (!this.match(48)) {
            node.params.push(this.flowParseTypeOrImplicitInstantiation());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.expect(48);
          this.state.inType = oldInType;
          return this.finishNode(node, "TypeParameterInstantiation");
        }
        flowParseInterfaceType() {
          const node = this.startNode();
          this.expectContextual(125);
          node.extends = [];
          if (this.eat(81)) {
            do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          node.body = this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: false,
            allowProto: false,
            allowInexact: false
          });
          return this.finishNode(node, "InterfaceTypeAnnotation");
        }
        flowParseObjectPropertyKey() {
          return this.match(130) || this.match(129) ? super.parseExprAtom() : this.parseIdentifier(true);
        }
        flowParseObjectTypeIndexer(node, isStatic, variance) {
          node.static = isStatic;
          if (this.lookahead().type === 14) {
            node.id = this.flowParseObjectPropertyKey();
            node.key = this.flowParseTypeInitialiser();
          } else {
            node.id = null;
            node.key = this.flowParseType();
          }
          this.expect(3);
          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
          return this.finishNode(node, "ObjectTypeIndexer");
        }
        flowParseObjectTypeInternalSlot(node, isStatic) {
          node.static = isStatic;
          node.id = this.flowParseObjectPropertyKey();
          this.expect(3);
          this.expect(3);
          if (this.match(47) || this.match(10)) {
            node.method = true;
            node.optional = false;
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
          } else {
            node.method = false;
            if (this.eat(17)) {
              node.optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
          }
          return this.finishNode(node, "ObjectTypeInternalSlot");
        }
        flowParseObjectTypeMethodish(node) {
          node.params = [];
          node.rest = null;
          node.typeParameters = null;
          node.this = null;
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          this.expect(10);
          if (this.match(78)) {
            node.this = this.flowParseFunctionTypeParam(true);
            node.this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            node.params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            node.rest = this.flowParseFunctionTypeParam(false);
          }
          this.expect(11);
          node.returnType = this.flowParseTypeInitialiser();
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        flowParseObjectTypeCallProperty(node, isStatic) {
          const valueNode = this.startNode();
          node.static = isStatic;
          node.value = this.flowParseObjectTypeMethodish(valueNode);
          return this.finishNode(node, "ObjectTypeCallProperty");
        }
        flowParseObjectType({
          allowStatic,
          allowExact,
          allowSpread,
          allowProto,
          allowInexact
        }) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const nodeStart = this.startNode();
          nodeStart.callProperties = [];
          nodeStart.properties = [];
          nodeStart.indexers = [];
          nodeStart.internalSlots = [];
          let endDelim;
          let exact;
          let inexact = false;
          if (allowExact && this.match(6)) {
            this.expect(6);
            endDelim = 9;
            exact = true;
          } else {
            this.expect(5);
            endDelim = 8;
            exact = false;
          }
          nodeStart.exact = exact;
          while (!this.match(endDelim)) {
            let isStatic = false;
            let protoStartLoc = null;
            let inexactStartLoc = null;
            const node = this.startNode();
            if (allowProto && this.isContextual(115)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                protoStartLoc = this.state.startLoc;
                allowStatic = false;
              }
            }
            if (allowStatic && this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (lookahead.type !== 14 && lookahead.type !== 17) {
                this.next();
                isStatic = true;
              }
            }
            const variance = this.flowParseVariance();
            if (this.eat(0)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (this.eat(0)) {
                if (variance) {
                  this.unexpected(variance.loc.start);
                }
                nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
              } else {
                nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              }
            } else if (this.match(10) || this.match(47)) {
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
            } else {
              let kind = "init";
              if (this.isContextual(98) || this.isContextual(103)) {
                const lookahead = this.lookahead();
                if (tokenIsLiteralPropertyName(lookahead.type)) {
                  kind = this.state.value;
                  this.next();
                }
              }
              const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
              if (propOrInexact === null) {
                inexact = true;
                inexactStartLoc = this.state.lastTokStartLoc;
              } else {
                nodeStart.properties.push(propOrInexact);
              }
            }
            this.flowObjectTypeSemicolon();
            if (inexactStartLoc && !this.match(8) && !this.match(9)) {
              this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                at: inexactStartLoc
              });
            }
          }
          this.expect(endDelim);
          if (allowSpread) {
            nodeStart.inexact = inexact;
          }
          const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
          this.state.inType = oldInType;
          return out;
        }
        flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
          if (this.eat(21)) {
            const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
            if (isInexactToken) {
              if (!allowSpread) {
                this.raise(FlowErrors.InexactInsideNonObject, {
                  at: this.state.lastTokStartLoc
                });
              } else if (!allowInexact) {
                this.raise(FlowErrors.InexactInsideExact, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (variance) {
                this.raise(FlowErrors.InexactVariance, {
                  at: variance
                });
              }
              return null;
            }
            if (!allowSpread) {
              this.raise(FlowErrors.UnexpectedSpreadType, {
                at: this.state.lastTokStartLoc
              });
            }
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.SpreadVariance, {
                at: variance
              });
            }
            node.argument = this.flowParseType();
            return this.finishNode(node, "ObjectTypeSpreadProperty");
          } else {
            node.key = this.flowParseObjectPropertyKey();
            node.static = isStatic;
            node.proto = protoStartLoc != null;
            node.kind = kind;
            let optional = false;
            if (this.match(47) || this.match(10)) {
              node.method = true;
              if (protoStartLoc != null) {
                this.unexpected(protoStartLoc);
              }
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
              if (kind === "get" || kind === "set") {
                this.flowCheckGetterSetterParams(node);
              }
              if (!allowSpread && node.key.name === "constructor" && node.value.this) {
                this.raise(FlowErrors.ThisParamBannedInConstructor, {
                  at: node.value.this
                });
              }
            } else {
              if (kind !== "init") this.unexpected();
              node.method = false;
              if (this.eat(17)) {
                optional = true;
              }
              node.value = this.flowParseTypeInitialiser();
              node.variance = variance;
            }
            node.optional = optional;
            return this.finishNode(node, "ObjectTypeProperty");
          }
        }
        flowCheckGetterSetterParams(property) {
          const paramCount = property.kind === "get" ? 0 : 1;
          const length = property.value.params.length + (property.value.rest ? 1 : 0);
          if (property.value.this) {
            this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
              at: property.value.this
            });
          }
          if (length !== paramCount) {
            this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: property
            });
          }
          if (property.kind === "set" && property.value.rest) {
            this.raise(Errors.BadSetterRestParameter, {
              at: property
            });
          }
        }
        flowObjectTypeSemicolon() {
          if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
            this.unexpected();
          }
        }
        flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
          startPos = startPos || this.state.start;
          startLoc = startLoc || this.state.startLoc;
          let node = id || this.flowParseRestrictedIdentifier(true);
          while (this.eat(16)) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.qualification = node;
            node2.id = this.flowParseRestrictedIdentifier(true);
            node = this.finishNode(node2, "QualifiedTypeIdentifier");
          }
          return node;
        }
        flowParseGenericType(startPos, startLoc, id) {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = null;
          node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          }
          return this.finishNode(node, "GenericTypeAnnotation");
        }
        flowParseTypeofType() {
          const node = this.startNode();
          this.expect(87);
          node.argument = this.flowParsePrimaryType();
          return this.finishNode(node, "TypeofTypeAnnotation");
        }
        flowParseTupleType() {
          const node = this.startNode();
          node.types = [];
          this.expect(0);
          while (this.state.pos < this.length && !this.match(3)) {
            node.types.push(this.flowParseType());
            if (this.match(3)) break;
            this.expect(12);
          }
          this.expect(3);
          return this.finishNode(node, "TupleTypeAnnotation");
        }
        flowParseFunctionTypeParam(first) {
          let name = null;
          let optional = false;
          let typeAnnotation = null;
          const node = this.startNode();
          const lh = this.lookahead();
          const isThis = this.state.type === 78;
          if (lh.type === 14 || lh.type === 17) {
            if (isThis && !first) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node
              });
            }
            name = this.parseIdentifier(isThis);
            if (this.eat(17)) {
              optional = true;
              if (isThis) {
                this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                  at: node
                });
              }
            }
            typeAnnotation = this.flowParseTypeInitialiser();
          } else {
            typeAnnotation = this.flowParseType();
          }
          node.name = name;
          node.optional = optional;
          node.typeAnnotation = typeAnnotation;
          return this.finishNode(node, "FunctionTypeParam");
        }
        reinterpretTypeAsFunctionTypeParam(type) {
          const node = this.startNodeAt(type.start, type.loc.start);
          node.name = null;
          node.optional = false;
          node.typeAnnotation = type;
          return this.finishNode(node, "FunctionTypeParam");
        }
        flowParseFunctionTypeParams(params = []) {
          let rest = null;
          let _this = null;
          if (this.match(78)) {
            _this = this.flowParseFunctionTypeParam(true);
            _this.name = null;
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          while (!this.match(11) && !this.match(21)) {
            params.push(this.flowParseFunctionTypeParam(false));
            if (!this.match(11)) {
              this.expect(12);
            }
          }
          if (this.eat(21)) {
            rest = this.flowParseFunctionTypeParam(false);
          }
          return {
            params,
            rest,
            _this
          };
        }
        flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
          switch (id.name) {
            case "any":
              return this.finishNode(node, "AnyTypeAnnotation");
            case "bool":
            case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");
            case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");
            case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");
            case "number":
              return this.finishNode(node, "NumberTypeAnnotation");
            case "string":
              return this.finishNode(node, "StringTypeAnnotation");
            case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");
            default:
              this.checkNotUnderscore(id.name);
              return this.flowParseGenericType(startPos, startLoc, id);
          }
        }
        flowParsePrimaryType() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const node = this.startNode();
          let tmp;
          let type;
          let isGroupedType = false;
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          switch (this.state.type) {
            case 5:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: false,
                allowSpread: true,
                allowProto: false,
                allowInexact: true
              });
            case 6:
              return this.flowParseObjectType({
                allowStatic: false,
                allowExact: true,
                allowSpread: true,
                allowProto: false,
                allowInexact: false
              });
            case 0:
              this.state.noAnonFunctionType = false;
              type = this.flowParseTupleType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              return type;
            case 47:
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(10);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 10:
              this.next();
              if (!this.match(11) && !this.match(21)) {
                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  const token = this.lookahead().type;
                  isGroupedType = token !== 17 && token !== 14;
                } else {
                  isGroupedType = true;
                }
              }
              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                  this.expect(11);
                  return type;
                } else {
                  this.eat(12);
                }
              }
              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }
              node.params = tmp.params;
              node.rest = tmp.rest;
              node.this = tmp._this;
              this.expect(11);
              this.expect(19);
              node.returnType = this.flowParseType();
              node.typeParameters = null;
              return this.finishNode(node, "FunctionTypeAnnotation");
            case 129:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
            case 85:
            case 86:
              node.value = this.match(85);
              this.next();
              return this.finishNode(node, "BooleanLiteralTypeAnnotation");
            case 53:
              if (this.state.value === "-") {
                this.next();
                if (this.match(130)) {
                  return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                }
                if (this.match(131)) {
                  return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                }
                throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                  at: this.state.startLoc
                });
              }
              throw this.unexpected();
            case 130:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
            case 131:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
            case 88:
              this.next();
              return this.finishNode(node, "VoidTypeAnnotation");
            case 84:
              this.next();
              return this.finishNode(node, "NullLiteralTypeAnnotation");
            case 78:
              this.next();
              return this.finishNode(node, "ThisTypeAnnotation");
            case 55:
              this.next();
              return this.finishNode(node, "ExistsTypeAnnotation");
            case 87:
              return this.flowParseTypeofType();
            default:
              if (tokenIsKeyword(this.state.type)) {
                const label = tokenLabelName(this.state.type);
                this.next();
                return super.createIdentifier(node, label);
              } else if (tokenIsIdentifier(this.state.type)) {
                if (this.isContextual(125)) {
                  return this.flowParseInterfaceType();
                }
                return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
              }
          }
          throw this.unexpected();
        }
        flowParsePostfixType() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let type = this.flowParsePrimaryType();
          let seenOptionalIndexedAccess = false;
          while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
            const node = this.startNodeAt(startPos, startLoc);
            const optional = this.eat(18);
            seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
            this.expect(0);
            if (!optional && this.match(3)) {
              node.elementType = type;
              this.next();
              type = this.finishNode(node, "ArrayTypeAnnotation");
            } else {
              node.objectType = type;
              node.indexType = this.flowParseType();
              this.expect(3);
              if (seenOptionalIndexedAccess) {
                node.optional = optional;
                type = this.finishNode(node, "OptionalIndexedAccessType");
              } else {
                type = this.finishNode(node, "IndexedAccessType");
              }
            }
          }
          return type;
        }
        flowParsePrefixType() {
          const node = this.startNode();
          if (this.eat(17)) {
            node.typeAnnotation = this.flowParsePrefixType();
            return this.finishNode(node, "NullableTypeAnnotation");
          } else {
            return this.flowParsePostfixType();
          }
        }
        flowParseAnonFunctionWithoutParens() {
          const param = this.flowParsePrefixType();
          if (!this.state.noAnonFunctionType && this.eat(19)) {
            const node = this.startNodeAt(param.start, param.loc.start);
            node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
            node.rest = null;
            node.this = null;
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          }
          return param;
        }
        flowParseIntersectionType() {
          const node = this.startNode();
          this.eat(45);
          const type = this.flowParseAnonFunctionWithoutParens();
          node.types = [type];
          while (this.eat(45)) {
            node.types.push(this.flowParseAnonFunctionWithoutParens());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
        }
        flowParseUnionType() {
          const node = this.startNode();
          this.eat(43);
          const type = this.flowParseIntersectionType();
          node.types = [type];
          while (this.eat(43)) {
            node.types.push(this.flowParseIntersectionType());
          }
          return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
        }
        flowParseType() {
          const oldInType = this.state.inType;
          this.state.inType = true;
          const type = this.flowParseUnionType();
          this.state.inType = oldInType;
          return type;
        }
        flowParseTypeOrImplicitInstantiation() {
          if (this.state.type === 128 && this.state.value === "_") {
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            const node = this.parseIdentifier();
            return this.flowParseGenericType(startPos, startLoc, node);
          } else {
            return this.flowParseType();
          }
        }
        flowParseTypeAnnotation() {
          const node = this.startNode();
          node.typeAnnotation = this.flowParseTypeInitialiser();
          return this.finishNode(node, "TypeAnnotation");
        }
        flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
          const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
          if (this.match(14)) {
            ident.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(ident);
          }
          return ident;
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        flowParseVariance() {
          let variance = null;
          if (this.match(53)) {
            variance = this.startNode();
            if (this.state.value === "+") {
              variance.kind = "plus";
            } else {
              variance.kind = "minus";
            }
            this.next();
            return this.finishNode(variance, "Variance");
          }
          return variance;
        }
        parseFunctionBody(node, allowExpressionBody, isMethod = false) {
          if (allowExpressionBody) {
            return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          }
          return super.parseFunctionBody(node, false, isMethod);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        parseStatement(context3, topLevel) {
          if (this.state.strict && this.isContextual(125)) {
            const lookahead = this.lookahead();
            if (tokenIsKeywordOrIdentifier(lookahead.type)) {
              const node = this.startNode();
              this.next();
              return this.flowParseInterface(node);
            }
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          const stmt = super.parseStatement(context3, topLevel);
          if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
            this.flowPragma = null;
          }
          return stmt;
        }
        parseExpressionStatement(node, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                return this.flowParseDeclare(node);
              }
            } else if (tokenIsIdentifier(this.state.type)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }
          return super.parseExpressionStatement(node, expr);
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
            return !this.state.containsEsc;
          }
          return super.shouldParseExportDeclaration();
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
            return this.state.containsEsc;
          }
          return super.isExportDefaultSpecifier();
        }
        parseExportDefaultExpression() {
          if (this.shouldParseEnums() && this.isContextual(122)) {
            const node = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(node);
          }
          return super.parseExportDefaultExpression();
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (!this.match(17)) return expr;
          if (this.state.maybeInArrowParameters) {
            const nextCh = this.lookaheadCharCode();
            if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
              this.setOptionalParametersError(refExpressionErrors);
              return expr;
            }
          }
          this.expect(17);
          const state = this.state.clone();
          const originalNoArrowAt = this.state.noArrowAt;
          const node = this.startNodeAt(startPos, startLoc);
          let {
            consequent,
            failed
          } = this.tryParseConditionalConsequent();
          let [valid, invalid] = this.getArrowLikeExpressions(consequent);
          if (failed || invalid.length > 0) {
            const noArrowAt = [...originalNoArrowAt];
            if (invalid.length > 0) {
              this.state = state;
              this.state.noArrowAt = noArrowAt;
              for (let i4 = 0; i4 < invalid.length; i4++) {
                noArrowAt.push(invalid[i4].start);
              }
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
              [valid, invalid] = this.getArrowLikeExpressions(consequent);
            }
            if (failed && valid.length > 1) {
              this.raise(FlowErrors.AmbiguousConditionalArrow, {
                at: state.startLoc
              });
            }
            if (failed && valid.length === 1) {
              this.state = state;
              noArrowAt.push(valid[0].start);
              this.state.noArrowAt = noArrowAt;
              ({
                consequent,
                failed
              } = this.tryParseConditionalConsequent());
            }
          }
          this.getArrowLikeExpressions(consequent, true);
          this.state.noArrowAt = originalNoArrowAt;
          this.expect(14);
          node.test = expr;
          node.consequent = consequent;
          node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
          return this.finishNode(node, "ConditionalExpression");
        }
        tryParseConditionalConsequent() {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          const consequent = this.parseMaybeAssignAllowIn();
          const failed = !this.match(14);
          this.state.noArrowParamsConversionAt.pop();
          return {
            consequent,
            failed
          };
        }
        getArrowLikeExpressions(node, disallowInvalid) {
          const stack = [node];
          const arrows = [];
          while (stack.length !== 0) {
            const node2 = stack.pop();
            if (node2.type === "ArrowFunctionExpression") {
              if (node2.typeParameters || !node2.returnType) {
                this.finishArrowValidation(node2);
              } else {
                arrows.push(node2);
              }
              stack.push(node2.body);
            } else if (node2.type === "ConditionalExpression") {
              stack.push(node2.consequent);
              stack.push(node2.alternate);
            }
          }
          if (disallowInvalid) {
            arrows.forEach((node2) => this.finishArrowValidation(node2));
            return [arrows, []];
          }
          return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
        }
        finishArrowValidation(node) {
          var _node$extra;
          this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          super.checkParams(node, false, true);
          this.scope.exit();
        }
        forwardNoArrowParamsConversionAt(node, parse4) {
          let result;
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            result = parse4();
            this.state.noArrowParamsConversionAt.pop();
          } else {
            result = parse4();
          }
          return result;
        }
        parseParenItem(node, startPos, startLoc) {
          node = super.parseParenItem(node, startPos, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }
          return node;
        }
        assertModuleNodeAllowed(node) {
          if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
            return;
          }
          super.assertModuleNodeAllowed(node);
        }
        parseExport(node) {
          const decl = super.parseExport(node);
          if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
            decl.exportKind = decl.exportKind || "value";
          }
          return decl;
        }
        parseExportDeclaration(node) {
          if (this.isContextual(126)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            if (this.match(5)) {
              node.specifiers = this.parseExportSpecifiers(true);
              super.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual(127)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseOpaqueType(declarationNode, false);
          } else if (this.isContextual(125)) {
            node.exportKind = "type";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseInterface(declarationNode);
          } else if (this.shouldParseEnums() && this.isContextual(122)) {
            node.exportKind = "value";
            const declarationNode = this.startNode();
            this.next();
            return this.flowParseEnumDeclaration(declarationNode);
          } else {
            return super.parseExportDeclaration(node);
          }
        }
        eatExportStar(node) {
          if (super.eatExportStar(node)) return true;
          if (this.isContextual(126) && this.lookahead().type === 55) {
            node.exportKind = "type";
            this.next();
            this.next();
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          const {
            startLoc
          } = this.state;
          const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
          if (hasNamespace && node.exportKind === "type") {
            this.unexpected(startLoc);
          }
          return hasNamespace;
        }
        parseClassId(node, isStatement, optionalId) {
          super.parseClassId(node, isStatement, optionalId);
          if (this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        }
        parseClassMember(classBody, member, state) {
          const {
            startLoc
          } = this.state;
          if (this.isContextual(121)) {
            if (super.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            member.declare = true;
          }
          super.parseClassMember(classBody, member, state);
          if (member.declare) {
            if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(FlowErrors.DeclareClassElement, {
                at: startLoc
              });
            } else if (member.value) {
              this.raise(FlowErrors.DeclareClassFieldInitializer, {
                at: member.value
              });
            }
          }
        }
        isIterator(word) {
          return word === "iterator" || word === "asyncIterator";
        }
        readIterator() {
          const word = super.readWord1();
          const fullWord = "@@" + word;
          if (!this.isIterator(word) || !this.state.inType) {
            this.raise(Errors.InvalidIdentifier, {
              at: this.state.curPosition(),
              identifierName: fullWord
            });
          }
          this.finishToken(128, fullWord);
        }
        getTokenFromCode(code) {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (code === 123 && next2 === 124) {
            return this.finishOp(6, 2);
          } else if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(code === 62 ? 48 : 47, 1);
          } else if (this.state.inType && code === 63) {
            if (next2 === 46) {
              return this.finishOp(18, 2);
            }
            return this.finishOp(17, 1);
          } else if (isIteratorStart(code, next2, this.input.charCodeAt(this.state.pos + 2))) {
            this.state.pos += 2;
            return this.readIterator();
          } else {
            return super.getTokenFromCode(code);
          }
        }
        isAssignable(node, isBinding) {
          if (node.type === "TypeCastExpression") {
            return this.isAssignable(node.expression, isBinding);
          } else {
            return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
            node.left = this.typeCastToParameter(node.left);
          }
          super.toAssignable(node, isLHS);
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i4 = 0; i4 < exprList.length; i4++) {
            const expr = exprList[i4];
            if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
              exprList[i4] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          for (let i4 = 0; i4 < exprList.length; i4++) {
            var _expr$extra;
            const expr = exprList[i4];
            if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
              this.raise(FlowErrors.TypeCastInPattern, {
                at: expr.typeAnnotation
              });
            }
          }
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (canBePattern && !this.state.maybeInArrowParameters) {
            this.toReferencedList(node.elements);
          }
          return node;
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
        }
        parseClassProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (this.match(14)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return super.parseClassPrivateProperty(node);
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(14) || super.isClassProperty();
        }
        isNonstaticConstructor(method) {
          return !this.match(14) && super.isNonstaticConstructor(method);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          if (method.params && isConstructor) {
            const params = method.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
            const params = method.value.params;
            if (params.length > 0 && this.isThisParam(params[0])) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          }
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          if (method.variance) {
            this.unexpected(method.variance.loc.start);
          }
          delete method.variance;
          if (this.match(47)) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && this.match(47)) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }
          if (this.isContextual(110)) {
            this.next();
            const implemented = node.implements = [];
            do {
              const node2 = this.startNode();
              node2.id = this.flowParseRestrictedIdentifier(true);
              if (this.match(47)) {
                node2.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                node2.typeParameters = null;
              }
              implemented.push(this.finishNode(node2, "ClassImplements"));
            } while (this.eat(12));
          }
        }
        checkGetterSetterParams(method) {
          super.checkGetterSetterParams(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length > 0) {
            const param = params[0];
            if (this.isThisParam(param) && method.kind === "get") {
              this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                at: param
              });
            } else if (this.isThisParam(param)) {
              this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                at: param
              });
            }
          }
        }
        parsePropertyNamePrefixOperator(node) {
          node.variance = this.flowParseVariance();
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          if (prop.variance) {
            this.unexpected(prop.variance.loc.start);
          }
          delete prop.variance;
          let typeParameters;
          if (this.match(47) && !isAccessor) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(10)) this.unexpected();
          }
          const result = super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
          if (typeParameters) {
            (result.value || result).typeParameters = typeParameters;
          }
          return result;
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier") {
              this.raise(FlowErrors.PatternIsOptional, {
                at: param
              });
            }
            if (this.isThisParam(param)) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          if (this.match(14)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamAnnotationRequired, {
              at: param
            });
          }
          if (this.match(29) && this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamNoDefault, {
              at: param
            });
          }
          this.resetEndLocation(param);
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          const node = super.parseMaybeDefault(startPos, startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(FlowErrors.TypeBeforeInitializer, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        shouldParseDefaultImport(node) {
          if (!hasTypeImportKind(node)) {
            return super.shouldParseDefaultImport(node);
          }
          return isMaybeDefaultImport(this.state.type);
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        maybeParseDefaultImportSpecifier(node) {
          node.importKind = "value";
          let kind = null;
          if (this.match(87)) {
            kind = "typeof";
          } else if (this.isContextual(126)) {
            kind = "type";
          }
          if (kind) {
            const lh = this.lookahead();
            const {
              type
            } = lh;
            if (kind === "type" && type === 55) {
              this.unexpected(null, lh.type);
            }
            if (isMaybeDefaultImport(type) || type === 5 || type === 55) {
              this.next();
              node.importKind = kind;
            }
          }
          return super.maybeParseDefaultImportSpecifier(node);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          const firstIdent = specifier.imported;
          let specifierTypeKind = null;
          if (firstIdent.type === "Identifier") {
            if (firstIdent.name === "type") {
              specifierTypeKind = "type";
            } else if (firstIdent.name === "typeof") {
              specifierTypeKind = "typeof";
            }
          }
          let isBinding = false;
          if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
            const as_ident = this.parseIdentifier(true);
            if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = cloneIdentifier(as_ident);
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else {
            if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
              specifier.imported = this.parseIdentifier(true);
              specifier.importKind = specifierTypeKind;
            } else {
              if (importedIsString) {
                throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: firstIdent.value
                });
              }
              specifier.imported = firstIdent;
              specifier.importKind = null;
            }
            if (this.eatContextual(93)) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = cloneIdentifier(specifier.imported);
            }
          }
          const specifierIsTypeImport = hasTypeImportKind(specifier);
          if (isInTypeOnlyImport && specifierIsTypeImport) {
            this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
              at: specifier
            });
          }
          if (isInTypeOnlyImport || specifierIsTypeImport) {
            this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
          }
          if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
            this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseFunctionParams(node, allowModifiers) {
          const kind = node.kind;
          if (kind !== "get" && kind !== "set" && this.match(47)) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          super.parseFunctionParams(node, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (this.match(14)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx;
          let state = null;
          let jsx2;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error) return jsx2.node;
            const {
              context: context3
            } = this.state;
            const currentContext = context3[context3.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context3.pop();
            }
          }
          if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
            var _jsx2, _jsx3;
            state = state || this.state.clone();
            let typeParameters;
            const arrow = this.tryParse((abort) => {
              var _arrowExpression$extr;
              typeParameters = this.flowParseTypeParameterDeclaration();
              const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                this.resetStartLocationFromNode(result, typeParameters);
                return result;
              });
              if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
              const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
              if (expr.type !== "ArrowFunctionExpression") abort();
              expr.typeParameters = typeParameters;
              this.resetStartLocationFromNode(expr, typeParameters);
              return arrowExpression2;
            }, state);
            let arrowExpression = null;
            if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
              if (!arrow.error && !arrow.aborted) {
                if (arrow.node.async) {
                  this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                    at: typeParameters
                  });
                }
                return arrow.node;
              }
              arrowExpression = arrow.node;
            }
            if ((_jsx2 = jsx2) != null && _jsx2.node) {
              this.state = jsx2.failState;
              return jsx2.node;
            }
            if (arrowExpression) {
              this.state = arrow.failState;
              return arrowExpression;
            }
            if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
            if (arrow.thrown) throw arrow.error;
            throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
              at: typeParameters
            });
          }
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse(() => {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.canInsertSemicolon()) this.unexpected();
              if (!this.match(19)) this.unexpected();
              return typeNode;
            });
            if (result.thrown) return null;
            if (result.error) this.state = result.failState;
            node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
          }
          return super.parseArrow(node);
        }
        shouldParseArrow(params) {
          return this.match(14) || super.shouldParseArrow(params);
        }
        setArrowFunctionParameters(node, params) {
          if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            node.params = params;
          } else {
            super.setArrowFunctionParameters(node, params);
          }
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
            return;
          }
          for (let i4 = 0; i4 < node.params.length; i4++) {
            if (this.isThisParam(node.params[i4]) && i4 > 0) {
              this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node.params[i4]
              });
            }
          }
          return super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
        }
        parseSubscripts(base, startPos, startLoc, noCalls) {
          if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
            this.next();
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = super.parseCallExpressionArguments(11, false);
            base = this.finishNode(node, "CallExpression");
          } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
            const state = this.state.clone();
            const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
            if (!arrow.error && !arrow.aborted) return arrow.node;
            const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
            if (result.node && !result.error) return result.node;
            if (arrow.node) {
              this.state = arrow.failState;
              return arrow.node;
            }
            if (result.node) {
              this.state = result.failState;
              return result.node;
            }
            throw arrow.error || result.error;
          }
          return super.parseSubscripts(base, startPos, startLoc, noCalls);
        }
        parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
          if (this.match(18) && this.isLookaheadToken_lt()) {
            subscriptState.optionalChainMember = true;
            if (noCalls) {
              subscriptState.stop = true;
              return base;
            }
            this.next();
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.typeArguments = this.flowParseTypeParameterInstantiation();
            this.expect(10);
            node.arguments = this.parseCallExpressionArguments(11, false);
            node.optional = true;
            return this.finishCallExpression(node, true);
          } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            const result = this.tryParse(() => {
              node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
              this.expect(10);
              node.arguments = super.parseCallExpressionArguments(11, false);
              if (subscriptState.optionalChainMember) {
                node.optional = false;
              }
              return this.finishCallExpression(node, subscriptState.optionalChainMember);
            });
            if (result.node) {
              if (result.error) this.state = result.failState;
              return result.node;
            }
          }
          return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
        }
        parseNewCallee(node) {
          super.parseNewCallee(node);
          let targs = null;
          if (this.shouldParseTypes() && this.match(47)) {
            targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
          }
          node.typeArguments = targs;
        }
        parseAsyncArrowWithTypeParameters(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          this.parseFunctionParams(node);
          if (!this.parseArrow(node)) return;
          return super.parseArrowExpression(node, void 0, true);
        }
        readToken_mult_modulo(code) {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (code === 42 && next2 === 47 && this.state.hasFlowComment) {
            this.state.hasFlowComment = false;
            this.state.pos += 2;
            this.nextToken();
            return;
          }
          super.readToken_mult_modulo(code);
        }
        readToken_pipe_amp(code) {
          const next2 = this.input.charCodeAt(this.state.pos + 1);
          if (code === 124 && next2 === 125) {
            this.finishOp(9, 2);
            return;
          }
          super.readToken_pipe_amp(code);
        }
        parseTopLevel(file, program) {
          const fileNode = super.parseTopLevel(file, program);
          if (this.state.hasFlowComment) {
            this.raise(FlowErrors.UnterminatedFlowComment, {
              at: this.state.curPosition()
            });
          }
          return fileNode;
        }
        skipBlockComment() {
          if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
            if (this.state.hasFlowComment) {
              throw this.raise(FlowErrors.NestedFlowComment, {
                at: this.state.startLoc
              });
            }
            this.hasFlowCommentCompletion();
            const commentSkip = this.skipFlowComment();
            if (commentSkip) {
              this.state.pos += commentSkip;
              this.state.hasFlowComment = true;
            }
            return;
          }
          if (this.state.hasFlowComment) {
            const end = this.input.indexOf("*-/", this.state.pos + 2);
            if (end === -1) {
              throw this.raise(Errors.UnterminatedComment, {
                at: this.state.curPosition()
              });
            }
            this.state.pos = end + 2 + 3;
            return;
          }
          return super.skipBlockComment();
        }
        skipFlowComment() {
          const {
            pos
          } = this.state;
          let shiftToFirstNonWhiteSpace = 2;
          while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
            shiftToFirstNonWhiteSpace++;
          }
          const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
          const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
          if (ch2 === 58 && ch3 === 58) {
            return shiftToFirstNonWhiteSpace + 2;
          }
          if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
            return shiftToFirstNonWhiteSpace + 12;
          }
          if (ch2 === 58 && ch3 !== 58) {
            return shiftToFirstNonWhiteSpace;
          }
          return false;
        }
        hasFlowCommentCompletion() {
          const end = this.input.indexOf("*/", this.state.pos);
          if (end === -1) {
            throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
        }
        flowEnumErrorBooleanMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
            at: loc,
            memberName,
            enumName
          });
        }
        flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
          return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({
            at: loc
          }, enumContext));
        }
        flowEnumErrorNumberMemberNotInitialized(loc, {
          enumName,
          memberName
        }) {
          this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
            at: loc,
            enumName,
            memberName
          });
        }
        flowEnumErrorStringMemberInconsistentlyInitailized(node, {
          enumName
        }) {
          this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
            at: node,
            enumName
          });
        }
        flowEnumMemberInit() {
          const startLoc = this.state.startLoc;
          const endOfInit = () => this.match(12) || this.match(8);
          switch (this.state.type) {
            case 130: {
              const literal = this.parseNumericLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "number",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 129: {
              const literal = this.parseStringLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "string",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            case 85:
            case 86: {
              const literal = this.parseBooleanLiteral(this.match(85));
              if (endOfInit()) {
                return {
                  type: "boolean",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
            default:
              return {
                type: "invalid",
                loc: startLoc
              };
          }
        }
        flowEnumMemberRaw() {
          const loc = this.state.startLoc;
          const id = this.parseIdentifier(true);
          const init5 = this.eat(29) ? this.flowEnumMemberInit() : {
            type: "none",
            loc
          };
          return {
            id,
            init: init5
          };
        }
        flowEnumCheckExplicitTypeMismatch(loc, context3, expectedType) {
          const {
            explicitType
          } = context3;
          if (explicitType === null) {
            return;
          }
          if (explicitType !== expectedType) {
            this.flowEnumErrorInvalidMemberInitializer(loc, context3);
          }
        }
        flowEnumMembers({
          enumName,
          explicitType
        }) {
          const seenNames = /* @__PURE__ */ new Set();
          const members = {
            booleanMembers: [],
            numberMembers: [],
            stringMembers: [],
            defaultedMembers: []
          };
          let hasUnknownMembers = false;
          while (!this.match(8)) {
            if (this.eat(21)) {
              hasUnknownMembers = true;
              break;
            }
            const memberNode = this.startNode();
            const {
              id,
              init: init5
            } = this.flowEnumMemberRaw();
            const memberName = id.name;
            if (memberName === "") {
              continue;
            }
            if (/^[a-z]/.test(memberName)) {
              this.raise(FlowErrors.EnumInvalidMemberName, {
                at: id,
                memberName,
                suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                enumName
              });
            }
            if (seenNames.has(memberName)) {
              this.raise(FlowErrors.EnumDuplicateMemberName, {
                at: id,
                memberName,
                enumName
              });
            }
            seenNames.add(memberName);
            const context3 = {
              enumName,
              explicitType,
              memberName
            };
            memberNode.id = id;
            switch (init5.type) {
              case "boolean": {
                this.flowEnumCheckExplicitTypeMismatch(init5.loc, context3, "boolean");
                memberNode.init = init5.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }
              case "number": {
                this.flowEnumCheckExplicitTypeMismatch(init5.loc, context3, "number");
                memberNode.init = init5.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }
              case "string": {
                this.flowEnumCheckExplicitTypeMismatch(init5.loc, context3, "string");
                memberNode.init = init5.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }
              case "invalid": {
                throw this.flowEnumErrorInvalidMemberInitializer(init5.loc, context3);
              }
              case "none": {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init5.loc, context3);
                    break;
                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init5.loc, context3);
                    break;
                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
            }
            if (!this.match(8)) {
              this.expect(12);
            }
          }
          return {
            members,
            hasUnknownMembers
          };
        }
        flowEnumStringMembers(initializedMembers, defaultedMembers, {
          enumName
        }) {
          if (initializedMembers.length === 0) {
            return defaultedMembers;
          } else if (defaultedMembers.length === 0) {
            return initializedMembers;
          } else if (defaultedMembers.length > initializedMembers.length) {
            for (const member of initializedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return defaultedMembers;
          } else {
            for (const member of defaultedMembers) {
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
            }
            return initializedMembers;
          }
        }
        flowEnumParseExplicitType({
          enumName
        }) {
          if (!this.eatContextual(101)) return null;
          if (!tokenIsIdentifier(this.state.type)) {
            throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
              at: this.state.startLoc,
              enumName
            });
          }
          const {
            value
          } = this.state;
          this.next();
          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.raise(FlowErrors.EnumInvalidExplicitType, {
              at: this.state.startLoc,
              enumName,
              invalidEnumType: value
            });
          }
          return value;
        }
        flowEnumBody(node, id) {
          const enumName = id.name;
          const nameLoc = id.loc.start;
          const explicitType = this.flowEnumParseExplicitType({
            enumName
          });
          this.expect(5);
          const {
            members,
            hasUnknownMembers
          } = this.flowEnumMembers({
            enumName,
            explicitType
          });
          node.hasUnknownMembers = hasUnknownMembers;
          switch (explicitType) {
            case "boolean":
              node.explicitType = true;
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            case "number":
              node.explicitType = true;
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            case "string":
              node.explicitType = true;
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            case "symbol":
              node.members = members.defaultedMembers;
              this.expect(8);
              return this.finishNode(node, "EnumSymbolBody");
            default: {
              const empty = () => {
                node.members = [];
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              };
              node.explicitType = false;
              const boolsLen = members.booleanMembers.length;
              const numsLen = members.numberMembers.length;
              const strsLen = members.stringMembers.length;
              const defaultedLen = members.defaultedMembers.length;
              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName
                });
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.booleanMembers;
                this.expect(8);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (const member of members.defaultedMembers) {
                  this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                    enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.numberMembers;
                this.expect(8);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.raise(FlowErrors.EnumInconsistentMemberValues, {
                  at: nameLoc,
                  enumName
                });
                return empty();
              }
            }
          }
        }
        flowParseEnumDeclaration(node) {
          const id = this.parseIdentifier();
          node.id = id;
          node.body = this.flowEnumBody(this.startNode(), id);
          return this.finishNode(node, "EnumDeclaration");
        }
        isLookaheadToken_lt() {
          const next2 = this.nextTokenStart();
          if (this.input.charCodeAt(next2) === 60) {
            const afterNext = this.input.charCodeAt(next2 + 1);
            return afterNext !== 60 && afterNext !== 61;
          }
          return false;
        }
        maybeUnwrapTypeCastExpression(node) {
          return node.type === "TypeCastExpression" ? node.expression : node;
        }
      };
      var entities = {
        __proto__: null,
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
      };
      var JsxErrors = ParseErrorEnum`jsx`({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
        MissingClosingTagElement: ({
          openingTagName
        }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
        UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
        UnexpectedToken: ({
          unexpected,
          HTMLEntity
        }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
        UnterminatedJsxContent: "Unterminated JSX contents.",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
      });
      function isFragment(object) {
        return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
      }
      function getQualifiedJSXName(object) {
        if (object.type === "JSXIdentifier") {
          return object.name;
        }
        if (object.type === "JSXNamespacedName") {
          return object.namespace.name + ":" + object.name.name;
        }
        if (object.type === "JSXMemberExpression") {
          return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
        }
        throw new Error("Node had unexpected type: " + object.type);
      }
      var jsx = (superClass) => class JSXParserMixin extends superClass {
        jsxReadToken() {
          let out = "";
          let chunkStart = this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(JsxErrors.UnterminatedJsxContent, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.state.pos === this.state.start) {
                  if (ch === 60 && this.state.canStartJSXElement) {
                    ++this.state.pos;
                    return this.finishToken(138);
                  }
                  return super.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.state.pos);
                return this.finishToken(137, out);
              case 38:
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadEntity();
                chunkStart = this.state.pos;
                break;
              case 62:
              case 125:
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.state.pos);
                  out += this.jsxReadNewLine(true);
                  chunkStart = this.state.pos;
                } else {
                  ++this.state.pos;
                }
            }
          }
        }
        jsxReadNewLine(normalizeCRLF) {
          const ch = this.input.charCodeAt(this.state.pos);
          let out;
          ++this.state.pos;
          if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          return out;
        }
        jsxReadString(quote) {
          let out = "";
          let chunkStart = ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length) {
              throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
            }
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote) break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(false);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos++);
          return this.finishToken(129, out);
        }
        jsxReadEntity() {
          const startPos = ++this.state.pos;
          if (this.codePointAtPos(this.state.pos) === 35) {
            ++this.state.pos;
            let radix = 10;
            if (this.codePointAtPos(this.state.pos) === 120) {
              radix = 16;
              ++this.state.pos;
            }
            const codePoint = this.readInt(radix, void 0, false, "bail");
            if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
              ++this.state.pos;
              return String.fromCodePoint(codePoint);
            }
          } else {
            let count = 0;
            let semi = false;
            while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {
              ++this.state.pos;
            }
            if (semi) {
              const desc = this.input.slice(startPos, this.state.pos);
              const entity = entities[desc];
              ++this.state.pos;
              if (entity) {
                return entity;
              }
            }
          }
          this.state.pos = startPos;
          return "&";
        }
        jsxReadWord() {
          let ch;
          const start = this.state.pos;
          do {
            ch = this.input.charCodeAt(++this.state.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(136, this.input.slice(start, this.state.pos));
        }
        jsxParseIdentifier() {
          const node = this.startNode();
          if (this.match(136)) {
            node.name = this.state.value;
          } else if (tokenIsKeyword(this.state.type)) {
            node.name = tokenLabelName(this.state.type);
          } else {
            this.unexpected();
          }
          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
        jsxParseNamespacedName() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const name = this.jsxParseIdentifier();
          if (!this.eat(14)) return name;
          const node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsxParseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
        jsxParseElementName() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let node = this.jsxParseNamespacedName();
          if (node.type === "JSXNamespacedName") {
            return node;
          }
          while (this.eat(16)) {
            const newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsxParseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        jsxParseAttributeValue() {
          let node;
          switch (this.state.type) {
            case 5:
              node = this.startNode();
              this.setContext(types.brace);
              this.next();
              node = this.jsxParseExpressionContainer(node, types.j_oTag);
              if (node.expression.type === "JSXEmptyExpression") {
                this.raise(JsxErrors.AttributeIsEmpty, {
                  at: node
                });
              }
              return node;
            case 138:
            case 129:
              return this.parseExprAtom();
            default:
              throw this.raise(JsxErrors.UnsupportedJsxValue, {
                at: this.state.startLoc
              });
          }
        }
        jsxParseEmptyExpression() {
          const node = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
        }
        jsxParseSpreadChild(node) {
          this.next();
          node.expression = this.parseExpression();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadChild");
        }
        jsxParseExpressionContainer(node, previousContext) {
          if (this.match(8)) {
            node.expression = this.jsxParseEmptyExpression();
          } else {
            const expression = this.parseExpression();
            node.expression = expression;
          }
          this.setContext(previousContext);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXExpressionContainer");
        }
        jsxParseAttribute() {
          const node = this.startNode();
          if (this.match(5)) {
            this.setContext(types.brace);
            this.next();
            this.expect(21);
            node.argument = this.parseMaybeAssignAllowIn();
            this.setContext(types.j_oTag);
            this.state.canStartJSXElement = true;
            this.expect(8);
            return this.finishNode(node, "JSXSpreadAttribute");
          }
          node.name = this.jsxParseNamespacedName();
          node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
        jsxParseOpeningElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          if (this.eat(139)) {
            return this.finishNode(node, "JSXOpeningFragment");
          }
          node.name = this.jsxParseElementName();
          return this.jsxParseOpeningElementAfterName(node);
        }
        jsxParseOpeningElementAfterName(node) {
          const attributes = [];
          while (!this.match(56) && !this.match(139)) {
            attributes.push(this.jsxParseAttribute());
          }
          node.attributes = attributes;
          node.selfClosing = this.eat(56);
          this.expect(139);
          return this.finishNode(node, "JSXOpeningElement");
        }
        jsxParseClosingElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          if (this.eat(139)) {
            return this.finishNode(node, "JSXClosingFragment");
          }
          node.name = this.jsxParseElementName();
          this.expect(139);
          return this.finishNode(node, "JSXClosingElement");
        }
        jsxParseElementAt(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          const children2 = [];
          const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents: for (; ; ) {
              switch (this.state.type) {
                case 138:
                  startPos = this.state.start;
                  startLoc = this.state.startLoc;
                  this.next();
                  if (this.eat(56)) {
                    closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children2.push(this.jsxParseElementAt(startPos, startLoc));
                  break;
                case 137:
                  children2.push(this.parseExprAtom());
                  break;
                case 5: {
                  const node2 = this.startNode();
                  this.setContext(types.brace);
                  this.next();
                  if (this.match(21)) {
                    children2.push(this.jsxParseSpreadChild(node2));
                  } else {
                    children2.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                  }
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
            if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
              this.raise(JsxErrors.MissingClosingTagFragment, {
                at: closingElement
              });
            } else if (!isFragment(openingElement) && isFragment(closingElement)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
              if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                this.raise(JsxErrors.MissingClosingTagElement, {
                  at: closingElement,
                  openingTagName: getQualifiedJSXName(openingElement.name)
                });
              }
            }
          }
          if (isFragment(openingElement)) {
            node.openingFragment = openingElement;
            node.closingFragment = closingElement;
          } else {
            node.openingElement = openingElement;
            node.closingElement = closingElement;
          }
          node.children = children2;
          if (this.match(47)) {
            throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
              at: this.state.startLoc
            });
          }
          return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
        }
        jsxParseElement() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          this.next();
          return this.jsxParseElementAt(startPos, startLoc);
        }
        setContext(newContext) {
          const {
            context: context3
          } = this.state;
          context3[context3.length - 1] = newContext;
        }
        parseExprAtom(refExpressionErrors) {
          if (this.match(137)) {
            return this.parseLiteral(this.state.value, "JSXText");
          } else if (this.match(138)) {
            return this.jsxParseElement();
          } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
            this.replaceToken(138);
            return this.jsxParseElement();
          } else {
            return super.parseExprAtom(refExpressionErrors);
          }
        }
        skipSpace() {
          const curContext = this.curContext();
          if (!curContext.preserveSpace) super.skipSpace();
        }
        getTokenFromCode(code) {
          const context3 = this.curContext();
          if (context3 === types.j_expr) {
            return this.jsxReadToken();
          }
          if (context3 === types.j_oTag || context3 === types.j_cTag) {
            if (isIdentifierStart(code)) {
              return this.jsxReadWord();
            }
            if (code === 62) {
              ++this.state.pos;
              return this.finishToken(139);
            }
            if ((code === 34 || code === 39) && context3 === types.j_oTag) {
              return this.jsxReadString(code);
            }
          }
          if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
            ++this.state.pos;
            return this.finishToken(138);
          }
          return super.getTokenFromCode(code);
        }
        updateContext(prevType) {
          const {
            context: context3,
            type
          } = this.state;
          if (type === 56 && prevType === 138) {
            context3.splice(-2, 2, types.j_cTag);
            this.state.canStartJSXElement = false;
          } else if (type === 138) {
            context3.push(types.j_oTag);
          } else if (type === 139) {
            const out = context3[context3.length - 1];
            if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
              context3.pop();
              this.state.canStartJSXElement = context3[context3.length - 1] === types.j_expr;
            } else {
              this.setContext(types.j_expr);
              this.state.canStartJSXElement = true;
            }
          } else {
            this.state.canStartJSXElement = tokenComesBeforeExpression(type);
          }
        }
      };
      var TypeScriptScope = class extends Scope {
        constructor(...args) {
          super(...args);
          this.types = /* @__PURE__ */ new Set();
          this.enums = /* @__PURE__ */ new Set();
          this.constEnums = /* @__PURE__ */ new Set();
          this.classes = /* @__PURE__ */ new Set();
          this.exportOnlyBindings = /* @__PURE__ */ new Set();
        }
      };
      var TypeScriptScopeHandler = class extends ScopeHandler {
        createScope(flags) {
          return new TypeScriptScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
            this.maybeExportDefined(scope, name);
            scope.exportOnlyBindings.add(name);
            return;
          }
          super.declareName(name, bindingType, loc);
          if (bindingType & BIND_KIND_TYPE) {
            if (!(bindingType & BIND_KIND_VALUE)) {
              this.checkRedeclarationInScope(scope, name, bindingType, loc);
              this.maybeExportDefined(scope, name);
            }
            scope.types.add(name);
          }
          if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);
          if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);
          if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (scope.enums.has(name)) {
            if (bindingType & BIND_FLAGS_TS_ENUM) {
              const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
              const wasConst = scope.constEnums.has(name);
              return isConst !== wasConst;
            }
            return true;
          }
          if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
            if (scope.lexical.has(name)) {
              return !!(bindingType & BIND_KIND_VALUE);
            } else {
              return false;
            }
          }
          if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
            return true;
          }
          return super.isRedeclaredInScope(scope, name, bindingType);
        }
        checkLocalExport(id) {
          const topLevelScope = this.scopeStack[0];
          const {
            name
          } = id;
          if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
            super.checkLocalExport(id);
          }
        }
      };
      var getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      function nonNull(x2) {
        if (x2 == null) {
          throw new Error(`Unexpected ${x2} value.`);
        }
        return x2;
      }
      function assert(x2) {
        if (!x2) {
          throw new Error("Assert fail");
        }
      }
      var TSErrors = ParseErrorEnum`typescript`({
        AbstractMethodHasImplementation: ({
          methodName
        }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
        AbstractPropertyHasInitializer: ({
          propertyName
        }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
        AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
        AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
        CannotFindName: ({
          name
        }) => `Cannot find name '${name}'.`,
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
        ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareAccessor: ({
          kind
        }) => `'declare' is not allowed in ${kind}ters.`,
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateAccessibilityModifier: ({
          modifier
        }) => `Accessibility modifier already seen.`,
        DuplicateModifier: ({
          modifier
        }) => `Duplicate modifier: '${modifier}'.`,
        EmptyHeritageClauseType: ({
          token
        }) => `'${token}' list cannot be empty.`,
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
        ImportAliasHasImportType: "An import alias can not use 'import type'.",
        IncompatibleModifiers: ({
          modifiers
        }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
        IndexSignatureHasAccessibility: ({
          modifier
        }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
        IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
        InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
        InvalidModifierOnTypeMember: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type member.`,
        InvalidModifierOnTypeParameter: ({
          modifier
        }) => `'${modifier}' modifier cannot appear on a type parameter.`,
        InvalidModifierOnTypeParameterPositions: ({
          modifier
        }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
        InvalidModifiersOrder: ({
          orderedModifiers
        }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
        InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
        MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
        NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
        NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: ({
          modifier
        }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
        ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
        ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
        ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
        SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
        SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
        SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
        SingleTypeParameterWithoutTrailingComma: ({
          typeParameterName
        }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
        StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
        TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
        TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: ({
          type
        }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
      });
      function keywordTypeFromName(value) {
        switch (value) {
          case "any":
            return "TSAnyKeyword";
          case "boolean":
            return "TSBooleanKeyword";
          case "bigint":
            return "TSBigIntKeyword";
          case "never":
            return "TSNeverKeyword";
          case "number":
            return "TSNumberKeyword";
          case "object":
            return "TSObjectKeyword";
          case "string":
            return "TSStringKeyword";
          case "symbol":
            return "TSSymbolKeyword";
          case "undefined":
            return "TSUndefinedKeyword";
          case "unknown":
            return "TSUnknownKeyword";
          default:
            return void 0;
        }
      }
      function tsIsAccessModifier(modifier) {
        return modifier === "private" || modifier === "public" || modifier === "protected";
      }
      function tsIsVarianceAnnotations(modifier) {
        return modifier === "in" || modifier === "out";
      }
      var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
        getScopeHandler() {
          return TypeScriptScopeHandler;
        }
        tsIsIdentifier() {
          return tokenIsIdentifier(this.state.type);
        }
        tsTokenCanFollowModifier() {
          return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
        }
        tsNextTokenCanFollowModifier() {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
          if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {
            return void 0;
          }
          const modifier = this.state.value;
          if (allowedModifiers.indexOf(modifier) !== -1) {
            if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
              return void 0;
            }
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
              return modifier;
            }
          }
          return void 0;
        }
        tsParseModifiers({
          modified,
          allowedModifiers,
          disallowedModifiers,
          stopOnStartOfClassStaticBlock,
          errorTemplate = TSErrors.InvalidModifierOnTypeMember
        }) {
          const enforceOrder = (loc, modifier, before, after) => {
            if (modifier === before && modified[after]) {
              this.raise(TSErrors.InvalidModifiersOrder, {
                at: loc,
                orderedModifiers: [before, after]
              });
            }
          };
          const incompatible = (loc, modifier, mod1, mod2) => {
            if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
              this.raise(TSErrors.IncompatibleModifiers, {
                at: loc,
                modifiers: [mod1, mod2]
              });
            }
          };
          for (; ; ) {
            const {
              startLoc
            } = this.state;
            const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
            if (!modifier) break;
            if (tsIsAccessModifier(modifier)) {
              if (modified.accessibility) {
                this.raise(TSErrors.DuplicateAccessibilityModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, modifier, "override");
                enforceOrder(startLoc, modifier, modifier, "static");
                enforceOrder(startLoc, modifier, modifier, "readonly");
                modified.accessibility = modifier;
              }
            } else if (tsIsVarianceAnnotations(modifier)) {
              if (modified[modifier]) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              }
              modified[modifier] = true;
              enforceOrder(startLoc, modifier, "in", "out");
            } else {
              if (Object.hasOwnProperty.call(modified, modifier)) {
                this.raise(TSErrors.DuplicateModifier, {
                  at: startLoc,
                  modifier
                });
              } else {
                enforceOrder(startLoc, modifier, "static", "readonly");
                enforceOrder(startLoc, modifier, "static", "override");
                enforceOrder(startLoc, modifier, "override", "readonly");
                enforceOrder(startLoc, modifier, "abstract", "override");
                incompatible(startLoc, modifier, "declare", "override");
                incompatible(startLoc, modifier, "static", "abstract");
              }
              modified[modifier] = true;
            }
            if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
              this.raise(errorTemplate, {
                at: startLoc,
                modifier
              });
            }
          }
        }
        tsIsListTerminator(kind) {
          switch (kind) {
            case "EnumMembers":
            case "TypeMembers":
              return this.match(8);
            case "HeritageClauseElement":
              return this.match(5);
            case "TupleElementTypes":
              return this.match(3);
            case "TypeParametersOrArguments":
              return this.match(48);
          }
          throw new Error("Unreachable");
        }
        tsParseList(kind, parseElement) {
          const result = [];
          while (!this.tsIsListTerminator(kind)) {
            result.push(parseElement());
          }
          return result;
        }
        tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
          return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
        }
        tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
          const result = [];
          let trailingCommaPos = -1;
          for (; ; ) {
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            trailingCommaPos = -1;
            const element = parseElement();
            if (element == null) {
              return void 0;
            }
            result.push(element);
            if (this.eat(12)) {
              trailingCommaPos = this.state.lastTokStart;
              continue;
            }
            if (this.tsIsListTerminator(kind)) {
              break;
            }
            if (expectSuccess) {
              this.expect(12);
            }
            return void 0;
          }
          if (refTrailingCommaPos) {
            refTrailingCommaPos.value = trailingCommaPos;
          }
          return result;
        }
        tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
          if (!skipFirstToken) {
            if (bracket) {
              this.expect(0);
            } else {
              this.expect(47);
            }
          }
          const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
          if (bracket) {
            this.expect(3);
          } else {
            this.expect(48);
          }
          return result;
        }
        tsParseImportType() {
          const node = this.startNode();
          this.expect(83);
          this.expect(10);
          if (!this.match(129)) {
            this.raise(TSErrors.UnsupportedImportTypeArgument, {
              at: this.state.startLoc
            });
          }
          node.argument = super.parseExprAtom();
          this.expect(11);
          if (this.eat(16)) {
            node.qualifier = this.tsParseEntityName();
          }
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSImportType");
        }
        tsParseEntityName(allowReservedWords = true) {
          let entity = this.parseIdentifier(allowReservedWords);
          while (this.eat(16)) {
            const node = this.startNodeAtNode(entity);
            node.left = entity;
            node.right = this.parseIdentifier(allowReservedWords);
            entity = this.finishNode(node, "TSQualifiedName");
          }
          return entity;
        }
        tsParseTypeReference() {
          const node = this.startNode();
          node.typeName = this.tsParseEntityName();
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeReference");
        }
        tsParseThisTypePredicate(lhs) {
          this.next();
          const node = this.startNodeAtNode(lhs);
          node.parameterName = lhs;
          node.typeAnnotation = this.tsParseTypeAnnotation(false);
          node.asserts = false;
          return this.finishNode(node, "TSTypePredicate");
        }
        tsParseThisTypeNode() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "TSThisType");
        }
        tsParseTypeQuery() {
          const node = this.startNode();
          this.expect(87);
          if (this.match(83)) {
            node.exprName = this.tsParseImportType();
          } else {
            node.exprName = this.tsParseEntityName();
          }
          if (!this.hasPrecedingLineBreak() && this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSTypeQuery");
        }
        tsParseInOutModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["in", "out"],
            disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameter
          });
        }
        tsParseNoneModifiers(node) {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: [],
            disallowedModifiers: ["in", "out"],
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
        }
        tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
          const node = this.startNode();
          parseModifiers(node);
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsEatThenParseType(81);
          node.default = this.tsEatThenParseType(29);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsTryParseTypeParameters(parseModifiers) {
          if (this.match(47)) {
            return this.tsParseTypeParameters(parseModifiers);
          }
        }
        tsParseTypeParameters(parseModifiers) {
          const node = this.startNode();
          if (this.match(47) || this.match(138)) {
            this.next();
          } else {
            this.unexpected();
          }
          const refTrailingCommaPos = {
            value: -1
          };
          node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeParameters, {
              at: node
            });
          }
          if (refTrailingCommaPos.value !== -1) {
            this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
          }
          return this.finishNode(node, "TSTypeParameterDeclaration");
        }
        tsTryNextParseConstantContext() {
          if (this.lookahead().type !== 75) return null;
          this.next();
          const typeReference = this.tsParseTypeReference();
          if (typeReference.typeParameters) {
            this.raise(TSErrors.CannotFindName, {
              at: typeReference.typeName,
              name: "const"
            });
          }
          return typeReference;
        }
        tsFillSignature(returnToken, signature) {
          const returnTokenRequired = returnToken === 19;
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          signature.typeParameters = this.tsTryParseTypeParameters();
          this.expect(10);
          signature[paramsKey] = this.tsParseBindingListForSignature();
          if (returnTokenRequired) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          } else if (this.match(returnToken)) {
            signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
          }
        }
        tsParseBindingListForSignature() {
          return super.parseBindingList(11, 41).map((pattern) => {
            if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
              this.raise(TSErrors.UnsupportedSignatureParameterKind, {
                at: pattern,
                type: pattern.type
              });
            }
            return pattern;
          });
        }
        tsParseTypeMemberSemicolon() {
          if (!this.eat(12) && !this.isLineTerminator()) {
            this.expect(13);
          }
        }
        tsParseSignatureMember(kind, node) {
          this.tsFillSignature(14, node);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, kind);
        }
        tsIsUnambiguouslyIndexSignature() {
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            this.next();
            return this.match(14);
          }
          return false;
        }
        tsTryParseIndexSignature(node) {
          if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
            return void 0;
          }
          this.expect(0);
          const id = this.parseIdentifier();
          id.typeAnnotation = this.tsParseTypeAnnotation();
          this.resetEndLocation(id);
          this.expect(3);
          node.parameters = [id];
          const type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(node, "TSIndexSignature");
        }
        tsParsePropertyOrMethodSignature(node, readonly) {
          if (this.eat(17)) node.optional = true;
          const nodeAny = node;
          if (this.match(10) || this.match(47)) {
            if (readonly) {
              this.raise(TSErrors.ReadonlyForMethodSignature, {
                at: node
              });
            }
            const method = nodeAny;
            if (method.kind && this.match(47)) {
              this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition()
              });
            }
            this.tsFillSignature(14, method);
            this.tsParseTypeMemberSemicolon();
            const paramsKey = "parameters";
            const returnTypeKey = "typeAnnotation";
            if (method.kind === "get") {
              if (method[paramsKey].length > 0) {
                this.raise(Errors.BadGetterArity, {
                  at: this.state.curPosition()
                });
                if (this.isThisParam(method[paramsKey][0])) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
            } else if (method.kind === "set") {
              if (method[paramsKey].length !== 1) {
                this.raise(Errors.BadSetterArity, {
                  at: this.state.curPosition()
                });
              } else {
                const firstParameter = method[paramsKey][0];
                if (this.isThisParam(firstParameter)) {
                  this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "Identifier" && firstParameter.optional) {
                  this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                    at: this.state.curPosition()
                  });
                }
                if (firstParameter.type === "RestElement") {
                  this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                    at: this.state.curPosition()
                  });
                }
              }
              if (method[returnTypeKey]) {
                this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                  at: method[returnTypeKey]
                });
              }
            } else {
              method.kind = "method";
            }
            return this.finishNode(method, "TSMethodSignature");
          } else {
            const property = nodeAny;
            if (readonly) property.readonly = true;
            const type = this.tsTryParseTypeAnnotation();
            if (type) property.typeAnnotation = type;
            this.tsParseTypeMemberSemicolon();
            return this.finishNode(property, "TSPropertySignature");
          }
        }
        tsParseTypeMember() {
          const node = this.startNode();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
          }
          if (this.match(77)) {
            const id = this.startNode();
            this.next();
            if (this.match(10) || this.match(47)) {
              return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
            } else {
              node.key = this.createIdentifier(id, "new");
              return this.tsParsePropertyOrMethodSignature(node, false);
            }
          }
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["readonly"],
            disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
          });
          const idx = this.tsTryParseIndexSignature(node);
          if (idx) {
            return idx;
          }
          super.parsePropertyName(node);
          if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
            node.kind = node.key.name;
            super.parsePropertyName(node);
          }
          return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
        }
        tsParseTypeLiteral() {
          const node = this.startNode();
          node.members = this.tsParseObjectTypeMembers();
          return this.finishNode(node, "TSTypeLiteral");
        }
        tsParseObjectTypeMembers() {
          this.expect(5);
          const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
          this.expect(8);
          return members;
        }
        tsIsStartOfMappedType() {
          this.next();
          if (this.eat(53)) {
            return this.isContextual(118);
          }
          if (this.isContextual(118)) {
            this.next();
          }
          if (!this.match(0)) {
            return false;
          }
          this.next();
          if (!this.tsIsIdentifier()) {
            return false;
          }
          this.next();
          return this.match(58);
        }
        tsParseMappedTypeParameter() {
          const node = this.startNode();
          node.name = this.tsParseTypeParameterName();
          node.constraint = this.tsExpectThenParseType(58);
          return this.finishNode(node, "TSTypeParameter");
        }
        tsParseMappedType() {
          const node = this.startNode();
          this.expect(5);
          if (this.match(53)) {
            node.readonly = this.state.value;
            this.next();
            this.expectContextual(118);
          } else if (this.eatContextual(118)) {
            node.readonly = true;
          }
          this.expect(0);
          node.typeParameter = this.tsParseMappedTypeParameter();
          node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
          this.expect(3);
          if (this.match(53)) {
            node.optional = this.state.value;
            this.next();
            this.expect(17);
          } else if (this.eat(17)) {
            node.optional = true;
          }
          node.typeAnnotation = this.tsTryParseType();
          this.semicolon();
          this.expect(8);
          return this.finishNode(node, "TSMappedType");
        }
        tsParseTupleType() {
          const node = this.startNode();
          node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
          let seenOptionalElement = false;
          let labeledElements = null;
          node.elementTypes.forEach((elementNode) => {
            var _labeledElements;
            const {
              type
            } = elementNode;
            if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
              this.raise(TSErrors.OptionalTypeBeforeRequired, {
                at: elementNode
              });
            }
            seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
            let checkType = type;
            if (type === "TSRestType") {
              elementNode = elementNode.typeAnnotation;
              checkType = elementNode.type;
            }
            const isLabeled = checkType === "TSNamedTupleMember";
            (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;
            if (labeledElements !== isLabeled) {
              this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                at: elementNode
              });
            }
          });
          return this.finishNode(node, "TSTupleType");
        }
        tsParseTupleElementType() {
          const {
            start: startPos,
            startLoc
          } = this.state;
          const rest = this.eat(21);
          let type = this.tsParseType();
          const optional = this.eat(17);
          const labeled = this.eat(14);
          if (labeled) {
            const labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;
            if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
              labeledNode.label = type.typeName;
            } else {
              this.raise(TSErrors.InvalidTupleMemberLabel, {
                at: type
              });
              labeledNode.label = type;
            }
            labeledNode.elementType = this.tsParseType();
            type = this.finishNode(labeledNode, "TSNamedTupleMember");
          } else if (optional) {
            const optionalTypeNode = this.startNodeAtNode(type);
            optionalTypeNode.typeAnnotation = type;
            type = this.finishNode(optionalTypeNode, "TSOptionalType");
          }
          if (rest) {
            const restNode = this.startNodeAt(startPos, startLoc);
            restNode.typeAnnotation = type;
            type = this.finishNode(restNode, "TSRestType");
          }
          return type;
        }
        tsParseParenthesizedType() {
          const node = this.startNode();
          this.expect(10);
          node.typeAnnotation = this.tsParseType();
          this.expect(11);
          return this.finishNode(node, "TSParenthesizedType");
        }
        tsParseFunctionOrConstructorType(type, abstract) {
          const node = this.startNode();
          if (type === "TSConstructorType") {
            node.abstract = !!abstract;
            if (abstract) this.next();
            this.next();
          }
          this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
          return this.finishNode(node, type);
        }
        tsParseLiteralTypeNode() {
          const node = this.startNode();
          node.literal = (() => {
            switch (this.state.type) {
              case 130:
              case 131:
              case 129:
              case 85:
              case 86:
                return super.parseExprAtom();
              default:
                throw this.unexpected();
            }
          })();
          return this.finishNode(node, "TSLiteralType");
        }
        tsParseTemplateLiteralType() {
          const node = this.startNode();
          node.literal = super.parseTemplate(false);
          return this.finishNode(node, "TSLiteralType");
        }
        parseTemplateSubstitution() {
          if (this.state.inType) return this.tsParseType();
          return super.parseTemplateSubstitution();
        }
        tsParseThisTypeOrThisTypePredicate() {
          const thisKeyword = this.tsParseThisTypeNode();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            return this.tsParseThisTypePredicate(thisKeyword);
          } else {
            return thisKeyword;
          }
        }
        tsParseNonArrayType() {
          switch (this.state.type) {
            case 129:
            case 130:
            case 131:
            case 85:
            case 86:
              return this.tsParseLiteralTypeNode();
            case 53:
              if (this.state.value === "-") {
                const node = this.startNode();
                const nextToken = this.lookahead();
                if (nextToken.type !== 130 && nextToken.type !== 131) {
                  throw this.unexpected();
                }
                node.literal = this.parseMaybeUnary();
                return this.finishNode(node, "TSLiteralType");
              }
              break;
            case 78:
              return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
              return this.tsParseTypeQuery();
            case 83:
              return this.tsParseImportType();
            case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
            case 0:
              return this.tsParseTupleType();
            case 10:
              return this.tsParseParenthesizedType();
            case 25:
            case 24:
              return this.tsParseTemplateLiteralType();
            default: {
              const {
                type
              } = this.state;
              if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                  const node = this.startNode();
                  this.next();
                  return this.finishNode(node, nodeType);
                }
                return this.tsParseTypeReference();
              }
            }
          }
          throw this.unexpected();
        }
        tsParseArrayTypeOrHigher() {
          let type = this.tsParseNonArrayType();
          while (!this.hasPrecedingLineBreak() && this.eat(0)) {
            if (this.match(3)) {
              const node = this.startNodeAtNode(type);
              node.elementType = type;
              this.expect(3);
              type = this.finishNode(node, "TSArrayType");
            } else {
              const node = this.startNodeAtNode(type);
              node.objectType = type;
              node.indexType = this.tsParseType();
              this.expect(3);
              type = this.finishNode(node, "TSIndexedAccessType");
            }
          }
          return type;
        }
        tsParseTypeOperator() {
          const node = this.startNode();
          const operator = this.state.value;
          this.next();
          node.operator = operator;
          node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
          if (operator === "readonly") {
            this.tsCheckTypeAnnotationForReadOnly(node);
          }
          return this.finishNode(node, "TSTypeOperator");
        }
        tsCheckTypeAnnotationForReadOnly(node) {
          switch (node.typeAnnotation.type) {
            case "TSTupleType":
            case "TSArrayType":
              return;
            default:
              this.raise(TSErrors.UnexpectedReadonly, {
                at: node
              });
          }
        }
        tsParseInferType() {
          const node = this.startNode();
          this.expectContextual(112);
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
          return this.finishNode(node, "TSInferType");
        }
        tsParseConstraintForInferType() {
          if (this.eat(81)) {
            const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
              return constraint;
            }
          }
        }
        tsParseTypeOperatorOrHigher() {
          const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
          return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }
        tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
          const node = this.startNode();
          const hasLeadingOperator = this.eat(operator);
          const types2 = [];
          do {
            types2.push(parseConstituentType());
          } while (this.eat(operator));
          if (types2.length === 1 && !hasLeadingOperator) {
            return types2[0];
          }
          node.types = types2;
          return this.finishNode(node, kind);
        }
        tsParseIntersectionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }
        tsParseUnionTypeOrHigher() {
          return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }
        tsIsStartOfFunctionType() {
          if (this.match(47)) {
            return true;
          }
          return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }
        tsSkipParameterStart() {
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            this.next();
            return true;
          }
          if (this.match(5)) {
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              this.parseObjectLike(8, true);
              return errors.length === previousErrorCount;
            } catch (_unused) {
              return false;
            }
          }
          if (this.match(0)) {
            this.next();
            const {
              errors
            } = this.state;
            const previousErrorCount = errors.length;
            try {
              super.parseBindingList(3, 93, true);
              return errors.length === previousErrorCount;
            } catch (_unused2) {
              return false;
            }
          }
          return false;
        }
        tsIsUnambiguouslyStartOfFunctionType() {
          this.next();
          if (this.match(11) || this.match(21)) {
            return true;
          }
          if (this.tsSkipParameterStart()) {
            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
              return true;
            }
            if (this.match(11)) {
              this.next();
              if (this.match(19)) {
                return true;
              }
            }
          }
          return false;
        }
        tsParseTypeOrTypePredicateAnnotation(returnToken) {
          return this.tsInType(() => {
            const t3 = this.startNode();
            this.expect(returnToken);
            const node = this.startNode();
            const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (asserts && this.match(78)) {
              let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
              if (thisTypePredicate.type === "TSThisType") {
                node.parameterName = thisTypePredicate;
                node.asserts = true;
                node.typeAnnotation = null;
                thisTypePredicate = this.finishNode(node, "TSTypePredicate");
              } else {
                this.resetStartLocationFromNode(thisTypePredicate, node);
                thisTypePredicate.asserts = true;
              }
              t3.typeAnnotation = thisTypePredicate;
              return this.finishNode(t3, "TSTypeAnnotation");
            }
            const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!typePredicateVariable) {
              if (!asserts) {
                return this.tsParseTypeAnnotation(false, t3);
              }
              node.parameterName = this.parseIdentifier();
              node.asserts = asserts;
              node.typeAnnotation = null;
              t3.typeAnnotation = this.finishNode(node, "TSTypePredicate");
              return this.finishNode(t3, "TSTypeAnnotation");
            }
            const type = this.tsParseTypeAnnotation(false);
            node.parameterName = typePredicateVariable;
            node.typeAnnotation = type;
            node.asserts = asserts;
            t3.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t3, "TSTypeAnnotation");
          });
        }
        tsTryParseTypeOrTypePredicateAnnotation() {
          return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
        }
        tsTryParseTypeAnnotation() {
          return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
        }
        tsTryParseType() {
          return this.tsEatThenParseType(14);
        }
        tsParseTypePredicatePrefix() {
          const id = this.parseIdentifier();
          if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
            this.next();
            return id;
          }
        }
        tsParseTypePredicateAsserts() {
          if (this.state.type !== 106) {
            return false;
          }
          const containsEsc = this.state.containsEsc;
          this.next();
          if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
            return false;
          }
          if (containsEsc) {
            this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.lastTokStartLoc,
              reservedWord: "asserts"
            });
          }
          return true;
        }
        tsParseTypeAnnotation(eatColon = true, t3 = this.startNode()) {
          this.tsInType(() => {
            if (eatColon) this.expect(14);
            t3.typeAnnotation = this.tsParseType();
          });
          return this.finishNode(t3, "TSTypeAnnotation");
        }
        tsParseType() {
          assert(this.state.inType);
          const type = this.tsParseNonConditionalType();
          if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
            return type;
          }
          const node = this.startNodeAtNode(type);
          node.checkType = type;
          node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
          this.expect(17);
          node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          this.expect(14);
          node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
          return this.finishNode(node, "TSConditionalType");
        }
        isAbstractConstructorSignature() {
          return this.isContextual(120) && this.lookahead().type === 77;
        }
        tsParseNonConditionalType() {
          if (this.tsIsStartOfFunctionType()) {
            return this.tsParseFunctionOrConstructorType("TSFunctionType");
          }
          if (this.match(77)) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType");
          } else if (this.isAbstractConstructorSignature()) {
            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
          }
          return this.tsParseUnionTypeOrHigher();
        }
        tsParseTypeAssertion() {
          if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedTypeAssertion, {
              at: this.state.startLoc
            });
          }
          const node = this.startNode();
          const _const = this.tsTryNextParseConstantContext();
          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(48);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        }
        tsParseHeritageClause(token) {
          const originalStartLoc = this.state.startLoc;
          const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
            const node = this.startNode();
            node.expression = this.tsParseEntityName();
            if (this.match(47)) {
              node.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node, "TSExpressionWithTypeArguments");
          });
          if (!delimitedList.length) {
            this.raise(TSErrors.EmptyHeritageClauseType, {
              at: originalStartLoc,
              token
            });
          }
          return delimitedList;
        }
        tsParseInterfaceDeclaration(node, properties = {}) {
          if (this.hasFollowingLineBreak()) return null;
          this.expectContextual(125);
          if (properties.declare) node.declare = true;
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            this.checkIdentifier(node.id, BIND_TS_INTERFACE);
          } else {
            node.id = null;
            this.raise(TSErrors.MissingInterfaceName, {
              at: this.state.startLoc
            });
          }
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (this.eat(81)) {
            node.extends = this.tsParseHeritageClause("extends");
          }
          const body2 = this.startNode();
          body2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
          node.body = this.finishNode(body2, "TSInterfaceBody");
          return this.finishNode(node, "TSInterfaceDeclaration");
        }
        tsParseTypeAliasDeclaration(node) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_TS_TYPE);
          node.typeAnnotation = this.tsInType(() => {
            node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
            this.expect(29);
            if (this.isContextual(111) && this.lookahead().type !== 16) {
              const node2 = this.startNode();
              this.next();
              return this.finishNode(node2, "TSIntrinsicKeyword");
            }
            return this.tsParseType();
          });
          this.semicolon();
          return this.finishNode(node, "TSTypeAliasDeclaration");
        }
        tsInNoContext(cb) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        }
        tsInType(cb) {
          const oldInType = this.state.inType;
          this.state.inType = true;
          try {
            return cb();
          } finally {
            this.state.inType = oldInType;
          }
        }
        tsInDisallowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = true;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsInAllowConditionalTypesContext(cb) {
          const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
          this.state.inDisallowConditionalTypesContext = false;
          try {
            return cb();
          } finally {
            this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
          }
        }
        tsEatThenParseType(token) {
          return !this.match(token) ? void 0 : this.tsNextThenParseType();
        }
        tsExpectThenParseType(token) {
          return this.tsDoThenParseType(() => this.expect(token));
        }
        tsNextThenParseType() {
          return this.tsDoThenParseType(() => this.next());
        }
        tsDoThenParseType(cb) {
          return this.tsInType(() => {
            cb();
            return this.tsParseType();
          });
        }
        tsParseEnumMember() {
          const node = this.startNode();
          node.id = this.match(129) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
          if (this.eat(29)) {
            node.initializer = super.parseMaybeAssignAllowIn();
          }
          return this.finishNode(node, "TSEnumMember");
        }
        tsParseEnumDeclaration(node, properties = {}) {
          if (properties.const) node.const = true;
          if (properties.declare) node.declare = true;
          this.expectContextual(122);
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
          return this.finishNode(node, "TSEnumDeclaration");
        }
        tsParseModuleBlock() {
          const node = this.startNode();
          this.scope.enter(SCOPE_OTHER);
          this.expect(5);
          super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
          this.scope.exit();
          return this.finishNode(node, "TSModuleBlock");
        }
        tsParseModuleOrNamespaceDeclaration(node, nested = false) {
          node.id = this.parseIdentifier();
          if (!nested) {
            this.checkIdentifier(node.id, BIND_TS_NAMESPACE);
          }
          if (this.eat(16)) {
            const inner = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(inner, true);
            node.body = inner;
          } else {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseAmbientExternalModuleDeclaration(node) {
          if (this.isContextual(109)) {
            node.global = true;
            node.id = this.parseIdentifier();
          } else if (this.match(129)) {
            node.id = super.parseStringLiteral(this.state.value);
          } else {
            this.unexpected();
          }
          if (this.match(5)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            node.body = this.tsParseModuleBlock();
            this.prodParam.exit();
            this.scope.exit();
          } else {
            this.semicolon();
          }
          return this.finishNode(node, "TSModuleDeclaration");
        }
        tsParseImportEqualsDeclaration(node, isExport) {
          node.isExport = isExport || false;
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BIND_LEXICAL);
          this.expect(29);
          const moduleReference = this.tsParseModuleReference();
          if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
            this.raise(TSErrors.ImportAliasHasImportType, {
              at: moduleReference
            });
          }
          node.moduleReference = moduleReference;
          this.semicolon();
          return this.finishNode(node, "TSImportEqualsDeclaration");
        }
        tsIsExternalModuleReference() {
          return this.isContextual(116) && this.lookaheadCharCode() === 40;
        }
        tsParseModuleReference() {
          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
        }
        tsParseExternalModuleReference() {
          const node = this.startNode();
          this.expectContextual(116);
          this.expect(10);
          if (!this.match(129)) {
            throw this.unexpected();
          }
          node.expression = super.parseExprAtom();
          this.expect(11);
          return this.finishNode(node, "TSExternalModuleReference");
        }
        tsLookAhead(f2) {
          const state = this.state.clone();
          const res = f2();
          this.state = state;
          return res;
        }
        tsTryParseAndCatch(f2) {
          const result = this.tryParse((abort) => f2() || abort());
          if (result.aborted || !result.node) return void 0;
          if (result.error) this.state = result.failState;
          return result.node;
        }
        tsTryParse(f2) {
          const state = this.state.clone();
          const result = f2();
          if (result !== void 0 && result !== false) {
            return result;
          } else {
            this.state = state;
            return void 0;
          }
        }
        tsTryParseDeclare(nany) {
          if (this.isLineTerminator()) {
            return;
          }
          let starttype = this.state.type;
          let kind;
          if (this.isContextual(99)) {
            starttype = 74;
            kind = "let";
          }
          return this.tsInAmbientContext(() => {
            if (starttype === 68) {
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, true);
            }
            if (starttype === 80) {
              nany.declare = true;
              return this.parseClass(nany, true, false);
            }
            if (starttype === 122) {
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            }
            if (starttype === 109) {
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            }
            if (starttype === 75 || starttype === 74) {
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            }
            if (starttype === 125) {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result) return result;
            }
            if (tokenIsIdentifier(starttype)) {
              return this.tsParseDeclaration(nany, this.state.value, true);
            }
          });
        }
        tsTryParseExportDeclaration() {
          return this.tsParseDeclaration(this.startNode(), this.state.value, true);
        }
        tsParseExpressionStatement(node, expr) {
          switch (expr.name) {
            case "declare": {
              const declaration = this.tsTryParseDeclare(node);
              if (declaration) {
                declaration.declare = true;
                return declaration;
              }
              break;
            }
            case "global":
              if (this.match(5)) {
                this.scope.enter(SCOPE_TS_MODULE);
                this.prodParam.enter(PARAM);
                const mod = node;
                mod.global = true;
                mod.id = expr;
                mod.body = this.tsParseModuleBlock();
                this.scope.exit();
                this.prodParam.exit();
                return this.finishNode(mod, "TSModuleDeclaration");
              }
              break;
            default:
              return this.tsParseDeclaration(node, expr.name, false);
          }
        }
        tsParseDeclaration(node, value, next2) {
          switch (value) {
            case "abstract":
              if (this.tsCheckLineTerminator(next2) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                return this.tsParseAbstractDeclaration(node);
              }
              break;
            case "module":
              if (this.tsCheckLineTerminator(next2)) {
                if (this.match(129)) {
                  return this.tsParseAmbientExternalModuleDeclaration(node);
                } else if (tokenIsIdentifier(this.state.type)) {
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                }
              }
              break;
            case "namespace":
              if (this.tsCheckLineTerminator(next2) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
              break;
            case "type":
              if (this.tsCheckLineTerminator(next2) && tokenIsIdentifier(this.state.type)) {
                return this.tsParseTypeAliasDeclaration(node);
              }
              break;
          }
        }
        tsCheckLineTerminator(next2) {
          if (next2) {
            if (this.hasFollowingLineBreak()) return false;
            this.next();
            return true;
          }
          return !this.isLineTerminator();
        }
        tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
          if (!this.match(47)) {
            return void 0;
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true;
          const res = this.tsTryParseAndCatch(() => {
            const node = this.startNodeAt(startPos, startLoc);
            node.typeParameters = this.tsParseTypeParameters();
            super.parseFunctionParams(node);
            node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
            this.expect(19);
            return node;
          });
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (!res) {
            return void 0;
          }
          return super.parseArrowExpression(res, null, true);
        }
        tsParseTypeArgumentsInExpression() {
          if (this.reScan_lt() !== 47) {
            return void 0;
          }
          return this.tsParseTypeArguments();
        }
        tsParseTypeArguments() {
          const node = this.startNode();
          node.params = this.tsInType(() => this.tsInNoContext(() => {
            this.expect(47);
            return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
          }));
          if (node.params.length === 0) {
            this.raise(TSErrors.EmptyTypeArguments, {
              at: node
            });
          }
          this.expect(48);
          return this.finishNode(node, "TSTypeParameterInstantiation");
        }
        tsIsDeclarationStart() {
          return tokenIsTSDeclarationStart(this.state.type);
        }
        isExportDefaultSpecifier() {
          if (this.tsIsDeclarationStart()) return false;
          return super.isExportDefaultSpecifier();
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let accessibility;
          let readonly = false;
          let override = false;
          if (allowModifiers !== void 0) {
            const modified = {};
            this.tsParseModifiers({
              modified,
              allowedModifiers: ["public", "private", "protected", "override", "readonly"]
            });
            accessibility = modified.accessibility;
            override = modified.override;
            readonly = modified.readonly;
            if (allowModifiers === false && (accessibility || readonly || override)) {
              this.raise(TSErrors.UnexpectedParameterModifier, {
                at: startLoc
              });
            }
          }
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          if (accessibility || readonly || override) {
            const pp = this.startNodeAt(startPos, startLoc);
            if (decorators.length) {
              pp.decorators = decorators;
            }
            if (accessibility) pp.accessibility = accessibility;
            if (readonly) pp.readonly = readonly;
            if (override) pp.override = override;
            if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
              this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                at: pp
              });
            }
            pp.parameter = elt;
            return this.finishNode(pp, "TSParameterProperty");
          }
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        isSimpleParameter(node) {
          return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
          if (bodilessType && !this.match(5) && this.isLineTerminator()) {
            return this.finishNode(node, bodilessType);
          }
          if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
            this.raise(TSErrors.DeclareFunctionHasImplementation, {
              at: node
            });
            if (node.declare) {
              return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            }
          }
          return super.parseFunctionBodyAndFinish(node, type, isMethod);
        }
        registerFunctionStatementId(node) {
          if (!node.body && node.id) {
            this.checkIdentifier(node.id, BIND_TS_AMBIENT);
          } else {
            super.registerFunctionStatementId(node);
          }
        }
        tsCheckForInvalidTypeCasts(items) {
          items.forEach((node) => {
            if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
              this.raise(TSErrors.UnexpectedTypeAnnotation, {
                at: node.typeAnnotation
              });
            }
          });
        }
        toReferencedList(exprList, isInParens) {
          this.tsCheckForInvalidTypeCasts(exprList);
          return exprList;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
          if (node.type === "ArrayExpression") {
            this.tsCheckForInvalidTypeCasts(node.elements);
          }
          return node;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          if (!this.hasPrecedingLineBreak() && this.match(35)) {
            this.state.canStartJSXElement = false;
            this.next();
            const nonNullExpression = this.startNodeAt(startPos, startLoc);
            nonNullExpression.expression = base;
            return this.finishNode(nonNullExpression, "TSNonNullExpression");
          }
          let isOptionalCall = false;
          if (this.match(18) && this.lookaheadCharCode() === 60) {
            if (noCalls) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = isOptionalCall = true;
            this.next();
          }
          if (this.match(47) || this.match(51)) {
            let missingParenErrorLoc;
            const result = this.tsTryParseAndCatch(() => {
              if (!noCalls && this.atPossibleAsyncArrow(base)) {
                const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
                if (asyncArrowFn) {
                  return asyncArrowFn;
                }
              }
              const typeArguments = this.tsParseTypeArgumentsInExpression();
              if (!typeArguments) return;
              if (isOptionalCall && !this.match(10)) {
                missingParenErrorLoc = this.state.curPosition();
                return;
              }
              if (tokenIsTemplate(this.state.type)) {
                const result2 = super.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                result2.typeParameters = typeArguments;
                return result2;
              }
              if (!noCalls && this.eat(10)) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.callee = base;
                node2.arguments = this.parseCallExpressionArguments(11, false);
                this.tsCheckForInvalidTypeCasts(node2.arguments);
                node2.typeParameters = typeArguments;
                if (state.optionalChainMember) {
                  node2.optional = isOptionalCall;
                }
                return this.finishCallExpression(node2, state.optionalChainMember);
              }
              const tokenType = this.state.type;
              if (tokenType === 48 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
                return;
              }
              const node = this.startNodeAt(startPos, startLoc);
              node.expression = base;
              node.typeParameters = typeArguments;
              return this.finishNode(node, "TSInstantiationExpression");
            });
            if (missingParenErrorLoc) {
              this.unexpected(missingParenErrorLoc, 10);
            }
            if (result) {
              if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
                  at: this.state.startLoc
                });
              }
              return result;
            }
          }
          return super.parseSubscript(base, startPos, startLoc, noCalls, state);
        }
        parseNewCallee(node) {
          var _callee$extra;
          super.parseNewCallee(node);
          const {
            callee
          } = node;
          if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
            node.typeParameters = callee.typeParameters;
            node.callee = callee.expression;
          }
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;
            const _const = this.tsTryNextParseConstantContext();
            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }
            this.finishNode(node, "TSAsExpression");
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
          }
          return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (!this.state.isAmbientContext) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        checkDuplicateExports() {
        }
        parseImport(node) {
          node.importKind = "value";
          if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
            let ahead = this.lookahead();
            if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
              node.importKind = "type";
              this.next();
              ahead = this.lookahead();
            }
            if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
              return this.tsParseImportEqualsDeclaration(node);
            }
          }
          const importNode = super.parseImport(node);
          if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
            this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
              at: importNode
            });
          }
          return importNode;
        }
        parseExport(node) {
          if (this.match(83)) {
            this.next();
            if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {
              node.importKind = "type";
              this.next();
            } else {
              node.importKind = "value";
            }
            return this.tsParseImportEqualsDeclaration(node, true);
          } else if (this.eat(29)) {
            const assign = node;
            assign.expression = super.parseExpression();
            this.semicolon();
            return this.finishNode(assign, "TSExportAssignment");
          } else if (this.eatContextual(93)) {
            const decl = node;
            this.expectContextual(124);
            decl.id = this.parseIdentifier();
            this.semicolon();
            return this.finishNode(decl, "TSNamespaceExportDeclaration");
          } else {
            if (this.isContextual(126) && this.lookahead().type === 5) {
              this.next();
              node.exportKind = "type";
            } else {
              node.exportKind = "value";
            }
            return super.parseExport(node);
          }
        }
        isAbstractClass() {
          return this.isContextual(120) && this.lookahead().type === 80;
        }
        parseExportDefaultExpression() {
          if (this.isAbstractClass()) {
            const cls = this.startNode();
            this.next();
            cls.abstract = true;
            return this.parseClass(cls, true, true);
          }
          if (this.match(125)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result) return result;
          }
          return super.parseExportDefaultExpression();
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          const {
            isAmbientContext
          } = this.state;
          const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
          if (!isAmbientContext) return declaration;
          for (const {
            id,
            init: init5
          } of declaration.declarations) {
            if (!init5) continue;
            if (kind !== "const" || !!id.typeAnnotation) {
              this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
                at: init5
              });
            } else if (init5.type !== "StringLiteral" && init5.type !== "BooleanLiteral" && init5.type !== "NumericLiteral" && init5.type !== "BigIntLiteral" && (init5.type !== "TemplateLiteral" || init5.expressions.length > 0) && !isPossiblyLiteralEnum(init5)) {
              this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                at: init5
              });
            }
          }
          return declaration;
        }
        parseStatementContent(context3, topLevel) {
          if (this.match(75) && this.isLookaheadContextual("enum")) {
            const node = this.startNode();
            this.expect(75);
            return this.tsParseEnumDeclaration(node, {
              const: true
            });
          }
          if (this.isContextual(122)) {
            return this.tsParseEnumDeclaration(this.startNode());
          }
          if (this.isContextual(125)) {
            const result = this.tsParseInterfaceDeclaration(this.startNode());
            if (result) return result;
          }
          return super.parseStatementContent(context3, topLevel);
        }
        parseAccessModifier() {
          return this.tsParseModifier(["public", "protected", "private"]);
        }
        tsHasSomeModifiers(member, modifiers) {
          return modifiers.some((modifier) => {
            if (tsIsAccessModifier(modifier)) {
              return member.accessibility === modifier;
            }
            return !!member[modifier];
          });
        }
        tsIsStartOfStaticBlocks() {
          return this.isContextual(104) && this.lookaheadCharCode() === 123;
        }
        parseClassMember(classBody, member, state) {
          const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
          this.tsParseModifiers({
            modified: member,
            allowedModifiers: modifiers,
            disallowedModifiers: ["in", "out"],
            stopOnStartOfClassStaticBlock: true,
            errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
          });
          const callParseClassMemberWithIsStatic = () => {
            if (this.tsIsStartOfStaticBlocks()) {
              this.next();
              this.next();
              if (this.tsHasSomeModifiers(member, modifiers)) {
                this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                  at: this.state.curPosition()
                });
              }
              super.parseClassStaticBlock(classBody, member);
            } else {
              this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            }
          };
          if (member.declare) {
            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
          } else {
            callParseClassMemberWithIsStatic();
          }
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const idx = this.tsTryParseIndexSignature(member);
          if (idx) {
            classBody.body.push(idx);
            if (member.abstract) {
              this.raise(TSErrors.IndexSignatureHasAbstract, {
                at: member
              });
            }
            if (member.accessibility) {
              this.raise(TSErrors.IndexSignatureHasAccessibility, {
                at: member,
                modifier: member.accessibility
              });
            }
            if (member.declare) {
              this.raise(TSErrors.IndexSignatureHasDeclare, {
                at: member
              });
            }
            if (member.override) {
              this.raise(TSErrors.IndexSignatureHasOverride, {
                at: member
              });
            }
            return;
          }
          if (!this.state.inAbstractClass && member.abstract) {
            this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
              at: member
            });
          }
          if (member.override) {
            if (!state.hadSuperClass) {
              this.raise(TSErrors.OverrideNotInSubClass, {
                at: member
              });
            }
          }
          super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parsePostMemberNameModifiers(methodOrProp) {
          const optional = this.eat(17);
          if (optional) methodOrProp.optional = true;
          if (methodOrProp.readonly && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasReadonly, {
              at: methodOrProp
            });
          }
          if (methodOrProp.declare && this.match(10)) {
            this.raise(TSErrors.ClassMethodHasDeclare, {
              at: methodOrProp
            });
          }
        }
        parseExpressionStatement(node, expr) {
          const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
          return decl || super.parseExpressionStatement(node, expr);
        }
        shouldParseExportDeclaration() {
          if (this.tsIsDeclarationStart()) return true;
          return super.shouldParseExportDeclaration();
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (!this.state.maybeInArrowParameters || !this.match(17)) {
            return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
          }
          const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));
          if (!result.node) {
            if (result.error) {
              super.setOptionalParametersError(refExpressionErrors, result.error);
            }
            return expr;
          }
          if (result.error) this.state = result.failState;
          return result.node;
        }
        parseParenItem(node, startPos, startLoc) {
          node = super.parseParenItem(node, startPos, startLoc);
          if (this.eat(17)) {
            node.optional = true;
            this.resetEndLocation(node);
          }
          if (this.match(14)) {
            const typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TSTypeCastExpression");
          }
          return node;
        }
        parseExportDeclaration(node) {
          if (!this.state.isAmbientContext && this.isContextual(121)) {
            return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
          }
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const isDeclare = this.eatContextual(121);
          if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
            throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc
            });
          }
          const isIdentifier = tokenIsIdentifier(this.state.type);
          const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
          if (!declaration) return null;
          if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
            node.exportKind = "type";
          }
          if (isDeclare) {
            this.resetStartLocation(declaration, startPos, startLoc);
            declaration.declare = true;
          }
          return declaration;
        }
        parseClassId(node, isStatement, optionalId, bindingType) {
          if ((!isStatement || optionalId) && this.isContextual(110)) {
            return;
          }
          super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
          const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
          if (typeParameters) node.typeParameters = typeParameters;
        }
        parseClassPropertyAnnotation(node) {
          if (!node.optional && this.eat(35)) {
            node.definite = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type) node.typeAnnotation = type;
        }
        parseClassProperty(node) {
          this.parseClassPropertyAnnotation(node);
          if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
            this.raise(TSErrors.DeclareClassFieldHasInitializer, {
              at: this.state.startLoc
            });
          }
          if (node.abstract && this.match(29)) {
            const {
              key
            } = node;
            this.raise(TSErrors.AbstractPropertyHasInitializer, {
              at: this.state.startLoc,
              propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
          return super.parseClassProperty(node);
        }
        parseClassPrivateProperty(node) {
          if (node.abstract) {
            this.raise(TSErrors.PrivateElementHasAbstract, {
              at: node
            });
          }
          if (node.accessibility) {
            this.raise(TSErrors.PrivateElementHasAccessibility, {
              at: node,
              modifier: node.accessibility
            });
          }
          this.parseClassPropertyAnnotation(node);
          return super.parseClassPrivateProperty(node);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters && isConstructor) {
            this.raise(TSErrors.ConstructorHasTypeParameters, {
              at: typeParameters
            });
          }
          const {
            declare = false,
            kind
          } = method;
          if (declare && (kind === "get" || kind === "set")) {
            this.raise(TSErrors.DeclareAccessor, {
              at: method,
              kind
            });
          }
          if (typeParameters) method.typeParameters = typeParameters;
          super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) method.typeParameters = typeParameters;
          super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
        }
        declareClassPrivateMethodInScope(node, kind) {
          if (node.type === "TSDeclareMethod") return;
          if (node.type === "MethodDefinition" && !node.value.body) return;
          super.declareClassPrivateMethodInScope(node, kind);
        }
        parseClassSuper(node) {
          super.parseClassSuper(node);
          if (node.superClass && (this.match(47) || this.match(51))) {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
          if (this.eatContextual(110)) {
            node.implements = this.tsParseHeritageClause("implements");
          }
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) prop.typeParameters = typeParameters;
          return super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        }
        parseFunctionParams(node, allowModifiers) {
          const typeParameters = this.tsTryParseTypeParameters();
          if (typeParameters) node.typeParameters = typeParameters;
          super.parseFunctionParams(node, allowModifiers);
        }
        parseVarId(decl, kind) {
          super.parseVarId(decl, kind);
          if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
            decl.definite = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            decl.id.typeAnnotation = type;
            this.resetEndLocation(decl.id);
          }
        }
        parseAsyncArrowFromCallExpression(node, call) {
          if (this.match(14)) {
            node.returnType = this.tsParseTypeAnnotation();
          }
          return super.parseAsyncArrowFromCallExpression(node, call);
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
          let state;
          let jsx2;
          let typeCast;
          if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
            state = this.state.clone();
            jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!jsx2.error) return jsx2.node;
            const {
              context: context3
            } = this.state;
            const currentContext = context3[context3.length - 1];
            if (currentContext === types.j_oTag || currentContext === types.j_expr) {
              context3.pop();
            }
          }
          if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          }
          if (!state || state === this.state) state = this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _expr$extra, _typeParameters;
            typeParameters = this.tsParseTypeParameters();
            const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
              abort();
            }
            if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
              this.resetStartLocationFromNode(expr, typeParameters);
            }
            expr.typeParameters = typeParameters;
            return expr;
          }, state);
          if (!arrow.error && !arrow.aborted) {
            if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if (!jsx2) {
            assert(!this.hasPlugin("jsx"));
            typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
            if (!typeCast.error) return typeCast.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrow.node) {
            this.state = arrow.failState;
            if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
            return arrow.node;
          }
          if ((_typeCast = typeCast) != null && _typeCast.node) {
            this.state = typeCast.failState;
            return typeCast.node;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
          if (arrow.thrown) throw arrow.error;
          if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;
          throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
        }
        reportReservedArrowTypeParam(node) {
          var _node$extra;
          if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
            this.raise(TSErrors.ReservedArrowTypeParam, {
              at: node
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          if (!this.hasPlugin("jsx") && this.match(47)) {
            return this.tsParseTypeAssertion();
          } else {
            return super.parseMaybeUnary(refExpressionErrors, sawUnary);
          }
        }
        parseArrow(node) {
          if (this.match(14)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
              if (this.canInsertSemicolon() || !this.match(19)) abort();
              return returnType;
            });
            if (result.aborted) return;
            if (!result.thrown) {
              if (result.error) this.state = result.failState;
              node.returnType = result.node;
            }
          }
          return super.parseArrow(node);
        }
        parseAssignableListItemTypes(param) {
          if (this.eat(17)) {
            if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
              this.raise(TSErrors.PatternIsOptional, {
                at: param
              });
            }
            param.optional = true;
          }
          const type = this.tsTryParseTypeAnnotation();
          if (type) param.typeAnnotation = type;
          this.resetEndLocation(param);
          return param;
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "TSTypeCastExpression":
              return this.isAssignable(node.expression, isBinding);
            case "TSParameterProperty":
              return true;
            default:
              return super.isAssignable(node, isBinding);
          }
        }
        toAssignable(node, isLHS = false) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.toAssignableParenthesizedExpression(node, isLHS);
              break;
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
              if (isLHS) {
                this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  at: node
                });
              }
              this.toAssignable(node.expression, isLHS);
              break;
            case "AssignmentExpression":
              if (!isLHS && node.left.type === "TSTypeCastExpression") {
                node.left = this.typeCastToParameter(node.left);
              }
            default:
              super.toAssignable(node, isLHS);
          }
        }
        toAssignableParenthesizedExpression(node, isLHS) {
          switch (node.expression.type) {
            case "TSAsExpression":
            case "TSNonNullExpression":
            case "TSTypeAssertion":
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isLHS);
              break;
            default:
              super.toAssignable(node, isLHS);
          }
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "TSAsExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              this.checkToRestConversion(node.expression, false);
              break;
            default:
              super.checkToRestConversion(node, allowPattern);
          }
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn$1({
            TSTypeCastExpression: true,
            TSParameterProperty: "parameter",
            TSNonNullExpression: "expression",
            TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true],
            TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && ["expression", true]
          }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 78:
              return this.parseIdentifier(true);
            default:
              return super.parseBindingAtom();
          }
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
              const call = super.parseMaybeDecoratorArguments(expr);
              call.typeParameters = typeArguments;
              return call;
            }
            this.unexpected(null, 10);
          }
          return super.parseMaybeDecoratorArguments(expr);
        }
        checkCommaAfterRest(close) {
          if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
            this.next();
            return false;
          } else {
            return super.checkCommaAfterRest(close);
          }
        }
        isClassMethod() {
          return this.match(47) || super.isClassMethod();
        }
        isClassProperty() {
          return this.match(35) || this.match(14) || super.isClassProperty();
        }
        parseMaybeDefault(startPos, startLoc, left) {
          const node = super.parseMaybeDefault(startPos, startLoc, left);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(TSErrors.TypeAnnotationAfterAssign, {
              at: node.typeAnnotation
            });
          }
          return node;
        }
        getTokenFromCode(code) {
          if (this.state.inType) {
            if (code === 62) {
              return this.finishOp(48, 1);
            }
            if (code === 60) {
              return this.finishOp(47, 1);
            }
          }
          return super.getTokenFromCode(code);
        }
        reScan_lt_gt() {
          const {
            type
          } = this.state;
          if (type === 47) {
            this.state.pos -= 1;
            this.readToken_lt();
          } else if (type === 48) {
            this.state.pos -= 1;
            this.readToken_gt();
          }
        }
        reScan_lt() {
          const {
            type
          } = this.state;
          if (type === 51) {
            this.state.pos -= 2;
            this.finishOp(47, 1);
            return 47;
          }
          return type;
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          for (let i4 = 0; i4 < exprList.length; i4++) {
            const expr = exprList[i4];
            if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
              exprList[i4] = this.typeCastToParameter(expr);
            }
          }
          super.toAssignableList(exprList, trailingCommaLoc, isLHS);
        }
        typeCastToParameter(node) {
          node.expression.typeAnnotation = node.typeAnnotation;
          this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
          return node.expression;
        }
        shouldParseArrow(params) {
          if (this.match(14)) {
            return params.every((expr) => this.isAssignable(expr, true));
          }
          return super.shouldParseArrow(params);
        }
        shouldParseAsyncArrow() {
          return this.match(14) || super.shouldParseAsyncArrow();
        }
        canHaveLeadingDecorator() {
          return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }
        jsxParseOpeningElementAfterName(node) {
          if (this.match(47) || this.match(51)) {
            const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            if (typeArguments) node.typeParameters = typeArguments;
          }
          return super.jsxParseOpeningElementAfterName(node);
        }
        getGetterSetterExpectedParamCount(method) {
          const baseCount = super.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          const firstParam = params[0];
          const hasContextParam = firstParam && this.isThisParam(firstParam);
          return hasContextParam ? baseCount + 1 : baseCount;
        }
        parseCatchClauseParam() {
          const param = super.parseCatchClauseParam();
          const type = this.tsTryParseTypeAnnotation();
          if (type) {
            param.typeAnnotation = type;
            this.resetEndLocation(param);
          }
          return param;
        }
        tsInAmbientContext(cb) {
          const oldIsAmbientContext = this.state.isAmbientContext;
          this.state.isAmbientContext = true;
          try {
            return cb();
          } finally {
            this.state.isAmbientContext = oldIsAmbientContext;
          }
        }
        parseClass(node, isStatement, optionalId) {
          const oldInAbstractClass = this.state.inAbstractClass;
          this.state.inAbstractClass = !!node.abstract;
          try {
            return super.parseClass(node, isStatement, optionalId);
          } finally {
            this.state.inAbstractClass = oldInAbstractClass;
          }
        }
        tsParseAbstractDeclaration(node) {
          if (this.match(80)) {
            node.abstract = true;
            return this.parseClass(node, true, false);
          } else if (this.isContextual(125)) {
            if (!this.hasFollowingLineBreak()) {
              node.abstract = true;
              this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                at: node
              });
              return this.tsParseInterfaceDeclaration(node);
            }
          } else {
            this.unexpected(null, 80);
          }
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
          const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
          if (method.abstract) {
            const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
            if (hasBody) {
              const {
                key
              } = method;
              this.raise(TSErrors.AbstractMethodHasImplementation, {
                at: method,
                methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
              });
            }
          }
          return method;
        }
        tsParseTypeParameterName() {
          const typeName = this.parseIdentifier();
          return typeName.name;
        }
        shouldParseAsAmbientContext() {
          return !!this.getPluginOption("typescript", "dts");
        }
        parse() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.parse();
        }
        getExpression() {
          if (this.shouldParseAsAmbientContext()) {
            this.state.isAmbientContext = true;
          }
          return super.getExpression();
        }
        parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly) {
          if (!isString2 && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
            return this.finishNode(node, "ExportSpecifier");
          }
          node.exportKind = "value";
          return super.parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly);
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (!importedIsString && isMaybeTypeOnly) {
            this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
            return this.finishNode(specifier, "ImportSpecifier");
          }
          specifier.importKind = "value";
          return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
        }
        parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
          const leftOfAsKey = isImport ? "imported" : "local";
          const rightOfAsKey = isImport ? "local" : "exported";
          let leftOfAs = node[leftOfAsKey];
          let rightOfAs;
          let hasTypeSpecifier = false;
          let canParseAsKeyword = true;
          const loc = leftOfAs.loc.start;
          if (this.isContextual(93)) {
            const firstAs = this.parseIdentifier();
            if (this.isContextual(93)) {
              const secondAs = this.parseIdentifier();
              if (tokenIsKeywordOrIdentifier(this.state.type)) {
                hasTypeSpecifier = true;
                leftOfAs = firstAs;
                rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
                canParseAsKeyword = false;
              } else {
                rightOfAs = secondAs;
                canParseAsKeyword = false;
              }
            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
              canParseAsKeyword = false;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
            } else {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            hasTypeSpecifier = true;
            if (isImport) {
              leftOfAs = this.parseIdentifier(true);
              if (!this.isContextual(93)) {
                this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
              }
            } else {
              leftOfAs = this.parseModuleExportName();
            }
          }
          if (hasTypeSpecifier && isInTypeOnlyImportExport) {
            this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
              at: loc
            });
          }
          node[leftOfAsKey] = leftOfAs;
          node[rightOfAsKey] = rightOfAs;
          const kindKey = isImport ? "importKind" : "exportKind";
          node[kindKey] = hasTypeSpecifier ? "type" : "value";
          if (canParseAsKeyword && this.eatContextual(93)) {
            node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          }
          if (!node[rightOfAsKey]) {
            node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
          }
          if (isImport) {
            this.checkIdentifier(node[rightOfAsKey], BIND_LEXICAL);
          }
        }
      };
      function isPossiblyLiteralEnum(expression) {
        if (expression.type !== "MemberExpression") return false;
        const {
          computed,
          property
        } = expression;
        if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
          return false;
        }
        return isUncomputedMemberExpressionChain(expression.object);
      }
      function isUncomputedMemberExpressionChain(expression) {
        if (expression.type === "Identifier") return true;
        if (expression.type !== "MemberExpression") return false;
        if (expression.computed) return false;
        return isUncomputedMemberExpressionChain(expression.object);
      }
      var PlaceholderErrors = ParseErrorEnum`placeholders`({
        ClassNameIsRequired: "A class name is required.",
        UnexpectedSpace: "Unexpected space in placeholder."
      });
      var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
        parsePlaceholder(expectedNode) {
          if (this.match(140)) {
            const node = this.startNode();
            this.next();
            this.assertNoSpace();
            node.name = super.parseIdentifier(true);
            this.assertNoSpace();
            this.expect(140);
            return this.finishPlaceholder(node, expectedNode);
          }
        }
        finishPlaceholder(node, expectedNode) {
          const isFinished = !!(node.expectedNode && node.type === "Placeholder");
          node.expectedNode = expectedNode;
          return isFinished ? node : this.finishNode(node, "Placeholder");
        }
        getTokenFromCode(code) {
          if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
            return this.finishOp(140, 2);
          }
          return super.getTokenFromCode(code);
        }
        parseExprAtom(refExpressionErrors) {
          return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
        }
        parseIdentifier(liberal) {
          return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word !== void 0) {
            super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
        }
        parseBindingAtom() {
          return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
        }
        isValidLVal(type, isParenthesized, binding) {
          return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
        }
        toAssignable(node, isLHS) {
          if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
            node.expectedNode = "Pattern";
          } else {
            super.toAssignable(node, isLHS);
          }
        }
        isLet(context3) {
          if (super.isLet(context3)) {
            return true;
          }
          if (!this.isContextual(99)) {
            return false;
          }
          if (context3) return false;
          const nextToken = this.lookahead();
          if (nextToken.type === 140) {
            return true;
          }
          return false;
        }
        verifyBreakContinue(node, isBreak) {
          if (node.label && node.label.type === "Placeholder") return;
          super.verifyBreakContinue(node, isBreak);
        }
        parseExpressionStatement(node, expr) {
          if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
            return super.parseExpressionStatement(node, expr);
          }
          if (this.match(14)) {
            const stmt = node;
            stmt.label = this.finishPlaceholder(expr, "Identifier");
            this.next();
            stmt.body = super.parseStatement("label");
            return this.finishNode(stmt, "LabeledStatement");
          }
          this.semicolon();
          node.name = expr.name;
          return this.finishPlaceholder(node, "Statement");
        }
        parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
          return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
        }
        parseFunctionId(requireId) {
          return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
        }
        parseClass(node, isStatement, optionalId) {
          const type = isStatement ? "ClassDeclaration" : "ClassExpression";
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.state.strict;
          const placeholder = this.parsePlaceholder("Identifier");
          if (placeholder) {
            if (this.match(81) || this.match(140) || this.match(5)) {
              node.id = placeholder;
            } else if (optionalId || !isStatement) {
              node.id = null;
              node.body = this.finishPlaceholder(placeholder, "ClassBody");
              return this.finishNode(node, type);
            } else {
              throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                at: this.state.startLoc
              });
            }
          } else {
            this.parseClassId(node, isStatement, optionalId);
          }
          super.parseClassSuper(node);
          node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, type);
        }
        parseExport(node) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return super.parseExport(node);
          if (!this.isContextual(97) && !this.match(12)) {
            node.specifiers = [];
            node.source = null;
            node.declaration = this.finishPlaceholder(placeholder, "Declaration");
            return this.finishNode(node, "ExportNamedDeclaration");
          }
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = placeholder;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return super.parseExport(node);
        }
        isExportDefaultSpecifier() {
          if (this.match(65)) {
            const next2 = this.nextTokenStart();
            if (this.isUnparsedContextual(next2, "from")) {
              if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next2 + 4))) {
                return true;
              }
            }
          }
          return super.isExportDefaultSpecifier();
        }
        maybeParseExportDefaultSpecifier(node) {
          if (node.specifiers && node.specifiers.length > 0) {
            return true;
          }
          return super.maybeParseExportDefaultSpecifier(node);
        }
        checkExport(node) {
          const {
            specifiers
          } = node;
          if (specifiers != null && specifiers.length) {
            node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
          }
          super.checkExport(node);
          node.specifiers = specifiers;
        }
        parseImport(node) {
          const placeholder = this.parsePlaceholder("Identifier");
          if (!placeholder) return super.parseImport(node);
          node.specifiers = [];
          if (!this.isContextual(97) && !this.match(12)) {
            node.source = this.finishPlaceholder(placeholder, "StringLiteral");
            this.semicolon();
            return this.finishNode(node, "ImportDeclaration");
          }
          const specifier = this.startNodeAtNode(placeholder);
          specifier.local = placeholder;
          node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
          if (this.eat(12)) {
            const hasStarImport = this.maybeParseStarImportSpecifier(node);
            if (!hasStarImport) this.parseNamedImportSpecifiers(node);
          }
          this.expectContextual(97);
          node.source = this.parseImportSource();
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
        }
        assertNoSpace() {
          if (this.state.start > this.state.lastTokEndLoc.index) {
            this.raise(PlaceholderErrors.UnexpectedSpace, {
              at: this.state.lastTokEndLoc
            });
          }
        }
      };
      var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
        parseV8Intrinsic() {
          if (this.match(54)) {
            const v8IntrinsicStartLoc = this.state.startLoc;
            const node = this.startNode();
            this.next();
            if (tokenIsIdentifier(this.state.type)) {
              const name = this.parseIdentifierName(this.state.start);
              const identifier = this.createIdentifier(node, name);
              identifier.type = "V8IntrinsicIdentifier";
              if (this.match(10)) {
                return identifier;
              }
            }
            this.unexpected(v8IntrinsicStartLoc);
          }
        }
        parseExprAtom(refExpressionErrors) {
          return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
        }
      };
      function hasPlugin(plugins, expectedConfig) {
        const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
        const expectedKeys = Object.keys(expectedOptions);
        const expectedOptionsIsEmpty = expectedKeys.length === 0;
        return plugins.some((p2) => {
          if (typeof p2 === "string") {
            return expectedOptionsIsEmpty && p2 === expectedName;
          } else {
            const [pluginName, pluginOptions] = p2;
            if (pluginName !== expectedName) {
              return false;
            }
            for (const key of expectedKeys) {
              if (pluginOptions[key] !== expectedOptions[key]) {
                return false;
              }
            }
            return true;
          }
        });
      }
      function getPluginOption(plugins, name, option2) {
        const plugin = plugins.find((plugin2) => {
          if (Array.isArray(plugin2)) {
            return plugin2[0] === name;
          } else {
            return plugin2 === name;
          }
        });
        if (plugin && Array.isArray(plugin)) {
          return plugin[1][option2];
        }
        return null;
      }
      var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
      var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
      var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
      function validatePlugins(plugins) {
        if (hasPlugin(plugins, "decorators")) {
          if (hasPlugin(plugins, "decorators-legacy")) {
            throw new Error("Cannot use the decorators and decorators-legacy plugin together");
          }
          const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
          if (decoratorsBeforeExport == null) {
            throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
          } else if (typeof decoratorsBeforeExport !== "boolean") {
            throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
        }
        if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
          throw new Error("Cannot combine flow and typescript plugins.");
        }
        if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
          throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        }
        if (hasPlugin(plugins, "pipelineOperator")) {
          const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
          if (!PIPELINE_PROPOSALS.includes(proposal)) {
            const proposalList = PIPELINE_PROPOSALS.map((p2) => `"${p2}"`).join(", ");
            throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
          }
          const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
            syntaxType: "hash"
          }]);
          if (proposal === "hack") {
            if (hasPlugin(plugins, "placeholders")) {
              throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
            }
            if (hasPlugin(plugins, "v8intrinsic")) {
              throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
            }
            const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
            if (!TOPIC_TOKENS.includes(topicToken)) {
              const tokenList = TOPIC_TOKENS.map((t3) => `"${t3}"`).join(", ");
              throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
            }
            if (topicToken === "#" && tupleSyntaxIsHash) {
              throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
          } else if (proposal === "smart" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        }
        if (hasPlugin(plugins, "moduleAttributes")) {
          {
            if (hasPlugin(plugins, "importAssertions")) {
              throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
            }
            const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
            if (moduleAttributesVersionPluginOption !== "may-2020") {
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
          }
        }
        if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
          throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p2) => `'${p2}'`).join(", "));
        }
        if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
          const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          error.missingPlugins = "doExpressions";
          throw error;
        }
      }
      var mixinPlugins = {
        estree,
        jsx,
        flow,
        typescript,
        v8intrinsic,
        placeholders
      };
      var mixinPluginNames = Object.keys(mixinPlugins);
      var defaultOptions = {
        sourceType: "script",
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true
      };
      function getOptions(opts) {
        const options = {};
        for (const key of Object.keys(defaultOptions)) {
          options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
        }
        return options;
      }
      var getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];
      var unwrapParenthesizedExpression = (node) => {
        return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
      };
      var LValParser = class extends NodeUtils {
        toAssignable(node, isLHS = false) {
          var _node$extra, _node$extra3;
          let parenthesized = void 0;
          if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
            parenthesized = unwrapParenthesizedExpression(node);
            if (isLHS) {
              if (parenthesized.type === "Identifier") {
                this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              } else if (parenthesized.type !== "MemberExpression") {
                this.raise(Errors.InvalidParenthesizedAssignment, {
                  at: node
                });
              }
            } else {
              this.raise(Errors.InvalidParenthesizedAssignment, {
                at: node
              });
            }
          }
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              for (let i4 = 0, length = node.properties.length, last = length - 1; i4 < length; i4++) {
                var _node$extra2;
                const prop = node.properties[i4];
                const isLast = i4 === last;
                this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
                if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                  this.raise(Errors.RestTrailingComma, {
                    at: node.extra.trailingCommaLoc
                  });
                }
              }
              break;
            case "ObjectProperty": {
              const {
                key,
                value
              } = node;
              if (this.isPrivateName(key)) {
                this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
              }
              this.toAssignable(value, isLHS);
              break;
            }
            case "SpreadElement": {
              throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
            }
            case "ArrayExpression":
              node.type = "ArrayPattern";
              this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(Errors.MissingEqInAssignment, {
                  at: node.left.loc.end
                });
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isLHS);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(parenthesized, isLHS);
              break;
          }
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          if (prop.type === "ObjectMethod") {
            this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
              at: prop.key
            });
          } else if (prop.type === "SpreadElement") {
            prop.type = "RestElement";
            const arg = prop.argument;
            this.checkToRestConversion(arg, false);
            this.toAssignable(arg, isLHS);
            if (!isLast) {
              this.raise(Errors.RestTrailingComma, {
                at: prop
              });
            }
          } else {
            this.toAssignable(prop, isLHS);
          }
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          const end = exprList.length - 1;
          for (let i4 = 0; i4 <= end; i4++) {
            const elt = exprList[i4];
            if (!elt) continue;
            if (elt.type === "SpreadElement") {
              elt.type = "RestElement";
              const arg = elt.argument;
              this.checkToRestConversion(arg, true);
              this.toAssignable(arg, isLHS);
            } else {
              this.toAssignable(elt, isLHS);
            }
            if (elt.type === "RestElement") {
              if (i4 < end) {
                this.raise(Errors.RestTrailingComma, {
                  at: elt
                });
              } else if (trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, {
                  at: trailingCommaLoc
                });
              }
            }
          }
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              return true;
            case "ObjectExpression": {
              const last = node.properties.length - 1;
              return node.properties.every((prop, i4) => {
                return prop.type !== "ObjectMethod" && (i4 === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
              });
            }
            case "ObjectProperty":
              return this.isAssignable(node.value);
            case "SpreadElement":
              return this.isAssignable(node.argument);
            case "ArrayExpression":
              return node.elements.every((element) => element === null || this.isAssignable(element));
            case "AssignmentExpression":
              return node.operator === "=";
            case "ParenthesizedExpression":
              return this.isAssignable(node.expression);
            case "MemberExpression":
            case "OptionalMemberExpression":
              return !isBinding;
            default:
              return false;
          }
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          return exprList;
        }
        toReferencedListDeep(exprList, isParenthesizedExpr) {
          this.toReferencedList(exprList, isParenthesizedExpr);
          for (const expr of exprList) {
            if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
              this.toReferencedListDeep(expr.elements);
            }
          }
        }
        parseSpread(refExpressionErrors) {
          const node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
          return this.finishNode(node, "SpreadElement");
        }
        parseRestBinding() {
          const node = this.startNode();
          this.next();
          node.argument = this.parseBindingAtom();
          return this.finishNode(node, "RestElement");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case 0: {
              const node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(3, 93, true);
              return this.finishNode(node, "ArrayPattern");
            }
            case 5:
              return this.parseObjectLike(8, true);
          }
          return this.parseIdentifier();
        }
        parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
            }
            if (allowEmpty && this.match(12)) {
              elts.push(null);
            } else if (this.eat(close)) {
              break;
            } else if (this.match(21)) {
              elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
              if (!this.checkCommaAfterRest(closeCharCode)) {
                this.expect(close);
                break;
              }
            } else {
              const decorators = [];
              if (this.match(26) && this.hasPlugin("decorators")) {
                this.raise(Errors.UnsupportedParameterDecorator, {
                  at: this.state.startLoc
                });
              }
              while (this.match(26)) {
                decorators.push(this.parseDecorator());
              }
              elts.push(this.parseAssignableListItem(allowModifiers, decorators));
            }
          }
          return elts;
        }
        parseBindingRestProperty(prop) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }
        parseBindingProperty() {
          const prop = this.startNode();
          const {
            type,
            start: startPos,
            startLoc
          } = this.state;
          if (type === 21) {
            return this.parseBindingRestProperty(prop);
          } else if (type === 134) {
            this.expectPlugin("destructuringPrivate", startLoc);
            this.classScope.usePrivateName(this.state.value, startLoc);
            prop.key = this.parsePrivateName();
          } else {
            this.parsePropertyName(prop);
          }
          prop.method = false;
          return this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          if (decorators.length) {
            left.decorators = decorators;
          }
          return elt;
        }
        parseAssignableListItemTypes(param) {
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          var _startLoc, _startPos, _left;
          startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
          startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
          left = (_left = left) != null ? _left : this.parseBindingAtom();
          if (!this.eat(29)) return left;
          const node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.right = this.parseMaybeAssignAllowIn();
          return this.finishNode(node, "AssignmentPattern");
        }
        isValidLVal(type, isUnparenthesizedInAssign, binding) {
          return getOwn({
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
          }, type);
        }
        checkLVal(expression, {
          in: ancestor,
          binding = BIND_NONE,
          checkClashes = false,
          strictModeChanged = false,
          allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),
          hasParenthesizedAncestor = false
        }) {
          var _expression$extra;
          const type = expression.type;
          if (this.isObjectMethod(expression)) return;
          if (type === "MemberExpression") {
            if (binding !== BIND_NONE) {
              this.raise(Errors.InvalidPropertyBindingPattern, {
                at: expression
              });
            }
            return;
          }
          if (expression.type === "Identifier") {
            this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);
            const {
              name
            } = expression;
            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(Errors.ParamDupe, {
                  at: expression
                });
              } else {
                checkClashes.add(name);
              }
            }
            return;
          }
          const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
          if (validity === true) return;
          if (validity === false) {
            const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            this.raise(ParseErrorClass, {
              at: expression,
              ancestor: ancestor.type === "UpdateExpression" ? {
                type: "UpdateExpression",
                prefix: ancestor.prefix
              } : {
                type: ancestor.type
              }
            });
            return;
          }
          const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
          const nextAncestor = expression.type === "ArrayPattern" || expression.type === "ObjectPattern" || expression.type === "ParenthesizedExpression" ? expression : ancestor;
          for (const child of [].concat(expression[key])) {
            if (child) {
              this.checkLVal(child, {
                in: nextAncestor,
                binding,
                checkClashes,
                allowingSloppyLetBinding,
                strictModeChanged,
                hasParenthesizedAncestor: isParenthesizedExpression
              });
            }
          }
        }
        checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
            if (bindingType === BIND_NONE) {
              this.raise(Errors.StrictEvalArguments, {
                at,
                referenceName: at.name
              });
            } else {
              this.raise(Errors.StrictEvalArgumentsBinding, {
                at,
                bindingName: at.name
              });
            }
          }
          if (!allowLetBinding && at.name === "let") {
            this.raise(Errors.LetInLexicalBinding, {
              at
            });
          }
          if (!(bindingType & BIND_NONE)) {
            this.declareNameFromIdentifier(at, bindingType);
          }
        }
        declareNameFromIdentifier(identifier, binding) {
          this.scope.declareName(identifier.name, binding, identifier.loc.start);
        }
        checkToRestConversion(node, allowPattern) {
          switch (node.type) {
            case "ParenthesizedExpression":
              this.checkToRestConversion(node.expression, allowPattern);
              break;
            case "Identifier":
            case "MemberExpression":
              break;
            case "ArrayExpression":
            case "ObjectExpression":
              if (allowPattern) break;
            default:
              this.raise(Errors.InvalidRestAssignmentPattern, {
                at: node
              });
          }
        }
        checkCommaAfterRest(close) {
          if (!this.match(12)) {
            return false;
          }
          this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
            at: this.state.startLoc
          });
          return true;
        }
      };
      var ExpressionParser = class extends LValParser {
        checkProto(prop, isRecord, protoRef, refExpressionErrors) {
          if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
            return;
          }
          const key = prop.key;
          const name = key.type === "Identifier" ? key.name : key.value;
          if (name === "__proto__") {
            if (isRecord) {
              this.raise(Errors.RecordNoProto, {
                at: key
              });
              return;
            }
            if (protoRef.used) {
              if (refExpressionErrors) {
                if (refExpressionErrors.doubleProtoLoc === null) {
                  refExpressionErrors.doubleProtoLoc = key.loc.start;
                }
              } else {
                this.raise(Errors.DuplicateProto, {
                  at: key
                });
              }
            }
            protoRef.used = true;
          }
        }
        shouldExitDescending(expr, potentialArrowAt) {
          return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
        }
        getExpression() {
          this.enterInitialScopes();
          this.nextToken();
          const expr = this.parseExpression();
          if (!this.match(135)) {
            this.unexpected();
          }
          this.finalizeRemainingComments();
          expr.comments = this.state.comments;
          expr.errors = this.state.errors;
          if (this.options.tokens) {
            expr.tokens = this.tokens;
          }
          return expr;
        }
        parseExpression(disallowIn, refExpressionErrors) {
          if (disallowIn) {
            return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        parseExpressionBase(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const expr = this.parseMaybeAssign(refExpressionErrors);
          if (this.match(12)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.expressions = [expr];
            while (this.eat(12)) {
              node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            }
            this.toReferencedList(node.expressions);
            return this.finishNode(node, "SequenceExpression");
          }
          return expr;
        }
        parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
          return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
          return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
        }
        setOptionalParametersError(refExpressionErrors, resultError) {
          var _resultError$loc;
          refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          if (this.isContextual(105)) {
            if (this.prodParam.hasYield) {
              let left2 = this.parseYield();
              if (afterLeftParse) {
                left2 = afterLeftParse.call(this, left2, startPos, startLoc);
              }
              return left2;
            }
          }
          let ownExpressionErrors;
          if (refExpressionErrors) {
            ownExpressionErrors = false;
          } else {
            refExpressionErrors = new ExpressionErrors();
            ownExpressionErrors = true;
          }
          const {
            type
          } = this.state;
          if (type === 10 || tokenIsIdentifier(type)) {
            this.state.potentialArrowAt = this.state.start;
          }
          let left = this.parseMaybeConditional(refExpressionErrors);
          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }
          if (tokenIsAssignment(this.state.type)) {
            const node = this.startNodeAt(startPos, startLoc);
            const operator = this.state.value;
            node.operator = operator;
            if (this.match(29)) {
              this.toAssignable(left, true);
              node.left = left;
              if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
                refExpressionErrors.doubleProtoLoc = null;
              }
              if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {
                refExpressionErrors.shorthandAssignLoc = null;
              }
              if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
                this.checkDestructuringPrivate(refExpressionErrors);
                refExpressionErrors.privateKeyLoc = null;
              }
            } else {
              node.left = left;
            }
            this.next();
            node.right = this.parseMaybeAssign();
            this.checkLVal(left, {
              in: this.finishNode(node, "AssignmentExpression")
            });
            return node;
          } else if (ownExpressionErrors) {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          return left;
        }
        parseMaybeConditional(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprOps(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (this.eat(17)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssignAllowIn();
            this.expect(14);
            node.alternate = this.parseMaybeAssign();
            return this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        }
        parseMaybeUnaryOrPrivate(refExpressionErrors) {
          return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
        }
        parseExprOps(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseExprOp(expr, startPos, startLoc, -1);
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
              this.raise(Errors.PrivateInExpectedIn, {
                at: left,
                identifierName: value
              });
            }
            this.classScope.usePrivateName(value, left.loc.start);
          }
          const op = this.state.type;
          if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
              if (op === 39) {
                this.expectPlugin("pipelineOperator");
                if (this.state.inFSharpPipelineDirectBody) {
                  return left;
                }
                this.checkPipelineAtInfixOperator(left, leftStartLoc);
              }
              const node = this.startNodeAt(leftStartPos, leftStartLoc);
              node.left = left;
              node.operator = this.state.value;
              const logical = op === 41 || op === 42;
              const coalesce = op === 40;
              if (coalesce) {
                prec = tokenOperatorPrecedence(42);
              }
              this.next();
              if (op === 39 && this.hasPlugin(["pipelineOperator", {
                proposal: "minimal"
              }])) {
                if (this.state.type === 96 && this.prodParam.hasAwait) {
                  throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                    at: this.state.startLoc
                  });
                }
              }
              node.right = this.parseExprOpRightExpr(op, prec);
              const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
              const nextOp = this.state.type;
              if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
                throw this.raise(Errors.MixingCoalesceWithLogical, {
                  at: this.state.startLoc
                });
              }
              return this.parseExprOp(finishedNode, leftStartPos, leftStartLoc, minPrec);
            }
          }
          return left;
        }
        parseExprOpRightExpr(op, prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          switch (op) {
            case 39:
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => {
                    return this.parseHackPipeBody();
                  });
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(105)) {
                      throw this.raise(Errors.PipeBodyIsTighter, {
                        at: this.state.startLoc
                      });
                    }
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => {
                    return this.parseFSharpPipelineBody(prec);
                  });
              }
            default:
              return this.parseExprOpBaseRightExpr(op, prec);
          }
        }
        parseExprOpBaseRightExpr(op, prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
        }
        parseHackPipeBody() {
          var _body$extra;
          const {
            startLoc
          } = this.state;
          const body2 = this.parseMaybeAssign();
          const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body2.type);
          if (requiredParentheses && !((_body$extra = body2.extra) != null && _body$extra.parenthesized)) {
            this.raise(Errors.PipeUnparenthesizedBody, {
              at: startLoc,
              type: body2.type
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnused, {
              at: startLoc
            });
          }
          return body2;
        }
        checkExponentialAfterUnary(node) {
          if (this.match(57)) {
            this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
              at: node.argument
            });
          }
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const isAwait = this.isContextual(96);
          if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr2 = this.parseAwait(startPos, startLoc);
            if (!sawUnary) this.checkExponentialAfterUnary(expr2);
            return expr2;
          }
          const update = this.match(34);
          const node = this.startNode();
          if (tokenIsPrefix(this.state.type)) {
            node.operator = this.state.value;
            node.prefix = true;
            if (this.match(72)) {
              this.expectPlugin("throwExpressions");
            }
            const isDelete = this.match(89);
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refExpressionErrors, true);
            if (this.state.strict && isDelete) {
              const arg = node.argument;
              if (arg.type === "Identifier") {
                this.raise(Errors.StrictDelete, {
                  at: node
                });
              } else if (this.hasPropertyAsPrivateName(arg)) {
                this.raise(Errors.DeletePrivateField, {
                  at: node
                });
              }
            }
            if (!update) {
              if (!sawUnary) {
                this.checkExponentialAfterUnary(node);
              }
              return this.finishNode(node, "UnaryExpression");
            }
          }
          const expr = this.parseUpdate(node, update, refExpressionErrors);
          if (isAwait) {
            const {
              type
            } = this.state;
            const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
            if (startsExpr2 && !this.isAmbiguousAwait()) {
              this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
                at: startLoc
              });
              return this.parseAwait(startPos, startLoc);
            }
          }
          return expr;
        }
        parseUpdate(node, update, refExpressionErrors) {
          if (update) {
            const updateExpressionNode = node;
            this.checkLVal(updateExpressionNode.argument, {
              in: this.finishNode(updateExpressionNode, "UpdateExpression")
            });
            return node;
          }
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let expr = this.parseExprSubscripts(refExpressionErrors);
          if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
          while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
            const node2 = this.startNodeAt(startPos, startLoc);
            node2.operator = this.state.value;
            node2.prefix = false;
            node2.argument = expr;
            this.next();
            this.checkLVal(expr, {
              in: expr = this.finishNode(node2, "UpdateExpression")
            });
          }
          return expr;
        }
        parseExprSubscripts(refExpressionErrors) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const potentialArrowAt = this.state.potentialArrowAt;
          const expr = this.parseExprAtom(refExpressionErrors);
          if (this.shouldExitDescending(expr, potentialArrowAt)) {
            return expr;
          }
          return this.parseSubscripts(expr, startPos, startLoc);
        }
        parseSubscripts(base, startPos, startLoc, noCalls) {
          const state = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: false
          };
          do {
            base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
            state.maybeAsyncArrow = false;
          } while (!state.stop);
          return base;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          const {
            type
          } = this.state;
          if (!noCalls && type === 15) {
            return this.parseBind(base, startPos, startLoc, noCalls, state);
          } else if (tokenIsTemplate(type)) {
            return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
          }
          let optional = false;
          if (type === 18) {
            if (noCalls && this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
            state.optionalChainMember = optional = true;
            this.next();
          }
          if (!noCalls && this.match(10)) {
            return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
          } else {
            const computed = this.eat(0);
            if (computed || optional || this.eat(16)) {
              return this.parseMember(base, startPos, startLoc, state, computed, optional);
            } else {
              state.stop = true;
              return base;
            }
          }
        }
        parseMember(base, startPos, startLoc, state, computed, optional) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.computed = computed;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(3);
          } else if (this.match(134)) {
            if (base.type === "Super") {
              this.raise(Errors.SuperPrivateField, {
                at: startLoc
              });
            }
            this.classScope.usePrivateName(this.state.value, this.state.startLoc);
            node.property = this.parsePrivateName();
          } else {
            node.property = this.parseIdentifier(true);
          }
          if (state.optionalChainMember) {
            node.optional = optional;
            return this.finishNode(node, "OptionalMemberExpression");
          } else {
            return this.finishNode(node, "MemberExpression");
          }
        }
        parseBind(base, startPos, startLoc, noCalls, state) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          this.next();
          node.callee = this.parseNoCallExpr();
          state.stop = true;
          return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
        }
        parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          let refExpressionErrors = null;
          this.state.maybeInArrowParameters = true;
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const {
            maybeAsyncArrow,
            optionalChainMember
          } = state;
          if (maybeAsyncArrow) {
            this.expressionScope.enter(newAsyncArrowScope());
            refExpressionErrors = new ExpressionErrors();
          }
          if (optionalChainMember) {
            node.optional = optional;
          }
          if (optional) {
            node.arguments = this.parseCallExpressionArguments(11);
          } else {
            node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
          }
          let finishedNode = this.finishCallExpression(node, optionalChainMember);
          if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
            state.stop = true;
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), finishedNode);
          } else {
            if (maybeAsyncArrow) {
              this.checkExpressionErrors(refExpressionErrors, true);
              this.expressionScope.exit();
            }
            this.toReferencedArguments(finishedNode);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return finishedNode;
        }
        toReferencedArguments(node, isParenthesizedExpr) {
          this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
        }
        parseTaggedTemplateExpression(base, startPos, startLoc, state) {
          const node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate(true);
          if (state.optionalChainMember) {
            this.raise(Errors.OptionalChainingNoTemplate, {
              at: startLoc
            });
          }
          return this.finishNode(node, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(base) {
          return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
        }
        finishCallExpression(node, optional) {
          if (node.callee.type === "Import") {
            if (node.arguments.length === 2) {
              {
                if (!this.hasPlugin("moduleAttributes")) {
                  this.expectPlugin("importAssertions");
                }
              }
            }
            if (node.arguments.length === 0 || node.arguments.length > 2) {
              this.raise(Errors.ImportCallArity, {
                at: node,
                maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
              });
            } else {
              for (const arg of node.arguments) {
                if (arg.type === "SpreadElement") {
                  this.raise(Errors.ImportCallSpreadArgument, {
                    at: arg
                  });
                }
              }
            }
          }
          return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
          const elts = [];
          let first = true;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                  this.raise(Errors.ImportCallArgumentTrailingComma, {
                    at: this.state.lastTokStartLoc
                  });
                }
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
          }
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return elts;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(node, call) {
          var _call$extra;
          this.resetPreviousNodeTrailingComments(call);
          this.expect(19);
          this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
          if (call.innerComments) {
            setInnerComments(node, call.innerComments);
          }
          if (call.callee.trailingComments) {
            setInnerComments(node, call.callee.trailingComments);
          }
          return node;
        }
        parseNoCallExpr() {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        }
        parseExprAtom(refExpressionErrors) {
          let node;
          const {
            type
          } = this.state;
          switch (type) {
            case 79:
              return this.parseSuper();
            case 83:
              node = this.startNode();
              this.next();
              if (this.match(16)) {
                return this.parseImportMetaProperty(node);
              }
              if (!this.match(10)) {
                this.raise(Errors.UnsupportedImport, {
                  at: this.state.lastTokStartLoc
                });
              }
              return this.finishNode(node, "Import");
            case 78:
              node = this.startNode();
              this.next();
              return this.finishNode(node, "ThisExpression");
            case 90: {
              return this.parseDo(this.startNode(), false);
            }
            case 56:
            case 31: {
              this.readRegexp();
              return this.parseRegExpLiteral(this.state.value);
            }
            case 130:
              return this.parseNumericLiteral(this.state.value);
            case 131:
              return this.parseBigIntLiteral(this.state.value);
            case 132:
              return this.parseDecimalLiteral(this.state.value);
            case 129:
              return this.parseStringLiteral(this.state.value);
            case 84:
              return this.parseNullLiteral();
            case 85:
              return this.parseBooleanLiteral(true);
            case 86:
              return this.parseBooleanLiteral(false);
            case 10: {
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(canBeArrow);
            }
            case 2:
            case 1: {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
            }
            case 0: {
              return this.parseArrayLike(3, true, false, refExpressionErrors);
            }
            case 6:
            case 7: {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
            case 5: {
              return this.parseObjectLike(8, false, false, refExpressionErrors);
            }
            case 68:
              return this.parseFunctionOrFunctionSent();
            case 26:
              this.parseDecorators();
            case 80:
              node = this.startNode();
              this.takeDecorators(node);
              return this.parseClass(node, false);
            case 77:
              return this.parseNewOrNewTarget();
            case 25:
            case 24:
              return this.parseTemplate(false);
            case 15: {
              node = this.startNode();
              this.next();
              node.object = null;
              const callee = node.callee = this.parseNoCallExpr();
              if (callee.type === "MemberExpression") {
                return this.finishNode(node, "BindExpression");
              } else {
                throw this.raise(Errors.UnsupportedBind, {
                  at: callee
                });
              }
            }
            case 134: {
              this.raise(Errors.PrivateInExpectedIn, {
                at: this.state.startLoc,
                identifierName: this.state.value
              });
              return this.parsePrivateName();
            }
            case 33: {
              return this.parseTopicReferenceThenEqualsSign(54, "%");
            }
            case 32: {
              return this.parseTopicReferenceThenEqualsSign(44, "^");
            }
            case 37:
            case 38: {
              return this.parseTopicReference("hack");
            }
            case 44:
            case 54:
            case 27: {
              const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
              if (pipeProposal) {
                return this.parseTopicReference(pipeProposal);
              } else {
                throw this.unexpected();
              }
            }
            case 47: {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                this.expectOnePlugin(["jsx", "flow", "typescript"]);
                break;
              } else {
                throw this.unexpected();
              }
            }
            default:
              if (tokenIsIdentifier(type)) {
                if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
                  return this.parseModuleExpression();
                }
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                const containsEsc = this.state.containsEsc;
                const id = this.parseIdentifier();
                if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                  const {
                    type: type2
                  } = this.state;
                  if (type2 === 68) {
                    this.resetPreviousNodeTrailingComments(id);
                    this.next();
                    return this.parseFunction(this.startNodeAtNode(id), void 0, true);
                  } else if (tokenIsIdentifier(type2)) {
                    if (this.lookaheadCharCode() === 61) {
                      return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                    } else {
                      return id;
                    }
                  } else if (type2 === 90) {
                    this.resetPreviousNodeTrailingComments(id);
                    return this.parseDo(this.startNodeAtNode(id), true);
                  }
                }
                if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                  this.next();
                  return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
                }
                return id;
              } else {
                throw this.unexpected();
              }
          }
        }
        parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) {
            this.state.type = topicTokenType;
            this.state.value = topicTokenValue;
            this.state.pos--;
            this.state.end--;
            this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
            return this.parseTopicReference(pipeProposal);
          } else {
            throw this.unexpected();
          }
        }
        parseTopicReference(pipeProposal) {
          const node = this.startNode();
          const startLoc = this.state.startLoc;
          const tokenType = this.state.type;
          this.next();
          return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
        }
        finishTopicReference(node, startLoc, pipeProposal, tokenType) {
          if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
                at: startLoc
              });
            }
            this.registerTopicReference();
            return this.finishNode(node, nodeType);
          } else {
            throw this.raise(Errors.PipeTopicUnconfiguredToken, {
              at: startLoc,
              token: tokenLabelName(tokenType)
            });
          }
        }
        testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
          switch (pipeProposal) {
            case "hack": {
              return this.hasPlugin(["pipelineOperator", {
                topicToken: tokenLabelName(tokenType)
              }]);
            }
            case "smart":
              return tokenType === 27;
            default:
              throw this.raise(Errors.PipeTopicRequiresHackPipes, {
                at: startLoc
              });
          }
        }
        parseAsyncArrowUnaryFunction(node) {
          this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
          const params = [this.parseIdentifier()];
          this.prodParam.exit();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.LineTerminatorBeforeArrow, {
              at: this.state.curPosition()
            });
          }
          this.expect(19);
          return this.parseArrowExpression(node, params, true);
        }
        parseDo(node, isAsync) {
          this.expectPlugin("doExpressions");
          if (isAsync) {
            this.expectPlugin("asyncDoExpressions");
          }
          node.async = isAsync;
          this.next();
          const oldLabels = this.state.labels;
          this.state.labels = [];
          if (isAsync) {
            this.prodParam.enter(PARAM_AWAIT);
            node.body = this.parseBlock();
            this.prodParam.exit();
          } else {
            node.body = this.parseBlock();
          }
          this.state.labels = oldLabels;
          return this.finishNode(node, "DoExpression");
        }
        parseSuper() {
          const node = this.startNode();
          this.next();
          if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.SuperNotAllowed, {
              at: node
            });
          } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
            this.raise(Errors.UnexpectedSuper, {
              at: node
            });
          }
          if (!this.match(10) && !this.match(0) && !this.match(16)) {
            this.raise(Errors.UnsupportedSuper, {
              at: node
            });
          }
          return this.finishNode(node, "Super");
        }
        parsePrivateName() {
          const node = this.startNode();
          const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1));
          const name = this.state.value;
          this.next();
          node.id = this.createIdentifier(id, name);
          return this.finishNode(node, "PrivateName");
        }
        parseFunctionOrFunctionSent() {
          const node = this.startNode();
          this.next();
          if (this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
            this.next();
            if (this.match(102)) {
              this.expectPlugin("functionSent");
            } else if (!this.hasPlugin("functionSent")) {
              this.unexpected();
            }
            return this.parseMetaProperty(node, meta, "sent");
          }
          return this.parseFunction(node);
        }
        parseMetaProperty(node, meta, propertyName) {
          node.meta = meta;
          const containsEsc = this.state.containsEsc;
          node.property = this.parseIdentifier(true);
          if (node.property.name !== propertyName || containsEsc) {
            this.raise(Errors.UnsupportedMetaProperty, {
              at: node.property,
              target: meta.name,
              onlyValidPropertyName: propertyName
            });
          }
          return this.finishNode(node, "MetaProperty");
        }
        parseImportMetaProperty(node) {
          const id = this.createIdentifier(this.startNodeAtNode(node), "import");
          this.next();
          if (this.isContextual(100)) {
            if (!this.inModule) {
              this.raise(Errors.ImportMetaOutsideModule, {
                at: id
              });
            }
            this.sawUnambiguousESM = true;
          }
          return this.parseMetaProperty(node, id, "meta");
        }
        parseLiteralAtNode(value, type, node) {
          this.addExtra(node, "rawValue", value);
          this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
          node.value = value;
          this.next();
          return this.finishNode(node, type);
        }
        parseLiteral(value, type) {
          const node = this.startNode();
          return this.parseLiteralAtNode(value, type, node);
        }
        parseStringLiteral(value) {
          return this.parseLiteral(value, "StringLiteral");
        }
        parseNumericLiteral(value) {
          return this.parseLiteral(value, "NumericLiteral");
        }
        parseBigIntLiteral(value) {
          return this.parseLiteral(value, "BigIntLiteral");
        }
        parseDecimalLiteral(value) {
          return this.parseLiteral(value, "DecimalLiteral");
        }
        parseRegExpLiteral(value) {
          const node = this.parseLiteral(value.value, "RegExpLiteral");
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        }
        parseBooleanLiteral(value) {
          const node = this.startNode();
          node.value = value;
          this.next();
          return this.finishNode(node, "BooleanLiteral");
        }
        parseNullLiteral() {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let val;
          this.next();
          this.expressionScope.enter(newArrowHeadScope());
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = true;
          this.state.inFSharpPipelineDirectBody = false;
          const innerStartPos = this.state.start;
          const innerStartLoc = this.state.startLoc;
          const exprList = [];
          const refExpressionErrors = new ExpressionErrors();
          let first = true;
          let spreadStartLoc;
          let optionalCommaStartLoc;
          while (!this.match(11)) {
            if (first) {
              first = false;
            } else {
              this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
              if (this.match(11)) {
                optionalCommaStartLoc = this.state.startLoc;
                break;
              }
            }
            if (this.match(21)) {
              const spreadNodeStartPos = this.state.start;
              const spreadNodeStartLoc = this.state.startLoc;
              spreadStartLoc = this.state.startLoc;
              exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
              if (!this.checkCommaAfterRest(41)) {
                break;
              }
            } else {
              exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
            }
          }
          const innerEndLoc = this.state.lastTokEndLoc;
          this.expect(11);
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let arrowNode = this.startNodeAt(startPos, startLoc);
          if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.expressionScope.validateAsPattern();
            this.expressionScope.exit();
            this.parseArrowExpression(arrowNode, exprList, false);
            return arrowNode;
          }
          this.expressionScope.exit();
          if (!exprList.length) {
            this.unexpected(this.state.lastTokStartLoc);
          }
          if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
          if (spreadStartLoc) this.unexpected(spreadStartLoc);
          this.checkExpressionErrors(refExpressionErrors, true);
          this.toReferencedListDeep(exprList, true);
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNode(val, "SequenceExpression");
            this.resetEndLocation(val, innerEndLoc);
          } else {
            val = exprList[0];
          }
          return this.wrapParenthesis(startPos, startLoc, val);
        }
        wrapParenthesis(startPos, startLoc, expression) {
          if (!this.options.createParenthesizedExpressions) {
            this.addExtra(expression, "parenthesized", true);
            this.addExtra(expression, "parenStart", startPos);
            this.takeSurroundingComments(expression, startPos, this.state.lastTokEndLoc.index);
            return expression;
          }
          const parenExpression = this.startNodeAt(startPos, startLoc);
          parenExpression.expression = expression;
          return this.finishNode(parenExpression, "ParenthesizedExpression");
        }
        shouldParseArrow(params) {
          return !this.canInsertSemicolon();
        }
        parseArrow(node) {
          if (this.eat(19)) {
            return node;
          }
        }
        parseParenItem(node, startPos, startLoc) {
          return node;
        }
        parseNewOrNewTarget() {
          const node = this.startNode();
          this.next();
          if (this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, "target");
            if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
              this.raise(Errors.UnexpectedNewTarget, {
                at: metaProp
              });
            }
            return metaProp;
          }
          return this.parseNew(node);
        }
        parseNew(node) {
          this.parseNewCallee(node);
          if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args);
            node.arguments = args;
          } else {
            node.arguments = [];
          }
          return this.finishNode(node, "NewExpression");
        }
        parseNewCallee(node) {
          node.callee = this.parseNoCallExpr();
          if (node.callee.type === "Import") {
            this.raise(Errors.ImportCallNotNewExpression, {
              at: node.callee
            });
          } else if (this.isOptionalChain(node.callee)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.lastTokEndLoc
            });
          } else if (this.eat(18)) {
            this.raise(Errors.OptionalChainingNoNew, {
              at: this.state.startLoc
            });
          }
        }
        parseTemplateElement(isTagged) {
          const {
            start,
            startLoc,
            end,
            value
          } = this.state;
          const elemStart = start + 1;
          const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));
          if (value === null) {
            if (!isTagged) {
              this.raise(Errors.InvalidEscapeSequenceTemplate, {
                at: createPositionWithColumnOffset(startLoc, 2)
              });
            }
          }
          const isTail = this.match(24);
          const endOffset = isTail ? -1 : -2;
          const elemEnd = end + endOffset;
          elem.value = {
            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
            cooked: value === null ? null : value.slice(1, endOffset)
          };
          elem.tail = isTail;
          this.next();
          const finishedNode = this.finishNode(elem, "TemplateElement");
          this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
          return finishedNode;
        }
        parseTemplate(isTagged) {
          const node = this.startNode();
          node.expressions = [];
          let curElt = this.parseTemplateElement(isTagged);
          node.quasis = [curElt];
          while (!curElt.tail) {
            node.expressions.push(this.parseTemplateSubstitution());
            this.readTemplateContinuation();
            node.quasis.push(curElt = this.parseTemplateElement(isTagged));
          }
          return this.finishNode(node, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
          if (isRecord) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const propHash = /* @__PURE__ */ Object.create(null);
          let first = true;
          const node = this.startNode();
          node.properties = [];
          this.next();
          while (!this.match(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                this.addTrailingCommaExtraToNode(node);
                break;
              }
            }
            let prop;
            if (isPattern) {
              prop = this.parseBindingProperty();
            } else {
              prop = this.parsePropertyDefinition(refExpressionErrors);
              this.checkProto(prop, isRecord, propHash, refExpressionErrors);
            }
            if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
              this.raise(Errors.InvalidRecordProperty, {
                at: prop
              });
            }
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
            node.properties.push(prop);
          }
          this.next();
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let type = "ObjectExpression";
          if (isPattern) {
            type = "ObjectPattern";
          } else if (isRecord) {
            type = "RecordExpression";
          }
          return this.finishNode(node, type);
        }
        addTrailingCommaExtraToNode(node) {
          this.addExtra(node, "trailingComma", this.state.lastTokStart);
          this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
        }
        maybeAsyncOrAccessorProp(prop) {
          return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(refExpressionErrors) {
          let decorators = [];
          if (this.match(26)) {
            if (this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedPropertyDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
          }
          const prop = this.startNode();
          let isAsync = false;
          let isAccessor = false;
          let startPos;
          let startLoc;
          if (this.match(21)) {
            if (decorators.length) this.unexpected();
            return this.parseSpread();
          }
          if (decorators.length) {
            prop.decorators = decorators;
            decorators = [];
          }
          prop.method = false;
          if (refExpressionErrors) {
            startPos = this.state.start;
            startLoc = this.state.startLoc;
          }
          let isGenerator = this.eat(55);
          this.parsePropertyNamePrefixOperator(prop);
          const containsEsc = this.state.containsEsc;
          const key = this.parsePropertyName(prop, refExpressionErrors);
          if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            if (keyName === "async" && !this.hasPrecedingLineBreak()) {
              isAsync = true;
              this.resetPreviousNodeTrailingComments(key);
              isGenerator = this.eat(55);
              this.parsePropertyName(prop);
            }
            if (keyName === "get" || keyName === "set") {
              isAccessor = true;
              this.resetPreviousNodeTrailingComments(key);
              prop.kind = keyName;
              if (this.match(55)) {
                isGenerator = true;
                this.raise(Errors.AccessorIsGenerator, {
                  at: this.state.curPosition(),
                  kind: keyName
                });
                this.next();
              }
              this.parsePropertyName(prop);
            }
          }
          return this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
        }
        getGetterSetterExpectedParamCount(method) {
          return method.kind === "get" ? 0 : 1;
        }
        getObjectOrClassMethodParams(method) {
          return method.params;
        }
        checkGetterSetterParams(method) {
          var _params;
          const paramCount = this.getGetterSetterExpectedParamCount(method);
          const params = this.getObjectOrClassMethodParams(method);
          if (params.length !== paramCount) {
            this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: method
            });
          }
          if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
            this.raise(Errors.BadSetterRestParameter, {
              at: method
            });
          }
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          if (isAccessor) {
            const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
            this.checkGetterSetterParams(finishedProp);
            return finishedProp;
          }
          if (isAsync || isGenerator || this.match(10)) {
            if (isPattern) this.unexpected();
            prop.kind = "method";
            prop.method = true;
            return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
          }
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          prop.shorthand = false;
          if (this.eat(14)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
            return this.finishNode(prop, "ObjectProperty");
          }
          if (!prop.computed && prop.key.type === "Identifier") {
            this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else if (this.match(29)) {
              const shorthandAssignLoc = this.state.startLoc;
              if (refExpressionErrors != null) {
                if (refExpressionErrors.shorthandAssignLoc === null) {
                  refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
                }
              } else {
                this.raise(Errors.InvalidCoverInitializedName, {
                  at: shorthandAssignLoc
                });
              }
              prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else {
              prop.value = cloneIdentifier(prop.key);
            }
            prop.shorthand = true;
            return this.finishNode(prop, "ObjectProperty");
          }
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          if (!node) this.unexpected();
          return node;
        }
        parsePropertyName(prop, refExpressionErrors) {
          if (this.eat(0)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssignAllowIn();
            this.expect(3);
          } else {
            const {
              type,
              value
            } = this.state;
            let key;
            if (tokenIsKeywordOrIdentifier(type)) {
              key = this.parseIdentifier(true);
            } else {
              switch (type) {
                case 130:
                  key = this.parseNumericLiteral(value);
                  break;
                case 129:
                  key = this.parseStringLiteral(value);
                  break;
                case 131:
                  key = this.parseBigIntLiteral(value);
                  break;
                case 132:
                  key = this.parseDecimalLiteral(value);
                  break;
                case 134: {
                  const privateKeyLoc = this.state.startLoc;
                  if (refExpressionErrors != null) {
                    if (refExpressionErrors.privateKeyLoc === null) {
                      refExpressionErrors.privateKeyLoc = privateKeyLoc;
                    }
                  } else {
                    this.raise(Errors.UnexpectedPrivateField, {
                      at: privateKeyLoc
                    });
                  }
                  key = this.parsePrivateName();
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
            prop.key = key;
            if (type !== 134) {
              prop.computed = false;
            }
          }
          return prop.key;
        }
        initFunction(node, isAsync) {
          node.id = null;
          node.generator = false;
          node.async = !!isAsync;
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
          this.initFunction(node, isAsync);
          node.generator = !!isGenerator;
          const allowModifiers = isConstructor;
          this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          this.parseFunctionParams(node, allowModifiers);
          const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
          this.prodParam.exit();
          this.scope.exit();
          return finishedNode;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          if (isTuple) {
            this.expectPlugin("recordAndTuple");
          }
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const node = this.startNode();
          this.next();
          node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
          this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
          let flags = functionFlags(isAsync, false);
          if (!this.match(5) && this.prodParam.hasIn) {
            flags |= PARAM_IN;
          }
          this.prodParam.enter(flags);
          this.initFunction(node, isAsync);
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          if (params) {
            this.state.maybeInArrowParameters = true;
            this.setArrowFunctionParameters(node, params, trailingCommaLoc);
          }
          this.state.maybeInArrowParameters = false;
          this.parseFunctionBody(node, true);
          this.prodParam.exit();
          this.scope.exit();
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return this.finishNode(node, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(node, params, trailingCommaLoc) {
          this.toAssignableList(params, trailingCommaLoc, false);
          node.params = params;
        }
        parseFunctionBodyAndFinish(node, type, isMethod = false) {
          this.parseFunctionBody(node, false, isMethod);
          return this.finishNode(node, type);
        }
        parseFunctionBody(node, allowExpression, isMethod = false) {
          const isExpression = allowExpression && !this.match(5);
          this.expressionScope.enter(newExpressionScope());
          if (isExpression) {
            node.body = this.parseMaybeAssign();
            this.checkParams(node, false, allowExpression, false);
          } else {
            const oldStrict = this.state.strict;
            const oldLabels = this.state.labels;
            this.state.labels = [];
            this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
            node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
              const nonSimple = !this.isSimpleParamList(node.params);
              if (hasStrictModeDirective && nonSimple) {
                this.raise(Errors.IllegalLanguageModeDirective, {
                  at: (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node
                });
              }
              const strictModeChanged = !oldStrict && this.state.strict;
              this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
              if (this.state.strict && node.id) {
                this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);
              }
            });
            this.prodParam.exit();
            this.state.labels = oldLabels;
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(node) {
          return node.type === "Identifier";
        }
        isSimpleParamList(params) {
          for (let i4 = 0, len = params.length; i4 < len; i4++) {
            if (!this.isSimpleParameter(params[i4])) return false;
          }
          return true;
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
          const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
          const formalParameters = {
            type: "FormalParameters"
          };
          for (const param of node.params) {
            this.checkLVal(param, {
              in: formalParameters,
              binding: BIND_VAR,
              checkClashes,
              strictModeChanged
            });
          }
        }
        parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
          const elts = [];
          let first = true;
          while (!this.eat(close)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.match(close)) {
                if (nodeForExtra) {
                  this.addTrailingCommaExtraToNode(nodeForExtra);
                }
                this.next();
                break;
              }
            }
            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
          }
          return elts;
        }
        parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
          let elt;
          if (this.match(12)) {
            if (!allowEmpty) {
              this.raise(Errors.UnexpectedToken, {
                at: this.state.curPosition(),
                unexpected: ","
              });
            }
            elt = null;
          } else if (this.match(21)) {
            const spreadNodeStartPos = this.state.start;
            const spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
          } else if (this.match(17)) {
            this.expectPlugin("partialApplication");
            if (!allowPlaceholder) {
              this.raise(Errors.UnexpectedArgumentPlaceholder, {
                at: this.state.startLoc
              });
            }
            const node = this.startNode();
            this.next();
            elt = this.finishNode(node, "ArgumentPlaceholder");
          } else {
            elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
          }
          return elt;
        }
        parseIdentifier(liberal) {
          const node = this.startNode();
          const name = this.parseIdentifierName(node.start, liberal);
          return this.createIdentifier(node, name);
        }
        createIdentifier(node, name) {
          node.name = name;
          node.loc.identifierName = name;
          return this.finishNode(node, "Identifier");
        }
        parseIdentifierName(pos, liberal) {
          let name;
          const {
            startLoc,
            type
          } = this.state;
          if (tokenIsKeywordOrIdentifier(type)) {
            name = this.state.value;
          } else {
            throw this.unexpected();
          }
          const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
          if (liberal) {
            if (tokenIsKeyword2) {
              this.replaceToken(128);
            }
          } else {
            this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
          }
          this.next();
          return name;
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word.length > 10) {
            return;
          }
          if (!canBeReservedWord(word)) {
            return;
          }
          if (word === "yield") {
            if (this.prodParam.hasYield) {
              this.raise(Errors.YieldBindingIdentifier, {
                at: startLoc
              });
              return;
            }
          } else if (word === "await") {
            if (this.prodParam.hasAwait) {
              this.raise(Errors.AwaitBindingIdentifier, {
                at: startLoc
              });
              return;
            }
            if (this.scope.inStaticBlock) {
              this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
                at: startLoc
              });
              return;
            }
            this.expressionScope.recordAsyncArrowParametersError({
              at: startLoc
            });
          } else if (word === "arguments") {
            if (this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(Errors.ArgumentsInClass, {
                at: startLoc
              });
              return;
            }
          }
          if (checkKeywords && isKeyword(word)) {
            this.raise(Errors.UnexpectedKeyword, {
              at: startLoc,
              keyword: word
            });
            return;
          }
          const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
          if (reservedTest(word, this.inModule)) {
            this.raise(Errors.UnexpectedReservedWord, {
              at: startLoc,
              reservedWord: word
            });
          }
        }
        isAwaitAllowed() {
          if (this.prodParam.hasAwait) return true;
          if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
            return true;
          }
          return false;
        }
        parseAwait(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
            at: node
          });
          if (this.eat(55)) {
            this.raise(Errors.ObsoleteAwaitStar, {
              at: node
            });
          }
          if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
            if (this.isAmbiguousAwait()) {
              this.ambiguousScriptDifferentAst = true;
            } else {
              this.sawUnambiguousESM = true;
            }
          }
          if (!this.state.soloAwait) {
            node.argument = this.parseMaybeUnary(null, true);
          }
          return this.finishNode(node, "AwaitExpression");
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak()) return true;
          const {
            type
          } = this.state;
          return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 133 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
        }
        parseYield() {
          const node = this.startNode();
          this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
            at: node
          });
          this.next();
          let delegating = false;
          let argument = null;
          if (!this.hasPrecedingLineBreak()) {
            delegating = this.eat(55);
            switch (this.state.type) {
              case 13:
              case 135:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!delegating) break;
              default:
                argument = this.parseMaybeAssign();
            }
          }
          node.delegate = delegating;
          node.argument = argument;
          return this.finishNode(node, "YieldExpression");
        }
        checkPipelineAtInfixOperator(left, leftStartLoc) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            if (left.type === "SequenceExpression") {
              this.raise(Errors.PipelineHeadSequenceExpression, {
                at: leftStartLoc
              });
            }
          }
        }
        parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
          if (this.isSimpleReference(childExpr)) {
            const bodyNode = this.startNodeAt(startPos, startLoc);
            bodyNode.callee = childExpr;
            return this.finishNode(bodyNode, "PipelineBareFunction");
          } else {
            const bodyNode = this.startNodeAt(startPos, startLoc);
            this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
            bodyNode.expression = childExpr;
            return this.finishNode(bodyNode, "PipelineTopicExpression");
          }
        }
        isSimpleReference(expression) {
          switch (expression.type) {
            case "MemberExpression":
              return !expression.computed && this.isSimpleReference(expression.object);
            case "Identifier":
              return true;
            default:
              return false;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(startLoc) {
          if (this.match(19)) {
            throw this.raise(Errors.PipelineBodyNoArrow, {
              at: this.state.startLoc
            });
          }
          if (!this.topicReferenceWasUsedInCurrentContext()) {
            this.raise(Errors.PipelineTopicUnused, {
              at: startLoc
            });
          }
        }
        withTopicBindingContext(callback) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        }
        withSmartMixTopicForbiddingContext(callback) {
          if (this.hasPlugin(["pipelineOperator", {
            proposal: "smart"
          }])) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null
            };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          } else {
            return callback();
          }
        }
        withSoloAwaitPermittingContext(callback) {
          const outerContextSoloAwaitState = this.state.soloAwait;
          this.state.soloAwait = true;
          try {
            return callback();
          } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
          }
        }
        allowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToSet = PARAM_IN & ~flags;
          if (prodParamToSet) {
            this.prodParam.enter(flags | PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        disallowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          const prodParamToClear = PARAM_IN & flags;
          if (prodParamToClear) {
            this.prodParam.enter(flags & ~PARAM_IN);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(prec) {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = true;
          const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          return ret;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          const node = this.startNode();
          this.next();
          this.eat(5);
          const revertScopes = this.initializeScopes(true);
          this.enterInitialScopes();
          const program = this.startNode();
          try {
            node.body = this.parseProgram(program, 8, "module");
          } finally {
            revertScopes();
          }
          this.eat(8);
          return this.finishNode(node, "ModuleExpression");
        }
        parsePropertyNamePrefixOperator(prop) {
        }
      };
      var loopLabel = {
        kind: "loop"
      };
      var switchLabel = {
        kind: "switch"
      };
      var FUNC_NO_FLAGS = 0;
      var FUNC_STATEMENT = 1;
      var FUNC_HANGING_STATEMENT = 2;
      var FUNC_NULLABLE_ID = 4;
      var loneSurrogate = /[\uD800-\uDFFF]/u;
      var keywordRelationalOperator = /in(?:stanceof)?/y;
      function babel7CompatTokens(tokens, input) {
        for (let i4 = 0; i4 < tokens.length; i4++) {
          const token = tokens[i4];
          const {
            type
          } = token;
          if (typeof type === "number") {
            {
              if (type === 134) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const hashEndPos = start + 1;
                const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                tokens.splice(i4, 1, new Token({
                  type: getExportedToken(27),
                  value: "#",
                  start,
                  end: hashEndPos,
                  startLoc: loc.start,
                  endLoc: hashEndLoc
                }), new Token({
                  type: getExportedToken(128),
                  value,
                  start: hashEndPos,
                  end,
                  startLoc: hashEndLoc,
                  endLoc: loc.end
                }));
                i4++;
                continue;
              }
              if (tokenIsTemplate(type)) {
                const {
                  loc,
                  start,
                  value,
                  end
                } = token;
                const backquoteEnd = start + 1;
                const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                let startToken;
                if (input.charCodeAt(start) === 96) {
                  startToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                } else {
                  startToken = new Token({
                    type: getExportedToken(8),
                    value: "}",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  });
                }
                let templateValue, templateElementEnd, templateElementEndLoc, endToken;
                if (type === 24) {
                  templateElementEnd = end - 1;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                  templateValue = value === null ? null : value.slice(1, -1);
                  endToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                } else {
                  templateElementEnd = end - 2;
                  templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                  templateValue = value === null ? null : value.slice(1, -2);
                  endToken = new Token({
                    type: getExportedToken(23),
                    value: "${",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  });
                }
                tokens.splice(i4, 1, startToken, new Token({
                  type: getExportedToken(20),
                  value: templateValue,
                  start: backquoteEnd,
                  end: templateElementEnd,
                  startLoc: backquoteEndLoc,
                  endLoc: templateElementEndLoc
                }), endToken);
                i4 += 2;
                continue;
              }
            }
            token.type = getExportedToken(type);
          }
        }
        return tokens;
      }
      var StatementParser = class extends ExpressionParser {
        parseTopLevel(file, program) {
          file.program = this.parseProgram(program);
          file.comments = this.state.comments;
          if (this.options.tokens) {
            file.tokens = babel7CompatTokens(this.tokens, this.input);
          }
          return this.finishNode(file, "File");
        }
        parseProgram(program, end = 135, sourceType = this.options.sourceType) {
          program.sourceType = sourceType;
          program.interpreter = this.parseInterpreterDirective();
          this.parseBlockBody(program, true, true, end);
          if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
            for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, {
                at,
                localName
              });
            }
          }
          return this.finishNode(program, "Program");
        }
        stmtToDirective(stmt) {
          const directive = stmt;
          directive.type = "Directive";
          directive.value = directive.expression;
          delete directive.expression;
          const directiveLiteral = directive.value;
          const expressionValue = directiveLiteral.value;
          const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
          const val = directiveLiteral.value = raw.slice(1, -1);
          this.addExtra(directiveLiteral, "raw", raw);
          this.addExtra(directiveLiteral, "rawValue", val);
          this.addExtra(directiveLiteral, "expressionValue", expressionValue);
          directiveLiteral.type = "DirectiveLiteral";
          return directive;
        }
        parseInterpreterDirective() {
          if (!this.match(28)) {
            return null;
          }
          const node = this.startNode();
          node.value = this.state.value;
          this.next();
          return this.finishNode(node, "InterpreterDirective");
        }
        isLet(context3) {
          if (!this.isContextual(99)) {
            return false;
          }
          return this.isLetKeyword(context3);
        }
        isLetKeyword(context3) {
          const next2 = this.nextTokenStart();
          const nextCh = this.codePointAtPos(next2);
          if (nextCh === 92 || nextCh === 91) {
            return true;
          }
          if (context3) return false;
          if (nextCh === 123) return true;
          if (isIdentifierStart(nextCh)) {
            keywordRelationalOperator.lastIndex = next2;
            if (keywordRelationalOperator.test(this.input)) {
              const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
              if (!isIdentifierChar(endCh) && endCh !== 92) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        parseStatement(context3, topLevel) {
          if (this.match(26)) {
            this.parseDecorators(true);
          }
          return this.parseStatementContent(context3, topLevel);
        }
        parseStatementContent(context3, topLevel) {
          let starttype = this.state.type;
          const node = this.startNode();
          let kind;
          if (this.isLet(context3)) {
            starttype = 74;
            kind = "let";
          }
          switch (starttype) {
            case 60:
              return this.parseBreakContinueStatement(node, true);
            case 63:
              return this.parseBreakContinueStatement(node, false);
            case 64:
              return this.parseDebuggerStatement(node);
            case 90:
              return this.parseDoStatement(node);
            case 91:
              return this.parseForStatement(node);
            case 68:
              if (this.lookaheadCharCode() === 46) break;
              if (context3) {
                if (this.state.strict) {
                  this.raise(Errors.StrictFunction, {
                    at: this.state.startLoc
                  });
                } else if (context3 !== "if" && context3 !== "label") {
                  this.raise(Errors.SloppyFunction, {
                    at: this.state.startLoc
                  });
                }
              }
              return this.parseFunctionStatement(node, false, !context3);
            case 80:
              if (context3) this.unexpected();
              return this.parseClass(node, true);
            case 69:
              return this.parseIfStatement(node);
            case 70:
              return this.parseReturnStatement(node);
            case 71:
              return this.parseSwitchStatement(node);
            case 72:
              return this.parseThrowStatement(node);
            case 73:
              return this.parseTryStatement(node);
            case 75:
            case 74:
              kind = kind || this.state.value;
              if (context3 && kind !== "var") {
                this.raise(Errors.UnexpectedLexicalDeclaration, {
                  at: this.state.startLoc
                });
              }
              return this.parseVarStatement(node, kind);
            case 92:
              return this.parseWhileStatement(node);
            case 76:
              return this.parseWithStatement(node);
            case 5:
              return this.parseBlock();
            case 13:
              return this.parseEmptyStatement(node);
            case 83: {
              const nextTokenCharCode = this.lookaheadCharCode();
              if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
            }
            case 82: {
              if (!this.options.allowImportExportEverywhere && !topLevel) {
                this.raise(Errors.UnexpectedImportExport, {
                  at: this.state.startLoc
                });
              }
              this.next();
              let result;
              if (starttype === 83) {
                result = this.parseImport(node);
                if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                  this.sawUnambiguousESM = true;
                }
              } else {
                result = this.parseExport(node);
                if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                  this.sawUnambiguousESM = true;
                }
              }
              this.assertModuleNodeAllowed(result);
              return result;
            }
            default: {
              if (this.isAsyncFunction()) {
                if (context3) {
                  this.raise(Errors.AsyncFunctionInSingleStatementContext, {
                    at: this.state.startLoc
                  });
                }
                this.next();
                return this.parseFunctionStatement(node, true, !context3);
              }
            }
          }
          const maybeName = this.state.value;
          const expr = this.parseExpression();
          if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
            return this.parseLabeledStatement(node, maybeName, expr, context3);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
        }
        assertModuleNodeAllowed(node) {
          if (!this.options.allowImportExportEverywhere && !this.inModule) {
            this.raise(Errors.ImportOutsideModule, {
              at: node
            });
          }
        }
        takeDecorators(node) {
          const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          if (decorators.length) {
            node.decorators = decorators;
            this.resetStartLocationFromNode(node, decorators[0]);
            this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
          }
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(allowExport) {
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          while (this.match(26)) {
            const decorator = this.parseDecorator();
            currentContextDecorators.push(decorator);
          }
          if (this.match(82)) {
            if (!allowExport) {
              this.unexpected();
            }
            if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorExportClass, {
                at: this.state.startLoc
              });
            }
          } else if (!this.canHaveLeadingDecorator()) {
            throw this.raise(Errors.UnexpectedLeadingDecorator, {
              at: this.state.startLoc
            });
          }
        }
        parseDecorator() {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          const node = this.startNode();
          this.next();
          if (this.hasPlugin("decorators")) {
            this.state.decoratorStack.push([]);
            const startPos = this.state.start;
            const startLoc = this.state.startLoc;
            let expr;
            if (this.match(10)) {
              const startPos2 = this.state.start;
              const startLoc2 = this.state.startLoc;
              this.next();
              expr = this.parseExpression();
              this.expect(11);
              expr = this.wrapParenthesis(startPos2, startLoc2, expr);
            } else {
              expr = this.parseIdentifier(false);
              while (this.eat(16)) {
                const node2 = this.startNodeAt(startPos, startLoc);
                node2.object = expr;
                node2.property = this.parseIdentifier(true);
                node2.computed = false;
                expr = this.finishNode(node2, "MemberExpression");
              }
            }
            node.expression = this.parseMaybeDecoratorArguments(expr);
            this.state.decoratorStack.pop();
          } else {
            node.expression = this.parseExprSubscripts();
          }
          return this.finishNode(node, "Decorator");
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.eat(10)) {
            const node = this.startNodeAtNode(expr);
            node.callee = expr;
            node.arguments = this.parseCallExpressionArguments(11, false);
            this.toReferencedList(node.arguments);
            return this.finishNode(node, "CallExpression");
          }
          return expr;
        }
        parseBreakContinueStatement(node, isBreak) {
          this.next();
          if (this.isLineTerminator()) {
            node.label = null;
          } else {
            node.label = this.parseIdentifier();
            this.semicolon();
          }
          this.verifyBreakContinue(node, isBreak);
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(node, isBreak) {
          let i4;
          for (i4 = 0; i4 < this.state.labels.length; ++i4) {
            const lab = this.state.labels[i4];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
              if (node.label && isBreak) break;
            }
          }
          if (i4 === this.state.labels.length) {
            const type = isBreak ? "BreakStatement" : "ContinueStatement";
            this.raise(Errors.IllegalBreakContinue, {
              at: node,
              type
            });
          }
        }
        parseDebuggerStatement(node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement");
        }
        parseHeaderExpression() {
          this.expect(10);
          const val = this.parseExpression();
          this.expect(11);
          return val;
        }
        parseDoStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do"));
          this.state.labels.pop();
          this.expect(92);
          node.test = this.parseHeaderExpression();
          this.eat(13);
          return this.finishNode(node, "DoWhileStatement");
        }
        parseForStatement(node) {
          this.next();
          this.state.labels.push(loopLabel);
          let awaitAt = null;
          if (this.isAwaitAllowed() && this.eatContextual(96)) {
            awaitAt = this.state.lastTokStartLoc;
          }
          this.scope.enter(SCOPE_OTHER);
          this.expect(10);
          if (this.match(13)) {
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, null);
          }
          const startsWithLet = this.isContextual(99);
          const isLet = startsWithLet && this.isLetKeyword();
          if (this.match(74) || this.match(75) || isLet) {
            const initNode = this.startNode();
            const kind = isLet ? "let" : this.state.value;
            this.next();
            this.parseVar(initNode, true, kind);
            const init6 = this.finishNode(initNode, "VariableDeclaration");
            if ((this.match(58) || this.isContextual(101)) && init6.declarations.length === 1) {
              return this.parseForIn(node, init6, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init6);
          }
          const startsWithAsync = this.isContextual(95);
          const refExpressionErrors = new ExpressionErrors();
          const init5 = this.parseExpression(true, refExpressionErrors);
          const isForOf = this.isContextual(101);
          if (isForOf) {
            if (startsWithLet) {
              this.raise(Errors.ForOfLet, {
                at: init5
              });
            }
            if (awaitAt === null && startsWithAsync && init5.type === "Identifier") {
              this.raise(Errors.ForOfAsync, {
                at: init5
              });
            }
          }
          if (isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors);
            this.toAssignable(init5, true);
            const type = isForOf ? "ForOfStatement" : "ForInStatement";
            this.checkLVal(init5, {
              in: {
                type
              }
            });
            return this.parseForIn(node, init5, awaitAt);
          } else {
            this.checkExpressionErrors(refExpressionErrors, true);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init5);
        }
        parseFunctionStatement(node, isAsync, declarationPosition) {
          this.next();
          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
        }
        parseIfStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          node.consequent = this.parseStatement("if");
          node.alternate = this.eat(66) ? this.parseStatement("if") : null;
          return this.finishNode(node, "IfStatement");
        }
        parseReturnStatement(node) {
          if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
            this.raise(Errors.IllegalReturn, {
              at: this.state.startLoc
            });
          }
          this.next();
          if (this.isLineTerminator()) {
            node.argument = null;
          } else {
            node.argument = this.parseExpression();
            this.semicolon();
          }
          return this.finishNode(node, "ReturnStatement");
        }
        parseSwitchStatement(node) {
          this.next();
          node.discriminant = this.parseHeaderExpression();
          const cases = node.cases = [];
          this.expect(5);
          this.state.labels.push(switchLabel);
          this.scope.enter(SCOPE_OTHER);
          let cur;
          for (let sawDefault; !this.match(8); ) {
            if (this.match(61) || this.match(65)) {
              const isCase = this.match(61);
              if (cur) this.finishNode(cur, "SwitchCase");
              cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) {
                  this.raise(Errors.MultipleDefaultsInSwitch, {
                    at: this.state.lastTokStartLoc
                  });
                }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(14);
            } else {
              if (cur) {
                cur.consequent.push(this.parseStatement(null));
              } else {
                this.unexpected();
              }
            }
          }
          this.scope.exit();
          if (cur) this.finishNode(cur, "SwitchCase");
          this.next();
          this.state.labels.pop();
          return this.finishNode(node, "SwitchStatement");
        }
        parseThrowStatement(node) {
          this.next();
          if (this.hasPrecedingLineBreak()) {
            this.raise(Errors.NewlineAfterThrow, {
              at: this.state.lastTokEndLoc
            });
          }
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement");
        }
        parseCatchClauseParam() {
          const param = this.parseBindingAtom();
          const simple = param.type === "Identifier";
          this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(param, {
            in: {
              type: "CatchClause"
            },
            binding: BIND_LEXICAL,
            allowingSloppyLetBinding: true
          });
          return param;
        }
        parseTryStatement(node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.match(62)) {
            const clause = this.startNode();
            this.next();
            if (this.match(10)) {
              this.expect(10);
              clause.param = this.parseCatchClauseParam();
              this.expect(11);
            } else {
              clause.param = null;
              this.scope.enter(SCOPE_OTHER);
            }
            clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
            this.scope.exit();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(67) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer) {
            this.raise(Errors.NoCatchOrFinally, {
              at: node
            });
          }
          return this.finishNode(node, "TryStatement");
        }
        parseVarStatement(node, kind, allowMissingInitializer = false) {
          this.next();
          this.parseVar(node, false, kind, allowMissingInitializer);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration");
        }
        parseWhileStatement(node) {
          this.next();
          node.test = this.parseHeaderExpression();
          this.state.labels.push(loopLabel);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while"));
          this.state.labels.pop();
          return this.finishNode(node, "WhileStatement");
        }
        parseWithStatement(node) {
          if (this.state.strict) {
            this.raise(Errors.StrictWith, {
              at: this.state.startLoc
            });
          }
          this.next();
          node.object = this.parseHeaderExpression();
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with"));
          return this.finishNode(node, "WithStatement");
        }
        parseEmptyStatement(node) {
          this.next();
          return this.finishNode(node, "EmptyStatement");
        }
        parseLabeledStatement(node, maybeName, expr, context3) {
          for (const label of this.state.labels) {
            if (label.name === maybeName) {
              this.raise(Errors.LabelRedeclaration, {
                at: expr,
                labelName: maybeName
              });
            }
          }
          const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
          for (let i4 = this.state.labels.length - 1; i4 >= 0; i4--) {
            const label = this.state.labels[i4];
            if (label.statementStart === node.start) {
              label.statementStart = this.state.start;
              label.kind = kind;
            } else {
              break;
            }
          }
          this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.state.start
          });
          node.body = this.parseStatement(context3 ? context3.indexOf("label") === -1 ? context3 + "label" : context3 : "label");
          this.state.labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement");
        }
        parseExpressionStatement(node, expr) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement");
        }
        parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
          const node = this.startNode();
          if (allowDirectives) {
            this.state.strictErrors.clear();
          }
          this.expect(5);
          if (createNewLexicalScope) {
            this.scope.enter(SCOPE_OTHER);
          }
          this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
          if (createNewLexicalScope) {
            this.scope.exit();
          }
          return this.finishNode(node, "BlockStatement");
        }
        isValidDirective(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          const body2 = node.body = [];
          const directives = node.directives = [];
          this.parseBlockOrModuleBlockBody(body2, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
        }
        parseBlockOrModuleBlockBody(body2, directives, topLevel, end, afterBlockParse) {
          const oldStrict = this.state.strict;
          let hasStrictModeDirective = false;
          let parsedNonDirective = false;
          while (!this.match(end)) {
            const stmt = this.parseStatement(null, topLevel);
            if (directives && !parsedNonDirective) {
              if (this.isValidDirective(stmt)) {
                const directive = this.stmtToDirective(stmt);
                directives.push(directive);
                if (!hasStrictModeDirective && directive.value.value === "use strict") {
                  hasStrictModeDirective = true;
                  this.setStrict(true);
                }
                continue;
              }
              parsedNonDirective = true;
              this.state.strictErrors.clear();
            }
            body2.push(stmt);
          }
          if (afterBlockParse) {
            afterBlockParse.call(this, hasStrictModeDirective);
          }
          if (!oldStrict) {
            this.setStrict(false);
          }
          this.next();
        }
        parseFor(node, init5) {
          node.init = init5;
          this.semicolon(false);
          node.test = this.match(13) ? null : this.parseExpression();
          this.semicolon(false);
          node.update = this.match(11) ? null : this.parseExpression();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, "ForStatement");
        }
        parseForIn(node, init5, awaitAt) {
          const isForIn = this.match(58);
          this.next();
          if (isForIn) {
            if (awaitAt !== null) this.unexpected(awaitAt);
          } else {
            node.await = awaitAt !== null;
          }
          if (init5.type === "VariableDeclaration" && init5.declarations[0].init != null && (!isForIn || this.state.strict || init5.kind !== "var" || init5.declarations[0].id.type !== "Identifier")) {
            this.raise(Errors.ForInOfLoopInitializer, {
              at: init5,
              type: isForIn ? "ForInStatement" : "ForOfStatement"
            });
          }
          if (init5.type === "AssignmentPattern") {
            this.raise(Errors.InvalidLhs, {
              at: init5,
              ancestor: {
                type: "ForStatement"
              }
            });
          }
          node.left = init5;
          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
          this.expect(11);
          node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
          this.scope.exit();
          this.state.labels.pop();
          return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(node, isFor, kind, allowMissingInitializer = false) {
          const declarations = node.declarations = [];
          node.kind = kind;
          for (; ; ) {
            const decl = this.startNode();
            this.parseVarId(decl, kind);
            decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
            if (decl.init === null && !allowMissingInitializer) {
              if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "destructuring"
                });
              } else if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
                this.raise(Errors.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc,
                  kind: "const"
                });
              }
            }
            declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(12)) break;
          }
          return node;
        }
        parseVarId(decl, kind) {
          decl.id = this.parseBindingAtom();
          this.checkLVal(decl.id, {
            in: {
              type: "VariableDeclarator"
            },
            binding: kind === "var" ? BIND_VAR : BIND_LEXICAL
          });
        }
        parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
          const isStatement = statement & FUNC_STATEMENT;
          const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
          const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
          this.initFunction(node, isAsync);
          if (this.match(55) && isHangingStatement) {
            this.raise(Errors.GeneratorInSingleStatementContext, {
              at: this.state.startLoc
            });
          }
          node.generator = this.eat(55);
          if (isStatement) {
            node.id = this.parseFunctionId(requireId);
          }
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = false;
          this.scope.enter(SCOPE_FUNCTION);
          this.prodParam.enter(functionFlags(isAsync, node.generator));
          if (!isStatement) {
            node.id = this.parseFunctionId();
          }
          this.parseFunctionParams(node, false);
          this.withSmartMixTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
          });
          this.prodParam.exit();
          this.scope.exit();
          if (isStatement && !isHangingStatement) {
            this.registerFunctionStatementId(node);
          }
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
          return node;
        }
        parseFunctionId(requireId) {
          return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(node, allowModifiers) {
          this.expect(10);
          this.expressionScope.enter(newParameterDeclarationScope());
          node.params = this.parseBindingList(11, 41, false, allowModifiers);
          this.expressionScope.exit();
        }
        registerFunctionStatementId(node) {
          if (!node.id) return;
          this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
        }
        parseClass(node, isStatement, optionalId) {
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.state.strict;
          this.state.strict = true;
          this.parseClassId(node, isStatement, optionalId);
          this.parseClassSuper(node);
          node.body = this.parseClassBody(!!node.superClass, oldStrict);
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(method) {
          return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
        }
        parseClassBody(hadSuperClass, oldStrict) {
          this.classScope.enter();
          const state = {
            hadConstructor: false,
            hadSuperClass
          };
          let decorators = [];
          const classBody = this.startNode();
          classBody.body = [];
          this.expect(5);
          this.withSmartMixTopicForbiddingContext(() => {
            while (!this.match(8)) {
              if (this.eat(13)) {
                if (decorators.length > 0) {
                  throw this.raise(Errors.DecoratorSemicolon, {
                    at: this.state.lastTokEndLoc
                  });
                }
                continue;
              }
              if (this.match(26)) {
                decorators.push(this.parseDecorator());
                continue;
              }
              const member = this.startNode();
              if (decorators.length) {
                member.decorators = decorators;
                this.resetStartLocationFromNode(member, decorators[0]);
                decorators = [];
              }
              this.parseClassMember(classBody, member, state);
              if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
                this.raise(Errors.DecoratorConstructor, {
                  at: member
                });
              }
            }
          });
          this.state.strict = oldStrict;
          this.next();
          if (decorators.length) {
            throw this.raise(Errors.TrailingDecorator, {
              at: this.state.startLoc
            });
          }
          this.classScope.exit();
          return this.finishNode(classBody, "ClassBody");
        }
        parseClassMemberFromModifier(classBody, member) {
          const key = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            const method = member;
            method.kind = "method";
            method.computed = false;
            method.key = key;
            method.static = false;
            this.pushClassMethod(classBody, method, false, false, false, false);
            return true;
          } else if (this.isClassProperty()) {
            const prop = member;
            prop.computed = false;
            prop.key = key;
            prop.static = false;
            classBody.body.push(this.parseClassProperty(prop));
            return true;
          }
          this.resetPreviousNodeTrailingComments(key);
          return false;
        }
        parseClassMember(classBody, member, state) {
          const isStatic = this.isContextual(104);
          if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody, member)) {
              return;
            }
            if (this.eat(5)) {
              this.parseClassStaticBlock(classBody, member);
              return;
            }
          }
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const publicMethod = member;
          const privateMethod = member;
          const publicProp = member;
          const privateProp = member;
          const accessorProp = member;
          const method = publicMethod;
          const publicMember = publicMethod;
          member.static = isStatic;
          this.parsePropertyNamePrefixOperator(member);
          if (this.eat(55)) {
            method.kind = "method";
            const isPrivateName = this.match(134);
            this.parseClassElementName(method);
            if (isPrivateName) {
              this.pushClassPrivateMethod(classBody, privateMethod, true, false);
              return;
            }
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsGenerator, {
                at: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, true, false, false, false);
            return;
          }
          const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
          const isPrivate = this.match(134);
          const key = this.parseClassElementName(member);
          const maybeQuestionTokenStartLoc = this.state.startLoc;
          this.parsePostMemberNameModifiers(publicMember);
          if (this.isClassMethod()) {
            method.kind = "method";
            if (isPrivate) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              return;
            }
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = false;
            if (isConstructor) {
              publicMethod.kind = "constructor";
              if (state.hadConstructor && !this.hasPlugin("typescript")) {
                this.raise(Errors.DuplicateConstructor, {
                  at: key
                });
              }
              if (isConstructor && this.hasPlugin("typescript") && member.override) {
                this.raise(Errors.OverrideOnConstructor, {
                  at: key
                });
              }
              state.hadConstructor = true;
              allowsDirectSuper = state.hadSuperClass;
            }
            this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
          } else if (this.isClassProperty()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            if (publicMember.optional) {
              this.unexpected(maybeQuestionTokenStartLoc);
            }
            method.kind = "method";
            const isPrivate2 = this.match(134);
            this.parseClassElementName(method);
            this.parsePostMemberNameModifiers(publicMember);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAsync, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
            }
          } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
            this.resetPreviousNodeTrailingComments(key);
            method.kind = key.name;
            const isPrivate2 = this.match(134);
            this.parseClassElementName(publicMethod);
            if (isPrivate2) {
              this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            } else {
              if (this.isNonstaticConstructor(publicMethod)) {
                this.raise(Errors.ConstructorIsAccessor, {
                  at: publicMethod.key
                });
              }
              this.pushClassMethod(classBody, publicMethod, false, false, false, false);
            }
            this.checkGetterSetterParams(publicMethod);
          } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors");
            this.resetPreviousNodeTrailingComments(key);
            const isPrivate2 = this.match(134);
            this.parseClassElementName(publicProp);
            this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
          } else if (this.isLineTerminator()) {
            if (isPrivate) {
              this.pushClassPrivateProperty(classBody, privateProp);
            } else {
              this.pushClassProperty(classBody, publicProp);
            }
          } else {
            this.unexpected();
          }
        }
        parseClassElementName(member) {
          const {
            type,
            value
          } = this.state;
          if ((type === 128 || type === 129) && member.static && value === "prototype") {
            this.raise(Errors.StaticPrototype, {
              at: this.state.startLoc
            });
          }
          if (type === 134) {
            if (value === "constructor") {
              this.raise(Errors.ConstructorClassPrivateField, {
                at: this.state.startLoc
              });
            }
            const key = this.parsePrivateName();
            member.key = key;
            return key;
          }
          return this.parsePropertyName(member);
        }
        parseClassStaticBlock(classBody, member) {
          var _member$decorators;
          this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(PARAM);
          const body2 = member.body = [];
          this.parseBlockOrModuleBlockBody(body2, void 0, false, 8);
          this.prodParam.exit();
          this.scope.exit();
          this.state.labels = oldLabels;
          classBody.body.push(this.finishNode(member, "StaticBlock"));
          if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
            this.raise(Errors.DecoratorStaticBlock, {
              at: member
            });
          }
        }
        pushClassProperty(classBody, prop) {
          if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
            this.raise(Errors.ConstructorClassField, {
              at: prop.key
            });
          }
          classBody.body.push(this.parseClassProperty(prop));
        }
        pushClassPrivateProperty(classBody, prop) {
          const node = this.parseClassPrivateProperty(prop);
          classBody.body.push(node);
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
        }
        pushClassAccessorProperty(classBody, prop, isPrivate) {
          if (!isPrivate && !prop.computed) {
            const key = prop.key;
            if (key.name === "constructor" || key.value === "constructor") {
              this.raise(Errors.ConstructorClassField, {
                at: key
              });
            }
          }
          const node = this.parseClassAccessorProperty(prop);
          classBody.body.push(node);
          if (isPrivate) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
          }
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
          classBody.body.push(node);
          const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
          this.declareClassPrivateMethodInScope(node, kind);
        }
        declareClassPrivateMethodInScope(node, kind) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
        }
        parsePostMemberNameModifiers(methodOrProp) {
        }
        parseClassPrivateProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassPrivateProperty");
        }
        parseClassProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassProperty");
        }
        parseClassAccessorProperty(node) {
          this.parseInitializer(node);
          this.semicolon();
          return this.finishNode(node, "ClassAccessorProperty");
        }
        parseInitializer(node) {
          this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
          this.expressionScope.enter(newExpressionScope());
          this.prodParam.enter(PARAM);
          node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
          this.expressionScope.exit();
          this.prodParam.exit();
          this.scope.exit();
        }
        parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
          if (tokenIsIdentifier(this.state.type)) {
            node.id = this.parseIdentifier();
            if (isStatement) {
              this.declareNameFromIdentifier(node.id, bindingType);
            }
          } else {
            if (optionalId || !isStatement) {
              node.id = null;
            } else {
              throw this.raise(Errors.MissingClassName, {
                at: this.state.startLoc
              });
            }
          }
        }
        parseClassSuper(node) {
          node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(node) {
          const hasDefault = this.maybeParseExportDefaultSpecifier(node);
          const parseAfterDefault = !hasDefault || this.eat(12);
          const hasStar = parseAfterDefault && this.eatExportStar(node);
          const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
          const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
          const isFromRequired = hasDefault || hasStar;
          if (hasStar && !hasNamespace) {
            if (hasDefault) this.unexpected();
            this.parseExportFrom(node, true);
            return this.finishNode(node, "ExportAllDeclaration");
          }
          const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
          if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
            throw this.unexpected(null, 5);
          }
          let hasDeclaration;
          if (isFromRequired || hasSpecifiers) {
            hasDeclaration = false;
            this.parseExportFrom(node, isFromRequired);
          } else {
            hasDeclaration = this.maybeParseExportDeclaration(node);
          }
          if (isFromRequired || hasSpecifiers || hasDeclaration) {
            this.checkExport(node, true, false, !!node.source);
            return this.finishNode(node, "ExportNamedDeclaration");
          }
          if (this.eat(65)) {
            node.declaration = this.parseExportDefaultExpression();
            this.checkExport(node, true, true);
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          throw this.unexpected(null, 5);
        }
        eatExportStar(node) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(node) {
          if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            specifier.exported = this.parseIdentifier(true);
            node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
            return true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(node) {
          if (this.isContextual(93)) {
            if (!node.specifiers) node.specifiers = [];
            const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
            this.next();
            specifier.exported = this.parseModuleExportName();
            node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
            return true;
          }
          return false;
        }
        maybeParseExportNamedSpecifiers(node) {
          if (this.match(5)) {
            if (!node.specifiers) node.specifiers = [];
            const isTypeExport = node.exportKind === "type";
            node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
            node.source = null;
            node.declaration = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            return true;
          }
          return false;
        }
        maybeParseExportDeclaration(node) {
          if (this.shouldParseExportDeclaration()) {
            node.specifiers = [];
            node.source = null;
            if (this.hasPlugin("importAssertions")) {
              node.assertions = [];
            }
            node.declaration = this.parseExportDeclaration(node);
            return true;
          }
          return false;
        }
        isAsyncFunction() {
          if (!this.isContextual(95)) return false;
          const next2 = this.nextTokenStart();
          return !lineBreak.test(this.input.slice(this.state.pos, next2)) && this.isUnparsedContextual(next2, "function");
        }
        parseExportDefaultExpression() {
          const expr = this.startNode();
          const isAsync = this.isAsyncFunction();
          if (this.match(68) || isAsync) {
            this.next();
            if (isAsync) {
              this.next();
            }
            return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
          }
          if (this.match(80)) {
            return this.parseClass(expr, true, true);
          }
          if (this.match(26)) {
            if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              this.raise(Errors.DecoratorBeforeExport, {
                at: this.state.startLoc
              });
            }
            this.parseDecorators(false);
            return this.parseClass(expr, true, true);
          }
          if (this.match(75) || this.match(74) || this.isLet()) {
            throw this.raise(Errors.UnsupportedDefaultExport, {
              at: this.state.startLoc
            });
          }
          const res = this.parseMaybeAssignAllowIn();
          this.semicolon();
          return res;
        }
        parseExportDeclaration(node) {
          return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
          const {
            type
          } = this.state;
          if (tokenIsIdentifier(type)) {
            if (type === 95 && !this.state.containsEsc || type === 99) {
              return false;
            }
            if ((type === 126 || type === 125) && !this.state.containsEsc) {
              const {
                type: nextType
              } = this.lookahead();
              if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
                this.expectOnePlugin(["flow", "typescript"]);
                return false;
              }
            }
          } else if (!this.match(65)) {
            return false;
          }
          const next2 = this.nextTokenStart();
          const hasFrom = this.isUnparsedContextual(next2, "from");
          if (this.input.charCodeAt(next2) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
            return true;
          }
          if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next2 + 4));
            return nextAfterFrom === 34 || nextAfterFrom === 39;
          }
          return false;
        }
        parseExportFrom(node, expect) {
          if (this.eatContextual(97)) {
            node.source = this.parseImportSource();
            this.checkExport(node);
            const assertions = this.maybeParseImportAssertions();
            if (assertions) {
              node.assertions = assertions;
              this.checkJSONModuleImport(node);
            }
          } else if (expect) {
            this.unexpected();
          }
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          const {
            type
          } = this.state;
          if (type === 26) {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            if (this.hasPlugin("decorators")) {
              if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
                throw this.raise(Errors.DecoratorBeforeExport, {
                  at: this.state.startLoc
                });
              }
              return true;
            }
          }
          return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
        }
        checkExport(node, checkNames, isDefault, isFrom) {
          if (checkNames) {
            if (isDefault) {
              this.checkDuplicateExports(node, "default");
              if (this.hasPlugin("exportDefaultFrom")) {
                var _declaration$extra;
                const declaration = node.declaration;
                if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                  this.raise(Errors.ExportDefaultFromAsIdentifier, {
                    at: declaration
                  });
                }
              }
            } else if (node.specifiers && node.specifiers.length) {
              for (const specifier of node.specifiers) {
                const {
                  exported
                } = specifier;
                const exportName = exported.type === "Identifier" ? exported.name : exported.value;
                this.checkDuplicateExports(specifier, exportName);
                if (!isFrom && specifier.local) {
                  const {
                    local
                  } = specifier;
                  if (local.type !== "Identifier") {
                    this.raise(Errors.ExportBindingIsString, {
                      at: specifier,
                      localName: local.value,
                      exportName
                    });
                  } else {
                    this.checkReservedWord(local.name, local.loc.start, true, false);
                    this.scope.checkLocalExport(local);
                  }
                }
              }
            } else if (node.declaration) {
              if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
                const id = node.declaration.id;
                if (!id) throw new Error("Assertion failure");
                this.checkDuplicateExports(node, id.name);
              } else if (node.declaration.type === "VariableDeclaration") {
                for (const declaration of node.declaration.declarations) {
                  this.checkDeclaration(declaration.id);
                }
              }
            }
          }
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          if (currentContextDecorators.length) {
            throw this.raise(Errors.UnsupportedDecoratorExport, {
              at: node
            });
          }
        }
        checkDeclaration(node) {
          if (node.type === "Identifier") {
            this.checkDuplicateExports(node, node.name);
          } else if (node.type === "ObjectPattern") {
            for (const prop of node.properties) {
              this.checkDeclaration(prop);
            }
          } else if (node.type === "ArrayPattern") {
            for (const elem of node.elements) {
              if (elem) {
                this.checkDeclaration(elem);
              }
            }
          } else if (node.type === "ObjectProperty") {
            this.checkDeclaration(node.value);
          } else if (node.type === "RestElement") {
            this.checkDeclaration(node.argument);
          } else if (node.type === "AssignmentPattern") {
            this.checkDeclaration(node.left);
          }
        }
        checkDuplicateExports(node, exportName) {
          if (this.exportedIdentifiers.has(exportName)) {
            if (exportName === "default") {
              this.raise(Errors.DuplicateDefaultExport, {
                at: node
              });
            } else {
              this.raise(Errors.DuplicateExport, {
                at: node,
                exportName
              });
            }
          }
          this.exportedIdentifiers.add(exportName);
        }
        parseExportSpecifiers(isInTypeExport) {
          const nodes = [];
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              this.expect(12);
              if (this.eat(8)) break;
            }
            const isMaybeTypeOnly = this.isContextual(126);
            const isString2 = this.match(129);
            const node = this.startNode();
            node.local = this.parseModuleExportName();
            nodes.push(this.parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly));
          }
          return nodes;
        }
        parseExportSpecifier(node, isString2, isInTypeExport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            node.exported = this.parseModuleExportName();
          } else if (isString2) {
            node.exported = cloneStringLiteral(node.local);
          } else if (!node.exported) {
            node.exported = cloneIdentifier(node.local);
          }
          return this.finishNode(node, "ExportSpecifier");
        }
        parseModuleExportName() {
          if (this.match(129)) {
            const result = this.parseStringLiteral(this.state.value);
            const surrogate = result.value.match(loneSurrogate);
            if (surrogate) {
              this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
                at: result,
                surrogateCharCode: surrogate[0].charCodeAt(0)
              });
            }
            return result;
          }
          return this.parseIdentifier(true);
        }
        isJSONModuleImport(node) {
          if (node.assertions != null) {
            return node.assertions.some(({
              key,
              value
            }) => {
              return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
            });
          }
          return false;
        }
        checkJSONModuleImport(node) {
          if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
            const {
              specifiers
            } = node;
            if (node.specifiers != null) {
              const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
                let imported;
                if (specifier.type === "ExportSpecifier") {
                  imported = specifier.local;
                } else if (specifier.type === "ImportSpecifier") {
                  imported = specifier.imported;
                }
                if (imported !== void 0) {
                  return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
                }
              });
              if (nonDefaultNamedSpecifier !== void 0) {
                this.raise(Errors.ImportJSONBindingNotDefault, {
                  at: nonDefaultNamedSpecifier.loc.start
                });
              }
            }
          }
        }
        parseImport(node) {
          node.specifiers = [];
          if (!this.match(129)) {
            const hasDefault = this.maybeParseDefaultImportSpecifier(node);
            const parseNext = !hasDefault || this.eat(12);
            const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
            if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
            this.expectContextual(97);
          }
          node.source = this.parseImportSource();
          const assertions = this.maybeParseImportAssertions();
          if (assertions) {
            node.assertions = assertions;
          } else {
            const attributes = this.maybeParseModuleAttributes();
            if (attributes) {
              node.attributes = attributes;
            }
          }
          this.checkJSONModuleImport(node);
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          if (!this.match(129)) this.unexpected();
          return this.parseExprAtom();
        }
        shouldParseDefaultImport(node) {
          return tokenIsIdentifier(this.state.type);
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = this.parseIdentifier();
          node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        finishImportSpecifier(specifier, type) {
          this.checkLVal(specifier.local, {
            in: specifier,
            binding: BIND_LEXICAL
          });
          return this.finishNode(specifier, type);
        }
        parseAssertEntries() {
          const attrs = [];
          const attrNames = /* @__PURE__ */ new Set();
          do {
            if (this.match(8)) {
              break;
            }
            const node = this.startNode();
            const keyName = this.state.value;
            if (attrNames.has(keyName)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: this.state.startLoc,
                key: keyName
              });
            }
            attrNames.add(keyName);
            if (this.match(129)) {
              node.key = this.parseStringLiteral(keyName);
            } else {
              node.key = this.parseIdentifier(true);
            }
            this.expect(14);
            if (!this.match(129)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
          } while (this.eat(12));
          return attrs;
        }
        maybeParseModuleAttributes() {
          if (this.match(76) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("moduleAttributes");
            this.next();
          } else {
            if (this.hasPlugin("moduleAttributes")) return [];
            return null;
          }
          const attrs = [];
          const attributes = /* @__PURE__ */ new Set();
          do {
            const node = this.startNode();
            node.key = this.parseIdentifier(true);
            if (node.key.name !== "type") {
              this.raise(Errors.ModuleAttributeDifferentFromType, {
                at: node.key
              });
            }
            if (attributes.has(node.key.name)) {
              this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
                at: node.key,
                key: node.key.name
              });
            }
            attributes.add(node.key.name);
            this.expect(14);
            if (!this.match(129)) {
              throw this.raise(Errors.ModuleAttributeInvalidValue, {
                at: this.state.startLoc
              });
            }
            node.value = this.parseStringLiteral(this.state.value);
            this.finishNode(node, "ImportAttribute");
            attrs.push(node);
          } while (this.eat(12));
          return attrs;
        }
        maybeParseImportAssertions() {
          if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
            this.expectPlugin("importAssertions");
            this.next();
          } else {
            if (this.hasPlugin("importAssertions")) return [];
            return null;
          }
          this.eat(5);
          const attrs = this.parseAssertEntries();
          this.eat(8);
          return attrs;
        }
        maybeParseDefaultImportSpecifier(node) {
          if (this.shouldParseDefaultImport(node)) {
            this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
            return true;
          }
          return false;
        }
        maybeParseStarImportSpecifier(node) {
          if (this.match(55)) {
            const specifier = this.startNode();
            this.next();
            this.expectContextual(93);
            this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
            return true;
          }
          return false;
        }
        parseNamedImportSpecifiers(node) {
          let first = true;
          this.expect(5);
          while (!this.eat(8)) {
            if (first) {
              first = false;
            } else {
              if (this.eat(14)) {
                throw this.raise(Errors.DestructureNamedImport, {
                  at: this.state.startLoc
                });
              }
              this.expect(12);
              if (this.eat(8)) break;
            }
            const specifier = this.startNode();
            const importedIsString = this.match(129);
            const isMaybeTypeOnly = this.isContextual(126);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly);
            node.specifiers.push(importSpecifier);
          }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            const {
              imported
            } = specifier;
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, {
                at: specifier,
                importName: imported.value
              });
            }
            this.checkReservedWord(imported.name, specifier.loc.start, true, true);
            if (!specifier.local) {
              specifier.local = cloneIdentifier(imported);
            }
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        isThisParam(param) {
          return param.type === "Identifier" && param.name === "this";
        }
      };
      var Parser = class extends StatementParser {
        constructor(options, input) {
          options = getOptions(options);
          super(options, input);
          this.options = options;
          this.initializeScopes();
          this.plugins = pluginsMap(this.options.plugins);
          this.filename = options.sourceFilename;
        }
        getScopeHandler() {
          return ScopeHandler;
        }
        parse() {
          this.enterInitialScopes();
          const file = this.startNode();
          const program = this.startNode();
          this.nextToken();
          file.errors = null;
          this.parseTopLevel(file, program);
          file.errors = this.state.errors;
          return file;
        }
      };
      function pluginsMap(plugins) {
        const pluginMap = /* @__PURE__ */ new Map();
        for (const plugin of plugins) {
          const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
          if (!pluginMap.has(name)) pluginMap.set(name, options || {});
        }
        return pluginMap;
      }
      function parse3(input, options) {
        var _options;
        if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
          options = Object.assign({}, options);
          try {
            options.sourceType = "module";
            const parser = getParser(options, input);
            const ast = parser.parse();
            if (parser.sawUnambiguousESM) {
              return ast;
            }
            if (parser.ambiguousScriptDifferentAst) {
              try {
                options.sourceType = "script";
                return getParser(options, input).parse();
              } catch (_unused) {
              }
            } else {
              ast.program.sourceType = "script";
            }
            return ast;
          } catch (moduleError) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused2) {
            }
            throw moduleError;
          }
        } else {
          return getParser(options, input).parse();
        }
      }
      function parseExpression(input, options) {
        const parser = getParser(options, input);
        if (parser.options.strictMode) {
          parser.state.strict = true;
        }
        return parser.getExpression();
      }
      function generateExportedTokenTypes(internalTokenTypes) {
        const tokenTypes2 = {};
        for (const typeName of Object.keys(internalTokenTypes)) {
          tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
        }
        return tokenTypes2;
      }
      var tokTypes = generateExportedTokenTypes(tt);
      function getParser(options, input) {
        let cls = Parser;
        if (options != null && options.plugins) {
          validatePlugins(options.plugins);
          cls = getParserClass(options.plugins);
        }
        return new cls(options, input);
      }
      var parserClassCache = {};
      function getParserClass(pluginsFromOptions) {
        const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
        const key = pluginList.join("/");
        let cls = parserClassCache[key];
        if (!cls) {
          cls = Parser;
          for (const plugin of pluginList) {
            cls = mixinPlugins[plugin](cls);
          }
          parserClassCache[key] = cls;
        }
        return cls;
      }
      exports.parse = parse3;
      exports.parseExpression = parseExpression;
      exports.tokTypes = tokTypes;
    }
  });

  // node_modules/source-map/lib/base64.js
  var require_base64 = __commonJS({
    "node_modules/source-map/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      exports.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // node_modules/source-map/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "node_modules/source-map/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // node_modules/source-map/lib/util.js
  var require_util = __commonJS({
    "node_modules/source-map/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize4(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = path.split(/\/+/);
        for (var part, up = 0, i4 = parts.length - 1; i4 >= 0; i4--) {
          part = parts[i4];
          if (part === ".") {
            parts.splice(i4, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i4 + 1, up);
              up = 0;
            } else {
              parts.splice(i4, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize4;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize4(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index2 = aRoot.lastIndexOf("/");
          if (index2 < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index2);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity(s4) {
        return s4;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s4) {
        if (!s4) {
          return false;
        }
        var length = s4.length;
        if (length < 9) {
          return false;
        }
        if (s4.charCodeAt(length - 1) !== 95 || s4.charCodeAt(length - 2) !== 95 || s4.charCodeAt(length - 3) !== 111 || s4.charCodeAt(length - 4) !== 116 || s4.charCodeAt(length - 5) !== 111 || s4.charCodeAt(length - 6) !== 114 || s4.charCodeAt(length - 7) !== 112 || s4.charCodeAt(length - 8) !== 95 || s4.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i4 = length - 10; i4 >= 0; i4--) {
          if (s4.charCodeAt(i4) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index2 = parsed.path.lastIndexOf("/");
            if (index2 >= 0) {
              parsed.path = parsed.path.substring(0, index2 + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize4(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // node_modules/source-map/lib/array-set.js
  var require_array_set = __commonJS({
    "node_modules/source-map/lib/array-set.js"(exports) {
      var util = require_util();
      var has = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set2 = new ArraySet();
        for (var i4 = 0, len = aArray.length; i4 < len; i4++) {
          set2.add(aArray[i4], aAllowDuplicates);
        }
        return set2;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // node_modules/source-map/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "node_modules/source-map/lib/mapping-list.js"(exports) {
      var util = require_util();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // node_modules/source-map/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "node_modules/source-map/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util = require_util();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, "generated");
        var original = util.getArg(aArgs, "original", null);
        var source = util.getArg(aArgs, "source", null);
        var name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next2;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i4 = 0, len = mappings.length; i4 < len; i4++) {
          mapping = mappings[i4];
          next2 = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next2 += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i4 > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i4 - 1])) {
                continue;
              }
              next2 += ",";
            }
          }
          next2 += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next2 += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next2 += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next2 += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next2 += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next2;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map2 = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map2.file = this._file;
        }
        if (this._sourceRoot != null) {
          map2.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
        }
        return map2;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    }
  });

  // node_modules/source-map/lib/binary-search.js
  var require_binary_search = __commonJS({
    "node_modules/source-map/lib/binary-search.js"(exports) {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index2 = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports.GREATEST_LOWER_BOUND
        );
        if (index2 < 0) {
          return -1;
        }
        while (index2 - 1 >= 0) {
          if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
            break;
          }
          --index2;
        }
        return index2;
      };
    }
  });

  // node_modules/source-map/lib/quick-sort.js
  var require_quick_sort = __commonJS({
    "node_modules/source-map/lib/quick-sort.js"(exports) {
      function swap(ary, x2, y2) {
        var temp = ary[x2];
        ary[x2] = ary[y2];
        ary[y2] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator, p2, r3) {
        if (p2 < r3) {
          var pivotIndex = randomIntInRange(p2, r3);
          var i4 = p2 - 1;
          swap(ary, pivotIndex, r3);
          var pivot = ary[r3];
          for (var j2 = p2; j2 < r3; j2++) {
            if (comparator(ary[j2], pivot) <= 0) {
              i4 += 1;
              swap(ary, i4, j2);
            }
          }
          swap(ary, i4 + 1, j2);
          var q2 = i4 + 1;
          doQuickSort(ary, comparator, p2, q2 - 1);
          doQuickSort(ary, comparator, q2 + 1, r3);
        }
      }
      exports.quickSort = function(ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
    }
  });

  // node_modules/source-map/lib/source-map-consumer.js
  var require_source_map_consumer = __commonJS({
    "node_modules/source-map/lib/source-map-consumer.js"(exports) {
      var util = require_util();
      var binarySearch = require_binary_search();
      var ArraySet = require_array_set().ArraySet;
      var base64VLQ = require_base64_vlq();
      var quickSort = require_quick_sort().quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };
      SourceMapConsumer.prototype._version = 3;
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
        var c3 = aStr.charAt(index2);
        return c3 === ";" || c3 === ",";
      };
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context3 = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function(mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context3);
      };
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, "line");
        var needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index2 = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index2 >= 0) {
          var mapping = this._originalMappings[index2];
          if (aArgs.column === void 0) {
            var originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index2];
            }
          } else {
            var originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index2];
            }
          }
        }
        return mappings;
      };
      exports.SourceMapConsumer = SourceMapConsumer;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version = util.getArg(sourceMap, "version");
        var sources = util.getArg(sourceMap, "sources");
        var names = util.getArg(sourceMap, "names", []);
        var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        var mappings = util.getArg(sourceMap, "mappings");
        var file = util.getArg(sourceMap, "file", null);
        if (version != this._version) {
          throw new Error("Unsupported version: " + version);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util.normalize).map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function(s4) {
          return util.computeSourceURL(sourceRoot, s4, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
      BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        var i4;
        for (i4 = 0; i4 < this._absoluteSources.length; ++i4) {
          if (this._absoluteSources[i4] == aSource) {
            return i4;
          }
        }
        return -1;
      };
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(
          smc._sources.toArray(),
          smc.sourceRoot
        );
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function(s4) {
          return util.computeSourceURL(smc.sourceRoot, s4, aSourceMapURL);
        });
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i4 = 0, length = generatedMappings.length; i4 < length; i4++) {
          var srcMapping = generatedMappings[i4];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
        return smc;
      };
      BasicSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function() {
          return this._absoluteSources.slice();
        }
      });
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index2 = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        while (index2 < length) {
          if (aStr.charAt(index2) === ";") {
            generatedLine++;
            index2++;
            previousGeneratedColumn = 0;
          } else if (aStr.charAt(index2) === ",") {
            index2++;
          } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for (end = index2; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index2, end);
            segment = cachedSegments[str];
            if (segment) {
              index2 += str.length;
            } else {
              segment = [];
              while (index2 < end) {
                base64VLQ.decode(aStr, index2, temp);
                value = temp.value;
                index2 = temp.rest;
                segment.push(value);
              }
              if (segment.length === 2) {
                throw new Error("Found a source, but no line and column");
              }
              if (segment.length === 3) {
                throw new Error("Found a source and line, but no column");
              }
              cachedSegments[str] = segment;
            }
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
              if (segment.length > 4) {
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === "number") {
              originalMappings.push(mapping);
            }
          }
        }
        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
        quickSort(originalMappings, util.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
          var mapping = this._generatedMappings[index2];
          if (index2 + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index2 + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = Infinity;
        }
      };
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var index2 = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util.compareByGeneratedPositionsDeflated,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index2 >= 0) {
          var mapping = this._generatedMappings[index2];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      };
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index2 = this._findSourceIndex(aSource);
        if (index2 >= 0) {
          return this.sourcesContent[index2];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        var index2 = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index2 >= 0) {
          var mapping = this._originalMappings[index2];
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version = util.getArg(sourceMap, "version");
        var sections = util.getArg(sourceMap, "sections");
        if (version != this._version) {
          throw new Error("Unsupported version: " + version);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function(s4) {
          if (s4.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          var offset2 = util.getArg(s4, "offset");
          var offsetLine = util.getArg(offset2, "line");
          var offsetColumn = util.getArg(offset2, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset2;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s4, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
      IndexedSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function() {
          var sources = [];
          for (var i4 = 0; i4 < this._sections.length; i4++) {
            for (var j2 = 0; j2 < this._sections[i4].consumer.sources.length; j2++) {
              sources.push(this._sections[i4].consumer.sources[j2]);
            }
          }
          return sources;
        }
      });
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function(s4) {
          return s4.consumer.hasContentsOfAllSources();
        });
      };
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i4 = 0; i4 < this._sections.length; i4++) {
          var section = this._sections[i4];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i4 = 0; i4 < this._sections.length; i4++) {
          var section = this._sections[i4];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      };
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i4 = 0; i4 < this._sections.length; i4++) {
          var section = this._sections[i4];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j2 = 0; j2 < sectionMappings.length; j2++) {
            var mapping = sectionMappings[j2];
            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }
            var adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }
  });

  // node_modules/source-map/lib/source-node.js
  var require_source_node = __commonJS({
    "node_modules/source-map/lib/source-node.js"(exports) {
      var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      var util = require_util();
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node = new SourceNode();
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i4 = aChunk.length - 1; i4 >= 0; i4--) {
            this.prepend(aChunk[i4]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i4 = 0, len = this.children.length; i4 < len; i4++) {
          chunk = this.children[i4];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i4;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i4 = 0; i4 < len - 1; i4++) {
            newChildren.push(this.children[i4]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i4]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i4 = 0, len = this.children.length; i4 < len; i4++) {
          if (this.children[i4][isSourceNode]) {
            this.children[i4].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i4 = 0, len = sources.length; i4 < len; i4++) {
          aFn(util.fromSetString(sources[i4]), this.sourceContents[sources[i4]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map2 = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map2.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map2.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map2.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map2.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map: map2 };
      };
      exports.SourceNode = SourceNode;
    }
  });

  // node_modules/source-map/source-map.js
  var require_source_map = __commonJS({
    "node_modules/source-map/source-map.js"(exports) {
      exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
      exports.SourceNode = require_source_node().SourceNode;
    }
  });

  // node_modules/estree-walker/dist/umd/estree-walker.js
  var require_estree_walker = __commonJS({
    "node_modules/estree-walker/dist/umd/estree-walker.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.estreeWalker = {}));
      })(exports, function(exports2) {
        "use strict";
        class WalkerBase {
          constructor() {
            this.should_skip = false;
            this.should_remove = false;
            this.replacement = null;
            this.context = {
              skip: () => this.should_skip = true,
              remove: () => this.should_remove = true,
              replace: (node) => this.replacement = node
            };
          }
          /**
           *
           * @param {any} parent
           * @param {string} prop
           * @param {number} index
           * @param {BaseNode} node
           */
          replace(parent2, prop, index2, node) {
            if (parent2) {
              if (index2 !== null) {
                parent2[prop][index2] = node;
              } else {
                parent2[prop] = node;
              }
            }
          }
          /**
           *
           * @param {any} parent
           * @param {string} prop
           * @param {number} index
           */
          remove(parent2, prop, index2) {
            if (parent2) {
              if (index2 !== null) {
                parent2[prop].splice(index2, 1);
              } else {
                delete parent2[prop];
              }
            }
          }
        }
        class SyncWalker extends WalkerBase {
          /**
           *
           * @param {SyncHandler} enter
           * @param {SyncHandler} leave
           */
          constructor(enter, leave) {
            super();
            this.enter = enter;
            this.leave = leave;
          }
          /**
           *
           * @param {BaseNode} node
           * @param {BaseNode} parent
           * @param {string} [prop]
           * @param {number} [index]
           * @returns {BaseNode}
           */
          visit(node, parent2, prop, index2) {
            if (node) {
              if (this.enter) {
                const _should_skip = this.should_skip;
                const _should_remove = this.should_remove;
                const _replacement = this.replacement;
                this.should_skip = false;
                this.should_remove = false;
                this.replacement = null;
                this.enter.call(this.context, node, parent2, prop, index2);
                if (this.replacement) {
                  node = this.replacement;
                  this.replace(parent2, prop, index2, node);
                }
                if (this.should_remove) {
                  this.remove(parent2, prop, index2);
                }
                const skipped = this.should_skip;
                const removed = this.should_remove;
                this.should_skip = _should_skip;
                this.should_remove = _should_remove;
                this.replacement = _replacement;
                if (skipped) return node;
                if (removed) return null;
              }
              for (const key in node) {
                const value = node[key];
                if (typeof value !== "object") {
                  continue;
                } else if (Array.isArray(value)) {
                  for (let i4 = 0; i4 < value.length; i4 += 1) {
                    if (value[i4] !== null && typeof value[i4].type === "string") {
                      if (!this.visit(value[i4], node, key, i4)) {
                        i4--;
                      }
                    }
                  }
                } else if (value !== null && typeof value.type === "string") {
                  this.visit(value, node, key, null);
                }
              }
              if (this.leave) {
                const _replacement = this.replacement;
                const _should_remove = this.should_remove;
                this.replacement = null;
                this.should_remove = false;
                this.leave.call(this.context, node, parent2, prop, index2);
                if (this.replacement) {
                  node = this.replacement;
                  this.replace(parent2, prop, index2, node);
                }
                if (this.should_remove) {
                  this.remove(parent2, prop, index2);
                }
                const removed = this.should_remove;
                this.replacement = _replacement;
                this.should_remove = _should_remove;
                if (removed) return null;
              }
            }
            return node;
          }
        }
        class AsyncWalker extends WalkerBase {
          /**
           *
           * @param {AsyncHandler} enter
           * @param {AsyncHandler} leave
           */
          constructor(enter, leave) {
            super();
            this.enter = enter;
            this.leave = leave;
          }
          /**
           *
           * @param {BaseNode} node
           * @param {BaseNode} parent
           * @param {string} [prop]
           * @param {number} [index]
           * @returns {Promise<BaseNode>}
           */
          visit(node, parent2, prop, index2) {
            return __async(this, null, function* () {
              if (node) {
                if (this.enter) {
                  const _should_skip = this.should_skip;
                  const _should_remove = this.should_remove;
                  const _replacement = this.replacement;
                  this.should_skip = false;
                  this.should_remove = false;
                  this.replacement = null;
                  yield this.enter.call(this.context, node, parent2, prop, index2);
                  if (this.replacement) {
                    node = this.replacement;
                    this.replace(parent2, prop, index2, node);
                  }
                  if (this.should_remove) {
                    this.remove(parent2, prop, index2);
                  }
                  const skipped = this.should_skip;
                  const removed = this.should_remove;
                  this.should_skip = _should_skip;
                  this.should_remove = _should_remove;
                  this.replacement = _replacement;
                  if (skipped) return node;
                  if (removed) return null;
                }
                for (const key in node) {
                  const value = node[key];
                  if (typeof value !== "object") {
                    continue;
                  } else if (Array.isArray(value)) {
                    for (let i4 = 0; i4 < value.length; i4 += 1) {
                      if (value[i4] !== null && typeof value[i4].type === "string") {
                        if (!(yield this.visit(value[i4], node, key, i4))) {
                          i4--;
                        }
                      }
                    }
                  } else if (value !== null && typeof value.type === "string") {
                    yield this.visit(value, node, key, null);
                  }
                }
                if (this.leave) {
                  const _replacement = this.replacement;
                  const _should_remove = this.should_remove;
                  this.replacement = null;
                  this.should_remove = false;
                  yield this.leave.call(this.context, node, parent2, prop, index2);
                  if (this.replacement) {
                    node = this.replacement;
                    this.replace(parent2, prop, index2, node);
                  }
                  if (this.should_remove) {
                    this.remove(parent2, prop, index2);
                  }
                  const removed = this.should_remove;
                  this.replacement = _replacement;
                  this.should_remove = _should_remove;
                  if (removed) return null;
                }
              }
              return node;
            });
          }
        }
        function walk(ast, { enter, leave }) {
          const instance = new SyncWalker(enter, leave);
          return instance.visit(ast, null);
        }
        function asyncWalk(_0, _1) {
          return __async(this, arguments, function* (ast, { enter, leave }) {
            const instance = new AsyncWalker(enter, leave);
            return yield instance.visit(ast, null);
          });
        }
        exports2.asyncWalk = asyncWalk;
        exports2.walk = walk;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@vue/compiler-core/dist/compiler-core.cjs.js
  var require_compiler_core_cjs = __commonJS({
    "node_modules/@vue/compiler-core/dist/compiler-core.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var shared = require_shared();
      var parser = require_lib();
      var sourceMap = require_source_map();
      var estreeWalker = require_estree_walker();
      function defaultOnError(error) {
        throw error;
      }
      function defaultOnWarn(msg) {
        console.warn(`[Vue warn] ${msg.message}`);
      }
      function createCompilerError(code, loc, messages, additionalMessage) {
        const msg = (messages || errorMessages)[code] + (additionalMessage || ``);
        const error = new SyntaxError(String(msg));
        error.code = code;
        error.loc = loc;
        return error;
      }
      var errorMessages = {
        // parse errors
        [
          0
          /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
        ]: "Illegal comment.",
        [
          1
          /* CDATA_IN_HTML_CONTENT */
        ]: "CDATA section is allowed only in XML context.",
        [
          2
          /* DUPLICATE_ATTRIBUTE */
        ]: "Duplicate attribute.",
        [
          3
          /* END_TAG_WITH_ATTRIBUTES */
        ]: "End tag cannot have attributes.",
        [
          4
          /* END_TAG_WITH_TRAILING_SOLIDUS */
        ]: "Illegal '/' in tags.",
        [
          5
          /* EOF_BEFORE_TAG_NAME */
        ]: "Unexpected EOF in tag.",
        [
          6
          /* EOF_IN_CDATA */
        ]: "Unexpected EOF in CDATA section.",
        [
          7
          /* EOF_IN_COMMENT */
        ]: "Unexpected EOF in comment.",
        [
          8
          /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
        ]: "Unexpected EOF in script.",
        [
          9
          /* EOF_IN_TAG */
        ]: "Unexpected EOF in tag.",
        [
          10
          /* INCORRECTLY_CLOSED_COMMENT */
        ]: "Incorrectly closed comment.",
        [
          11
          /* INCORRECTLY_OPENED_COMMENT */
        ]: "Incorrectly opened comment.",
        [
          12
          /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
        ]: "Illegal tag name. Use '&lt;' to print '<'.",
        [
          13
          /* MISSING_ATTRIBUTE_VALUE */
        ]: "Attribute value was expected.",
        [
          14
          /* MISSING_END_TAG_NAME */
        ]: "End tag name was expected.",
        [
          15
          /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
        ]: "Whitespace was expected.",
        [
          16
          /* NESTED_COMMENT */
        ]: "Unexpected '<!--' in comment.",
        [
          17
          /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */
        ]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
        [
          18
          /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */
        ]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
        [
          19
          /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
        ]: "Attribute name cannot start with '='.",
        [
          21
          /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */
        ]: "'<?' is allowed only in XML context.",
        [
          20
          /* UNEXPECTED_NULL_CHARACTER */
        ]: `Unexpected null character.`,
        [
          22
          /* UNEXPECTED_SOLIDUS_IN_TAG */
        ]: "Illegal '/' in tags.",
        // Vue-specific parse errors
        [
          23
          /* X_INVALID_END_TAG */
        ]: "Invalid end tag.",
        [
          24
          /* X_MISSING_END_TAG */
        ]: "Element is missing end tag.",
        [
          25
          /* X_MISSING_INTERPOLATION_END */
        ]: "Interpolation end sign was not found.",
        [
          27
          /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
        ]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
        [
          26
          /* X_MISSING_DIRECTIVE_NAME */
        ]: "Legal directive name was expected.",
        // transform errors
        [
          28
          /* X_V_IF_NO_EXPRESSION */
        ]: `v-if/v-else-if is missing expression.`,
        [
          29
          /* X_V_IF_SAME_KEY */
        ]: `v-if/else branches must use unique keys.`,
        [
          30
          /* X_V_ELSE_NO_ADJACENT_IF */
        ]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
        [
          31
          /* X_V_FOR_NO_EXPRESSION */
        ]: `v-for is missing expression.`,
        [
          32
          /* X_V_FOR_MALFORMED_EXPRESSION */
        ]: `v-for has invalid expression.`,
        [
          33
          /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */
        ]: `<template v-for> key should be placed on the <template> tag.`,
        [
          34
          /* X_V_BIND_NO_EXPRESSION */
        ]: `v-bind is missing expression.`,
        [
          35
          /* X_V_ON_NO_EXPRESSION */
        ]: `v-on is missing expression.`,
        [
          36
          /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */
        ]: `Unexpected custom directive on <slot> outlet.`,
        [
          37
          /* X_V_SLOT_MIXED_SLOT_USAGE */
        ]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
        [
          38
          /* X_V_SLOT_DUPLICATE_SLOT_NAMES */
        ]: `Duplicate slot names found. `,
        [
          39
          /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */
        ]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
        [
          40
          /* X_V_SLOT_MISPLACED */
        ]: `v-slot can only be used on components or <template> tags.`,
        [
          41
          /* X_V_MODEL_NO_EXPRESSION */
        ]: `v-model is missing expression.`,
        [
          42
          /* X_V_MODEL_MALFORMED_EXPRESSION */
        ]: `v-model value must be a valid JavaScript member expression.`,
        [
          43
          /* X_V_MODEL_ON_SCOPE_VARIABLE */
        ]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
        [
          44
          /* X_INVALID_EXPRESSION */
        ]: `Error parsing JavaScript expression: `,
        [
          45
          /* X_KEEP_ALIVE_INVALID_CHILDREN */
        ]: `<KeepAlive> expects exactly one child component.`,
        // generic errors
        [
          46
          /* X_PREFIX_ID_NOT_SUPPORTED */
        ]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
        [
          47
          /* X_MODULE_MODE_NOT_SUPPORTED */
        ]: `ES module mode is not supported in this build of compiler.`,
        [
          48
          /* X_CACHE_HANDLER_NOT_SUPPORTED */
        ]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
        [
          49
          /* X_SCOPE_ID_NOT_SUPPORTED */
        ]: `"scopeId" option is only supported in module mode.`,
        // just to fulfill types
        [
          50
          /* __EXTEND_POINT__ */
        ]: ``
      };
      var FRAGMENT = Symbol(`Fragment`);
      var TELEPORT = Symbol(`Teleport`);
      var SUSPENSE = Symbol(`Suspense`);
      var KEEP_ALIVE = Symbol(`KeepAlive`);
      var BASE_TRANSITION = Symbol(`BaseTransition`);
      var OPEN_BLOCK = Symbol(`openBlock`);
      var CREATE_BLOCK = Symbol(`createBlock`);
      var CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock`);
      var CREATE_VNODE = Symbol(`createVNode`);
      var CREATE_ELEMENT_VNODE = Symbol(`createElementVNode`);
      var CREATE_COMMENT = Symbol(`createCommentVNode`);
      var CREATE_TEXT = Symbol(`createTextVNode`);
      var CREATE_STATIC = Symbol(`createStaticVNode`);
      var RESOLVE_COMPONENT = Symbol(`resolveComponent`);
      var RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent`);
      var RESOLVE_DIRECTIVE = Symbol(`resolveDirective`);
      var RESOLVE_FILTER = Symbol(`resolveFilter`);
      var WITH_DIRECTIVES = Symbol(`withDirectives`);
      var RENDER_LIST = Symbol(`renderList`);
      var RENDER_SLOT = Symbol(`renderSlot`);
      var CREATE_SLOTS = Symbol(`createSlots`);
      var TO_DISPLAY_STRING = Symbol(`toDisplayString`);
      var MERGE_PROPS = Symbol(`mergeProps`);
      var NORMALIZE_CLASS = Symbol(`normalizeClass`);
      var NORMALIZE_STYLE = Symbol(`normalizeStyle`);
      var NORMALIZE_PROPS = Symbol(`normalizeProps`);
      var GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps`);
      var TO_HANDLERS = Symbol(`toHandlers`);
      var CAMELIZE = Symbol(`camelize`);
      var CAPITALIZE = Symbol(`capitalize`);
      var TO_HANDLER_KEY = Symbol(`toHandlerKey`);
      var SET_BLOCK_TRACKING = Symbol(`setBlockTracking`);
      var PUSH_SCOPE_ID = Symbol(`pushScopeId`);
      var POP_SCOPE_ID = Symbol(`popScopeId`);
      var WITH_CTX = Symbol(`withCtx`);
      var UNREF = Symbol(`unref`);
      var IS_REF = Symbol(`isRef`);
      var WITH_MEMO = Symbol(`withMemo`);
      var IS_MEMO_SAME = Symbol(`isMemoSame`);
      var helperNameMap = {
        [FRAGMENT]: `Fragment`,
        [TELEPORT]: `Teleport`,
        [SUSPENSE]: `Suspense`,
        [KEEP_ALIVE]: `KeepAlive`,
        [BASE_TRANSITION]: `BaseTransition`,
        [OPEN_BLOCK]: `openBlock`,
        [CREATE_BLOCK]: `createBlock`,
        [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
        [CREATE_VNODE]: `createVNode`,
        [CREATE_ELEMENT_VNODE]: `createElementVNode`,
        [CREATE_COMMENT]: `createCommentVNode`,
        [CREATE_TEXT]: `createTextVNode`,
        [CREATE_STATIC]: `createStaticVNode`,
        [RESOLVE_COMPONENT]: `resolveComponent`,
        [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
        [RESOLVE_DIRECTIVE]: `resolveDirective`,
        [RESOLVE_FILTER]: `resolveFilter`,
        [WITH_DIRECTIVES]: `withDirectives`,
        [RENDER_LIST]: `renderList`,
        [RENDER_SLOT]: `renderSlot`,
        [CREATE_SLOTS]: `createSlots`,
        [TO_DISPLAY_STRING]: `toDisplayString`,
        [MERGE_PROPS]: `mergeProps`,
        [NORMALIZE_CLASS]: `normalizeClass`,
        [NORMALIZE_STYLE]: `normalizeStyle`,
        [NORMALIZE_PROPS]: `normalizeProps`,
        [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
        [TO_HANDLERS]: `toHandlers`,
        [CAMELIZE]: `camelize`,
        [CAPITALIZE]: `capitalize`,
        [TO_HANDLER_KEY]: `toHandlerKey`,
        [SET_BLOCK_TRACKING]: `setBlockTracking`,
        [PUSH_SCOPE_ID]: `pushScopeId`,
        [POP_SCOPE_ID]: `popScopeId`,
        [WITH_CTX]: `withCtx`,
        [UNREF]: `unref`,
        [IS_REF]: `isRef`,
        [WITH_MEMO]: `withMemo`,
        [IS_MEMO_SAME]: `isMemoSame`
      };
      function registerRuntimeHelpers(helpers) {
        Object.getOwnPropertySymbols(helpers).forEach((s4) => {
          helperNameMap[s4] = helpers[s4];
        });
      }
      var locStub = {
        source: "",
        start: { line: 1, column: 1, offset: 0 },
        end: { line: 1, column: 1, offset: 0 }
      };
      function createRoot(children2, loc = locStub) {
        return {
          type: 0,
          children: children2,
          helpers: [],
          components: [],
          directives: [],
          hoists: [],
          imports: [],
          cached: 0,
          temps: 0,
          codegenNode: void 0,
          loc
        };
      }
      function createVNodeCall(context3, tag, props, children2, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
        if (context3) {
          if (isBlock) {
            context3.helper(OPEN_BLOCK);
            context3.helper(getVNodeBlockHelper(context3.inSSR, isComponent2));
          } else {
            context3.helper(getVNodeHelper(context3.inSSR, isComponent2));
          }
          if (directives) {
            context3.helper(WITH_DIRECTIVES);
          }
        }
        return {
          type: 13,
          tag,
          props,
          children: children2,
          patchFlag,
          dynamicProps,
          directives,
          isBlock,
          disableTracking,
          isComponent: isComponent2,
          loc
        };
      }
      function createArrayExpression(elements, loc = locStub) {
        return {
          type: 17,
          loc,
          elements
        };
      }
      function createObjectExpression(properties, loc = locStub) {
        return {
          type: 15,
          loc,
          properties
        };
      }
      function createObjectProperty(key, value) {
        return {
          type: 16,
          loc: locStub,
          key: shared.isString(key) ? createSimpleExpression(key, true) : key,
          value
        };
      }
      function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
        return {
          type: 4,
          loc,
          content,
          isStatic,
          constType: isStatic ? 3 : constType
        };
      }
      function createInterpolation(content, loc) {
        return {
          type: 5,
          loc,
          content: shared.isString(content) ? createSimpleExpression(content, false, loc) : content
        };
      }
      function createCompoundExpression(children2, loc = locStub) {
        return {
          type: 8,
          loc,
          children: children2
        };
      }
      function createCallExpression(callee, args = [], loc = locStub) {
        return {
          type: 14,
          loc,
          callee,
          arguments: args
        };
      }
      function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
        return {
          type: 18,
          params,
          returns,
          newline,
          isSlot,
          loc
        };
      }
      function createConditionalExpression(test, consequent, alternate, newline = true) {
        return {
          type: 19,
          test,
          consequent,
          alternate,
          newline,
          loc: locStub
        };
      }
      function createCacheExpression(index2, value, isVNode = false) {
        return {
          type: 20,
          index: index2,
          value,
          isVNode,
          loc: locStub
        };
      }
      function createBlockStatement(body2) {
        return {
          type: 21,
          body: body2,
          loc: locStub
        };
      }
      function createTemplateLiteral(elements) {
        return {
          type: 22,
          elements,
          loc: locStub
        };
      }
      function createIfStatement(test, consequent, alternate) {
        return {
          type: 23,
          test,
          consequent,
          alternate,
          loc: locStub
        };
      }
      function createAssignmentExpression(left, right) {
        return {
          type: 24,
          left,
          right,
          loc: locStub
        };
      }
      function createSequenceExpression(expressions) {
        return {
          type: 25,
          expressions,
          loc: locStub
        };
      }
      function createReturnStatement(returns) {
        return {
          type: 26,
          returns,
          loc: locStub
        };
      }
      var isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
      var isBuiltInType = (tag, expected) => tag === expected || tag === shared.hyphenate(expected);
      function isCoreComponent(tag) {
        if (isBuiltInType(tag, "Teleport")) {
          return TELEPORT;
        } else if (isBuiltInType(tag, "Suspense")) {
          return SUSPENSE;
        } else if (isBuiltInType(tag, "KeepAlive")) {
          return KEEP_ALIVE;
        } else if (isBuiltInType(tag, "BaseTransition")) {
          return BASE_TRANSITION;
        }
      }
      var nonIdentifierRE = /^\d|[^\$\w]/;
      var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
      var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
      var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
      var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
      var isMemberExpressionBrowser = (path) => {
        path = path.trim().replace(whitespaceRE, (s4) => s4.trim());
        let state = 0;
        let stateStack = [];
        let currentOpenBracketCount = 0;
        let currentOpenParensCount = 0;
        let currentStringType = null;
        for (let i4 = 0; i4 < path.length; i4++) {
          const char = path.charAt(i4);
          switch (state) {
            case 0:
              if (char === "[") {
                stateStack.push(state);
                state = 1;
                currentOpenBracketCount++;
              } else if (char === "(") {
                stateStack.push(state);
                state = 2;
                currentOpenParensCount++;
              } else if (!(i4 === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                return false;
              }
              break;
            case 1:
              if (char === `'` || char === `"` || char === "`") {
                stateStack.push(state);
                state = 3;
                currentStringType = char;
              } else if (char === `[`) {
                currentOpenBracketCount++;
              } else if (char === `]`) {
                if (!--currentOpenBracketCount) {
                  state = stateStack.pop();
                }
              }
              break;
            case 2:
              if (char === `'` || char === `"` || char === "`") {
                stateStack.push(state);
                state = 3;
                currentStringType = char;
              } else if (char === `(`) {
                currentOpenParensCount++;
              } else if (char === `)`) {
                if (i4 === path.length - 1) {
                  return false;
                }
                if (!--currentOpenParensCount) {
                  state = stateStack.pop();
                }
              }
              break;
            case 3:
              if (char === currentStringType) {
                state = stateStack.pop();
                currentStringType = null;
              }
              break;
          }
        }
        return !currentOpenBracketCount && !currentOpenParensCount;
      };
      var isMemberExpressionNode = (path, context3) => {
        try {
          let ret = parser.parseExpression(path, {
            plugins: context3.expressionPlugins
          });
          if (ret.type === "TSAsExpression" || ret.type === "TSTypeAssertion") {
            ret = ret.expression;
          }
          return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier";
        } catch (e4) {
          return false;
        }
      };
      var isMemberExpression = isMemberExpressionNode;
      function getInnerRange(loc, offset2, length) {
        const source = loc.source.slice(offset2, offset2 + length);
        const newLoc = {
          source,
          start: advancePositionWithClone(loc.start, loc.source, offset2),
          end: loc.end
        };
        if (length != null) {
          newLoc.end = advancePositionWithClone(loc.start, loc.source, offset2 + length);
        }
        return newLoc;
      }
      function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
        return advancePositionWithMutation(shared.extend({}, pos), source, numberOfCharacters);
      }
      function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
        let linesCount = 0;
        let lastNewLinePos = -1;
        for (let i4 = 0; i4 < numberOfCharacters; i4++) {
          if (source.charCodeAt(i4) === 10) {
            linesCount++;
            lastNewLinePos = i4;
          }
        }
        pos.offset += numberOfCharacters;
        pos.line += linesCount;
        pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
        return pos;
      }
      function assert(condition, msg) {
        if (!condition) {
          throw new Error(msg || `unexpected compiler condition`);
        }
      }
      function findDir(node, name, allowEmpty = false) {
        for (let i4 = 0; i4 < node.props.length; i4++) {
          const p2 = node.props[i4];
          if (p2.type === 7 && (allowEmpty || p2.exp) && (shared.isString(name) ? p2.name === name : name.test(p2.name))) {
            return p2;
          }
        }
      }
      function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
        for (let i4 = 0; i4 < node.props.length; i4++) {
          const p2 = node.props[i4];
          if (p2.type === 6) {
            if (dynamicOnly)
              continue;
            if (p2.name === name && (p2.value || allowEmpty)) {
              return p2;
            }
          } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name)) {
            return p2;
          }
        }
      }
      function isStaticArgOf(arg, name) {
        return !!(arg && isStaticExp(arg) && arg.content === name);
      }
      function hasDynamicKeyVBind(node) {
        return node.props.some(
          (p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || // v-bind="obj"
          p2.arg.type !== 4 || // v-bind:[_ctx.foo]
          !p2.arg.isStatic)
          // v-bind:[foo]
        );
      }
      function isText(node) {
        return node.type === 5 || node.type === 2;
      }
      function isVSlot(p2) {
        return p2.type === 7 && p2.name === "slot";
      }
      function isTemplateNode(node) {
        return node.type === 1 && node.tagType === 3;
      }
      function isSlotOutlet(node) {
        return node.type === 1 && node.tagType === 2;
      }
      function getVNodeHelper(ssr, isComponent2) {
        return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
      }
      function getVNodeBlockHelper(ssr, isComponent2) {
        return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
      }
      var propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
      function getUnnormalizedProps(props, callPath = []) {
        if (props && !shared.isString(props) && props.type === 14) {
          const callee = props.callee;
          if (!shared.isString(callee) && propsHelperSet.has(callee)) {
            return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
          }
        }
        return [props, callPath];
      }
      function injectProp(node, prop, context3) {
        let propsWithInjection;
        let props = node.type === 13 ? node.props : node.arguments[2];
        let callPath = [];
        let parentCall;
        if (props && !shared.isString(props) && props.type === 14) {
          const ret = getUnnormalizedProps(props);
          props = ret[0];
          callPath = ret[1];
          parentCall = callPath[callPath.length - 1];
        }
        if (props == null || shared.isString(props)) {
          propsWithInjection = createObjectExpression([prop]);
        } else if (props.type === 14) {
          const first = props.arguments[0];
          if (!shared.isString(first) && first.type === 15) {
            first.properties.unshift(prop);
          } else {
            if (props.callee === TO_HANDLERS) {
              propsWithInjection = createCallExpression(context3.helper(MERGE_PROPS), [
                createObjectExpression([prop]),
                props
              ]);
            } else {
              props.arguments.unshift(createObjectExpression([prop]));
            }
          }
          !propsWithInjection && (propsWithInjection = props);
        } else if (props.type === 15) {
          let alreadyExists = false;
          if (prop.key.type === 4) {
            const propKeyName = prop.key.content;
            alreadyExists = props.properties.some((p2) => p2.key.type === 4 && p2.key.content === propKeyName);
          }
          if (!alreadyExists) {
            props.properties.unshift(prop);
          }
          propsWithInjection = props;
        } else {
          propsWithInjection = createCallExpression(context3.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
          ]);
          if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
            parentCall = callPath[callPath.length - 2];
          }
        }
        if (node.type === 13) {
          if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
          } else {
            node.props = propsWithInjection;
          }
        } else {
          if (parentCall) {
            parentCall.arguments[0] = propsWithInjection;
          } else {
            node.arguments[2] = propsWithInjection;
          }
        }
      }
      function toValidAssetId(name, type) {
        return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
          return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
        })}`;
      }
      function hasScopeRef(node, ids) {
        if (!node || Object.keys(ids).length === 0) {
          return false;
        }
        switch (node.type) {
          case 1:
            for (let i4 = 0; i4 < node.props.length; i4++) {
              const p2 = node.props[i4];
              if (p2.type === 7 && (hasScopeRef(p2.arg, ids) || hasScopeRef(p2.exp, ids))) {
                return true;
              }
            }
            return node.children.some((c3) => hasScopeRef(c3, ids));
          case 11:
            if (hasScopeRef(node.source, ids)) {
              return true;
            }
            return node.children.some((c3) => hasScopeRef(c3, ids));
          case 9:
            return node.branches.some((b2) => hasScopeRef(b2, ids));
          case 10:
            if (hasScopeRef(node.condition, ids)) {
              return true;
            }
            return node.children.some((c3) => hasScopeRef(c3, ids));
          case 4:
            return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
          case 8:
            return node.children.some((c3) => shared.isObject(c3) && hasScopeRef(c3, ids));
          case 5:
          case 12:
            return hasScopeRef(node.content, ids);
          case 2:
          case 3:
            return false;
          default:
            return false;
        }
      }
      function getMemoedVNodeCall(node) {
        if (node.type === 14 && node.callee === WITH_MEMO) {
          return node.arguments[1].returns;
        } else {
          return node;
        }
      }
      function makeBlock(node, { helper, removeHelper, inSSR }) {
        if (!node.isBlock) {
          node.isBlock = true;
          removeHelper(getVNodeHelper(inSSR, node.isComponent));
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(inSSR, node.isComponent));
        }
      }
      var deprecationData = {
        [
          "COMPILER_IS_ON_ELEMENT"
          /* COMPILER_IS_ON_ELEMENT */
        ]: {
          message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
          link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
        },
        [
          "COMPILER_V_BIND_SYNC"
          /* COMPILER_V_BIND_SYNC */
        ]: {
          message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
        },
        [
          "COMPILER_V_BIND_PROP"
          /* COMPILER_V_BIND_PROP */
        ]: {
          message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
        },
        [
          "COMPILER_V_BIND_OBJECT_ORDER"
          /* COMPILER_V_BIND_OBJECT_ORDER */
        ]: {
          message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
        },
        [
          "COMPILER_V_ON_NATIVE"
          /* COMPILER_V_ON_NATIVE */
        ]: {
          message: `.native modifier for v-on has been removed as is no longer necessary.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
        },
        [
          "COMPILER_V_IF_V_FOR_PRECEDENCE"
          /* COMPILER_V_IF_V_FOR_PRECEDENCE */
        ]: {
          message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
        },
        [
          "COMPILER_NATIVE_TEMPLATE"
          /* COMPILER_NATIVE_TEMPLATE */
        ]: {
          message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
        },
        [
          "COMPILER_INLINE_TEMPLATE"
          /* COMPILER_INLINE_TEMPLATE */
        ]: {
          message: `"inline-template" has been removed in Vue 3.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
        },
        [
          "COMPILER_FILTER"
          /* COMPILER_FILTERS */
        ]: {
          message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
        }
      };
      function getCompatValue(key, context3) {
        const config3 = context3.options ? context3.options.compatConfig : context3.compatConfig;
        const value = config3 && config3[key];
        if (key === "MODE") {
          return value || 3;
        } else {
          return value;
        }
      }
      function isCompatEnabled(key, context3) {
        const mode = getCompatValue("MODE", context3);
        const value = getCompatValue(key, context3);
        return mode === 3 ? value === true : value !== false;
      }
      function checkCompatEnabled(key, context3, loc, ...args) {
        const enabled = isCompatEnabled(key, context3);
        if (enabled) {
          warnDeprecation(key, context3, loc, ...args);
        }
        return enabled;
      }
      function warnDeprecation(key, context3, loc, ...args) {
        const val = getCompatValue(key, context3);
        if (val === "suppress-warning") {
          return;
        }
        const { message, link } = deprecationData[key];
        const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
        const err = new SyntaxError(msg);
        err.code = key;
        if (loc)
          err.loc = loc;
        context3.onWarn(err);
      }
      var decodeRE = /&(gt|lt|amp|apos|quot);/g;
      var decodeMap = {
        gt: ">",
        lt: "<",
        amp: "&",
        apos: "'",
        quot: '"'
      };
      var defaultParserOptions = {
        delimiters: [`{{`, `}}`],
        getNamespace: () => 0,
        getTextMode: () => 0,
        isVoidTag: shared.NO,
        isPreTag: shared.NO,
        isCustomElement: shared.NO,
        decodeEntities: (rawText) => rawText.replace(decodeRE, (_2, p1) => decodeMap[p1]),
        onError: defaultOnError,
        onWarn: defaultOnWarn,
        comments: true
      };
      function baseParse(content, options = {}) {
        const context3 = createParserContext(content, options);
        const start = getCursor(context3);
        return createRoot(parseChildren(context3, 0, []), getSelection(context3, start));
      }
      function createParserContext(content, rawOptions) {
        const options = shared.extend({}, defaultParserOptions);
        let key;
        for (key in rawOptions) {
          options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
        }
        return {
          options,
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false,
          onWarn: options.onWarn
        };
      }
      function parseChildren(context3, mode, ancestors) {
        const parent2 = last(ancestors);
        const ns = parent2 ? parent2.ns : 0;
        const nodes = [];
        while (!isEnd(context3, mode, ancestors)) {
          const s4 = context3.source;
          let node = void 0;
          if (mode === 0 || mode === 1) {
            if (!context3.inVPre && startsWith(s4, context3.options.delimiters[0])) {
              node = parseInterpolation(context3, mode);
            } else if (mode === 0 && s4[0] === "<") {
              if (s4.length === 1) {
                emitError(context3, 5, 1);
              } else if (s4[1] === "!") {
                if (startsWith(s4, "<!--")) {
                  node = parseComment(context3);
                } else if (startsWith(s4, "<!DOCTYPE")) {
                  node = parseBogusComment(context3);
                } else if (startsWith(s4, "<![CDATA[")) {
                  if (ns !== 0) {
                    node = parseCDATA(context3, ancestors);
                  } else {
                    emitError(
                      context3,
                      1
                      /* CDATA_IN_HTML_CONTENT */
                    );
                    node = parseBogusComment(context3);
                  }
                } else {
                  emitError(
                    context3,
                    11
                    /* INCORRECTLY_OPENED_COMMENT */
                  );
                  node = parseBogusComment(context3);
                }
              } else if (s4[1] === "/") {
                if (s4.length === 2) {
                  emitError(context3, 5, 2);
                } else if (s4[2] === ">") {
                  emitError(context3, 14, 2);
                  advanceBy(context3, 3);
                  continue;
                } else if (/[a-z]/i.test(s4[2])) {
                  emitError(
                    context3,
                    23
                    /* X_INVALID_END_TAG */
                  );
                  parseTag(context3, 1, parent2);
                  continue;
                } else {
                  emitError(context3, 12, 2);
                  node = parseBogusComment(context3);
                }
              } else if (/[a-z]/i.test(s4[1])) {
                node = parseElement(context3, ancestors);
                if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context3) && node && node.tag === "template" && !node.props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
                  warnDeprecation("COMPILER_NATIVE_TEMPLATE", context3, node.loc);
                  node = node.children;
                }
              } else if (s4[1] === "?") {
                emitError(context3, 21, 1);
                node = parseBogusComment(context3);
              } else {
                emitError(context3, 12, 1);
              }
            }
          }
          if (!node) {
            node = parseText(context3, mode);
          }
          if (shared.isArray(node)) {
            for (let i4 = 0; i4 < node.length; i4++) {
              pushNode(nodes, node[i4]);
            }
          } else {
            pushNode(nodes, node);
          }
        }
        let removedWhitespace = false;
        if (mode !== 2 && mode !== 1) {
          const shouldCondense = context3.options.whitespace !== "preserve";
          for (let i4 = 0; i4 < nodes.length; i4++) {
            const node = nodes[i4];
            if (!context3.inPre && node.type === 2) {
              if (!/[^\t\r\n\f ]/.test(node.content)) {
                const prev2 = nodes[i4 - 1];
                const next2 = nodes[i4 + 1];
                if (!prev2 || !next2 || shouldCondense && (prev2.type === 3 || next2.type === 3 || prev2.type === 1 && next2.type === 1 && /[\r\n]/.test(node.content))) {
                  removedWhitespace = true;
                  nodes[i4] = null;
                } else {
                  node.content = " ";
                }
              } else if (shouldCondense) {
                node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
              }
            } else if (node.type === 3 && !context3.options.comments) {
              removedWhitespace = true;
              nodes[i4] = null;
            }
          }
          if (context3.inPre && parent2 && context3.options.isPreTag(parent2.tag)) {
            const first = nodes[0];
            if (first && first.type === 2) {
              first.content = first.content.replace(/^\r?\n/, "");
            }
          }
        }
        return removedWhitespace ? nodes.filter(Boolean) : nodes;
      }
      function pushNode(nodes, node) {
        if (node.type === 2) {
          const prev2 = last(nodes);
          if (prev2 && prev2.type === 2 && prev2.loc.end.offset === node.loc.start.offset) {
            prev2.content += node.content;
            prev2.loc.end = node.loc.end;
            prev2.loc.source += node.loc.source;
            return;
          }
        }
        nodes.push(node);
      }
      function parseCDATA(context3, ancestors) {
        advanceBy(context3, 9);
        const nodes = parseChildren(context3, 3, ancestors);
        if (context3.source.length === 0) {
          emitError(
            context3,
            6
            /* EOF_IN_CDATA */
          );
        } else {
          advanceBy(context3, 3);
        }
        return nodes;
      }
      function parseComment(context3) {
        const start = getCursor(context3);
        let content;
        const match = /--(\!)?>/.exec(context3.source);
        if (!match) {
          content = context3.source.slice(4);
          advanceBy(context3, context3.source.length);
          emitError(
            context3,
            7
            /* EOF_IN_COMMENT */
          );
        } else {
          if (match.index <= 3) {
            emitError(
              context3,
              0
              /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
            );
          }
          if (match[1]) {
            emitError(
              context3,
              10
              /* INCORRECTLY_CLOSED_COMMENT */
            );
          }
          content = context3.source.slice(4, match.index);
          const s4 = context3.source.slice(0, match.index);
          let prevIndex = 1, nestedIndex = 0;
          while ((nestedIndex = s4.indexOf("<!--", prevIndex)) !== -1) {
            advanceBy(context3, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s4.length) {
              emitError(
                context3,
                16
                /* NESTED_COMMENT */
              );
            }
            prevIndex = nestedIndex + 1;
          }
          advanceBy(context3, match.index + match[0].length - prevIndex + 1);
        }
        return {
          type: 3,
          content,
          loc: getSelection(context3, start)
        };
      }
      function parseBogusComment(context3) {
        const start = getCursor(context3);
        const contentStart = context3.source[1] === "?" ? 1 : 2;
        let content;
        const closeIndex = context3.source.indexOf(">");
        if (closeIndex === -1) {
          content = context3.source.slice(contentStart);
          advanceBy(context3, context3.source.length);
        } else {
          content = context3.source.slice(contentStart, closeIndex);
          advanceBy(context3, closeIndex + 1);
        }
        return {
          type: 3,
          content,
          loc: getSelection(context3, start)
        };
      }
      function parseElement(context3, ancestors) {
        const wasInPre = context3.inPre;
        const wasInVPre = context3.inVPre;
        const parent2 = last(ancestors);
        const element = parseTag(context3, 0, parent2);
        const isPreBoundary = context3.inPre && !wasInPre;
        const isVPreBoundary = context3.inVPre && !wasInVPre;
        if (element.isSelfClosing || context3.options.isVoidTag(element.tag)) {
          if (isPreBoundary) {
            context3.inPre = false;
          }
          if (isVPreBoundary) {
            context3.inVPre = false;
          }
          return element;
        }
        ancestors.push(element);
        const mode = context3.options.getTextMode(element, parent2);
        const children2 = parseChildren(context3, mode, ancestors);
        ancestors.pop();
        {
          const inlineTemplateProp = element.props.find((p2) => p2.type === 6 && p2.name === "inline-template");
          if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context3, inlineTemplateProp.loc)) {
            const loc = getSelection(context3, element.loc.end);
            inlineTemplateProp.value = {
              type: 2,
              content: loc.source,
              loc
            };
          }
        }
        element.children = children2;
        if (startsWithEndTagOpen(context3.source, element.tag)) {
          parseTag(context3, 1, parent2);
        } else {
          emitError(context3, 24, 0, element.loc.start);
          if (context3.source.length === 0 && element.tag.toLowerCase() === "script") {
            const first = children2[0];
            if (first && startsWith(first.loc.source, "<!--")) {
              emitError(
                context3,
                8
                /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
              );
            }
          }
        }
        element.loc = getSelection(context3, element.loc.start);
        if (isPreBoundary) {
          context3.inPre = false;
        }
        if (isVPreBoundary) {
          context3.inVPre = false;
        }
        return element;
      }
      var isSpecialTemplateDirective = /* @__PURE__ */ shared.makeMap(`if,else,else-if,for,slot`);
      function parseTag(context3, type, parent2) {
        const start = getCursor(context3);
        const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context3.source);
        const tag = match[1];
        const ns = context3.options.getNamespace(tag, parent2);
        advanceBy(context3, match[0].length);
        advanceSpaces(context3);
        const cursor = getCursor(context3);
        const currentSource = context3.source;
        if (context3.options.isPreTag(tag)) {
          context3.inPre = true;
        }
        let props = parseAttributes(context3, type);
        if (type === 0 && !context3.inVPre && props.some((p2) => p2.type === 7 && p2.name === "pre")) {
          context3.inVPre = true;
          shared.extend(context3, cursor);
          context3.source = currentSource;
          props = parseAttributes(context3, type).filter((p2) => p2.name !== "v-pre");
        }
        let isSelfClosing = false;
        if (context3.source.length === 0) {
          emitError(
            context3,
            9
            /* EOF_IN_TAG */
          );
        } else {
          isSelfClosing = startsWith(context3.source, "/>");
          if (type === 1 && isSelfClosing) {
            emitError(
              context3,
              4
              /* END_TAG_WITH_TRAILING_SOLIDUS */
            );
          }
          advanceBy(context3, isSelfClosing ? 2 : 1);
        }
        if (type === 1) {
          return;
        }
        if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context3)) {
          let hasIf = false;
          let hasFor = false;
          for (let i4 = 0; i4 < props.length; i4++) {
            const p2 = props[i4];
            if (p2.type === 7) {
              if (p2.name === "if") {
                hasIf = true;
              } else if (p2.name === "for") {
                hasFor = true;
              }
            }
            if (hasIf && hasFor) {
              warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context3, getSelection(context3, start));
              break;
            }
          }
        }
        let tagType = 0;
        if (!context3.inVPre) {
          if (tag === "slot") {
            tagType = 2;
          } else if (tag === "template") {
            if (props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
              tagType = 3;
            }
          } else if (isComponent(tag, props, context3)) {
            tagType = 1;
          }
        }
        return {
          type: 1,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context3, start),
          codegenNode: void 0
          // to be created during transform phase
        };
      }
      function isComponent(tag, props, context3) {
        const options = context3.options;
        if (options.isCustomElement(tag)) {
          return false;
        }
        if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
          return true;
        }
        for (let i4 = 0; i4 < props.length; i4++) {
          const p2 = props[i4];
          if (p2.type === 6) {
            if (p2.name === "is" && p2.value) {
              if (p2.value.content.startsWith("vue:")) {
                return true;
              } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context3, p2.loc)) {
                return true;
              }
            }
          } else {
            if (p2.name === "is") {
              return true;
            } else if (
              // :is on plain element - only treat as component in compat mode
              p2.name === "bind" && isStaticArgOf(p2.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context3, p2.loc)
            ) {
              return true;
            }
          }
        }
      }
      function parseAttributes(context3, type) {
        const props = [];
        const attributeNames = /* @__PURE__ */ new Set();
        while (context3.source.length > 0 && !startsWith(context3.source, ">") && !startsWith(context3.source, "/>")) {
          if (startsWith(context3.source, "/")) {
            emitError(
              context3,
              22
              /* UNEXPECTED_SOLIDUS_IN_TAG */
            );
            advanceBy(context3, 1);
            advanceSpaces(context3);
            continue;
          }
          if (type === 1) {
            emitError(
              context3,
              3
              /* END_TAG_WITH_ATTRIBUTES */
            );
          }
          const attr2 = parseAttribute(context3, attributeNames);
          if (attr2.type === 6 && attr2.value && attr2.name === "class") {
            attr2.value.content = attr2.value.content.replace(/\s+/g, " ").trim();
          }
          if (type === 0) {
            props.push(attr2);
          }
          if (/^[^\t\r\n\f />]/.test(context3.source)) {
            emitError(
              context3,
              15
              /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
            );
          }
          advanceSpaces(context3);
        }
        return props;
      }
      function parseAttribute(context3, nameSet) {
        const start = getCursor(context3);
        const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context3.source);
        const name = match[0];
        if (nameSet.has(name)) {
          emitError(
            context3,
            2
            /* DUPLICATE_ATTRIBUTE */
          );
        }
        nameSet.add(name);
        if (name[0] === "=") {
          emitError(
            context3,
            19
            /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
          );
        }
        {
          const pattern = /["'<]/g;
          let m2;
          while (m2 = pattern.exec(name)) {
            emitError(context3, 17, m2.index);
          }
        }
        advanceBy(context3, name.length);
        let value = void 0;
        if (/^[\t\r\n\f ]*=/.test(context3.source)) {
          advanceSpaces(context3);
          advanceBy(context3, 1);
          advanceSpaces(context3);
          value = parseAttributeValue(context3);
          if (!value) {
            emitError(
              context3,
              13
              /* MISSING_ATTRIBUTE_VALUE */
            );
          }
        }
        const loc = getSelection(context3, start);
        if (!context3.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
          const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
          let isPropShorthand = startsWith(name, ".");
          let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
          let arg;
          if (match2[2]) {
            const isSlot = dirName === "slot";
            const startOffset = name.lastIndexOf(match2[2]);
            const loc2 = getSelection(context3, getNewPosition(context3, start, startOffset), getNewPosition(context3, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
            let content = match2[2];
            let isStatic = true;
            if (content.startsWith("[")) {
              isStatic = false;
              if (!content.endsWith("]")) {
                emitError(
                  context3,
                  27
                  /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
                );
                content = content.slice(1);
              } else {
                content = content.slice(1, content.length - 1);
              }
            } else if (isSlot) {
              content += match2[3] || "";
            }
            arg = {
              type: 4,
              content,
              isStatic,
              constType: isStatic ? 3 : 0,
              loc: loc2
            };
          }
          if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
          }
          const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
          if (isPropShorthand)
            modifiers.push("prop");
          if (dirName === "bind" && arg) {
            if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context3, loc, arg.loc.source)) {
              dirName = "model";
              modifiers.splice(modifiers.indexOf("sync"), 1);
            }
            if (modifiers.includes("prop")) {
              checkCompatEnabled("COMPILER_V_BIND_PROP", context3, loc);
            }
          }
          return {
            type: 7,
            name: dirName,
            exp: value && {
              type: 4,
              content: value.content,
              isStatic: false,
              // Treat as non-constant by default. This can be potentially set to
              // other values by `transformExpression` to make it eligible for hoisting.
              constType: 0,
              loc: value.loc
            },
            arg,
            modifiers,
            loc
          };
        }
        if (!context3.inVPre && startsWith(name, "v-")) {
          emitError(
            context3,
            26
            /* X_MISSING_DIRECTIVE_NAME */
          );
        }
        return {
          type: 6,
          name,
          value: value && {
            type: 2,
            content: value.content,
            loc: value.loc
          },
          loc
        };
      }
      function parseAttributeValue(context3) {
        const start = getCursor(context3);
        let content;
        const quote = context3.source[0];
        const isQuoted = quote === `"` || quote === `'`;
        if (isQuoted) {
          advanceBy(context3, 1);
          const endIndex = context3.source.indexOf(quote);
          if (endIndex === -1) {
            content = parseTextData(
              context3,
              context3.source.length,
              4
              /* ATTRIBUTE_VALUE */
            );
          } else {
            content = parseTextData(
              context3,
              endIndex,
              4
              /* ATTRIBUTE_VALUE */
            );
            advanceBy(context3, 1);
          }
        } else {
          const match = /^[^\t\r\n\f >]+/.exec(context3.source);
          if (!match) {
            return void 0;
          }
          const unexpectedChars = /["'<=`]/g;
          let m2;
          while (m2 = unexpectedChars.exec(match[0])) {
            emitError(context3, 18, m2.index);
          }
          content = parseTextData(
            context3,
            match[0].length,
            4
            /* ATTRIBUTE_VALUE */
          );
        }
        return { content, isQuoted, loc: getSelection(context3, start) };
      }
      function parseInterpolation(context3, mode) {
        const [open, close] = context3.options.delimiters;
        const closeIndex = context3.source.indexOf(close, open.length);
        if (closeIndex === -1) {
          emitError(
            context3,
            25
            /* X_MISSING_INTERPOLATION_END */
          );
          return void 0;
        }
        const start = getCursor(context3);
        advanceBy(context3, open.length);
        const innerStart = getCursor(context3);
        const innerEnd = getCursor(context3);
        const rawContentLength = closeIndex - open.length;
        const rawContent = context3.source.slice(0, rawContentLength);
        const preTrimContent = parseTextData(context3, rawContentLength, mode);
        const content = preTrimContent.trim();
        const startOffset = preTrimContent.indexOf(content);
        if (startOffset > 0) {
          advancePositionWithMutation(innerStart, rawContent, startOffset);
        }
        const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
        advancePositionWithMutation(innerEnd, rawContent, endOffset);
        advanceBy(context3, close.length);
        return {
          type: 5,
          content: {
            type: 4,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            constType: 0,
            content,
            loc: getSelection(context3, innerStart, innerEnd)
          },
          loc: getSelection(context3, start)
        };
      }
      function parseText(context3, mode) {
        const endTokens = mode === 3 ? ["]]>"] : ["<", context3.options.delimiters[0]];
        let endIndex = context3.source.length;
        for (let i4 = 0; i4 < endTokens.length; i4++) {
          const index2 = context3.source.indexOf(endTokens[i4], 1);
          if (index2 !== -1 && endIndex > index2) {
            endIndex = index2;
          }
        }
        const start = getCursor(context3);
        const content = parseTextData(context3, endIndex, mode);
        return {
          type: 2,
          content,
          loc: getSelection(context3, start)
        };
      }
      function parseTextData(context3, length, mode) {
        const rawText = context3.source.slice(0, length);
        advanceBy(context3, length);
        if (mode === 2 || mode === 3 || !rawText.includes("&")) {
          return rawText;
        } else {
          return context3.options.decodeEntities(
            rawText,
            mode === 4
            /* ATTRIBUTE_VALUE */
          );
        }
      }
      function getCursor(context3) {
        const { column, line, offset: offset2 } = context3;
        return { column, line, offset: offset2 };
      }
      function getSelection(context3, start, end) {
        end = end || getCursor(context3);
        return {
          start,
          end,
          source: context3.originalSource.slice(start.offset, end.offset)
        };
      }
      function last(xs) {
        return xs[xs.length - 1];
      }
      function startsWith(source, searchString) {
        return source.startsWith(searchString);
      }
      function advanceBy(context3, numberOfCharacters) {
        const { source } = context3;
        advancePositionWithMutation(context3, source, numberOfCharacters);
        context3.source = source.slice(numberOfCharacters);
      }
      function advanceSpaces(context3) {
        const match = /^[\t\r\n\f ]+/.exec(context3.source);
        if (match) {
          advanceBy(context3, match[0].length);
        }
      }
      function getNewPosition(context3, start, numberOfCharacters) {
        return advancePositionWithClone(start, context3.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
      }
      function emitError(context3, code, offset2, loc = getCursor(context3)) {
        if (offset2) {
          loc.offset += offset2;
          loc.column += offset2;
        }
        context3.options.onError(createCompilerError(code, {
          start: loc,
          end: loc,
          source: ""
        }));
      }
      function isEnd(context3, mode, ancestors) {
        const s4 = context3.source;
        switch (mode) {
          case 0:
            if (startsWith(s4, "</")) {
              for (let i4 = ancestors.length - 1; i4 >= 0; --i4) {
                if (startsWithEndTagOpen(s4, ancestors[i4].tag)) {
                  return true;
                }
              }
            }
            break;
          case 1:
          case 2: {
            const parent2 = last(ancestors);
            if (parent2 && startsWithEndTagOpen(s4, parent2.tag)) {
              return true;
            }
            break;
          }
          case 3:
            if (startsWith(s4, "]]>")) {
              return true;
            }
            break;
        }
        return !s4;
      }
      function startsWithEndTagOpen(source, tag) {
        return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
      }
      function hoistStatic(root, context3) {
        walk(
          root,
          context3,
          // Root node is unfortunately non-hoistable due to potential parent
          // fallthrough attributes.
          isSingleElementRoot(root, root.children[0])
        );
      }
      function isSingleElementRoot(root, child) {
        const { children: children2 } = root;
        return children2.length === 1 && child.type === 1 && !isSlotOutlet(child);
      }
      function walk(node, context3, doNotHoistNode = false) {
        const { children: children2 } = node;
        const originalCount = children2.length;
        let hoistedCount = 0;
        for (let i4 = 0; i4 < children2.length; i4++) {
          const child = children2[i4];
          if (child.type === 1 && child.tagType === 0) {
            const constantType = doNotHoistNode ? 0 : getConstantType(child, context3);
            if (constantType > 0) {
              if (constantType >= 2) {
                child.codegenNode.patchFlag = `-1 /* HOISTED */`;
                child.codegenNode = context3.hoist(child.codegenNode);
                hoistedCount++;
                continue;
              }
            } else {
              const codegenNode = child.codegenNode;
              if (codegenNode.type === 13) {
                const flag = getPatchFlag(codegenNode);
                if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context3) >= 2) {
                  const props = getNodeProps(child);
                  if (props) {
                    codegenNode.props = context3.hoist(props);
                  }
                }
                if (codegenNode.dynamicProps) {
                  codegenNode.dynamicProps = context3.hoist(codegenNode.dynamicProps);
                }
              }
            }
          } else if (child.type === 12 && getConstantType(child.content, context3) >= 2) {
            child.codegenNode = context3.hoist(child.codegenNode);
            hoistedCount++;
          }
          if (child.type === 1) {
            const isComponent2 = child.tagType === 1;
            if (isComponent2) {
              context3.scopes.vSlot++;
            }
            walk(child, context3);
            if (isComponent2) {
              context3.scopes.vSlot--;
            }
          } else if (child.type === 11) {
            walk(child, context3, child.children.length === 1);
          } else if (child.type === 9) {
            for (let i5 = 0; i5 < child.branches.length; i5++) {
              walk(child.branches[i5], context3, child.branches[i5].children.length === 1);
            }
          }
        }
        if (hoistedCount && context3.transformHoist) {
          context3.transformHoist(children2, context3, node);
        }
        if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && shared.isArray(node.codegenNode.children)) {
          node.codegenNode.children = context3.hoist(createArrayExpression(node.codegenNode.children));
        }
      }
      function getConstantType(node, context3) {
        const { constantCache } = context3;
        switch (node.type) {
          case 1:
            if (node.tagType !== 0) {
              return 0;
            }
            const cached = constantCache.get(node);
            if (cached !== void 0) {
              return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13) {
              return 0;
            }
            if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
              return 0;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag) {
              let returnType2 = 3;
              const generatedPropsType = getGeneratedPropsConstantType(node, context3);
              if (generatedPropsType === 0) {
                constantCache.set(
                  node,
                  0
                  /* NOT_CONSTANT */
                );
                return 0;
              }
              if (generatedPropsType < returnType2) {
                returnType2 = generatedPropsType;
              }
              for (let i4 = 0; i4 < node.children.length; i4++) {
                const childType = getConstantType(node.children[i4], context3);
                if (childType === 0) {
                  constantCache.set(
                    node,
                    0
                    /* NOT_CONSTANT */
                  );
                  return 0;
                }
                if (childType < returnType2) {
                  returnType2 = childType;
                }
              }
              if (returnType2 > 1) {
                for (let i4 = 0; i4 < node.props.length; i4++) {
                  const p2 = node.props[i4];
                  if (p2.type === 7 && p2.name === "bind" && p2.exp) {
                    const expType = getConstantType(p2.exp, context3);
                    if (expType === 0) {
                      constantCache.set(
                        node,
                        0
                        /* NOT_CONSTANT */
                      );
                      return 0;
                    }
                    if (expType < returnType2) {
                      returnType2 = expType;
                    }
                  }
                }
              }
              if (codegenNode.isBlock) {
                for (let i4 = 0; i4 < node.props.length; i4++) {
                  const p2 = node.props[i4];
                  if (p2.type === 7) {
                    constantCache.set(
                      node,
                      0
                      /* NOT_CONSTANT */
                    );
                    return 0;
                  }
                }
                context3.removeHelper(OPEN_BLOCK);
                context3.removeHelper(getVNodeBlockHelper(context3.inSSR, codegenNode.isComponent));
                codegenNode.isBlock = false;
                context3.helper(getVNodeHelper(context3.inSSR, codegenNode.isComponent));
              }
              constantCache.set(node, returnType2);
              return returnType2;
            } else {
              constantCache.set(
                node,
                0
                /* NOT_CONSTANT */
              );
              return 0;
            }
          case 2:
          case 3:
            return 3;
          case 9:
          case 11:
          case 10:
            return 0;
          case 5:
          case 12:
            return getConstantType(node.content, context3);
          case 4:
            return node.constType;
          case 8:
            let returnType = 3;
            for (let i4 = 0; i4 < node.children.length; i4++) {
              const child = node.children[i4];
              if (shared.isString(child) || shared.isSymbol(child)) {
                continue;
              }
              const childType = getConstantType(child, context3);
              if (childType === 0) {
                return 0;
              } else if (childType < returnType) {
                returnType = childType;
              }
            }
            return returnType;
          default:
            return 0;
        }
      }
      var allowHoistedHelperSet = /* @__PURE__ */ new Set([
        NORMALIZE_CLASS,
        NORMALIZE_STYLE,
        NORMALIZE_PROPS,
        GUARD_REACTIVE_PROPS
      ]);
      function getConstantTypeOfHelperCall(value, context3) {
        if (value.type === 14 && !shared.isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
          const arg = value.arguments[0];
          if (arg.type === 4) {
            return getConstantType(arg, context3);
          } else if (arg.type === 14) {
            return getConstantTypeOfHelperCall(arg, context3);
          }
        }
        return 0;
      }
      function getGeneratedPropsConstantType(node, context3) {
        let returnType = 3;
        const props = getNodeProps(node);
        if (props && props.type === 15) {
          const { properties } = props;
          for (let i4 = 0; i4 < properties.length; i4++) {
            const { key, value } = properties[i4];
            const keyType = getConstantType(key, context3);
            if (keyType === 0) {
              return keyType;
            }
            if (keyType < returnType) {
              returnType = keyType;
            }
            let valueType;
            if (value.type === 4) {
              valueType = getConstantType(value, context3);
            } else if (value.type === 14) {
              valueType = getConstantTypeOfHelperCall(value, context3);
            } else {
              valueType = 0;
            }
            if (valueType === 0) {
              return valueType;
            }
            if (valueType < returnType) {
              returnType = valueType;
            }
          }
        }
        return returnType;
      }
      function getNodeProps(node) {
        const codegenNode = node.codegenNode;
        if (codegenNode.type === 13) {
          return codegenNode.props;
        }
      }
      function getPatchFlag(node) {
        const flag = node.patchFlag;
        return flag ? parseInt(flag, 10) : void 0;
      }
      function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = shared.NOOP, isCustomElement = shared.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = shared.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
        const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
        const context3 = {
          // options
          selfName: nameMatch && shared.capitalize(shared.camelize(nameMatch[1])),
          prefixIdentifiers,
          hoistStatic: hoistStatic2,
          cacheHandlers,
          nodeTransforms,
          directiveTransforms,
          transformHoist,
          isBuiltInComponent,
          isCustomElement,
          expressionPlugins,
          scopeId,
          slotted,
          ssr,
          inSSR,
          ssrCssVars,
          bindingMetadata,
          inline,
          isTS,
          onError,
          onWarn,
          compatConfig,
          // state
          root,
          helpers: /* @__PURE__ */ new Map(),
          components: /* @__PURE__ */ new Set(),
          directives: /* @__PURE__ */ new Set(),
          hoists: [],
          imports: [],
          constantCache: /* @__PURE__ */ new Map(),
          temps: 0,
          cached: 0,
          identifiers: /* @__PURE__ */ Object.create(null),
          scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
          },
          parent: null,
          currentNode: root,
          childIndex: 0,
          inVOnce: false,
          // methods
          helper(name) {
            const count = context3.helpers.get(name) || 0;
            context3.helpers.set(name, count + 1);
            return name;
          },
          removeHelper(name) {
            const count = context3.helpers.get(name);
            if (count) {
              const currentCount = count - 1;
              if (!currentCount) {
                context3.helpers.delete(name);
              } else {
                context3.helpers.set(name, currentCount);
              }
            }
          },
          helperString(name) {
            return `_${helperNameMap[context3.helper(name)]}`;
          },
          replaceNode(node) {
            {
              if (!context3.currentNode) {
                throw new Error(`Node being replaced is already removed.`);
              }
              if (!context3.parent) {
                throw new Error(`Cannot replace root node.`);
              }
            }
            context3.parent.children[context3.childIndex] = context3.currentNode = node;
          },
          removeNode(node) {
            if (!context3.parent) {
              throw new Error(`Cannot remove root node.`);
            }
            const list = context3.parent.children;
            const removalIndex = node ? list.indexOf(node) : context3.currentNode ? context3.childIndex : -1;
            if (removalIndex < 0) {
              throw new Error(`node being removed is not a child of current parent`);
            }
            if (!node || node === context3.currentNode) {
              context3.currentNode = null;
              context3.onNodeRemoved();
            } else {
              if (context3.childIndex > removalIndex) {
                context3.childIndex--;
                context3.onNodeRemoved();
              }
            }
            context3.parent.children.splice(removalIndex, 1);
          },
          onNodeRemoved: () => {
          },
          addIdentifiers(exp) {
            {
              if (shared.isString(exp)) {
                addId(exp);
              } else if (exp.identifiers) {
                exp.identifiers.forEach(addId);
              } else if (exp.type === 4) {
                addId(exp.content);
              }
            }
          },
          removeIdentifiers(exp) {
            {
              if (shared.isString(exp)) {
                removeId(exp);
              } else if (exp.identifiers) {
                exp.identifiers.forEach(removeId);
              } else if (exp.type === 4) {
                removeId(exp.content);
              }
            }
          },
          hoist(exp) {
            if (shared.isString(exp))
              exp = createSimpleExpression(exp);
            context3.hoists.push(exp);
            const identifier = createSimpleExpression(
              `_hoisted_${context3.hoists.length}`,
              false,
              exp.loc,
              2
              /* CAN_HOIST */
            );
            identifier.hoisted = exp;
            return identifier;
          },
          cache(exp, isVNode = false) {
            return createCacheExpression(context3.cached++, exp, isVNode);
          }
        };
        {
          context3.filters = /* @__PURE__ */ new Set();
        }
        function addId(id) {
          const { identifiers } = context3;
          if (identifiers[id] === void 0) {
            identifiers[id] = 0;
          }
          identifiers[id]++;
        }
        function removeId(id) {
          context3.identifiers[id]--;
        }
        return context3;
      }
      function transform2(root, options) {
        const context3 = createTransformContext(root, options);
        traverseNode(root, context3);
        if (options.hoistStatic) {
          hoistStatic(root, context3);
        }
        if (!options.ssr) {
          createRootCodegen(root, context3);
        }
        root.helpers = [...context3.helpers.keys()];
        root.components = [...context3.components];
        root.directives = [...context3.directives];
        root.imports = context3.imports;
        root.hoists = context3.hoists;
        root.temps = context3.temps;
        root.cached = context3.cached;
        {
          root.filters = [...context3.filters];
        }
      }
      function createRootCodegen(root, context3) {
        const { helper } = context3;
        const { children: children2 } = root;
        if (children2.length === 1) {
          const child = children2[0];
          if (isSingleElementRoot(root, child) && child.codegenNode) {
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13) {
              makeBlock(codegenNode, context3);
            }
            root.codegenNode = codegenNode;
          } else {
            root.codegenNode = child;
          }
        } else if (children2.length > 1) {
          let patchFlag = 64;
          let patchFlagText = shared.PatchFlagNames[
            64
            /* STABLE_FRAGMENT */
          ];
          if (children2.filter(
            (c3) => c3.type !== 3
            /* COMMENT */
          ).length === 1) {
            patchFlag |= 2048;
            patchFlagText += `, ${shared.PatchFlagNames[
              2048
              /* DEV_ROOT_FRAGMENT */
            ]}`;
          }
          root.codegenNode = createVNodeCall(
            context3,
            helper(FRAGMENT),
            void 0,
            root.children,
            patchFlag + ` /* ${patchFlagText} */`,
            void 0,
            void 0,
            true,
            void 0,
            false
            /* isComponent */
          );
        } else ;
      }
      function traverseChildren(parent2, context3) {
        let i4 = 0;
        const nodeRemoved = () => {
          i4--;
        };
        for (; i4 < parent2.children.length; i4++) {
          const child = parent2.children[i4];
          if (shared.isString(child))
            continue;
          context3.parent = parent2;
          context3.childIndex = i4;
          context3.onNodeRemoved = nodeRemoved;
          traverseNode(child, context3);
        }
      }
      function traverseNode(node, context3) {
        context3.currentNode = node;
        const { nodeTransforms } = context3;
        const exitFns = [];
        for (let i5 = 0; i5 < nodeTransforms.length; i5++) {
          const onExit = nodeTransforms[i5](node, context3);
          if (onExit) {
            if (shared.isArray(onExit)) {
              exitFns.push(...onExit);
            } else {
              exitFns.push(onExit);
            }
          }
          if (!context3.currentNode) {
            return;
          } else {
            node = context3.currentNode;
          }
        }
        switch (node.type) {
          case 3:
            if (!context3.ssr) {
              context3.helper(CREATE_COMMENT);
            }
            break;
          case 5:
            if (!context3.ssr) {
              context3.helper(TO_DISPLAY_STRING);
            }
            break;
          // for container types, further traverse downwards
          case 9:
            for (let i5 = 0; i5 < node.branches.length; i5++) {
              traverseNode(node.branches[i5], context3);
            }
            break;
          case 10:
          case 11:
          case 1:
          case 0:
            traverseChildren(node, context3);
            break;
        }
        context3.currentNode = node;
        let i4 = exitFns.length;
        while (i4--) {
          exitFns[i4]();
        }
      }
      function createStructuralDirectiveTransform(name, fn) {
        const matches2 = shared.isString(name) ? (n4) => n4 === name : (n4) => name.test(n4);
        return (node, context3) => {
          if (node.type === 1) {
            const { props } = node;
            if (node.tagType === 3 && props.some(isVSlot)) {
              return;
            }
            const exitFns = [];
            for (let i4 = 0; i4 < props.length; i4++) {
              const prop = props[i4];
              if (prop.type === 7 && matches2(prop.name)) {
                props.splice(i4, 1);
                i4--;
                const onExit = fn(node, prop, context3);
                if (onExit)
                  exitFns.push(onExit);
              }
            }
            return exitFns;
          }
        };
      }
      var PURE_ANNOTATION = `/*#__PURE__*/`;
      var aliasHelper = (s4) => `${helperNameMap[s4]}: _${helperNameMap[s4]}`;
      function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap: sourceMap$1 = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
        const context3 = {
          mode,
          prefixIdentifiers,
          sourceMap: sourceMap$1,
          filename,
          scopeId,
          optimizeImports,
          runtimeGlobalName,
          runtimeModuleName,
          ssrRuntimeModuleName,
          ssr,
          isTS,
          inSSR,
          source: ast.loc.source,
          code: ``,
          column: 1,
          line: 1,
          offset: 0,
          indentLevel: 0,
          pure: false,
          map: void 0,
          helper(key) {
            return `_${helperNameMap[key]}`;
          },
          push(code, node) {
            context3.code += code;
            if (context3.map) {
              if (node) {
                let name;
                if (node.type === 4 && !node.isStatic) {
                  const content = node.content.replace(/^_ctx\./, "");
                  if (content !== node.content && isSimpleIdentifier(content)) {
                    name = content;
                  }
                }
                addMapping(node.loc.start, name);
              }
              advancePositionWithMutation(context3, code);
              if (node && node.loc !== locStub) {
                addMapping(node.loc.end);
              }
            }
          },
          indent() {
            newline(++context3.indentLevel);
          },
          deindent(withoutNewLine = false) {
            if (withoutNewLine) {
              --context3.indentLevel;
            } else {
              newline(--context3.indentLevel);
            }
          },
          newline() {
            newline(context3.indentLevel);
          }
        };
        function newline(n4) {
          context3.push("\n" + `  `.repeat(n4));
        }
        function addMapping(loc, name) {
          context3.map.addMapping({
            name,
            source: context3.filename,
            original: {
              line: loc.line,
              column: loc.column - 1
              // source-map column is 0 based
            },
            generated: {
              line: context3.line,
              column: context3.column - 1
            }
          });
        }
        if (sourceMap$1) {
          context3.map = new sourceMap.SourceMapGenerator();
          context3.map.setSourceContent(filename, context3.source);
        }
        return context3;
      }
      function generate(ast, options = {}) {
        const context3 = createCodegenContext(ast, options);
        if (options.onContextCreated)
          options.onContextCreated(context3);
        const { mode, push: push2, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context3;
        const hasHelpers = ast.helpers.length > 0;
        const useWithBlock = !prefixIdentifiers && mode !== "module";
        const genScopeId = scopeId != null && mode === "module";
        const isSetupInlined = !!options.inline;
        const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context3;
        if (mode === "module") {
          genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
        } else {
          genFunctionPreamble(ast, preambleContext);
        }
        const functionName = ssr ? `ssrRender` : `render`;
        const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
        if (options.bindingMetadata && !options.inline) {
          args.push("$props", "$setup", "$data", "$options");
        }
        const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
        if (isSetupInlined) {
          push2(`(${signature}) => {`);
        } else {
          push2(`function ${functionName}(${signature}) {`);
        }
        indent();
        if (useWithBlock) {
          push2(`with (_ctx) {`);
          indent();
          if (hasHelpers) {
            push2(`const { ${ast.helpers.map(aliasHelper).join(", ")} } = _Vue`);
            push2(`
`);
            newline();
          }
        }
        if (ast.components.length) {
          genAssets(ast.components, "component", context3);
          if (ast.directives.length || ast.temps > 0) {
            newline();
          }
        }
        if (ast.directives.length) {
          genAssets(ast.directives, "directive", context3);
          if (ast.temps > 0) {
            newline();
          }
        }
        if (ast.filters && ast.filters.length) {
          newline();
          genAssets(ast.filters, "filter", context3);
          newline();
        }
        if (ast.temps > 0) {
          push2(`let `);
          for (let i4 = 0; i4 < ast.temps; i4++) {
            push2(`${i4 > 0 ? `, ` : ``}_temp${i4}`);
          }
        }
        if (ast.components.length || ast.directives.length || ast.temps) {
          push2(`
`);
          newline();
        }
        if (!ssr) {
          push2(`return `);
        }
        if (ast.codegenNode) {
          genNode(ast.codegenNode, context3);
        } else {
          push2(`null`);
        }
        if (useWithBlock) {
          deindent();
          push2(`}`);
        }
        deindent();
        push2(`}`);
        return {
          ast,
          code: context3.code,
          preamble: isSetupInlined ? preambleContext.code : ``,
          // SourceMapGenerator does have toJSON() method but it's not in the types
          map: context3.map ? context3.map.toJSON() : void 0
        };
      }
      function genFunctionPreamble(ast, context3) {
        const { ssr, prefixIdentifiers, push: push2, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context3;
        const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
        if (ast.helpers.length > 0) {
          if (prefixIdentifiers) {
            push2(`const { ${ast.helpers.map(aliasHelper).join(", ")} } = ${VueBinding}
`);
          } else {
            push2(`const _Vue = ${VueBinding}
`);
            if (ast.hoists.length) {
              const staticHelpers = [
                CREATE_VNODE,
                CREATE_ELEMENT_VNODE,
                CREATE_COMMENT,
                CREATE_TEXT,
                CREATE_STATIC
              ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
              push2(`const { ${staticHelpers} } = _Vue
`);
            }
          }
        }
        if (ast.ssrHelpers && ast.ssrHelpers.length) {
          push2(`const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("${ssrRuntimeModuleName}")
`);
        }
        genHoists(ast.hoists, context3);
        newline();
        push2(`return `);
      }
      function genModulePreamble(ast, context3, genScopeId, inline) {
        const { push: push2, newline, optimizeImports, runtimeModuleName, ssrRuntimeModuleName } = context3;
        if (genScopeId && ast.hoists.length) {
          ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID);
        }
        if (ast.helpers.length) {
          if (optimizeImports) {
            push2(`import { ${ast.helpers.map((s4) => helperNameMap[s4]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`);
            push2(`
// Binding optimization for webpack code-split
const ${ast.helpers.map((s4) => `_${helperNameMap[s4]} = ${helperNameMap[s4]}`).join(", ")}
`);
          } else {
            push2(`import { ${ast.helpers.map((s4) => `${helperNameMap[s4]} as _${helperNameMap[s4]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`);
          }
        }
        if (ast.ssrHelpers && ast.ssrHelpers.length) {
          push2(`import { ${ast.ssrHelpers.map((s4) => `${helperNameMap[s4]} as _${helperNameMap[s4]}`).join(", ")} } from "${ssrRuntimeModuleName}"
`);
        }
        if (ast.imports.length) {
          genImports(ast.imports, context3);
          newline();
        }
        genHoists(ast.hoists, context3);
        newline();
        if (!inline) {
          push2(`export `);
        }
      }
      function genAssets(assets, type, { helper, push: push2, newline, isTS }) {
        const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
        for (let i4 = 0; i4 < assets.length; i4++) {
          let id = assets[i4];
          const maybeSelfReference = id.endsWith("__self");
          if (maybeSelfReference) {
            id = id.slice(0, -6);
          }
          push2(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
          if (i4 < assets.length - 1) {
            newline();
          }
        }
      }
      function genHoists(hoists, context3) {
        if (!hoists.length) {
          return;
        }
        context3.pure = true;
        const { push: push2, newline, helper, scopeId, mode } = context3;
        const genScopeId = scopeId != null && mode !== "function";
        newline();
        if (genScopeId) {
          push2(`const _withScopeId = n => (${helper(PUSH_SCOPE_ID)}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`);
          newline();
        }
        for (let i4 = 0; i4 < hoists.length; i4++) {
          const exp = hoists[i4];
          if (exp) {
            const needScopeIdWrapper = genScopeId && exp.type === 13;
            push2(`const _hoisted_${i4 + 1} = ${needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``}`);
            genNode(exp, context3);
            if (needScopeIdWrapper) {
              push2(`)`);
            }
            newline();
          }
        }
        context3.pure = false;
      }
      function genImports(importsOptions, context3) {
        if (!importsOptions.length) {
          return;
        }
        importsOptions.forEach((imports) => {
          context3.push(`import `);
          genNode(imports.exp, context3);
          context3.push(` from '${imports.path}'`);
          context3.newline();
        });
      }
      function isText$1(n4) {
        return shared.isString(n4) || n4.type === 4 || n4.type === 2 || n4.type === 5 || n4.type === 8;
      }
      function genNodeListAsArray(nodes, context3) {
        const multilines = nodes.length > 3 || nodes.some((n4) => shared.isArray(n4) || !isText$1(n4));
        context3.push(`[`);
        multilines && context3.indent();
        genNodeList(nodes, context3, multilines);
        multilines && context3.deindent();
        context3.push(`]`);
      }
      function genNodeList(nodes, context3, multilines = false, comma = true) {
        const { push: push2, newline } = context3;
        for (let i4 = 0; i4 < nodes.length; i4++) {
          const node = nodes[i4];
          if (shared.isString(node)) {
            push2(node);
          } else if (shared.isArray(node)) {
            genNodeListAsArray(node, context3);
          } else {
            genNode(node, context3);
          }
          if (i4 < nodes.length - 1) {
            if (multilines) {
              comma && push2(",");
              newline();
            } else {
              comma && push2(", ");
            }
          }
        }
      }
      function genNode(node, context3) {
        if (shared.isString(node)) {
          context3.push(node);
          return;
        }
        if (shared.isSymbol(node)) {
          context3.push(context3.helper(node));
          return;
        }
        switch (node.type) {
          case 1:
          case 9:
          case 11:
            assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
            genNode(node.codegenNode, context3);
            break;
          case 2:
            genText(node, context3);
            break;
          case 4:
            genExpression(node, context3);
            break;
          case 5:
            genInterpolation(node, context3);
            break;
          case 12:
            genNode(node.codegenNode, context3);
            break;
          case 8:
            genCompoundExpression(node, context3);
            break;
          case 3:
            genComment(node, context3);
            break;
          case 13:
            genVNodeCall(node, context3);
            break;
          case 14:
            genCallExpression(node, context3);
            break;
          case 15:
            genObjectExpression(node, context3);
            break;
          case 17:
            genArrayExpression(node, context3);
            break;
          case 18:
            genFunctionExpression(node, context3);
            break;
          case 19:
            genConditionalExpression(node, context3);
            break;
          case 20:
            genCacheExpression(node, context3);
            break;
          case 21:
            genNodeList(node.body, context3, true, false);
            break;
          // SSR only types
          case 22:
            genTemplateLiteral(node, context3);
            break;
          case 23:
            genIfStatement(node, context3);
            break;
          case 24:
            genAssignmentExpression(node, context3);
            break;
          case 25:
            genSequenceExpression(node, context3);
            break;
          case 26:
            genReturnStatement(node, context3);
            break;
          /* istanbul ignore next */
          case 10:
            break;
          default: {
            assert(false, `unhandled codegen node type: ${node.type}`);
            const exhaustiveCheck = node;
            return exhaustiveCheck;
          }
        }
      }
      function genText(node, context3) {
        context3.push(JSON.stringify(node.content), node);
      }
      function genExpression(node, context3) {
        const { content, isStatic } = node;
        context3.push(isStatic ? JSON.stringify(content) : content, node);
      }
      function genInterpolation(node, context3) {
        const { push: push2, helper, pure } = context3;
        if (pure)
          push2(PURE_ANNOTATION);
        push2(`${helper(TO_DISPLAY_STRING)}(`);
        genNode(node.content, context3);
        push2(`)`);
      }
      function genCompoundExpression(node, context3) {
        for (let i4 = 0; i4 < node.children.length; i4++) {
          const child = node.children[i4];
          if (shared.isString(child)) {
            context3.push(child);
          } else {
            genNode(child, context3);
          }
        }
      }
      function genExpressionAsPropertyKey(node, context3) {
        const { push: push2 } = context3;
        if (node.type === 8) {
          push2(`[`);
          genCompoundExpression(node, context3);
          push2(`]`);
        } else if (node.isStatic) {
          const text2 = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
          push2(text2, node);
        } else {
          push2(`[${node.content}]`, node);
        }
      }
      function genComment(node, context3) {
        const { push: push2, helper, pure } = context3;
        if (pure) {
          push2(PURE_ANNOTATION);
        }
        push2(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
      }
      function genVNodeCall(node, context3) {
        const { push: push2, helper, pure } = context3;
        const { tag, props, children: children2, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
        if (directives) {
          push2(helper(WITH_DIRECTIVES) + `(`);
        }
        if (isBlock) {
          push2(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
        }
        if (pure) {
          push2(PURE_ANNOTATION);
        }
        const callHelper = isBlock ? getVNodeBlockHelper(context3.inSSR, isComponent2) : getVNodeHelper(context3.inSSR, isComponent2);
        push2(helper(callHelper) + `(`, node);
        genNodeList(genNullableArgs([tag, props, children2, patchFlag, dynamicProps]), context3);
        push2(`)`);
        if (isBlock) {
          push2(`)`);
        }
        if (directives) {
          push2(`, `);
          genNode(directives, context3);
          push2(`)`);
        }
      }
      function genNullableArgs(args) {
        let i4 = args.length;
        while (i4--) {
          if (args[i4] != null)
            break;
        }
        return args.slice(0, i4 + 1).map((arg) => arg || `null`);
      }
      function genCallExpression(node, context3) {
        const { push: push2, helper, pure } = context3;
        const callee = shared.isString(node.callee) ? node.callee : helper(node.callee);
        if (pure) {
          push2(PURE_ANNOTATION);
        }
        push2(callee + `(`, node);
        genNodeList(node.arguments, context3);
        push2(`)`);
      }
      function genObjectExpression(node, context3) {
        const { push: push2, indent, deindent, newline } = context3;
        const { properties } = node;
        if (!properties.length) {
          push2(`{}`, node);
          return;
        }
        const multilines = properties.length > 1 || properties.some(
          (p2) => p2.value.type !== 4
          /* SIMPLE_EXPRESSION */
        );
        push2(multilines ? `{` : `{ `);
        multilines && indent();
        for (let i4 = 0; i4 < properties.length; i4++) {
          const { key, value } = properties[i4];
          genExpressionAsPropertyKey(key, context3);
          push2(`: `);
          genNode(value, context3);
          if (i4 < properties.length - 1) {
            push2(`,`);
            newline();
          }
        }
        multilines && deindent();
        push2(multilines ? `}` : ` }`);
      }
      function genArrayExpression(node, context3) {
        genNodeListAsArray(node.elements, context3);
      }
      function genFunctionExpression(node, context3) {
        const { push: push2, indent, deindent } = context3;
        const { params, returns, body: body2, newline, isSlot } = node;
        if (isSlot) {
          push2(`_${helperNameMap[WITH_CTX]}(`);
        }
        push2(`(`, node);
        if (shared.isArray(params)) {
          genNodeList(params, context3);
        } else if (params) {
          genNode(params, context3);
        }
        push2(`) => `);
        if (newline || body2) {
          push2(`{`);
          indent();
        }
        if (returns) {
          if (newline) {
            push2(`return `);
          }
          if (shared.isArray(returns)) {
            genNodeListAsArray(returns, context3);
          } else {
            genNode(returns, context3);
          }
        } else if (body2) {
          genNode(body2, context3);
        }
        if (newline || body2) {
          deindent();
          push2(`}`);
        }
        if (isSlot) {
          if (node.isNonScopedSlot) {
            push2(`, undefined, true`);
          }
          push2(`)`);
        }
      }
      function genConditionalExpression(node, context3) {
        const { test, consequent, alternate, newline: needNewline } = node;
        const { push: push2, indent, deindent, newline } = context3;
        if (test.type === 4) {
          const needsParens = !isSimpleIdentifier(test.content);
          needsParens && push2(`(`);
          genExpression(test, context3);
          needsParens && push2(`)`);
        } else {
          push2(`(`);
          genNode(test, context3);
          push2(`)`);
        }
        needNewline && indent();
        context3.indentLevel++;
        needNewline || push2(` `);
        push2(`? `);
        genNode(consequent, context3);
        context3.indentLevel--;
        needNewline && newline();
        needNewline || push2(` `);
        push2(`: `);
        const isNested = alternate.type === 19;
        if (!isNested) {
          context3.indentLevel++;
        }
        genNode(alternate, context3);
        if (!isNested) {
          context3.indentLevel--;
        }
        needNewline && deindent(
          true
          /* without newline */
        );
      }
      function genCacheExpression(node, context3) {
        const { push: push2, helper, indent, deindent, newline } = context3;
        push2(`_cache[${node.index}] || (`);
        if (node.isVNode) {
          indent();
          push2(`${helper(SET_BLOCK_TRACKING)}(-1),`);
          newline();
        }
        push2(`_cache[${node.index}] = `);
        genNode(node.value, context3);
        if (node.isVNode) {
          push2(`,`);
          newline();
          push2(`${helper(SET_BLOCK_TRACKING)}(1),`);
          newline();
          push2(`_cache[${node.index}]`);
          deindent();
        }
        push2(`)`);
      }
      function genTemplateLiteral(node, context3) {
        const { push: push2, indent, deindent } = context3;
        push2("`");
        const l4 = node.elements.length;
        const multilines = l4 > 3;
        for (let i4 = 0; i4 < l4; i4++) {
          const e4 = node.elements[i4];
          if (shared.isString(e4)) {
            push2(e4.replace(/(`|\$|\\)/g, "\\$1"));
          } else {
            push2("${");
            if (multilines)
              indent();
            genNode(e4, context3);
            if (multilines)
              deindent();
            push2("}");
          }
        }
        push2("`");
      }
      function genIfStatement(node, context3) {
        const { push: push2, indent, deindent } = context3;
        const { test, consequent, alternate } = node;
        push2(`if (`);
        genNode(test, context3);
        push2(`) {`);
        indent();
        genNode(consequent, context3);
        deindent();
        push2(`}`);
        if (alternate) {
          push2(` else `);
          if (alternate.type === 23) {
            genIfStatement(alternate, context3);
          } else {
            push2(`{`);
            indent();
            genNode(alternate, context3);
            deindent();
            push2(`}`);
          }
        }
      }
      function genAssignmentExpression(node, context3) {
        genNode(node.left, context3);
        context3.push(` = `);
        genNode(node.right, context3);
      }
      function genSequenceExpression(node, context3) {
        context3.push(`(`);
        genNodeList(node.expressions, context3);
        context3.push(`)`);
      }
      function genReturnStatement({ returns }, context3) {
        context3.push(`return `);
        if (shared.isArray(returns)) {
          genNodeListAsArray(returns, context3);
        } else {
          genNode(returns, context3);
        }
      }
      function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
        const rootExp = root.type === "Program" && root.body[0].type === "ExpressionStatement" && root.body[0].expression;
        estreeWalker.walk(root, {
          enter(node, parent2) {
            parent2 && parentStack.push(parent2);
            if (parent2 && parent2.type.startsWith("TS") && parent2.type !== "TSAsExpression" && parent2.type !== "TSNonNullExpression" && parent2.type !== "TSTypeAssertion") {
              return this.skip();
            }
            if (node.type === "Identifier") {
              const isLocal = !!knownIds[node.name];
              const isRefed = isReferencedIdentifier(node, parent2, parentStack);
              if (includeAll || isRefed && !isLocal) {
                onIdentifier(node, parent2, parentStack, isRefed, isLocal);
              }
            } else if (node.type === "ObjectProperty" && parent2.type === "ObjectPattern") {
              node.inPattern = true;
            } else if (isFunctionType(node)) {
              walkFunctionParams(node, (id) => markScopeIdentifier(node, id, knownIds));
            } else if (node.type === "BlockStatement") {
              walkBlockDeclarations(node, (id) => markScopeIdentifier(node, id, knownIds));
            }
          },
          leave(node, parent2) {
            parent2 && parentStack.pop();
            if (node !== rootExp && node.scopeIds) {
              for (const id of node.scopeIds) {
                knownIds[id]--;
                if (knownIds[id] === 0) {
                  delete knownIds[id];
                }
              }
            }
          }
        });
      }
      function isReferencedIdentifier(id, parent2, parentStack) {
        if (!parent2) {
          return true;
        }
        if (id.name === "arguments") {
          return false;
        }
        if (isReferenced(id, parent2)) {
          return true;
        }
        switch (parent2.type) {
          case "AssignmentExpression":
          case "AssignmentPattern":
            return true;
          case "ObjectPattern":
          case "ArrayPattern":
            return isInDestructureAssignment(parent2, parentStack);
        }
        return false;
      }
      function isInDestructureAssignment(parent2, parentStack) {
        if (parent2 && (parent2.type === "ObjectProperty" || parent2.type === "ArrayPattern")) {
          let i4 = parentStack.length;
          while (i4--) {
            const p2 = parentStack[i4];
            if (p2.type === "AssignmentExpression") {
              return true;
            } else if (p2.type !== "ObjectProperty" && !p2.type.endsWith("Pattern")) {
              break;
            }
          }
        }
        return false;
      }
      function walkFunctionParams(node, onIdent) {
        for (const p2 of node.params) {
          for (const id of extractIdentifiers(p2)) {
            onIdent(id);
          }
        }
      }
      function walkBlockDeclarations(block, onIdent) {
        for (const stmt of block.body) {
          if (stmt.type === "VariableDeclaration") {
            if (stmt.declare)
              continue;
            for (const decl of stmt.declarations) {
              for (const id of extractIdentifiers(decl.id)) {
                onIdent(id);
              }
            }
          } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
            if (stmt.declare || !stmt.id)
              continue;
            onIdent(stmt.id);
          }
        }
      }
      function extractIdentifiers(param, nodes = []) {
        switch (param.type) {
          case "Identifier":
            nodes.push(param);
            break;
          case "MemberExpression":
            let object = param;
            while (object.type === "MemberExpression") {
              object = object.object;
            }
            nodes.push(object);
            break;
          case "ObjectPattern":
            for (const prop of param.properties) {
              if (prop.type === "RestElement") {
                extractIdentifiers(prop.argument, nodes);
              } else {
                extractIdentifiers(prop.value, nodes);
              }
            }
            break;
          case "ArrayPattern":
            param.elements.forEach((element) => {
              if (element)
                extractIdentifiers(element, nodes);
            });
            break;
          case "RestElement":
            extractIdentifiers(param.argument, nodes);
            break;
          case "AssignmentPattern":
            extractIdentifiers(param.left, nodes);
            break;
        }
        return nodes;
      }
      function markScopeIdentifier(node, child, knownIds) {
        const { name } = child;
        if (node.scopeIds && node.scopeIds.has(name)) {
          return;
        }
        if (name in knownIds) {
          knownIds[name]++;
        } else {
          knownIds[name] = 1;
        }
        (node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);
      }
      var isFunctionType = (node) => {
        return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
      };
      var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
      var isStaticPropertyKey = (node, parent2) => isStaticProperty(parent2) && parent2.key === node;
      function isReferenced(node, parent2, grandparent) {
        switch (parent2.type) {
          // yes: PARENT[NODE]
          // yes: NODE.child
          // no: parent.NODE
          case "MemberExpression":
          case "OptionalMemberExpression":
            if (parent2.property === node) {
              return !!parent2.computed;
            }
            return parent2.object === node;
          case "JSXMemberExpression":
            return parent2.object === node;
          // no: let NODE = init;
          // yes: let id = NODE;
          case "VariableDeclarator":
            return parent2.init === node;
          // yes: () => NODE
          // no: (NODE) => {}
          case "ArrowFunctionExpression":
            return parent2.body === node;
          // no: class { #NODE; }
          // no: class { get #NODE() {} }
          // no: class { #NODE() {} }
          // no: class { fn() { return this.#NODE; } }
          case "PrivateName":
            return false;
          // no: class { NODE() {} }
          // yes: class { [NODE]() {} }
          // no: class { foo(NODE) {} }
          case "ClassMethod":
          case "ClassPrivateMethod":
          case "ObjectMethod":
            if (parent2.key === node) {
              return !!parent2.computed;
            }
            return false;
          // yes: { [NODE]: "" }
          // no: { NODE: "" }
          // depends: { NODE }
          // depends: { key: NODE }
          case "ObjectProperty":
            if (parent2.key === node) {
              return !!parent2.computed;
            }
            return !grandparent || grandparent.type !== "ObjectPattern";
          // no: class { NODE = value; }
          // yes: class { [NODE] = value; }
          // yes: class { key = NODE; }
          case "ClassProperty":
            if (parent2.key === node) {
              return !!parent2.computed;
            }
            return true;
          case "ClassPrivateProperty":
            return parent2.key !== node;
          // no: class NODE {}
          // yes: class Foo extends NODE {}
          case "ClassDeclaration":
          case "ClassExpression":
            return parent2.superClass === node;
          // yes: left = NODE;
          // no: NODE = right;
          case "AssignmentExpression":
            return parent2.right === node;
          // no: [NODE = foo] = [];
          // yes: [foo = NODE] = [];
          case "AssignmentPattern":
            return parent2.right === node;
          // no: NODE: for (;;) {}
          case "LabeledStatement":
            return false;
          // no: try {} catch (NODE) {}
          case "CatchClause":
            return false;
          // no: function foo(...NODE) {}
          case "RestElement":
            return false;
          case "BreakStatement":
          case "ContinueStatement":
            return false;
          // no: function NODE() {}
          // no: function foo(NODE) {}
          case "FunctionDeclaration":
          case "FunctionExpression":
            return false;
          // no: export NODE from "foo";
          // no: export * as NODE from "foo";
          case "ExportNamespaceSpecifier":
          case "ExportDefaultSpecifier":
            return false;
          // no: export { foo as NODE };
          // yes: export { NODE as foo };
          // no: export { NODE as foo } from "foo";
          case "ExportSpecifier":
            if (grandparent === null || grandparent === void 0 ? void 0 : grandparent.source) {
              return false;
            }
            return parent2.local === node;
          // no: import NODE from "foo";
          // no: import * as NODE from "foo";
          // no: import { NODE as foo } from "foo";
          // no: import { foo as NODE } from "foo";
          // no: import NODE from "bar";
          case "ImportDefaultSpecifier":
          case "ImportNamespaceSpecifier":
          case "ImportSpecifier":
            return false;
          // no: import "foo" assert { NODE: "json" }
          case "ImportAttribute":
            return false;
          // no: <div NODE="foo" />
          case "JSXAttribute":
            return false;
          // no: [NODE] = [];
          // no: ({ NODE }) = [];
          case "ObjectPattern":
          case "ArrayPattern":
            return false;
          // no: new.NODE
          // no: NODE.target
          case "MetaProperty":
            return false;
          // yes: type X = { someProperty: NODE }
          // no: type X = { NODE: OtherType }
          case "ObjectTypeProperty":
            return parent2.key !== node;
          // yes: enum X { Foo = NODE }
          // no: enum X { NODE }
          case "TSEnumMember":
            return parent2.id !== node;
          // yes: { [NODE]: value }
          // no: { NODE: value }
          case "TSPropertySignature":
            if (parent2.key === node) {
              return !!parent2.computed;
            }
            return true;
        }
        return true;
      }
      var isLiteralWhitelisted = /* @__PURE__ */ shared.makeMap("true,false,null,this");
      var transformExpression = (node, context3) => {
        if (node.type === 5) {
          node.content = processExpression(node.content, context3);
        } else if (node.type === 1) {
          for (let i4 = 0; i4 < node.props.length; i4++) {
            const dir = node.props[i4];
            if (dir.type === 7 && dir.name !== "for") {
              const exp = dir.exp;
              const arg = dir.arg;
              if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
                dir.exp = processExpression(
                  exp,
                  context3,
                  // slot args must be processed as function params
                  dir.name === "slot"
                );
              }
              if (arg && arg.type === 4 && !arg.isStatic) {
                dir.arg = processExpression(arg, context3);
              }
            }
          }
        }
      };
      function processExpression(node, context3, asParams = false, asRawStatements = false, localVars = Object.create(context3.identifiers)) {
        if (!context3.prefixIdentifiers || !node.content.trim()) {
          return node;
        }
        const { inline, bindingMetadata } = context3;
        const rewriteIdentifier = (raw, parent2, id) => {
          const type = shared.hasOwn(bindingMetadata, raw) && bindingMetadata[raw];
          if (inline) {
            const isAssignmentLVal = parent2 && parent2.type === "AssignmentExpression" && parent2.left === id;
            const isUpdateArg = parent2 && parent2.type === "UpdateExpression" && parent2.argument === id;
            const isDestructureAssignment = parent2 && isInDestructureAssignment(parent2, parentStack);
            if (type === "setup-const" || type === "setup-reactive-const" || localVars[raw]) {
              return raw;
            } else if (type === "setup-ref") {
              return `${raw}.value`;
            } else if (type === "setup-maybe-ref") {
              return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : `${context3.helperString(UNREF)}(${raw})`;
            } else if (type === "setup-let") {
              if (isAssignmentLVal) {
                const { right: rVal, operator } = parent2;
                const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
                const rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp, false), context3, false, false, knownIds));
                return `${context3.helperString(IS_REF)}(${raw})${context3.isTS ? ` //@ts-ignore
` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
              } else if (isUpdateArg) {
                id.start = parent2.start;
                id.end = parent2.end;
                const { prefix: isPrefix, operator } = parent2;
                const prefix = isPrefix ? operator : ``;
                const postfix = isPrefix ? `` : operator;
                return `${context3.helperString(IS_REF)}(${raw})${context3.isTS ? ` //@ts-ignore
` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;
              } else if (isDestructureAssignment) {
                return raw;
              } else {
                return `${context3.helperString(UNREF)}(${raw})`;
              }
            } else if (type === "props") {
              return shared.genPropsAccessExp(raw);
            } else if (type === "props-aliased") {
              return shared.genPropsAccessExp(bindingMetadata.__propsAliases[raw]);
            }
          } else {
            if (type && type.startsWith("setup")) {
              return `$setup.${raw}`;
            } else if (type === "props-aliased") {
              return `$props['${bindingMetadata.__propsAliases[raw]}']`;
            } else if (type) {
              return `$${type}.${raw}`;
            }
          }
          return `_ctx.${raw}`;
        };
        const rawExp = node.content;
        const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf(".") > 0;
        if (isSimpleIdentifier(rawExp)) {
          const isScopeVarReference = context3.identifiers[rawExp];
          const isAllowedGlobal = shared.isGloballyWhitelisted(rawExp);
          const isLiteral = isLiteralWhitelisted(rawExp);
          if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {
            if (bindingMetadata[node.content] === "setup-const") {
              node.constType = 1;
            }
            node.content = rewriteIdentifier(rawExp);
          } else if (!isScopeVarReference) {
            if (isLiteral) {
              node.constType = 3;
            } else {
              node.constType = 2;
            }
          }
          return node;
        }
        let ast;
        const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
        try {
          ast = parser.parse(source, {
            plugins: context3.expressionPlugins
          }).program;
        } catch (e4) {
          context3.onError(createCompilerError(44, node.loc, void 0, e4.message));
          return node;
        }
        const ids = [];
        const parentStack = [];
        const knownIds = Object.create(context3.identifiers);
        walkIdentifiers(
          ast,
          (node2, parent2, _2, isReferenced2, isLocal) => {
            if (isStaticPropertyKey(node2, parent2)) {
              return;
            }
            if (node2.name.startsWith("_filter_")) {
              return;
            }
            const needPrefix = isReferenced2 && canPrefix(node2);
            if (needPrefix && !isLocal) {
              if (isStaticProperty(parent2) && parent2.shorthand) {
                node2.prefix = `${node2.name}: `;
              }
              node2.name = rewriteIdentifier(node2.name, parent2, node2);
              ids.push(node2);
            } else {
              if (!(needPrefix && isLocal) && !bailConstant) {
                node2.isConstant = true;
              }
              ids.push(node2);
            }
          },
          true,
          // invoke on ALL identifiers
          parentStack,
          knownIds
        );
        const children2 = [];
        ids.sort((a3, b2) => a3.start - b2.start);
        ids.forEach((id, i4) => {
          const start = id.start - 1;
          const end = id.end - 1;
          const last2 = ids[i4 - 1];
          const leadingText = rawExp.slice(last2 ? last2.end - 1 : 0, start);
          if (leadingText.length || id.prefix) {
            children2.push(leadingText + (id.prefix || ``));
          }
          const source2 = rawExp.slice(start, end);
          children2.push(createSimpleExpression(
            id.name,
            false,
            {
              source: source2,
              start: advancePositionWithClone(node.loc.start, source2, start),
              end: advancePositionWithClone(node.loc.start, source2, end)
            },
            id.isConstant ? 3 : 0
            /* NOT_CONSTANT */
          ));
          if (i4 === ids.length - 1 && end < rawExp.length) {
            children2.push(rawExp.slice(end));
          }
        });
        let ret;
        if (children2.length) {
          ret = createCompoundExpression(children2, node.loc);
        } else {
          ret = node;
          ret.constType = bailConstant ? 0 : 3;
        }
        ret.identifiers = Object.keys(knownIds);
        return ret;
      }
      function canPrefix(id) {
        if (shared.isGloballyWhitelisted(id.name)) {
          return false;
        }
        if (id.name === "require") {
          return false;
        }
        return true;
      }
      function stringifyExpression(exp) {
        if (shared.isString(exp)) {
          return exp;
        } else if (exp.type === 4) {
          return exp.content;
        } else {
          return exp.children.map(stringifyExpression).join("");
        }
      }
      var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context3) => {
        return processIf(node, dir, context3, (ifNode, branch, isRoot) => {
          const siblings = context3.parent.children;
          let i4 = siblings.indexOf(ifNode);
          let key = 0;
          while (i4-- >= 0) {
            const sibling = siblings[i4];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context3);
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context3);
            }
          };
        });
      });
      function processIf(node, dir, context3, processCodegen) {
        if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
          const loc = dir.exp ? dir.exp.loc : node.loc;
          context3.onError(createCompilerError(28, dir.loc));
          dir.exp = createSimpleExpression(`true`, false, loc);
        }
        if (context3.prefixIdentifiers && dir.exp) {
          dir.exp = processExpression(dir.exp, context3);
        }
        if (dir.name === "if") {
          const branch = createIfBranch(node, dir);
          const ifNode = {
            type: 9,
            loc: node.loc,
            branches: [branch]
          };
          context3.replaceNode(ifNode);
          if (processCodegen) {
            return processCodegen(ifNode, branch, true);
          }
        } else {
          const siblings = context3.parent.children;
          const comments = [];
          let i4 = siblings.indexOf(node);
          while (i4-- >= -1) {
            const sibling = siblings[i4];
            if (sibling && sibling.type === 3) {
              context3.removeNode(sibling);
              comments.unshift(sibling);
              continue;
            }
            if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
              context3.removeNode(sibling);
              continue;
            }
            if (sibling && sibling.type === 9) {
              if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
                context3.onError(createCompilerError(30, node.loc));
              }
              context3.removeNode();
              const branch = createIfBranch(node, dir);
              if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
              !(context3.parent && context3.parent.type === 1 && isBuiltInType(context3.parent.tag, "transition"))) {
                branch.children = [...comments, ...branch.children];
              }
              {
                const key = branch.userKey;
                if (key) {
                  sibling.branches.forEach(({ userKey }) => {
                    if (isSameKey(userKey, key)) {
                      context3.onError(createCompilerError(29, branch.userKey.loc));
                    }
                  });
                }
              }
              sibling.branches.push(branch);
              const onExit = processCodegen && processCodegen(sibling, branch, false);
              traverseNode(branch, context3);
              if (onExit)
                onExit();
              context3.currentNode = null;
            } else {
              context3.onError(createCompilerError(30, node.loc));
            }
            break;
          }
        }
      }
      function createIfBranch(node, dir) {
        const isTemplateIf = node.tagType === 3;
        return {
          type: 10,
          loc: node.loc,
          condition: dir.name === "else" ? void 0 : dir.exp,
          children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
          userKey: findProp(node, `key`),
          isTemplateIf
        };
      }
      function createCodegenNodeForBranch(branch, keyIndex, context3) {
        if (branch.condition) {
          return createConditionalExpression(
            branch.condition,
            createChildrenCodegenNode(branch, keyIndex, context3),
            // make sure to pass in asBlock: true so that the comment node call
            // closes the current block.
            createCallExpression(context3.helper(CREATE_COMMENT), [
              '"v-if"',
              "true"
            ])
          );
        } else {
          return createChildrenCodegenNode(branch, keyIndex, context3);
        }
      }
      function createChildrenCodegenNode(branch, keyIndex, context3) {
        const { helper } = context3;
        const keyProperty = createObjectProperty(`key`, createSimpleExpression(
          `${keyIndex}`,
          false,
          locStub,
          2
          /* CAN_HOIST */
        ));
        const { children: children2 } = branch;
        const firstChild = children2[0];
        const needFragmentWrapper = children2.length !== 1 || firstChild.type !== 1;
        if (needFragmentWrapper) {
          if (children2.length === 1 && firstChild.type === 11) {
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context3);
            return vnodeCall;
          } else {
            let patchFlag = 64;
            let patchFlagText = shared.PatchFlagNames[
              64
              /* STABLE_FRAGMENT */
            ];
            if (!branch.isTemplateIf && children2.filter(
              (c3) => c3.type !== 3
              /* COMMENT */
            ).length === 1) {
              patchFlag |= 2048;
              patchFlagText += `, ${shared.PatchFlagNames[
                2048
                /* DEV_ROOT_FRAGMENT */
              ]}`;
            }
            return createVNodeCall(context3, helper(FRAGMENT), createObjectExpression([keyProperty]), children2, patchFlag + ` /* ${patchFlagText} */`, void 0, void 0, true, false, false, branch.loc);
          }
        } else {
          const ret = firstChild.codegenNode;
          const vnodeCall = getMemoedVNodeCall(ret);
          if (vnodeCall.type === 13) {
            makeBlock(vnodeCall, context3);
          }
          injectProp(vnodeCall, keyProperty, context3);
          return ret;
        }
      }
      function isSameKey(a3, b2) {
        if (!a3 || a3.type !== b2.type) {
          return false;
        }
        if (a3.type === 6) {
          if (a3.value.content !== b2.value.content) {
            return false;
          }
        } else {
          const exp = a3.exp;
          const branchExp = b2.exp;
          if (exp.type !== branchExp.type) {
            return false;
          }
          if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
            return false;
          }
        }
        return true;
      }
      function getParentCondition(node) {
        while (true) {
          if (node.type === 19) {
            if (node.alternate.type === 19) {
              node = node.alternate;
            } else {
              return node;
            }
          } else if (node.type === 20) {
            node = node.value;
          }
        }
      }
      var transformFor = createStructuralDirectiveTransform("for", (node, dir, context3) => {
        const { helper, removeHelper } = context3;
        return processFor(node, dir, context3, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`);
          const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
          if (isTemplate) {
            if (memo) {
              memo.exp = processExpression(memo.exp, context3);
            }
            if (keyProperty && keyProp.type !== 6) {
              keyProperty.value = processExpression(keyProperty.value, context3);
            }
          }
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(context3, helper(FRAGMENT), void 0, renderExp, fragmentFlag + ` /* ${shared.PatchFlagNames[fragmentFlag]} */`, void 0, void 0, true, !isStableFragment, false, node.loc);
          return () => {
            let childBlock;
            const { children: children2 } = forNode;
            if (isTemplate) {
              node.children.some((c3) => {
                if (c3.type === 1) {
                  const key = findProp(c3, "key");
                  if (key) {
                    context3.onError(createCompilerError(33, key.loc));
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children2.length !== 1 || children2[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context3);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context3,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                `64 /* ${shared.PatchFlagNames[
                  64
                  /* STABLE_FRAGMENT */
                ]} */`,
                void 0,
                void 0,
                true,
                void 0,
                false
                /* isComponent */
              );
            } else {
              childBlock = children2[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context3);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(getVNodeBlockHelper(context3.inSSR, childBlock.isComponent));
                } else {
                  removeHelper(getVNodeHelper(context3.inSSR, childBlock.isComponent));
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context3.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context3.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                createSimpleExpression(`_cached`)
              ]));
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context3.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context3.cached++)));
            } else {
              renderExp.arguments.push(createFunctionExpression(
                createForLoopParams(forNode.parseResult),
                childBlock,
                true
                /* force newline */
              ));
            }
          };
        });
      });
      function processFor(node, dir, context3, processCodegen) {
        if (!dir.exp) {
          context3.onError(createCompilerError(31, dir.loc));
          return;
        }
        const parseResult = parseForExpression(
          // can only be simple expression because vFor transform is applied
          // before expression transform.
          dir.exp,
          context3
        );
        if (!parseResult) {
          context3.onError(createCompilerError(32, dir.loc));
          return;
        }
        const { addIdentifiers, removeIdentifiers, scopes } = context3;
        const { source, value, key, index: index2 } = parseResult;
        const forNode = {
          type: 11,
          loc: dir.loc,
          source,
          valueAlias: value,
          keyAlias: key,
          objectIndexAlias: index2,
          parseResult,
          children: isTemplateNode(node) ? node.children : [node]
        };
        context3.replaceNode(forNode);
        scopes.vFor++;
        if (context3.prefixIdentifiers) {
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index2 && addIdentifiers(index2);
        }
        const onExit = processCodegen && processCodegen(forNode);
        return () => {
          scopes.vFor--;
          if (context3.prefixIdentifiers) {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index2 && removeIdentifiers(index2);
          }
          if (onExit)
            onExit();
        };
      }
      var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
      var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
      var stripParensRE = /^\(|\)$/g;
      function parseForExpression(input, context3) {
        const loc = input.loc;
        const exp = input.content;
        const inMatch = exp.match(forAliasRE);
        if (!inMatch)
          return;
        const [, LHS, RHS] = inMatch;
        const result = {
          source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
          value: void 0,
          key: void 0,
          index: void 0
        };
        if (context3.prefixIdentifiers) {
          result.source = processExpression(result.source, context3);
        }
        let valueContent = LHS.trim().replace(stripParensRE, "").trim();
        const trimmedOffset = LHS.indexOf(valueContent);
        const iteratorMatch = valueContent.match(forIteratorRE);
        if (iteratorMatch) {
          valueContent = valueContent.replace(forIteratorRE, "").trim();
          const keyContent = iteratorMatch[1].trim();
          let keyOffset;
          if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
            if (context3.prefixIdentifiers) {
              result.key = processExpression(result.key, context3, true);
            }
          }
          if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
              result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
              if (context3.prefixIdentifiers) {
                result.index = processExpression(result.index, context3, true);
              }
            }
          }
        }
        if (valueContent) {
          result.value = createAliasExpression(loc, valueContent, trimmedOffset);
          if (context3.prefixIdentifiers) {
            result.value = processExpression(result.value, context3, true);
          }
        }
        return result;
      }
      function createAliasExpression(range, content, offset2) {
        return createSimpleExpression(content, false, getInnerRange(range, offset2, content.length));
      }
      function createForLoopParams({ value, key, index: index2 }, memoArgs = []) {
        return createParamsList([value, key, index2, ...memoArgs]);
      }
      function createParamsList(args) {
        let i4 = args.length;
        while (i4--) {
          if (args[i4])
            break;
        }
        return args.slice(0, i4 + 1).map((arg, i5) => arg || createSimpleExpression(`_`.repeat(i5 + 1), false));
      }
      var defaultFallback = createSimpleExpression(`undefined`, false);
      var trackSlotScopes = (node, context3) => {
        if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
          const vSlot = findDir(node, "slot");
          if (vSlot) {
            const slotProps = vSlot.exp;
            if (context3.prefixIdentifiers) {
              slotProps && context3.addIdentifiers(slotProps);
            }
            context3.scopes.vSlot++;
            return () => {
              if (context3.prefixIdentifiers) {
                slotProps && context3.removeIdentifiers(slotProps);
              }
              context3.scopes.vSlot--;
            };
          }
        }
      };
      var trackVForSlotScopes = (node, context3) => {
        let vFor;
        if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
          const result = vFor.parseResult = parseForExpression(vFor.exp, context3);
          if (result) {
            const { value, key, index: index2 } = result;
            const { addIdentifiers, removeIdentifiers } = context3;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index2 && addIdentifiers(index2);
            return () => {
              value && removeIdentifiers(value);
              key && removeIdentifiers(key);
              index2 && removeIdentifiers(index2);
            };
          }
        }
      };
      var buildClientSlotFn = (props, children2, loc) => createFunctionExpression(props, children2, false, true, children2.length ? children2[0].loc : loc);
      function buildSlots(node, context3, buildSlotFn = buildClientSlotFn) {
        context3.helper(WITH_CTX);
        const { children: children2, loc } = node;
        const slotsProperties = [];
        const dynamicSlots = [];
        let hasDynamicSlots = context3.scopes.vSlot > 0 || context3.scopes.vFor > 0;
        if (!context3.ssr && context3.prefixIdentifiers) {
          hasDynamicSlots = hasScopeRef(node, context3.identifiers);
        }
        const onComponentSlot = findDir(node, "slot", true);
        if (onComponentSlot) {
          const { arg, exp } = onComponentSlot;
          if (arg && !isStaticExp(arg)) {
            hasDynamicSlots = true;
          }
          slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children2, loc)));
        }
        let hasTemplateSlots = false;
        let hasNamedDefaultSlot = false;
        const implicitDefaultChildren = [];
        const seenSlotNames = /* @__PURE__ */ new Set();
        for (let i4 = 0; i4 < children2.length; i4++) {
          const slotElement = children2[i4];
          let slotDir;
          if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
            if (slotElement.type !== 3) {
              implicitDefaultChildren.push(slotElement);
            }
            continue;
          }
          if (onComponentSlot) {
            context3.onError(createCompilerError(37, slotDir.loc));
            break;
          }
          hasTemplateSlots = true;
          const { children: slotChildren, loc: slotLoc } = slotElement;
          const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
          let staticSlotName;
          if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
          } else {
            hasDynamicSlots = true;
          }
          const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
          let vIf;
          let vElse;
          let vFor;
          if (vIf = findDir(slotElement, "if")) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
          } else if (vElse = findDir(
            slotElement,
            /^else(-if)?$/,
            true
            /* allowEmpty */
          )) {
            let j2 = i4;
            let prev2;
            while (j2--) {
              prev2 = children2[j2];
              if (prev2.type !== 3) {
                break;
              }
            }
            if (prev2 && isTemplateNode(prev2) && findDir(prev2, "if")) {
              children2.splice(i4, 1);
              i4--;
              let conditional = dynamicSlots[dynamicSlots.length - 1];
              while (conditional.alternate.type === 19) {
                conditional = conditional.alternate;
              }
              conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
            } else {
              context3.onError(createCompilerError(30, vElse.loc));
            }
          } else if (vFor = findDir(slotElement, "for")) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context3);
            if (parseResult) {
              dynamicSlots.push(createCallExpression(context3.helper(RENDER_LIST), [
                parseResult.source,
                createFunctionExpression(
                  createForLoopParams(parseResult),
                  buildDynamicSlot(slotName, slotFunction),
                  true
                  /* force newline */
                )
              ]));
            } else {
              context3.onError(createCompilerError(32, vFor.loc));
            }
          } else {
            if (staticSlotName) {
              if (seenSlotNames.has(staticSlotName)) {
                context3.onError(createCompilerError(38, dirLoc));
                continue;
              }
              seenSlotNames.add(staticSlotName);
              if (staticSlotName === "default") {
                hasNamedDefaultSlot = true;
              }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
          }
        }
        if (!onComponentSlot) {
          const buildDefaultSlotProperty = (props, children3) => {
            const fn = buildSlotFn(props, children3, loc);
            if (context3.compatConfig) {
              fn.isNonScopedSlot = true;
            }
            return createObjectProperty(`default`, fn);
          };
          if (!hasTemplateSlots) {
            slotsProperties.push(buildDefaultSlotProperty(void 0, children2));
          } else if (implicitDefaultChildren.length && // #3766
          // with whitespace: 'preserve', whitespaces between slots will end up in
          // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
          implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
            if (hasNamedDefaultSlot) {
              context3.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
            } else {
              slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
            }
          }
        }
        const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
        let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(
          `_`,
          // 2 = compiled but dynamic = can skip normalization, but must run diff
          // 1 = compiled and static = can skip normalization AND diff as optimized
          createSimpleExpression(slotFlag + ` /* ${shared.slotFlagsText[slotFlag]} */`, false)
        )), loc);
        if (dynamicSlots.length) {
          slots = createCallExpression(context3.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
          ]);
        }
        return {
          slots,
          hasDynamicSlots
        };
      }
      function buildDynamicSlot(name, fn) {
        return createObjectExpression([
          createObjectProperty(`name`, name),
          createObjectProperty(`fn`, fn)
        ]);
      }
      function hasForwardedSlots(children2) {
        for (let i4 = 0; i4 < children2.length; i4++) {
          const child = children2[i4];
          switch (child.type) {
            case 1:
              if (child.tagType === 2 || hasForwardedSlots(child.children)) {
                return true;
              }
              break;
            case 9:
              if (hasForwardedSlots(child.branches))
                return true;
              break;
            case 10:
            case 11:
              if (hasForwardedSlots(child.children))
                return true;
              break;
          }
        }
        return false;
      }
      function isNonWhitespaceContent(node) {
        if (node.type !== 2 && node.type !== 12)
          return true;
        return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
      }
      var directiveImportMap = /* @__PURE__ */ new WeakMap();
      var transformElement = (node, context3) => {
        return function postTransformElement() {
          node = context3.currentNode;
          if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
            return;
          }
          const { tag, props } = node;
          const isComponent2 = node.tagType === 1;
          let vnodeTag = isComponent2 ? resolveComponentType(node, context3) : `"${tag}"`;
          const isDynamicComponent = shared.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
          let vnodeProps;
          let vnodeChildren;
          let vnodePatchFlag;
          let patchFlag = 0;
          let vnodeDynamicProps;
          let dynamicPropNames;
          let vnodeDirectives;
          let shouldUseBlock = (
            // dynamic component may resolve to plain elements
            isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
            // updates inside get proper isSVG flag at runtime. (#639, #643)
            // This is technically web-specific, but splitting the logic out of core
            // leads to too much unnecessary complexity.
            (tag === "svg" || tag === "foreignObject")
          );
          if (props.length > 0) {
            const propsBuildResult = buildProps(node, context3, void 0, isComponent2, isDynamicComponent);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context3))) : void 0;
            if (propsBuildResult.shouldUseBlock) {
              shouldUseBlock = true;
            }
          }
          if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
              shouldUseBlock = true;
              patchFlag |= 1024;
              if (node.children.length > 1) {
                context3.onError(createCompilerError(45, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                }));
              }
            }
            const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
            vnodeTag !== TELEPORT && // explained above.
            vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
              const { slots, hasDynamicSlots } = buildSlots(node, context3);
              vnodeChildren = slots;
              if (hasDynamicSlots) {
                patchFlag |= 1024;
              }
            } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
              const child = node.children[0];
              const type = child.type;
              const hasDynamicTextChild = type === 5 || type === 8;
              if (hasDynamicTextChild && getConstantType(child, context3) === 0) {
                patchFlag |= 1;
              }
              if (hasDynamicTextChild || type === 2) {
                vnodeChildren = child;
              } else {
                vnodeChildren = node.children;
              }
            } else {
              vnodeChildren = node.children;
            }
          }
          if (patchFlag !== 0) {
            {
              if (patchFlag < 0) {
                vnodePatchFlag = patchFlag + ` /* ${shared.PatchFlagNames[patchFlag]} */`;
              } else {
                const flagNames = Object.keys(shared.PatchFlagNames).map(Number).filter((n4) => n4 > 0 && patchFlag & n4).map((n4) => shared.PatchFlagNames[n4]).join(`, `);
                vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
              }
            }
            if (dynamicPropNames && dynamicPropNames.length) {
              vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
          }
          node.codegenNode = createVNodeCall(context3, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
        };
      };
      function resolveComponentType(node, context3, ssr = false) {
        let { tag } = node;
        const isExplicitDynamic = isComponentTag(tag);
        const isProp = findProp(node, "is");
        if (isProp) {
          if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context3)) {
            const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
            if (exp) {
              return createCallExpression(context3.helper(RESOLVE_DYNAMIC_COMPONENT), [
                exp
              ]);
            }
          } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
            tag = isProp.value.content.slice(4);
          }
        }
        const isDir = !isExplicitDynamic && findDir(node, "is");
        if (isDir && isDir.exp) {
          return createCallExpression(context3.helper(RESOLVE_DYNAMIC_COMPONENT), [
            isDir.exp
          ]);
        }
        const builtIn = isCoreComponent(tag) || context3.isBuiltInComponent(tag);
        if (builtIn) {
          if (!ssr)
            context3.helper(builtIn);
          return builtIn;
        }
        {
          const fromSetup = resolveSetupReference(tag, context3);
          if (fromSetup) {
            return fromSetup;
          }
          const dotIndex = tag.indexOf(".");
          if (dotIndex > 0) {
            const ns = resolveSetupReference(tag.slice(0, dotIndex), context3);
            if (ns) {
              return ns + tag.slice(dotIndex);
            }
          }
        }
        if (context3.selfName && shared.capitalize(shared.camelize(tag)) === context3.selfName) {
          context3.helper(RESOLVE_COMPONENT);
          context3.components.add(tag + `__self`);
          return toValidAssetId(tag, `component`);
        }
        context3.helper(RESOLVE_COMPONENT);
        context3.components.add(tag);
        return toValidAssetId(tag, `component`);
      }
      function resolveSetupReference(name, context3) {
        const bindings = context3.bindingMetadata;
        if (!bindings || bindings.__isScriptSetup === false) {
          return;
        }
        const camelName = shared.camelize(name);
        const PascalName = shared.capitalize(camelName);
        const checkType = (type) => {
          if (bindings[name] === type) {
            return name;
          }
          if (bindings[camelName] === type) {
            return camelName;
          }
          if (bindings[PascalName] === type) {
            return PascalName;
          }
        };
        const fromConst = checkType(
          "setup-const"
          /* SETUP_CONST */
        ) || checkType(
          "setup-reactive-const"
          /* SETUP_REACTIVE_CONST */
        );
        if (fromConst) {
          return context3.inline ? (
            // in inline mode, const setup bindings (e.g. imports) can be used as-is
            fromConst
          ) : `$setup[${JSON.stringify(fromConst)}]`;
        }
        const fromMaybeRef = checkType(
          "setup-let"
          /* SETUP_LET */
        ) || checkType(
          "setup-ref"
          /* SETUP_REF */
        ) || checkType(
          "setup-maybe-ref"
          /* SETUP_MAYBE_REF */
        );
        if (fromMaybeRef) {
          return context3.inline ? (
            // setup scope bindings that may be refs need to be unrefed
            `${context3.helperString(UNREF)}(${fromMaybeRef})`
          ) : `$setup[${JSON.stringify(fromMaybeRef)}]`;
        }
      }
      function buildProps(node, context3, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
        const { tag, loc: elementLoc, children: children2 } = node;
        let properties = [];
        const mergeArgs = [];
        const runtimeDirectives = [];
        const hasChildren = children2.length > 0;
        let shouldUseBlock = false;
        let patchFlag = 0;
        let hasRef = false;
        let hasClassBinding = false;
        let hasStyleBinding = false;
        let hasHydrationEventBinding = false;
        let hasDynamicKeys = false;
        let hasVnodeHook = false;
        const dynamicPropNames = [];
        const analyzePatchFlag = ({ key, value }) => {
          if (isStaticExp(key)) {
            const name = key.content;
            const isEventHandler = shared.isOn(name);
            if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
            // dedicated fast path.
            name.toLowerCase() !== "onclick" && // omit v-model handlers
            name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
            !shared.isReservedProp(name)) {
              hasHydrationEventBinding = true;
            }
            if (isEventHandler && shared.isReservedProp(name)) {
              hasVnodeHook = true;
            }
            if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context3) > 0) {
              return;
            }
            if (name === "ref") {
              hasRef = true;
            } else if (name === "class") {
              hasClassBinding = true;
            } else if (name === "style") {
              hasStyleBinding = true;
            } else if (name !== "key" && !dynamicPropNames.includes(name)) {
              dynamicPropNames.push(name);
            }
            if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
              dynamicPropNames.push(name);
            }
          } else {
            hasDynamicKeys = true;
          }
        };
        for (let i4 = 0; i4 < props.length; i4++) {
          const prop = props[i4];
          if (prop.type === 6) {
            const { loc, name, value } = prop;
            let isStatic = true;
            if (name === "ref") {
              hasRef = true;
              if (context3.scopes.vFor > 0) {
                properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
              }
              if (value && context3.inline && context3.bindingMetadata[value.content]) {
                isStatic = false;
                properties.push(createObjectProperty(createSimpleExpression("ref_key", true), createSimpleExpression(value.content, true, value.loc)));
              }
            }
            if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context3))) {
              continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
          } else {
            const { name, arg, exp, loc } = prop;
            const isVBind = name === "bind";
            const isVOn = name === "on";
            if (name === "slot") {
              if (!isComponent2) {
                context3.onError(createCompilerError(40, loc));
              }
              continue;
            }
            if (name === "once" || name === "memo") {
              continue;
            }
            if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context3))) {
              continue;
            }
            if (isVOn && ssr) {
              continue;
            }
            if (
              // #938: elements with dynamic keys should be forced into blocks
              isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
              // before children
              isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
            ) {
              shouldUseBlock = true;
            }
            if (isVBind && isStaticArgOf(arg, "ref") && context3.scopes.vFor > 0) {
              properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
            }
            if (!arg && (isVBind || isVOn)) {
              hasDynamicKeys = true;
              if (exp) {
                if (properties.length) {
                  mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                  properties = [];
                }
                if (isVBind) {
                  {
                    {
                      const hasOverridableKeys = mergeArgs.some((arg2) => {
                        if (arg2.type === 15) {
                          return arg2.properties.some(({ key }) => {
                            if (key.type !== 4 || !key.isStatic) {
                              return true;
                            }
                            return key.content !== "class" && key.content !== "style" && !shared.isOn(key.content);
                          });
                        } else {
                          return true;
                        }
                      });
                      if (hasOverridableKeys) {
                        checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context3, loc);
                      }
                    }
                    if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context3)) {
                      mergeArgs.unshift(exp);
                      continue;
                    }
                  }
                  mergeArgs.push(exp);
                } else {
                  mergeArgs.push({
                    type: 14,
                    loc,
                    callee: context3.helper(TO_HANDLERS),
                    arguments: [exp]
                  });
                }
              } else {
                context3.onError(createCompilerError(isVBind ? 34 : 35, loc));
              }
              continue;
            }
            const directiveTransform = context3.directiveTransforms[name];
            if (directiveTransform) {
              const { props: props2, needRuntime } = directiveTransform(prop, node, context3);
              !ssr && props2.forEach(analyzePatchFlag);
              properties.push(...props2);
              if (needRuntime) {
                runtimeDirectives.push(prop);
                if (shared.isSymbol(needRuntime)) {
                  directiveImportMap.set(prop, needRuntime);
                }
              }
            } else if (!shared.isBuiltInDirective(name)) {
              runtimeDirectives.push(prop);
              if (hasChildren) {
                shouldUseBlock = true;
              }
            }
          }
        }
        let propsExpression = void 0;
        if (mergeArgs.length) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
          }
          if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context3.helper(MERGE_PROPS), mergeArgs, elementLoc);
          } else {
            propsExpression = mergeArgs[0];
          }
        } else if (properties.length) {
          propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
        }
        if (hasDynamicKeys) {
          patchFlag |= 16;
        } else {
          if (hasClassBinding && !isComponent2) {
            patchFlag |= 2;
          }
          if (hasStyleBinding && !isComponent2) {
            patchFlag |= 4;
          }
          if (dynamicPropNames.length) {
            patchFlag |= 8;
          }
          if (hasHydrationEventBinding) {
            patchFlag |= 32;
          }
        }
        if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
          patchFlag |= 512;
        }
        if (!context3.inSSR && propsExpression) {
          switch (propsExpression.type) {
            case 15:
              let classKeyIndex = -1;
              let styleKeyIndex = -1;
              let hasDynamicKey = false;
              for (let i4 = 0; i4 < propsExpression.properties.length; i4++) {
                const key = propsExpression.properties[i4].key;
                if (isStaticExp(key)) {
                  if (key.content === "class") {
                    classKeyIndex = i4;
                  } else if (key.content === "style") {
                    styleKeyIndex = i4;
                  }
                } else if (!key.isHandlerKey) {
                  hasDynamicKey = true;
                }
              }
              const classProp = propsExpression.properties[classKeyIndex];
              const styleProp = propsExpression.properties[styleKeyIndex];
              if (!hasDynamicKey) {
                if (classProp && !isStaticExp(classProp.value)) {
                  classProp.value = createCallExpression(context3.helper(NORMALIZE_CLASS), [classProp.value]);
                }
                if (styleProp && // the static style is compiled into an object,
                // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
                // v-bind:style with static literal object
                styleProp.value.type === 17)) {
                  styleProp.value = createCallExpression(context3.helper(NORMALIZE_STYLE), [styleProp.value]);
                }
              } else {
                propsExpression = createCallExpression(context3.helper(NORMALIZE_PROPS), [propsExpression]);
              }
              break;
            case 14:
              break;
            default:
              propsExpression = createCallExpression(context3.helper(NORMALIZE_PROPS), [
                createCallExpression(context3.helper(GUARD_REACTIVE_PROPS), [
                  propsExpression
                ])
              ]);
              break;
          }
        }
        return {
          props: propsExpression,
          directives: runtimeDirectives,
          patchFlag,
          dynamicPropNames,
          shouldUseBlock
        };
      }
      function dedupeProperties(properties) {
        const knownProps = /* @__PURE__ */ new Map();
        const deduped = [];
        for (let i4 = 0; i4 < properties.length; i4++) {
          const prop = properties[i4];
          if (prop.key.type === 8 || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
          }
          const name = prop.key.content;
          const existing = knownProps.get(name);
          if (existing) {
            if (name === "style" || name === "class" || shared.isOn(name)) {
              mergeAsArray(existing, prop);
            }
          } else {
            knownProps.set(name, prop);
            deduped.push(prop);
          }
        }
        return deduped;
      }
      function mergeAsArray(existing, incoming) {
        if (existing.value.type === 17) {
          existing.value.elements.push(incoming.value);
        } else {
          existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
        }
      }
      function buildDirectiveArgs(dir, context3) {
        const dirArgs = [];
        const runtime = directiveImportMap.get(dir);
        if (runtime) {
          dirArgs.push(context3.helperString(runtime));
        } else {
          const fromSetup = resolveSetupReference("v-" + dir.name, context3);
          if (fromSetup) {
            dirArgs.push(fromSetup);
          } else {
            context3.helper(RESOLVE_DIRECTIVE);
            context3.directives.add(dir.name);
            dirArgs.push(toValidAssetId(dir.name, `directive`));
          }
        }
        const { loc } = dir;
        if (dir.exp)
          dirArgs.push(dir.exp);
        if (dir.arg) {
          if (!dir.exp) {
            dirArgs.push(`void 0`);
          }
          dirArgs.push(dir.arg);
        }
        if (Object.keys(dir.modifiers).length) {
          if (!dir.arg) {
            if (!dir.exp) {
              dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
          }
          const trueExpression = createSimpleExpression(`true`, false, loc);
          dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
        }
        return createArrayExpression(dirArgs, dir.loc);
      }
      function stringifyDynamicPropNames(props) {
        let propsNamesString = `[`;
        for (let i4 = 0, l4 = props.length; i4 < l4; i4++) {
          propsNamesString += JSON.stringify(props[i4]);
          if (i4 < l4 - 1)
            propsNamesString += ", ";
        }
        return propsNamesString + `]`;
      }
      function isComponentTag(tag) {
        return tag === "component" || tag === "Component";
      }
      Object.freeze({});
      Object.freeze([]);
      var cacheStringFunction = (fn) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      };
      var camelizeRE = /-(\w)/g;
      var camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_2, c3) => c3 ? c3.toUpperCase() : "");
      });
      var transformSlotOutlet = (node, context3) => {
        if (isSlotOutlet(node)) {
          const { children: children2, loc } = node;
          const { slotName, slotProps } = processSlotOutlet(node, context3);
          const slotArgs = [
            context3.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName,
            "{}",
            "undefined",
            "true"
          ];
          let expectedLen = 2;
          if (slotProps) {
            slotArgs[2] = slotProps;
            expectedLen = 3;
          }
          if (children2.length) {
            slotArgs[3] = createFunctionExpression([], children2, false, false, loc);
            expectedLen = 4;
          }
          if (context3.scopeId && !context3.slotted) {
            expectedLen = 5;
          }
          slotArgs.splice(expectedLen);
          node.codegenNode = createCallExpression(context3.helper(RENDER_SLOT), slotArgs, loc);
        }
      };
      function processSlotOutlet(node, context3) {
        let slotName = `"default"`;
        let slotProps = void 0;
        const nonNameProps = [];
        for (let i4 = 0; i4 < node.props.length; i4++) {
          const p2 = node.props[i4];
          if (p2.type === 6) {
            if (p2.value) {
              if (p2.name === "name") {
                slotName = JSON.stringify(p2.value.content);
              } else {
                p2.name = camelize(p2.name);
                nonNameProps.push(p2);
              }
            }
          } else {
            if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
              if (p2.exp)
                slotName = p2.exp;
            } else {
              if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
                p2.arg.content = camelize(p2.arg.content);
              }
              nonNameProps.push(p2);
            }
          }
        }
        if (nonNameProps.length > 0) {
          const { props, directives } = buildProps(node, context3, nonNameProps, false, false);
          slotProps = props;
          if (directives.length) {
            context3.onError(createCompilerError(36, directives[0].loc));
          }
        }
        return {
          slotName,
          slotProps
        };
      }
      var fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
      var transformOn = (dir, node, context3, augmentor) => {
        const { loc, modifiers, arg } = dir;
        if (!dir.exp && !modifiers.length) {
          context3.onError(createCompilerError(35, loc));
        }
        let eventName;
        if (arg.type === 4) {
          if (arg.isStatic) {
            let rawName = arg.content;
            if (rawName.startsWith("vue:")) {
              rawName = `vnode-${rawName.slice(4)}`;
            }
            eventName = createSimpleExpression(shared.toHandlerKey(shared.camelize(rawName)), true, arg.loc);
          } else {
            eventName = createCompoundExpression([
              `${context3.helperString(TO_HANDLER_KEY)}(`,
              arg,
              `)`
            ]);
          }
        } else {
          eventName = arg;
          eventName.children.unshift(`${context3.helperString(TO_HANDLER_KEY)}(`);
          eventName.children.push(`)`);
        }
        let exp = dir.exp;
        if (exp && !exp.content.trim()) {
          exp = void 0;
        }
        let shouldCache = context3.cacheHandlers && !exp && !context3.inVOnce;
        if (exp) {
          const isMemberExp = isMemberExpression(exp.content, context3);
          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
          const hasMultipleStatements = exp.content.includes(`;`);
          if (context3.prefixIdentifiers) {
            isInlineStatement && context3.addIdentifiers(`$event`);
            exp = dir.exp = processExpression(exp, context3, false, hasMultipleStatements);
            isInlineStatement && context3.removeIdentifiers(`$event`);
            shouldCache = context3.cacheHandlers && // unnecessary to cache inside v-once
            !context3.inVOnce && // runtime constants don't need to be cached
            // (this is analyzed by compileScript in SFC <script setup>)
            !(exp.type === 4 && exp.constType > 0) && // #1541 bail if this is a member exp handler passed to a component -
            // we need to use the original function to preserve arity,
            // e.g. <transition> relies on checking cb.length to determine
            // transition end handling. Inline function is ok since its arity
            // is preserved even when cached.
            !(isMemberExp && node.tagType === 1) && // bail if the function references closure variables (v-for, v-slot)
            // it must be passed fresh to avoid stale values.
            !hasScopeRef(exp, context3.identifiers);
            if (shouldCache && isMemberExp) {
              if (exp.type === 4) {
                exp.content = `${exp.content} && ${exp.content}(...args)`;
              } else {
                exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];
              }
            }
          }
          if (isInlineStatement || shouldCache && isMemberExp) {
            exp = createCompoundExpression([
              `${isInlineStatement ? context3.isTS ? `($event: any)` : `$event` : `${context3.isTS ? `
//@ts-ignore
` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
              exp,
              hasMultipleStatements ? `}` : `)`
            ]);
          }
        }
        let ret = {
          props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
          ]
        };
        if (augmentor) {
          ret = augmentor(ret);
        }
        if (shouldCache) {
          ret.props[0].value = context3.cache(ret.props[0].value);
        }
        ret.props.forEach((p2) => p2.key.isHandlerKey = true);
        return ret;
      };
      var transformBind = (dir, _node, context3) => {
        const { exp, modifiers, loc } = dir;
        const arg = dir.arg;
        if (arg.type !== 4) {
          arg.children.unshift(`(`);
          arg.children.push(`) || ""`);
        } else if (!arg.isStatic) {
          arg.content = `${arg.content} || ""`;
        }
        if (modifiers.includes("camel")) {
          if (arg.type === 4) {
            if (arg.isStatic) {
              arg.content = shared.camelize(arg.content);
            } else {
              arg.content = `${context3.helperString(CAMELIZE)}(${arg.content})`;
            }
          } else {
            arg.children.unshift(`${context3.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
          }
        }
        if (!context3.inSSR) {
          if (modifiers.includes("prop")) {
            injectPrefix(arg, ".");
          }
          if (modifiers.includes("attr")) {
            injectPrefix(arg, "^");
          }
        }
        if (!exp || exp.type === 4 && !exp.content.trim()) {
          context3.onError(createCompilerError(34, loc));
          return {
            props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
          };
        }
        return {
          props: [createObjectProperty(arg, exp)]
        };
      };
      var injectPrefix = (arg, prefix) => {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = prefix + arg.content;
          } else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
          }
        } else {
          arg.children.unshift(`'${prefix}' + (`);
          arg.children.push(`)`);
        }
      };
      var transformText = (node, context3) => {
        if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
          return () => {
            const children2 = node.children;
            let currentContainer = void 0;
            let hasText = false;
            for (let i4 = 0; i4 < children2.length; i4++) {
              const child = children2[i4];
              if (isText(child)) {
                hasText = true;
                for (let j2 = i4 + 1; j2 < children2.length; j2++) {
                  const next2 = children2[j2];
                  if (isText(next2)) {
                    if (!currentContainer) {
                      currentContainer = children2[i4] = createCompoundExpression([child], child.loc);
                    }
                    currentContainer.children.push(` + `, next2);
                    children2.splice(j2, 1);
                    j2--;
                  } else {
                    currentContainer = void 0;
                    break;
                  }
                }
              }
            }
            if (!hasText || // if this is a plain element with a single text child, leave it
            // as-is since the runtime has dedicated fast path for this by directly
            // setting textContent of the element.
            // for component root it's always normalized anyway.
            children2.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
            // custom directives can potentially add DOM elements arbitrarily,
            // we need to avoid setting textContent of the element at runtime
            // to avoid accidentally overwriting the DOM elements added
            // by the user through custom directives.
            !node.props.find((p2) => p2.type === 7 && !context3.directiveTransforms[p2.name]) && // in compat mode, <template> tags with no special directives
            // will be rendered as a fragment so its children must be
            // converted into vnodes.
            !(node.tag === "template"))) {
              return;
            }
            for (let i4 = 0; i4 < children2.length; i4++) {
              const child = children2[i4];
              if (isText(child) || child.type === 8) {
                const callArgs = [];
                if (child.type !== 2 || child.content !== " ") {
                  callArgs.push(child);
                }
                if (!context3.ssr && getConstantType(child, context3) === 0) {
                  callArgs.push(`1 /* ${shared.PatchFlagNames[
                    1
                    /* TEXT */
                  ]} */`);
                }
                children2[i4] = {
                  type: 12,
                  content: child,
                  loc: child.loc,
                  codegenNode: createCallExpression(context3.helper(CREATE_TEXT), callArgs)
                };
              }
            }
          };
        }
      };
      var seen = /* @__PURE__ */ new WeakSet();
      var transformOnce = (node, context3) => {
        if (node.type === 1 && findDir(node, "once", true)) {
          if (seen.has(node) || context3.inVOnce) {
            return;
          }
          seen.add(node);
          context3.inVOnce = true;
          context3.helper(SET_BLOCK_TRACKING);
          return () => {
            context3.inVOnce = false;
            const cur = context3.currentNode;
            if (cur.codegenNode) {
              cur.codegenNode = context3.cache(
                cur.codegenNode,
                true
                /* isVNode */
              );
            }
          };
        }
      };
      var transformModel = (dir, node, context3) => {
        const { exp, arg } = dir;
        if (!exp) {
          context3.onError(createCompilerError(41, dir.loc));
          return createTransformProps();
        }
        const rawExp = exp.loc.source;
        const expString = exp.type === 4 ? exp.content : rawExp;
        const bindingType = context3.bindingMetadata[rawExp];
        const maybeRef = context3.inline && bindingType && bindingType !== "setup-const";
        if (!expString.trim() || !isMemberExpression(expString, context3) && !maybeRef) {
          context3.onError(createCompilerError(42, exp.loc));
          return createTransformProps();
        }
        if (context3.prefixIdentifiers && isSimpleIdentifier(expString) && context3.identifiers[expString]) {
          context3.onError(createCompilerError(43, exp.loc));
          return createTransformProps();
        }
        const propName = arg ? arg : createSimpleExpression("modelValue", true);
        const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
        let assignmentExp;
        const eventArg = context3.isTS ? `($event: any)` : `$event`;
        if (maybeRef) {
          if (bindingType === "setup-ref") {
            assignmentExp = createCompoundExpression([
              `${eventArg} => ((`,
              createSimpleExpression(rawExp, false, exp.loc),
              `).value = $event)`
            ]);
          } else {
            const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
            assignmentExp = createCompoundExpression([
              `${eventArg} => (${context3.helperString(IS_REF)}(${rawExp}) ? (`,
              createSimpleExpression(rawExp, false, exp.loc),
              `).value = $event : ${altAssignment})`
            ]);
          }
        } else {
          assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            exp,
            `) = $event)`
          ]);
        }
        const props = [
          // modelValue: foo
          createObjectProperty(propName, dir.exp),
          // "onUpdate:modelValue": $event => (foo = $event)
          createObjectProperty(eventName, assignmentExp)
        ];
        if (context3.prefixIdentifiers && !context3.inVOnce && context3.cacheHandlers && !hasScopeRef(exp, context3.identifiers)) {
          props[1].value = context3.cache(props[1].value);
        }
        if (dir.modifiers.length && node.tagType === 1) {
          const modifiers = dir.modifiers.map((m2) => (isSimpleIdentifier(m2) ? m2 : JSON.stringify(m2)) + `: true`).join(`, `);
          const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
          props.push(createObjectProperty(modifiersKey, createSimpleExpression(
            `{ ${modifiers} }`,
            false,
            dir.loc,
            2
            /* CAN_HOIST */
          )));
        }
        return createTransformProps(props);
      };
      function createTransformProps(props = []) {
        return { props };
      }
      var validDivisionCharRE = /[\w).+\-_$\]]/;
      var transformFilter = (node, context3) => {
        if (!isCompatEnabled("COMPILER_FILTER", context3)) {
          return;
        }
        if (node.type === 5) {
          rewriteFilter(node.content, context3);
        }
        if (node.type === 1) {
          node.props.forEach((prop) => {
            if (prop.type === 7 && prop.name !== "for" && prop.exp) {
              rewriteFilter(prop.exp, context3);
            }
          });
        }
      };
      function rewriteFilter(node, context3) {
        if (node.type === 4) {
          parseFilter(node, context3);
        } else {
          for (let i4 = 0; i4 < node.children.length; i4++) {
            const child = node.children[i4];
            if (typeof child !== "object")
              continue;
            if (child.type === 4) {
              parseFilter(child, context3);
            } else if (child.type === 8) {
              rewriteFilter(node, context3);
            } else if (child.type === 5) {
              rewriteFilter(child.content, context3);
            }
          }
        }
      }
      function parseFilter(node, context3) {
        const exp = node.content;
        let inSingle = false;
        let inDouble = false;
        let inTemplateString = false;
        let inRegex = false;
        let curly = 0;
        let square = 0;
        let paren = 0;
        let lastFilterIndex = 0;
        let c3, prev2, i4, expression, filters = [];
        for (i4 = 0; i4 < exp.length; i4++) {
          prev2 = c3;
          c3 = exp.charCodeAt(i4);
          if (inSingle) {
            if (c3 === 39 && prev2 !== 92)
              inSingle = false;
          } else if (inDouble) {
            if (c3 === 34 && prev2 !== 92)
              inDouble = false;
          } else if (inTemplateString) {
            if (c3 === 96 && prev2 !== 92)
              inTemplateString = false;
          } else if (inRegex) {
            if (c3 === 47 && prev2 !== 92)
              inRegex = false;
          } else if (c3 === 124 && // pipe
          exp.charCodeAt(i4 + 1) !== 124 && exp.charCodeAt(i4 - 1) !== 124 && !curly && !square && !paren) {
            if (expression === void 0) {
              lastFilterIndex = i4 + 1;
              expression = exp.slice(0, i4).trim();
            } else {
              pushFilter();
            }
          } else {
            switch (c3) {
              case 34:
                inDouble = true;
                break;
              // "
              case 39:
                inSingle = true;
                break;
              // '
              case 96:
                inTemplateString = true;
                break;
              // `
              case 40:
                paren++;
                break;
              // (
              case 41:
                paren--;
                break;
              // )
              case 91:
                square++;
                break;
              // [
              case 93:
                square--;
                break;
              // ]
              case 123:
                curly++;
                break;
              // {
              case 125:
                curly--;
                break;
            }
            if (c3 === 47) {
              let j2 = i4 - 1;
              let p2;
              for (; j2 >= 0; j2--) {
                p2 = exp.charAt(j2);
                if (p2 !== " ")
                  break;
              }
              if (!p2 || !validDivisionCharRE.test(p2)) {
                inRegex = true;
              }
            }
          }
        }
        if (expression === void 0) {
          expression = exp.slice(0, i4).trim();
        } else if (lastFilterIndex !== 0) {
          pushFilter();
        }
        function pushFilter() {
          filters.push(exp.slice(lastFilterIndex, i4).trim());
          lastFilterIndex = i4 + 1;
        }
        if (filters.length) {
          warnDeprecation("COMPILER_FILTER", context3, node.loc);
          for (i4 = 0; i4 < filters.length; i4++) {
            expression = wrapFilter(expression, filters[i4], context3);
          }
          node.content = expression;
        }
      }
      function wrapFilter(exp, filter2, context3) {
        context3.helper(RESOLVE_FILTER);
        const i4 = filter2.indexOf("(");
        if (i4 < 0) {
          context3.filters.add(filter2);
          return `${toValidAssetId(filter2, "filter")}(${exp})`;
        } else {
          const name = filter2.slice(0, i4);
          const args = filter2.slice(i4 + 1);
          context3.filters.add(name);
          return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
        }
      }
      var seen$1 = /* @__PURE__ */ new WeakSet();
      var transformMemo = (node, context3) => {
        if (node.type === 1) {
          const dir = findDir(node, "memo");
          if (!dir || seen$1.has(node)) {
            return;
          }
          seen$1.add(node);
          return () => {
            const codegenNode = node.codegenNode || context3.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13) {
              if (node.tagType !== 1) {
                makeBlock(codegenNode, context3);
              }
              node.codegenNode = createCallExpression(context3.helper(WITH_MEMO), [
                dir.exp,
                createFunctionExpression(void 0, codegenNode),
                `_cache`,
                String(context3.cached++)
              ]);
            }
          };
        }
      };
      function getBaseTransformPreset(prefixIdentifiers) {
        return [
          [
            transformOnce,
            transformIf,
            transformMemo,
            transformFor,
            ...[transformFilter],
            ...prefixIdentifiers ? [
              // order is important
              trackVForSlotScopes,
              transformExpression
            ] : [],
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
          ],
          {
            on: transformOn,
            bind: transformBind,
            model: transformModel
          }
        ];
      }
      function baseCompile(template2, options = {}) {
        const onError = options.onError || defaultOnError;
        const isModuleMode = options.mode === "module";
        const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
        if (!prefixIdentifiers && options.cacheHandlers) {
          onError(createCompilerError(
            48
            /* X_CACHE_HANDLER_NOT_SUPPORTED */
          ));
        }
        if (options.scopeId && !isModuleMode) {
          onError(createCompilerError(
            49
            /* X_SCOPE_ID_NOT_SUPPORTED */
          ));
        }
        const ast = shared.isString(template2) ? baseParse(template2, options) : template2;
        const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
        if (options.isTS) {
          const { expressionPlugins } = options;
          if (!expressionPlugins || !expressionPlugins.includes("typescript")) {
            options.expressionPlugins = [...expressionPlugins || [], "typescript"];
          }
        }
        transform2(ast, shared.extend({}, options, {
          prefixIdentifiers,
          nodeTransforms: [
            ...nodeTransforms,
            ...options.nodeTransforms || []
            // user transforms
          ],
          directiveTransforms: shared.extend(
            {},
            directiveTransforms,
            options.directiveTransforms || {}
            // user transforms
          )
        }));
        return generate(ast, shared.extend({}, options, {
          prefixIdentifiers
        }));
      }
      var noopDirectiveTransform = () => ({ props: [] });
      exports.generateCodeFrame = shared.generateCodeFrame;
      exports.BASE_TRANSITION = BASE_TRANSITION;
      exports.CAMELIZE = CAMELIZE;
      exports.CAPITALIZE = CAPITALIZE;
      exports.CREATE_BLOCK = CREATE_BLOCK;
      exports.CREATE_COMMENT = CREATE_COMMENT;
      exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
      exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
      exports.CREATE_SLOTS = CREATE_SLOTS;
      exports.CREATE_STATIC = CREATE_STATIC;
      exports.CREATE_TEXT = CREATE_TEXT;
      exports.CREATE_VNODE = CREATE_VNODE;
      exports.FRAGMENT = FRAGMENT;
      exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
      exports.IS_MEMO_SAME = IS_MEMO_SAME;
      exports.IS_REF = IS_REF;
      exports.KEEP_ALIVE = KEEP_ALIVE;
      exports.MERGE_PROPS = MERGE_PROPS;
      exports.NORMALIZE_CLASS = NORMALIZE_CLASS;
      exports.NORMALIZE_PROPS = NORMALIZE_PROPS;
      exports.NORMALIZE_STYLE = NORMALIZE_STYLE;
      exports.OPEN_BLOCK = OPEN_BLOCK;
      exports.POP_SCOPE_ID = POP_SCOPE_ID;
      exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
      exports.RENDER_LIST = RENDER_LIST;
      exports.RENDER_SLOT = RENDER_SLOT;
      exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
      exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
      exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
      exports.RESOLVE_FILTER = RESOLVE_FILTER;
      exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
      exports.SUSPENSE = SUSPENSE;
      exports.TELEPORT = TELEPORT;
      exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
      exports.TO_HANDLERS = TO_HANDLERS;
      exports.TO_HANDLER_KEY = TO_HANDLER_KEY;
      exports.UNREF = UNREF;
      exports.WITH_CTX = WITH_CTX;
      exports.WITH_DIRECTIVES = WITH_DIRECTIVES;
      exports.WITH_MEMO = WITH_MEMO;
      exports.advancePositionWithClone = advancePositionWithClone;
      exports.advancePositionWithMutation = advancePositionWithMutation;
      exports.assert = assert;
      exports.baseCompile = baseCompile;
      exports.baseParse = baseParse;
      exports.buildDirectiveArgs = buildDirectiveArgs;
      exports.buildProps = buildProps;
      exports.buildSlots = buildSlots;
      exports.checkCompatEnabled = checkCompatEnabled;
      exports.createArrayExpression = createArrayExpression;
      exports.createAssignmentExpression = createAssignmentExpression;
      exports.createBlockStatement = createBlockStatement;
      exports.createCacheExpression = createCacheExpression;
      exports.createCallExpression = createCallExpression;
      exports.createCompilerError = createCompilerError;
      exports.createCompoundExpression = createCompoundExpression;
      exports.createConditionalExpression = createConditionalExpression;
      exports.createForLoopParams = createForLoopParams;
      exports.createFunctionExpression = createFunctionExpression;
      exports.createIfStatement = createIfStatement;
      exports.createInterpolation = createInterpolation;
      exports.createObjectExpression = createObjectExpression;
      exports.createObjectProperty = createObjectProperty;
      exports.createReturnStatement = createReturnStatement;
      exports.createRoot = createRoot;
      exports.createSequenceExpression = createSequenceExpression;
      exports.createSimpleExpression = createSimpleExpression;
      exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
      exports.createTemplateLiteral = createTemplateLiteral;
      exports.createTransformContext = createTransformContext;
      exports.createVNodeCall = createVNodeCall;
      exports.extractIdentifiers = extractIdentifiers;
      exports.findDir = findDir;
      exports.findProp = findProp;
      exports.generate = generate;
      exports.getBaseTransformPreset = getBaseTransformPreset;
      exports.getConstantType = getConstantType;
      exports.getInnerRange = getInnerRange;
      exports.getMemoedVNodeCall = getMemoedVNodeCall;
      exports.getVNodeBlockHelper = getVNodeBlockHelper;
      exports.getVNodeHelper = getVNodeHelper;
      exports.hasDynamicKeyVBind = hasDynamicKeyVBind;
      exports.hasScopeRef = hasScopeRef;
      exports.helperNameMap = helperNameMap;
      exports.injectProp = injectProp;
      exports.isBuiltInType = isBuiltInType;
      exports.isCoreComponent = isCoreComponent;
      exports.isFunctionType = isFunctionType;
      exports.isInDestructureAssignment = isInDestructureAssignment;
      exports.isMemberExpression = isMemberExpression;
      exports.isMemberExpressionBrowser = isMemberExpressionBrowser;
      exports.isMemberExpressionNode = isMemberExpressionNode;
      exports.isReferencedIdentifier = isReferencedIdentifier;
      exports.isSimpleIdentifier = isSimpleIdentifier;
      exports.isSlotOutlet = isSlotOutlet;
      exports.isStaticArgOf = isStaticArgOf;
      exports.isStaticExp = isStaticExp;
      exports.isStaticProperty = isStaticProperty;
      exports.isStaticPropertyKey = isStaticPropertyKey;
      exports.isTemplateNode = isTemplateNode;
      exports.isText = isText;
      exports.isVSlot = isVSlot;
      exports.locStub = locStub;
      exports.makeBlock = makeBlock;
      exports.noopDirectiveTransform = noopDirectiveTransform;
      exports.processExpression = processExpression;
      exports.processFor = processFor;
      exports.processIf = processIf;
      exports.processSlotOutlet = processSlotOutlet;
      exports.registerRuntimeHelpers = registerRuntimeHelpers;
      exports.resolveComponentType = resolveComponentType;
      exports.toValidAssetId = toValidAssetId;
      exports.trackSlotScopes = trackSlotScopes;
      exports.trackVForSlotScopes = trackVForSlotScopes;
      exports.transform = transform2;
      exports.transformBind = transformBind;
      exports.transformElement = transformElement;
      exports.transformExpression = transformExpression;
      exports.transformModel = transformModel;
      exports.transformOn = transformOn;
      exports.traverseNode = traverseNode;
      exports.walkBlockDeclarations = walkBlockDeclarations;
      exports.walkFunctionParams = walkFunctionParams;
      exports.walkIdentifiers = walkIdentifiers;
      exports.warnDeprecation = warnDeprecation;
    }
  });

  // node_modules/@vue/compiler-core/index.js
  var require_compiler_core = __commonJS({
    "node_modules/@vue/compiler-core/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_compiler_core_cjs();
      }
    }
  });

  // node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js
  var require_compiler_dom_cjs = __commonJS({
    "node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var compilerCore = require_compiler_core();
      var shared = require_shared();
      var V_MODEL_RADIO = Symbol(`vModelRadio`);
      var V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
      var V_MODEL_TEXT = Symbol(`vModelText`);
      var V_MODEL_SELECT = Symbol(`vModelSelect`);
      var V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
      var V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
      var V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
      var V_SHOW = Symbol(`vShow`);
      var TRANSITION = Symbol(`Transition`);
      var TRANSITION_GROUP = Symbol(`TransitionGroup`);
      compilerCore.registerRuntimeHelpers({
        [V_MODEL_RADIO]: `vModelRadio`,
        [V_MODEL_CHECKBOX]: `vModelCheckbox`,
        [V_MODEL_TEXT]: `vModelText`,
        [V_MODEL_SELECT]: `vModelSelect`,
        [V_MODEL_DYNAMIC]: `vModelDynamic`,
        [V_ON_WITH_MODIFIERS]: `withModifiers`,
        [V_ON_WITH_KEYS]: `withKeys`,
        [V_SHOW]: `vShow`,
        [TRANSITION]: `Transition`,
        [TRANSITION_GROUP]: `TransitionGroup`
      });
      var namedCharacterReferences = {
        GT: ">",
        gt: ">",
        LT: "<",
        lt: "<",
        "ac;": "\u223E",
        "af;": "\u2061",
        AMP: "&",
        amp: "&",
        "ap;": "\u2248",
        "DD;": "\u2145",
        "dd;": "\u2146",
        deg: "\xB0",
        "ee;": "\u2147",
        "eg;": "\u2A9A",
        "el;": "\u2A99",
        ETH: "\xD0",
        eth: "\xF0",
        "gE;": "\u2267",
        "ge;": "\u2265",
        "Gg;": "\u22D9",
        "gg;": "\u226B",
        "gl;": "\u2277",
        "GT;": ">",
        "Gt;": "\u226B",
        "gt;": ">",
        "ic;": "\u2063",
        "ii;": "\u2148",
        "Im;": "\u2111",
        "in;": "\u2208",
        "it;": "\u2062",
        "lE;": "\u2266",
        "le;": "\u2264",
        "lg;": "\u2276",
        "Ll;": "\u22D8",
        "ll;": "\u226A",
        "LT;": "<",
        "Lt;": "\u226A",
        "lt;": "<",
        "mp;": "\u2213",
        "Mu;": "\u039C",
        "mu;": "\u03BC",
        "ne;": "\u2260",
        "ni;": "\u220B",
        not: "\xAC",
        "Nu;": "\u039D",
        "nu;": "\u03BD",
        "Or;": "\u2A54",
        "or;": "\u2228",
        "oS;": "\u24C8",
        "Pi;": "\u03A0",
        "pi;": "\u03C0",
        "pm;": "\xB1",
        "Pr;": "\u2ABB",
        "pr;": "\u227A",
        "Re;": "\u211C",
        REG: "\xAE",
        reg: "\xAE",
        "rx;": "\u211E",
        "Sc;": "\u2ABC",
        "sc;": "\u227B",
        shy: "\xAD",
        uml: "\xA8",
        "wp;": "\u2118",
        "wr;": "\u2240",
        "Xi;": "\u039E",
        "xi;": "\u03BE",
        yen: "\xA5",
        "acd;": "\u223F",
        "acE;": "\u223E\u0333",
        "Acy;": "\u0410",
        "acy;": "\u0430",
        "Afr;": "\u{1D504}",
        "afr;": "\u{1D51E}",
        "AMP;": "&",
        "amp;": "&",
        "And;": "\u2A53",
        "and;": "\u2227",
        "ang;": "\u2220",
        "apE;": "\u2A70",
        "ape;": "\u224A",
        "ast;": "*",
        Auml: "\xC4",
        auml: "\xE4",
        "Bcy;": "\u0411",
        "bcy;": "\u0431",
        "Bfr;": "\u{1D505}",
        "bfr;": "\u{1D51F}",
        "bne;": "=\u20E5",
        "bot;": "\u22A5",
        "Cap;": "\u22D2",
        "cap;": "\u2229",
        cent: "\xA2",
        "Cfr;": "\u212D",
        "cfr;": "\u{1D520}",
        "Chi;": "\u03A7",
        "chi;": "\u03C7",
        "cir;": "\u25CB",
        COPY: "\xA9",
        copy: "\xA9",
        "Cup;": "\u22D3",
        "cup;": "\u222A",
        "Dcy;": "\u0414",
        "dcy;": "\u0434",
        "deg;": "\xB0",
        "Del;": "\u2207",
        "Dfr;": "\u{1D507}",
        "dfr;": "\u{1D521}",
        "die;": "\xA8",
        "div;": "\xF7",
        "Dot;": "\xA8",
        "dot;": "\u02D9",
        "Ecy;": "\u042D",
        "ecy;": "\u044D",
        "Efr;": "\u{1D508}",
        "efr;": "\u{1D522}",
        "egs;": "\u2A96",
        "ell;": "\u2113",
        "els;": "\u2A95",
        "ENG;": "\u014A",
        "eng;": "\u014B",
        "Eta;": "\u0397",
        "eta;": "\u03B7",
        "ETH;": "\xD0",
        "eth;": "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        "Fcy;": "\u0424",
        "fcy;": "\u0444",
        "Ffr;": "\u{1D509}",
        "ffr;": "\u{1D523}",
        "gap;": "\u2A86",
        "Gcy;": "\u0413",
        "gcy;": "\u0433",
        "gEl;": "\u2A8C",
        "gel;": "\u22DB",
        "geq;": "\u2265",
        "ges;": "\u2A7E",
        "Gfr;": "\u{1D50A}",
        "gfr;": "\u{1D524}",
        "ggg;": "\u22D9",
        "gla;": "\u2AA5",
        "glE;": "\u2A92",
        "glj;": "\u2AA4",
        "gnE;": "\u2269",
        "gne;": "\u2A88",
        "Hat;": "^",
        "Hfr;": "\u210C",
        "hfr;": "\u{1D525}",
        "Icy;": "\u0418",
        "icy;": "\u0438",
        "iff;": "\u21D4",
        "Ifr;": "\u2111",
        "ifr;": "\u{1D526}",
        "Int;": "\u222C",
        "int;": "\u222B",
        Iuml: "\xCF",
        iuml: "\xEF",
        "Jcy;": "\u0419",
        "jcy;": "\u0439",
        "Jfr;": "\u{1D50D}",
        "jfr;": "\u{1D527}",
        "Kcy;": "\u041A",
        "kcy;": "\u043A",
        "Kfr;": "\u{1D50E}",
        "kfr;": "\u{1D528}",
        "lap;": "\u2A85",
        "lat;": "\u2AAB",
        "Lcy;": "\u041B",
        "lcy;": "\u043B",
        "lEg;": "\u2A8B",
        "leg;": "\u22DA",
        "leq;": "\u2264",
        "les;": "\u2A7D",
        "Lfr;": "\u{1D50F}",
        "lfr;": "\u{1D529}",
        "lgE;": "\u2A91",
        "lnE;": "\u2268",
        "lne;": "\u2A87",
        "loz;": "\u25CA",
        "lrm;": "\u200E",
        "Lsh;": "\u21B0",
        "lsh;": "\u21B0",
        macr: "\xAF",
        "Map;": "\u2905",
        "map;": "\u21A6",
        "Mcy;": "\u041C",
        "mcy;": "\u043C",
        "Mfr;": "\u{1D510}",
        "mfr;": "\u{1D52A}",
        "mho;": "\u2127",
        "mid;": "\u2223",
        "nap;": "\u2249",
        nbsp: "\xA0",
        "Ncy;": "\u041D",
        "ncy;": "\u043D",
        "Nfr;": "\u{1D511}",
        "nfr;": "\u{1D52B}",
        "ngE;": "\u2267\u0338",
        "nge;": "\u2271",
        "nGg;": "\u22D9\u0338",
        "nGt;": "\u226B\u20D2",
        "ngt;": "\u226F",
        "nis;": "\u22FC",
        "niv;": "\u220B",
        "nlE;": "\u2266\u0338",
        "nle;": "\u2270",
        "nLl;": "\u22D8\u0338",
        "nLt;": "\u226A\u20D2",
        "nlt;": "\u226E",
        "Not;": "\u2AEC",
        "not;": "\xAC",
        "npr;": "\u2280",
        "nsc;": "\u2281",
        "num;": "#",
        "Ocy;": "\u041E",
        "ocy;": "\u043E",
        "Ofr;": "\u{1D512}",
        "ofr;": "\u{1D52C}",
        "ogt;": "\u29C1",
        "ohm;": "\u03A9",
        "olt;": "\u29C0",
        "ord;": "\u2A5D",
        ordf: "\xAA",
        ordm: "\xBA",
        "orv;": "\u2A5B",
        Ouml: "\xD6",
        ouml: "\xF6",
        "par;": "\u2225",
        para: "\xB6",
        "Pcy;": "\u041F",
        "pcy;": "\u043F",
        "Pfr;": "\u{1D513}",
        "pfr;": "\u{1D52D}",
        "Phi;": "\u03A6",
        "phi;": "\u03C6",
        "piv;": "\u03D6",
        "prE;": "\u2AB3",
        "pre;": "\u2AAF",
        "Psi;": "\u03A8",
        "psi;": "\u03C8",
        "Qfr;": "\u{1D514}",
        "qfr;": "\u{1D52E}",
        QUOT: '"',
        quot: '"',
        "Rcy;": "\u0420",
        "rcy;": "\u0440",
        "REG;": "\xAE",
        "reg;": "\xAE",
        "Rfr;": "\u211C",
        "rfr;": "\u{1D52F}",
        "Rho;": "\u03A1",
        "rho;": "\u03C1",
        "rlm;": "\u200F",
        "Rsh;": "\u21B1",
        "rsh;": "\u21B1",
        "scE;": "\u2AB4",
        "sce;": "\u2AB0",
        "Scy;": "\u0421",
        "scy;": "\u0441",
        sect: "\xA7",
        "Sfr;": "\u{1D516}",
        "sfr;": "\u{1D530}",
        "shy;": "\xAD",
        "sim;": "\u223C",
        "smt;": "\u2AAA",
        "sol;": "/",
        "squ;": "\u25A1",
        "Sub;": "\u22D0",
        "sub;": "\u2282",
        "Sum;": "\u2211",
        "sum;": "\u2211",
        "Sup;": "\u22D1",
        "sup;": "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        "Tab;": "	",
        "Tau;": "\u03A4",
        "tau;": "\u03C4",
        "Tcy;": "\u0422",
        "tcy;": "\u0442",
        "Tfr;": "\u{1D517}",
        "tfr;": "\u{1D531}",
        "top;": "\u22A4",
        "Ucy;": "\u0423",
        "ucy;": "\u0443",
        "Ufr;": "\u{1D518}",
        "ufr;": "\u{1D532}",
        "uml;": "\xA8",
        Uuml: "\xDC",
        uuml: "\xFC",
        "Vcy;": "\u0412",
        "vcy;": "\u0432",
        "Vee;": "\u22C1",
        "vee;": "\u2228",
        "Vfr;": "\u{1D519}",
        "vfr;": "\u{1D533}",
        "Wfr;": "\u{1D51A}",
        "wfr;": "\u{1D534}",
        "Xfr;": "\u{1D51B}",
        "xfr;": "\u{1D535}",
        "Ycy;": "\u042B",
        "ycy;": "\u044B",
        "yen;": "\xA5",
        "Yfr;": "\u{1D51C}",
        "yfr;": "\u{1D536}",
        yuml: "\xFF",
        "Zcy;": "\u0417",
        "zcy;": "\u0437",
        "Zfr;": "\u2128",
        "zfr;": "\u{1D537}",
        "zwj;": "\u200D",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        AElig: "\xC6",
        aelig: "\xE6",
        "andd;": "\u2A5C",
        "andv;": "\u2A5A",
        "ange;": "\u29A4",
        "Aopf;": "\u{1D538}",
        "aopf;": "\u{1D552}",
        "apid;": "\u224B",
        "apos;": "'",
        Aring: "\xC5",
        aring: "\xE5",
        "Ascr;": "\u{1D49C}",
        "ascr;": "\u{1D4B6}",
        "Auml;": "\xC4",
        "auml;": "\xE4",
        "Barv;": "\u2AE7",
        "bbrk;": "\u23B5",
        "Beta;": "\u0392",
        "beta;": "\u03B2",
        "beth;": "\u2136",
        "bNot;": "\u2AED",
        "bnot;": "\u2310",
        "Bopf;": "\u{1D539}",
        "bopf;": "\u{1D553}",
        "boxH;": "\u2550",
        "boxh;": "\u2500",
        "boxV;": "\u2551",
        "boxv;": "\u2502",
        "Bscr;": "\u212C",
        "bscr;": "\u{1D4B7}",
        "bsim;": "\u223D",
        "bsol;": "\\",
        "bull;": "\u2022",
        "bump;": "\u224E",
        "caps;": "\u2229\uFE00",
        "Cdot;": "\u010A",
        "cdot;": "\u010B",
        cedil: "\xB8",
        "cent;": "\xA2",
        "CHcy;": "\u0427",
        "chcy;": "\u0447",
        "circ;": "\u02C6",
        "cirE;": "\u29C3",
        "cire;": "\u2257",
        "comp;": "\u2201",
        "cong;": "\u2245",
        "Copf;": "\u2102",
        "copf;": "\u{1D554}",
        "COPY;": "\xA9",
        "copy;": "\xA9",
        "Cscr;": "\u{1D49E}",
        "cscr;": "\u{1D4B8}",
        "csub;": "\u2ACF",
        "csup;": "\u2AD0",
        "cups;": "\u222A\uFE00",
        "Darr;": "\u21A1",
        "dArr;": "\u21D3",
        "darr;": "\u2193",
        "dash;": "\u2010",
        "dHar;": "\u2965",
        "diam;": "\u22C4",
        "DJcy;": "\u0402",
        "djcy;": "\u0452",
        "Dopf;": "\u{1D53B}",
        "dopf;": "\u{1D555}",
        "Dscr;": "\u{1D49F}",
        "dscr;": "\u{1D4B9}",
        "DScy;": "\u0405",
        "dscy;": "\u0455",
        "dsol;": "\u29F6",
        "dtri;": "\u25BF",
        "DZcy;": "\u040F",
        "dzcy;": "\u045F",
        "ecir;": "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        "Edot;": "\u0116",
        "eDot;": "\u2251",
        "edot;": "\u0117",
        "emsp;": "\u2003",
        "ensp;": "\u2002",
        "Eopf;": "\u{1D53C}",
        "eopf;": "\u{1D556}",
        "epar;": "\u22D5",
        "epsi;": "\u03B5",
        "Escr;": "\u2130",
        "escr;": "\u212F",
        "Esim;": "\u2A73",
        "esim;": "\u2242",
        "Euml;": "\xCB",
        "euml;": "\xEB",
        "euro;": "\u20AC",
        "excl;": "!",
        "flat;": "\u266D",
        "fnof;": "\u0192",
        "Fopf;": "\u{1D53D}",
        "fopf;": "\u{1D557}",
        "fork;": "\u22D4",
        "Fscr;": "\u2131",
        "fscr;": "\u{1D4BB}",
        "Gdot;": "\u0120",
        "gdot;": "\u0121",
        "geqq;": "\u2267",
        "gesl;": "\u22DB\uFE00",
        "GJcy;": "\u0403",
        "gjcy;": "\u0453",
        "gnap;": "\u2A8A",
        "gneq;": "\u2A88",
        "Gopf;": "\u{1D53E}",
        "gopf;": "\u{1D558}",
        "Gscr;": "\u{1D4A2}",
        "gscr;": "\u210A",
        "gsim;": "\u2273",
        "gtcc;": "\u2AA7",
        "gvnE;": "\u2269\uFE00",
        "half;": "\xBD",
        "hArr;": "\u21D4",
        "harr;": "\u2194",
        "hbar;": "\u210F",
        "Hopf;": "\u210D",
        "hopf;": "\u{1D559}",
        "Hscr;": "\u210B",
        "hscr;": "\u{1D4BD}",
        Icirc: "\xCE",
        icirc: "\xEE",
        "Idot;": "\u0130",
        "IEcy;": "\u0415",
        "iecy;": "\u0435",
        iexcl: "\xA1",
        "imof;": "\u22B7",
        "IOcy;": "\u0401",
        "iocy;": "\u0451",
        "Iopf;": "\u{1D540}",
        "iopf;": "\u{1D55A}",
        "Iota;": "\u0399",
        "iota;": "\u03B9",
        "Iscr;": "\u2110",
        "iscr;": "\u{1D4BE}",
        "isin;": "\u2208",
        "Iuml;": "\xCF",
        "iuml;": "\xEF",
        "Jopf;": "\u{1D541}",
        "jopf;": "\u{1D55B}",
        "Jscr;": "\u{1D4A5}",
        "jscr;": "\u{1D4BF}",
        "KHcy;": "\u0425",
        "khcy;": "\u0445",
        "KJcy;": "\u040C",
        "kjcy;": "\u045C",
        "Kopf;": "\u{1D542}",
        "kopf;": "\u{1D55C}",
        "Kscr;": "\u{1D4A6}",
        "kscr;": "\u{1D4C0}",
        "Lang;": "\u27EA",
        "lang;": "\u27E8",
        laquo: "\xAB",
        "Larr;": "\u219E",
        "lArr;": "\u21D0",
        "larr;": "\u2190",
        "late;": "\u2AAD",
        "lcub;": "{",
        "ldca;": "\u2936",
        "ldsh;": "\u21B2",
        "leqq;": "\u2266",
        "lesg;": "\u22DA\uFE00",
        "lHar;": "\u2962",
        "LJcy;": "\u0409",
        "ljcy;": "\u0459",
        "lnap;": "\u2A89",
        "lneq;": "\u2A87",
        "Lopf;": "\u{1D543}",
        "lopf;": "\u{1D55D}",
        "lozf;": "\u29EB",
        "lpar;": "(",
        "Lscr;": "\u2112",
        "lscr;": "\u{1D4C1}",
        "lsim;": "\u2272",
        "lsqb;": "[",
        "ltcc;": "\u2AA6",
        "ltri;": "\u25C3",
        "lvnE;": "\u2268\uFE00",
        "macr;": "\xAF",
        "male;": "\u2642",
        "malt;": "\u2720",
        micro: "\xB5",
        "mlcp;": "\u2ADB",
        "mldr;": "\u2026",
        "Mopf;": "\u{1D544}",
        "mopf;": "\u{1D55E}",
        "Mscr;": "\u2133",
        "mscr;": "\u{1D4C2}",
        "nang;": "\u2220\u20D2",
        "napE;": "\u2A70\u0338",
        "nbsp;": "\xA0",
        "ncap;": "\u2A43",
        "ncup;": "\u2A42",
        "ngeq;": "\u2271",
        "nges;": "\u2A7E\u0338",
        "ngtr;": "\u226F",
        "nGtv;": "\u226B\u0338",
        "nisd;": "\u22FA",
        "NJcy;": "\u040A",
        "njcy;": "\u045A",
        "nldr;": "\u2025",
        "nleq;": "\u2270",
        "nles;": "\u2A7D\u0338",
        "nLtv;": "\u226A\u0338",
        "nmid;": "\u2224",
        "Nopf;": "\u2115",
        "nopf;": "\u{1D55F}",
        "npar;": "\u2226",
        "npre;": "\u2AAF\u0338",
        "nsce;": "\u2AB0\u0338",
        "Nscr;": "\u{1D4A9}",
        "nscr;": "\u{1D4C3}",
        "nsim;": "\u2241",
        "nsub;": "\u2284",
        "nsup;": "\u2285",
        "ntgl;": "\u2279",
        "ntlg;": "\u2278",
        "nvap;": "\u224D\u20D2",
        "nvge;": "\u2265\u20D2",
        "nvgt;": ">\u20D2",
        "nvle;": "\u2264\u20D2",
        "nvlt;": "<\u20D2",
        "oast;": "\u229B",
        "ocir;": "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        "odiv;": "\u2A38",
        "odot;": "\u2299",
        "ogon;": "\u02DB",
        "oint;": "\u222E",
        "omid;": "\u29B6",
        "Oopf;": "\u{1D546}",
        "oopf;": "\u{1D560}",
        "opar;": "\u29B7",
        "ordf;": "\xAA",
        "ordm;": "\xBA",
        "oror;": "\u2A56",
        "Oscr;": "\u{1D4AA}",
        "oscr;": "\u2134",
        "osol;": "\u2298",
        "Ouml;": "\xD6",
        "ouml;": "\xF6",
        "para;": "\xB6",
        "part;": "\u2202",
        "perp;": "\u22A5",
        "phiv;": "\u03D5",
        "plus;": "+",
        "Popf;": "\u2119",
        "popf;": "\u{1D561}",
        pound: "\xA3",
        "prap;": "\u2AB7",
        "prec;": "\u227A",
        "prnE;": "\u2AB5",
        "prod;": "\u220F",
        "prop;": "\u221D",
        "Pscr;": "\u{1D4AB}",
        "pscr;": "\u{1D4C5}",
        "qint;": "\u2A0C",
        "Qopf;": "\u211A",
        "qopf;": "\u{1D562}",
        "Qscr;": "\u{1D4AC}",
        "qscr;": "\u{1D4C6}",
        "QUOT;": '"',
        "quot;": '"',
        "race;": "\u223D\u0331",
        "Rang;": "\u27EB",
        "rang;": "\u27E9",
        raquo: "\xBB",
        "Rarr;": "\u21A0",
        "rArr;": "\u21D2",
        "rarr;": "\u2192",
        "rcub;": "}",
        "rdca;": "\u2937",
        "rdsh;": "\u21B3",
        "real;": "\u211C",
        "rect;": "\u25AD",
        "rHar;": "\u2964",
        "rhov;": "\u03F1",
        "ring;": "\u02DA",
        "Ropf;": "\u211D",
        "ropf;": "\u{1D563}",
        "rpar;": ")",
        "Rscr;": "\u211B",
        "rscr;": "\u{1D4C7}",
        "rsqb;": "]",
        "rtri;": "\u25B9",
        "scap;": "\u2AB8",
        "scnE;": "\u2AB6",
        "sdot;": "\u22C5",
        "sect;": "\xA7",
        "semi;": ";",
        "sext;": "\u2736",
        "SHcy;": "\u0428",
        "shcy;": "\u0448",
        "sime;": "\u2243",
        "simg;": "\u2A9E",
        "siml;": "\u2A9D",
        "smid;": "\u2223",
        "smte;": "\u2AAC",
        "solb;": "\u29C4",
        "Sopf;": "\u{1D54A}",
        "sopf;": "\u{1D564}",
        "spar;": "\u2225",
        "Sqrt;": "\u221A",
        "squf;": "\u25AA",
        "Sscr;": "\u{1D4AE}",
        "sscr;": "\u{1D4C8}",
        "Star;": "\u22C6",
        "star;": "\u2606",
        "subE;": "\u2AC5",
        "sube;": "\u2286",
        "succ;": "\u227B",
        "sung;": "\u266A",
        "sup1;": "\xB9",
        "sup2;": "\xB2",
        "sup3;": "\xB3",
        "supE;": "\u2AC6",
        "supe;": "\u2287",
        szlig: "\xDF",
        "tbrk;": "\u23B4",
        "tdot;": "\u20DB",
        THORN: "\xDE",
        thorn: "\xFE",
        times: "\xD7",
        "tint;": "\u222D",
        "toea;": "\u2928",
        "Topf;": "\u{1D54B}",
        "topf;": "\u{1D565}",
        "tosa;": "\u2929",
        "trie;": "\u225C",
        "Tscr;": "\u{1D4AF}",
        "tscr;": "\u{1D4C9}",
        "TScy;": "\u0426",
        "tscy;": "\u0446",
        "Uarr;": "\u219F",
        "uArr;": "\u21D1",
        "uarr;": "\u2191",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        "uHar;": "\u2963",
        "Uopf;": "\u{1D54C}",
        "uopf;": "\u{1D566}",
        "Upsi;": "\u03D2",
        "upsi;": "\u03C5",
        "Uscr;": "\u{1D4B0}",
        "uscr;": "\u{1D4CA}",
        "utri;": "\u25B5",
        "Uuml;": "\xDC",
        "uuml;": "\xFC",
        "vArr;": "\u21D5",
        "varr;": "\u2195",
        "Vbar;": "\u2AEB",
        "vBar;": "\u2AE8",
        "Vert;": "\u2016",
        "vert;": "|",
        "Vopf;": "\u{1D54D}",
        "vopf;": "\u{1D567}",
        "Vscr;": "\u{1D4B1}",
        "vscr;": "\u{1D4CB}",
        "Wopf;": "\u{1D54E}",
        "wopf;": "\u{1D568}",
        "Wscr;": "\u{1D4B2}",
        "wscr;": "\u{1D4CC}",
        "xcap;": "\u22C2",
        "xcup;": "\u22C3",
        "xmap;": "\u27FC",
        "xnis;": "\u22FB",
        "Xopf;": "\u{1D54F}",
        "xopf;": "\u{1D569}",
        "Xscr;": "\u{1D4B3}",
        "xscr;": "\u{1D4CD}",
        "xvee;": "\u22C1",
        "YAcy;": "\u042F",
        "yacy;": "\u044F",
        "YIcy;": "\u0407",
        "yicy;": "\u0457",
        "Yopf;": "\u{1D550}",
        "yopf;": "\u{1D56A}",
        "Yscr;": "\u{1D4B4}",
        "yscr;": "\u{1D4CE}",
        "YUcy;": "\u042E",
        "yucy;": "\u044E",
        "Yuml;": "\u0178",
        "yuml;": "\xFF",
        "Zdot;": "\u017B",
        "zdot;": "\u017C",
        "Zeta;": "\u0396",
        "zeta;": "\u03B6",
        "ZHcy;": "\u0416",
        "zhcy;": "\u0436",
        "Zopf;": "\u2124",
        "zopf;": "\u{1D56B}",
        "Zscr;": "\u{1D4B5}",
        "zscr;": "\u{1D4CF}",
        "zwnj;": "\u200C",
        Aacute: "\xC1",
        aacute: "\xE1",
        "Acirc;": "\xC2",
        "acirc;": "\xE2",
        "acute;": "\xB4",
        "AElig;": "\xC6",
        "aelig;": "\xE6",
        Agrave: "\xC0",
        agrave: "\xE0",
        "aleph;": "\u2135",
        "Alpha;": "\u0391",
        "alpha;": "\u03B1",
        "Amacr;": "\u0100",
        "amacr;": "\u0101",
        "amalg;": "\u2A3F",
        "angle;": "\u2220",
        "angrt;": "\u221F",
        "angst;": "\xC5",
        "Aogon;": "\u0104",
        "aogon;": "\u0105",
        "Aring;": "\xC5",
        "aring;": "\xE5",
        "asymp;": "\u2248",
        Atilde: "\xC3",
        atilde: "\xE3",
        "awint;": "\u2A11",
        "bcong;": "\u224C",
        "bdquo;": "\u201E",
        "bepsi;": "\u03F6",
        "blank;": "\u2423",
        "blk12;": "\u2592",
        "blk14;": "\u2591",
        "blk34;": "\u2593",
        "block;": "\u2588",
        "boxDL;": "\u2557",
        "boxDl;": "\u2556",
        "boxdL;": "\u2555",
        "boxdl;": "\u2510",
        "boxDR;": "\u2554",
        "boxDr;": "\u2553",
        "boxdR;": "\u2552",
        "boxdr;": "\u250C",
        "boxHD;": "\u2566",
        "boxHd;": "\u2564",
        "boxhD;": "\u2565",
        "boxhd;": "\u252C",
        "boxHU;": "\u2569",
        "boxHu;": "\u2567",
        "boxhU;": "\u2568",
        "boxhu;": "\u2534",
        "boxUL;": "\u255D",
        "boxUl;": "\u255C",
        "boxuL;": "\u255B",
        "boxul;": "\u2518",
        "boxUR;": "\u255A",
        "boxUr;": "\u2559",
        "boxuR;": "\u2558",
        "boxur;": "\u2514",
        "boxVH;": "\u256C",
        "boxVh;": "\u256B",
        "boxvH;": "\u256A",
        "boxvh;": "\u253C",
        "boxVL;": "\u2563",
        "boxVl;": "\u2562",
        "boxvL;": "\u2561",
        "boxvl;": "\u2524",
        "boxVR;": "\u2560",
        "boxVr;": "\u255F",
        "boxvR;": "\u255E",
        "boxvr;": "\u251C",
        "Breve;": "\u02D8",
        "breve;": "\u02D8",
        brvbar: "\xA6",
        "bsemi;": "\u204F",
        "bsime;": "\u22CD",
        "bsolb;": "\u29C5",
        "bumpE;": "\u2AAE",
        "bumpe;": "\u224F",
        "caret;": "\u2041",
        "caron;": "\u02C7",
        "ccaps;": "\u2A4D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        "Ccirc;": "\u0108",
        "ccirc;": "\u0109",
        "ccups;": "\u2A4C",
        "cedil;": "\xB8",
        "check;": "\u2713",
        "clubs;": "\u2663",
        "Colon;": "\u2237",
        "colon;": ":",
        "comma;": ",",
        "crarr;": "\u21B5",
        "Cross;": "\u2A2F",
        "cross;": "\u2717",
        "csube;": "\u2AD1",
        "csupe;": "\u2AD2",
        "ctdot;": "\u22EF",
        "cuepr;": "\u22DE",
        "cuesc;": "\u22DF",
        "cupor;": "\u2A45",
        curren: "\xA4",
        "cuvee;": "\u22CE",
        "cuwed;": "\u22CF",
        "cwint;": "\u2231",
        "Dashv;": "\u2AE4",
        "dashv;": "\u22A3",
        "dblac;": "\u02DD",
        "ddarr;": "\u21CA",
        "Delta;": "\u0394",
        "delta;": "\u03B4",
        "dharl;": "\u21C3",
        "dharr;": "\u21C2",
        "diams;": "\u2666",
        "disin;": "\u22F2",
        divide: "\xF7",
        "doteq;": "\u2250",
        "dtdot;": "\u22F1",
        "dtrif;": "\u25BE",
        "duarr;": "\u21F5",
        "duhar;": "\u296F",
        Eacute: "\xC9",
        eacute: "\xE9",
        "Ecirc;": "\xCA",
        "ecirc;": "\xEA",
        "eDDot;": "\u2A77",
        "efDot;": "\u2252",
        Egrave: "\xC8",
        egrave: "\xE8",
        "Emacr;": "\u0112",
        "emacr;": "\u0113",
        "empty;": "\u2205",
        "Eogon;": "\u0118",
        "eogon;": "\u0119",
        "eplus;": "\u2A71",
        "epsiv;": "\u03F5",
        "eqsim;": "\u2242",
        "Equal;": "\u2A75",
        "equiv;": "\u2261",
        "erarr;": "\u2971",
        "erDot;": "\u2253",
        "esdot;": "\u2250",
        "exist;": "\u2203",
        "fflig;": "\uFB00",
        "filig;": "\uFB01",
        "fjlig;": "fj",
        "fllig;": "\uFB02",
        "fltns;": "\u25B1",
        "forkv;": "\u2AD9",
        frac12: "\xBD",
        frac14: "\xBC",
        frac34: "\xBE",
        "frasl;": "\u2044",
        "frown;": "\u2322",
        "Gamma;": "\u0393",
        "gamma;": "\u03B3",
        "Gcirc;": "\u011C",
        "gcirc;": "\u011D",
        "gescc;": "\u2AA9",
        "gimel;": "\u2137",
        "gneqq;": "\u2269",
        "gnsim;": "\u22E7",
        "grave;": "`",
        "gsime;": "\u2A8E",
        "gsiml;": "\u2A90",
        "gtcir;": "\u2A7A",
        "gtdot;": "\u22D7",
        "Hacek;": "\u02C7",
        "harrw;": "\u21AD",
        "Hcirc;": "\u0124",
        "hcirc;": "\u0125",
        "hoarr;": "\u21FF",
        Iacute: "\xCD",
        iacute: "\xED",
        "Icirc;": "\xCE",
        "icirc;": "\xEE",
        "iexcl;": "\xA1",
        Igrave: "\xCC",
        igrave: "\xEC",
        "iiint;": "\u222D",
        "iiota;": "\u2129",
        "IJlig;": "\u0132",
        "ijlig;": "\u0133",
        "Imacr;": "\u012A",
        "imacr;": "\u012B",
        "image;": "\u2111",
        "imath;": "\u0131",
        "imped;": "\u01B5",
        "infin;": "\u221E",
        "Iogon;": "\u012E",
        "iogon;": "\u012F",
        "iprod;": "\u2A3C",
        iquest: "\xBF",
        "isinE;": "\u22F9",
        "isins;": "\u22F4",
        "isinv;": "\u2208",
        "Iukcy;": "\u0406",
        "iukcy;": "\u0456",
        "Jcirc;": "\u0134",
        "jcirc;": "\u0135",
        "jmath;": "\u0237",
        "Jukcy;": "\u0404",
        "jukcy;": "\u0454",
        "Kappa;": "\u039A",
        "kappa;": "\u03BA",
        "lAarr;": "\u21DA",
        "langd;": "\u2991",
        "laquo;": "\xAB",
        "larrb;": "\u21E4",
        "lates;": "\u2AAD\uFE00",
        "lBarr;": "\u290E",
        "lbarr;": "\u290C",
        "lbbrk;": "\u2772",
        "lbrke;": "\u298B",
        "lceil;": "\u2308",
        "ldquo;": "\u201C",
        "lescc;": "\u2AA8",
        "lhard;": "\u21BD",
        "lharu;": "\u21BC",
        "lhblk;": "\u2584",
        "llarr;": "\u21C7",
        "lltri;": "\u25FA",
        "lneqq;": "\u2268",
        "lnsim;": "\u22E6",
        "loang;": "\u27EC",
        "loarr;": "\u21FD",
        "lobrk;": "\u27E6",
        "lopar;": "\u2985",
        "lrarr;": "\u21C6",
        "lrhar;": "\u21CB",
        "lrtri;": "\u22BF",
        "lsime;": "\u2A8D",
        "lsimg;": "\u2A8F",
        "lsquo;": "\u2018",
        "ltcir;": "\u2A79",
        "ltdot;": "\u22D6",
        "ltrie;": "\u22B4",
        "ltrif;": "\u25C2",
        "mdash;": "\u2014",
        "mDDot;": "\u223A",
        "micro;": "\xB5",
        middot: "\xB7",
        "minus;": "\u2212",
        "mumap;": "\u22B8",
        "nabla;": "\u2207",
        "napid;": "\u224B\u0338",
        "napos;": "\u0149",
        "natur;": "\u266E",
        "nbump;": "\u224E\u0338",
        "ncong;": "\u2247",
        "ndash;": "\u2013",
        "neArr;": "\u21D7",
        "nearr;": "\u2197",
        "nedot;": "\u2250\u0338",
        "nesim;": "\u2242\u0338",
        "ngeqq;": "\u2267\u0338",
        "ngsim;": "\u2275",
        "nhArr;": "\u21CE",
        "nharr;": "\u21AE",
        "nhpar;": "\u2AF2",
        "nlArr;": "\u21CD",
        "nlarr;": "\u219A",
        "nleqq;": "\u2266\u0338",
        "nless;": "\u226E",
        "nlsim;": "\u2274",
        "nltri;": "\u22EA",
        "notin;": "\u2209",
        "notni;": "\u220C",
        "npart;": "\u2202\u0338",
        "nprec;": "\u2280",
        "nrArr;": "\u21CF",
        "nrarr;": "\u219B",
        "nrtri;": "\u22EB",
        "nsime;": "\u2244",
        "nsmid;": "\u2224",
        "nspar;": "\u2226",
        "nsubE;": "\u2AC5\u0338",
        "nsube;": "\u2288",
        "nsucc;": "\u2281",
        "nsupE;": "\u2AC6\u0338",
        "nsupe;": "\u2289",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        "numsp;": "\u2007",
        "nvsim;": "\u223C\u20D2",
        "nwArr;": "\u21D6",
        "nwarr;": "\u2196",
        Oacute: "\xD3",
        oacute: "\xF3",
        "Ocirc;": "\xD4",
        "ocirc;": "\xF4",
        "odash;": "\u229D",
        "OElig;": "\u0152",
        "oelig;": "\u0153",
        "ofcir;": "\u29BF",
        Ograve: "\xD2",
        ograve: "\xF2",
        "ohbar;": "\u29B5",
        "olarr;": "\u21BA",
        "olcir;": "\u29BE",
        "oline;": "\u203E",
        "Omacr;": "\u014C",
        "omacr;": "\u014D",
        "Omega;": "\u03A9",
        "omega;": "\u03C9",
        "operp;": "\u29B9",
        "oplus;": "\u2295",
        "orarr;": "\u21BB",
        "order;": "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        Otilde: "\xD5",
        otilde: "\xF5",
        "ovbar;": "\u233D",
        "parsl;": "\u2AFD",
        "phone;": "\u260E",
        "plusb;": "\u229E",
        "pluse;": "\u2A72",
        plusmn: "\xB1",
        "pound;": "\xA3",
        "prcue;": "\u227C",
        "Prime;": "\u2033",
        "prime;": "\u2032",
        "prnap;": "\u2AB9",
        "prsim;": "\u227E",
        "quest;": "?",
        "rAarr;": "\u21DB",
        "radic;": "\u221A",
        "rangd;": "\u2992",
        "range;": "\u29A5",
        "raquo;": "\xBB",
        "rarrb;": "\u21E5",
        "rarrc;": "\u2933",
        "rarrw;": "\u219D",
        "ratio;": "\u2236",
        "RBarr;": "\u2910",
        "rBarr;": "\u290F",
        "rbarr;": "\u290D",
        "rbbrk;": "\u2773",
        "rbrke;": "\u298C",
        "rceil;": "\u2309",
        "rdquo;": "\u201D",
        "reals;": "\u211D",
        "rhard;": "\u21C1",
        "rharu;": "\u21C0",
        "rlarr;": "\u21C4",
        "rlhar;": "\u21CC",
        "rnmid;": "\u2AEE",
        "roang;": "\u27ED",
        "roarr;": "\u21FE",
        "robrk;": "\u27E7",
        "ropar;": "\u2986",
        "rrarr;": "\u21C9",
        "rsquo;": "\u2019",
        "rtrie;": "\u22B5",
        "rtrif;": "\u25B8",
        "sbquo;": "\u201A",
        "sccue;": "\u227D",
        "Scirc;": "\u015C",
        "scirc;": "\u015D",
        "scnap;": "\u2ABA",
        "scsim;": "\u227F",
        "sdotb;": "\u22A1",
        "sdote;": "\u2A66",
        "seArr;": "\u21D8",
        "searr;": "\u2198",
        "setmn;": "\u2216",
        "sharp;": "\u266F",
        "Sigma;": "\u03A3",
        "sigma;": "\u03C3",
        "simeq;": "\u2243",
        "simgE;": "\u2AA0",
        "simlE;": "\u2A9F",
        "simne;": "\u2246",
        "slarr;": "\u2190",
        "smile;": "\u2323",
        "smtes;": "\u2AAC\uFE00",
        "sqcap;": "\u2293",
        "sqcup;": "\u2294",
        "sqsub;": "\u228F",
        "sqsup;": "\u2290",
        "srarr;": "\u2192",
        "starf;": "\u2605",
        "strns;": "\xAF",
        "subnE;": "\u2ACB",
        "subne;": "\u228A",
        "supnE;": "\u2ACC",
        "supne;": "\u228B",
        "swArr;": "\u21D9",
        "swarr;": "\u2199",
        "szlig;": "\xDF",
        "Theta;": "\u0398",
        "theta;": "\u03B8",
        "thkap;": "\u2248",
        "THORN;": "\xDE",
        "thorn;": "\xFE",
        "Tilde;": "\u223C",
        "tilde;": "\u02DC",
        "times;": "\xD7",
        "TRADE;": "\u2122",
        "trade;": "\u2122",
        "trisb;": "\u29CD",
        "TSHcy;": "\u040B",
        "tshcy;": "\u045B",
        "twixt;": "\u226C",
        Uacute: "\xDA",
        uacute: "\xFA",
        "Ubrcy;": "\u040E",
        "ubrcy;": "\u045E",
        "Ucirc;": "\xDB",
        "ucirc;": "\xFB",
        "udarr;": "\u21C5",
        "udhar;": "\u296E",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        "uharl;": "\u21BF",
        "uharr;": "\u21BE",
        "uhblk;": "\u2580",
        "ultri;": "\u25F8",
        "Umacr;": "\u016A",
        "umacr;": "\u016B",
        "Union;": "\u22C3",
        "Uogon;": "\u0172",
        "uogon;": "\u0173",
        "uplus;": "\u228E",
        "upsih;": "\u03D2",
        "UpTee;": "\u22A5",
        "Uring;": "\u016E",
        "uring;": "\u016F",
        "urtri;": "\u25F9",
        "utdot;": "\u22F0",
        "utrif;": "\u25B4",
        "uuarr;": "\u21C8",
        "varpi;": "\u03D6",
        "vBarv;": "\u2AE9",
        "VDash;": "\u22AB",
        "Vdash;": "\u22A9",
        "vDash;": "\u22A8",
        "vdash;": "\u22A2",
        "veeeq;": "\u225A",
        "vltri;": "\u22B2",
        "vnsub;": "\u2282\u20D2",
        "vnsup;": "\u2283\u20D2",
        "vprop;": "\u221D",
        "vrtri;": "\u22B3",
        "Wcirc;": "\u0174",
        "wcirc;": "\u0175",
        "Wedge;": "\u22C0",
        "wedge;": "\u2227",
        "xcirc;": "\u25EF",
        "xdtri;": "\u25BD",
        "xhArr;": "\u27FA",
        "xharr;": "\u27F7",
        "xlArr;": "\u27F8",
        "xlarr;": "\u27F5",
        "xodot;": "\u2A00",
        "xrArr;": "\u27F9",
        "xrarr;": "\u27F6",
        "xutri;": "\u25B3",
        Yacute: "\xDD",
        yacute: "\xFD",
        "Ycirc;": "\u0176",
        "ycirc;": "\u0177",
        "Aacute;": "\xC1",
        "aacute;": "\xE1",
        "Abreve;": "\u0102",
        "abreve;": "\u0103",
        "Agrave;": "\xC0",
        "agrave;": "\xE0",
        "andand;": "\u2A55",
        "angmsd;": "\u2221",
        "angsph;": "\u2222",
        "apacir;": "\u2A6F",
        "approx;": "\u2248",
        "Assign;": "\u2254",
        "Atilde;": "\xC3",
        "atilde;": "\xE3",
        "barvee;": "\u22BD",
        "Barwed;": "\u2306",
        "barwed;": "\u2305",
        "becaus;": "\u2235",
        "bernou;": "\u212C",
        "bigcap;": "\u22C2",
        "bigcup;": "\u22C3",
        "bigvee;": "\u22C1",
        "bkarow;": "\u290D",
        "bottom;": "\u22A5",
        "bowtie;": "\u22C8",
        "boxbox;": "\u29C9",
        "bprime;": "\u2035",
        "brvbar;": "\xA6",
        "bullet;": "\u2022",
        "Bumpeq;": "\u224E",
        "bumpeq;": "\u224F",
        "Cacute;": "\u0106",
        "cacute;": "\u0107",
        "capand;": "\u2A44",
        "capcap;": "\u2A4B",
        "capcup;": "\u2A47",
        "capdot;": "\u2A40",
        "Ccaron;": "\u010C",
        "ccaron;": "\u010D",
        "Ccedil;": "\xC7",
        "ccedil;": "\xE7",
        "circeq;": "\u2257",
        "cirmid;": "\u2AEF",
        "Colone;": "\u2A74",
        "colone;": "\u2254",
        "commat;": "@",
        "compfn;": "\u2218",
        "Conint;": "\u222F",
        "conint;": "\u222E",
        "coprod;": "\u2210",
        "copysr;": "\u2117",
        "cularr;": "\u21B6",
        "CupCap;": "\u224D",
        "cupcap;": "\u2A46",
        "cupcup;": "\u2A4A",
        "cupdot;": "\u228D",
        "curarr;": "\u21B7",
        "curren;": "\xA4",
        "cylcty;": "\u232D",
        "Dagger;": "\u2021",
        "dagger;": "\u2020",
        "daleth;": "\u2138",
        "Dcaron;": "\u010E",
        "dcaron;": "\u010F",
        "dfisht;": "\u297F",
        "divide;": "\xF7",
        "divonx;": "\u22C7",
        "dlcorn;": "\u231E",
        "dlcrop;": "\u230D",
        "dollar;": "$",
        "DotDot;": "\u20DC",
        "drcorn;": "\u231F",
        "drcrop;": "\u230C",
        "Dstrok;": "\u0110",
        "dstrok;": "\u0111",
        "Eacute;": "\xC9",
        "eacute;": "\xE9",
        "easter;": "\u2A6E",
        "Ecaron;": "\u011A",
        "ecaron;": "\u011B",
        "ecolon;": "\u2255",
        "Egrave;": "\xC8",
        "egrave;": "\xE8",
        "egsdot;": "\u2A98",
        "elsdot;": "\u2A97",
        "emptyv;": "\u2205",
        "emsp13;": "\u2004",
        "emsp14;": "\u2005",
        "eparsl;": "\u29E3",
        "eqcirc;": "\u2256",
        "equals;": "=",
        "equest;": "\u225F",
        "Exists;": "\u2203",
        "female;": "\u2640",
        "ffilig;": "\uFB03",
        "ffllig;": "\uFB04",
        "ForAll;": "\u2200",
        "forall;": "\u2200",
        "frac12;": "\xBD",
        "frac13;": "\u2153",
        "frac14;": "\xBC",
        "frac15;": "\u2155",
        "frac16;": "\u2159",
        "frac18;": "\u215B",
        "frac23;": "\u2154",
        "frac25;": "\u2156",
        "frac34;": "\xBE",
        "frac35;": "\u2157",
        "frac38;": "\u215C",
        "frac45;": "\u2158",
        "frac56;": "\u215A",
        "frac58;": "\u215D",
        "frac78;": "\u215E",
        "gacute;": "\u01F5",
        "Gammad;": "\u03DC",
        "gammad;": "\u03DD",
        "Gbreve;": "\u011E",
        "gbreve;": "\u011F",
        "Gcedil;": "\u0122",
        "gesdot;": "\u2A80",
        "gesles;": "\u2A94",
        "gtlPar;": "\u2995",
        "gtrarr;": "\u2978",
        "gtrdot;": "\u22D7",
        "gtrsim;": "\u2273",
        "hairsp;": "\u200A",
        "hamilt;": "\u210B",
        "HARDcy;": "\u042A",
        "hardcy;": "\u044A",
        "hearts;": "\u2665",
        "hellip;": "\u2026",
        "hercon;": "\u22B9",
        "homtht;": "\u223B",
        "horbar;": "\u2015",
        "hslash;": "\u210F",
        "Hstrok;": "\u0126",
        "hstrok;": "\u0127",
        "hybull;": "\u2043",
        "hyphen;": "\u2010",
        "Iacute;": "\xCD",
        "iacute;": "\xED",
        "Igrave;": "\xCC",
        "igrave;": "\xEC",
        "iiiint;": "\u2A0C",
        "iinfin;": "\u29DC",
        "incare;": "\u2105",
        "inodot;": "\u0131",
        "intcal;": "\u22BA",
        "iquest;": "\xBF",
        "isinsv;": "\u22F3",
        "Itilde;": "\u0128",
        "itilde;": "\u0129",
        "Jsercy;": "\u0408",
        "jsercy;": "\u0458",
        "kappav;": "\u03F0",
        "Kcedil;": "\u0136",
        "kcedil;": "\u0137",
        "kgreen;": "\u0138",
        "Lacute;": "\u0139",
        "lacute;": "\u013A",
        "lagran;": "\u2112",
        "Lambda;": "\u039B",
        "lambda;": "\u03BB",
        "langle;": "\u27E8",
        "larrfs;": "\u291D",
        "larrhk;": "\u21A9",
        "larrlp;": "\u21AB",
        "larrpl;": "\u2939",
        "larrtl;": "\u21A2",
        "lAtail;": "\u291B",
        "latail;": "\u2919",
        "lbrace;": "{",
        "lbrack;": "[",
        "Lcaron;": "\u013D",
        "lcaron;": "\u013E",
        "Lcedil;": "\u013B",
        "lcedil;": "\u013C",
        "ldquor;": "\u201E",
        "lesdot;": "\u2A7F",
        "lesges;": "\u2A93",
        "lfisht;": "\u297C",
        "lfloor;": "\u230A",
        "lharul;": "\u296A",
        "llhard;": "\u296B",
        "Lmidot;": "\u013F",
        "lmidot;": "\u0140",
        "lmoust;": "\u23B0",
        "loplus;": "\u2A2D",
        "lowast;": "\u2217",
        "lowbar;": "_",
        "lparlt;": "\u2993",
        "lrhard;": "\u296D",
        "lsaquo;": "\u2039",
        "lsquor;": "\u201A",
        "Lstrok;": "\u0141",
        "lstrok;": "\u0142",
        "lthree;": "\u22CB",
        "ltimes;": "\u22C9",
        "ltlarr;": "\u2976",
        "ltrPar;": "\u2996",
        "mapsto;": "\u21A6",
        "marker;": "\u25AE",
        "mcomma;": "\u2A29",
        "midast;": "*",
        "midcir;": "\u2AF0",
        "middot;": "\xB7",
        "minusb;": "\u229F",
        "minusd;": "\u2238",
        "mnplus;": "\u2213",
        "models;": "\u22A7",
        "mstpos;": "\u223E",
        "Nacute;": "\u0143",
        "nacute;": "\u0144",
        "nbumpe;": "\u224F\u0338",
        "Ncaron;": "\u0147",
        "ncaron;": "\u0148",
        "Ncedil;": "\u0145",
        "ncedil;": "\u0146",
        "nearhk;": "\u2924",
        "nequiv;": "\u2262",
        "nesear;": "\u2928",
        "nexist;": "\u2204",
        "nltrie;": "\u22EC",
        "notinE;": "\u22F9\u0338",
        "nparsl;": "\u2AFD\u20E5",
        "nprcue;": "\u22E0",
        "nrarrc;": "\u2933\u0338",
        "nrarrw;": "\u219D\u0338",
        "nrtrie;": "\u22ED",
        "nsccue;": "\u22E1",
        "nsimeq;": "\u2244",
        "Ntilde;": "\xD1",
        "ntilde;": "\xF1",
        "numero;": "\u2116",
        "nVDash;": "\u22AF",
        "nVdash;": "\u22AE",
        "nvDash;": "\u22AD",
        "nvdash;": "\u22AC",
        "nvHarr;": "\u2904",
        "nvlArr;": "\u2902",
        "nvrArr;": "\u2903",
        "nwarhk;": "\u2923",
        "nwnear;": "\u2927",
        "Oacute;": "\xD3",
        "oacute;": "\xF3",
        "Odblac;": "\u0150",
        "odblac;": "\u0151",
        "odsold;": "\u29BC",
        "Ograve;": "\xD2",
        "ograve;": "\xF2",
        "ominus;": "\u2296",
        "origof;": "\u22B6",
        "Oslash;": "\xD8",
        "oslash;": "\xF8",
        "Otilde;": "\xD5",
        "otilde;": "\xF5",
        "Otimes;": "\u2A37",
        "otimes;": "\u2297",
        "parsim;": "\u2AF3",
        "percnt;": "%",
        "period;": ".",
        "permil;": "\u2030",
        "phmmat;": "\u2133",
        "planck;": "\u210F",
        "plankv;": "\u210F",
        "plusdo;": "\u2214",
        "plusdu;": "\u2A25",
        "plusmn;": "\xB1",
        "preceq;": "\u2AAF",
        "primes;": "\u2119",
        "prnsim;": "\u22E8",
        "propto;": "\u221D",
        "prurel;": "\u22B0",
        "puncsp;": "\u2008",
        "qprime;": "\u2057",
        "Racute;": "\u0154",
        "racute;": "\u0155",
        "rangle;": "\u27E9",
        "rarrap;": "\u2975",
        "rarrfs;": "\u291E",
        "rarrhk;": "\u21AA",
        "rarrlp;": "\u21AC",
        "rarrpl;": "\u2945",
        "Rarrtl;": "\u2916",
        "rarrtl;": "\u21A3",
        "rAtail;": "\u291C",
        "ratail;": "\u291A",
        "rbrace;": "}",
        "rbrack;": "]",
        "Rcaron;": "\u0158",
        "rcaron;": "\u0159",
        "Rcedil;": "\u0156",
        "rcedil;": "\u0157",
        "rdquor;": "\u201D",
        "rfisht;": "\u297D",
        "rfloor;": "\u230B",
        "rharul;": "\u296C",
        "rmoust;": "\u23B1",
        "roplus;": "\u2A2E",
        "rpargt;": "\u2994",
        "rsaquo;": "\u203A",
        "rsquor;": "\u2019",
        "rthree;": "\u22CC",
        "rtimes;": "\u22CA",
        "Sacute;": "\u015A",
        "sacute;": "\u015B",
        "Scaron;": "\u0160",
        "scaron;": "\u0161",
        "Scedil;": "\u015E",
        "scedil;": "\u015F",
        "scnsim;": "\u22E9",
        "searhk;": "\u2925",
        "seswar;": "\u2929",
        "sfrown;": "\u2322",
        "SHCHcy;": "\u0429",
        "shchcy;": "\u0449",
        "sigmaf;": "\u03C2",
        "sigmav;": "\u03C2",
        "simdot;": "\u2A6A",
        "smashp;": "\u2A33",
        "SOFTcy;": "\u042C",
        "softcy;": "\u044C",
        "solbar;": "\u233F",
        "spades;": "\u2660",
        "sqcaps;": "\u2293\uFE00",
        "sqcups;": "\u2294\uFE00",
        "sqsube;": "\u2291",
        "sqsupe;": "\u2292",
        "Square;": "\u25A1",
        "square;": "\u25A1",
        "squarf;": "\u25AA",
        "ssetmn;": "\u2216",
        "ssmile;": "\u2323",
        "sstarf;": "\u22C6",
        "subdot;": "\u2ABD",
        "Subset;": "\u22D0",
        "subset;": "\u2282",
        "subsim;": "\u2AC7",
        "subsub;": "\u2AD5",
        "subsup;": "\u2AD3",
        "succeq;": "\u2AB0",
        "supdot;": "\u2ABE",
        "Supset;": "\u22D1",
        "supset;": "\u2283",
        "supsim;": "\u2AC8",
        "supsub;": "\u2AD4",
        "supsup;": "\u2AD6",
        "swarhk;": "\u2926",
        "swnwar;": "\u292A",
        "target;": "\u2316",
        "Tcaron;": "\u0164",
        "tcaron;": "\u0165",
        "Tcedil;": "\u0162",
        "tcedil;": "\u0163",
        "telrec;": "\u2315",
        "there4;": "\u2234",
        "thetav;": "\u03D1",
        "thinsp;": "\u2009",
        "thksim;": "\u223C",
        "timesb;": "\u22A0",
        "timesd;": "\u2A30",
        "topbot;": "\u2336",
        "topcir;": "\u2AF1",
        "tprime;": "\u2034",
        "tridot;": "\u25EC",
        "Tstrok;": "\u0166",
        "tstrok;": "\u0167",
        "Uacute;": "\xDA",
        "uacute;": "\xFA",
        "Ubreve;": "\u016C",
        "ubreve;": "\u016D",
        "Udblac;": "\u0170",
        "udblac;": "\u0171",
        "ufisht;": "\u297E",
        "Ugrave;": "\xD9",
        "ugrave;": "\xF9",
        "ulcorn;": "\u231C",
        "ulcrop;": "\u230F",
        "urcorn;": "\u231D",
        "urcrop;": "\u230E",
        "Utilde;": "\u0168",
        "utilde;": "\u0169",
        "vangrt;": "\u299C",
        "varphi;": "\u03D5",
        "varrho;": "\u03F1",
        "Vdashl;": "\u2AE6",
        "veebar;": "\u22BB",
        "vellip;": "\u22EE",
        "Verbar;": "\u2016",
        "verbar;": "|",
        "vsubnE;": "\u2ACB\uFE00",
        "vsubne;": "\u228A\uFE00",
        "vsupnE;": "\u2ACC\uFE00",
        "vsupne;": "\u228B\uFE00",
        "Vvdash;": "\u22AA",
        "wedbar;": "\u2A5F",
        "wedgeq;": "\u2259",
        "weierp;": "\u2118",
        "wreath;": "\u2240",
        "xoplus;": "\u2A01",
        "xotime;": "\u2A02",
        "xsqcup;": "\u2A06",
        "xuplus;": "\u2A04",
        "xwedge;": "\u22C0",
        "Yacute;": "\xDD",
        "yacute;": "\xFD",
        "Zacute;": "\u0179",
        "zacute;": "\u017A",
        "Zcaron;": "\u017D",
        "zcaron;": "\u017E",
        "zeetrf;": "\u2128",
        "alefsym;": "\u2135",
        "angrtvb;": "\u22BE",
        "angzarr;": "\u237C",
        "asympeq;": "\u224D",
        "backsim;": "\u223D",
        "Because;": "\u2235",
        "because;": "\u2235",
        "bemptyv;": "\u29B0",
        "between;": "\u226C",
        "bigcirc;": "\u25EF",
        "bigodot;": "\u2A00",
        "bigstar;": "\u2605",
        "bnequiv;": "\u2261\u20E5",
        "boxplus;": "\u229E",
        "Cayleys;": "\u212D",
        "Cconint;": "\u2230",
        "ccupssm;": "\u2A50",
        "Cedilla;": "\xB8",
        "cemptyv;": "\u29B2",
        "cirscir;": "\u29C2",
        "coloneq;": "\u2254",
        "congdot;": "\u2A6D",
        "cudarrl;": "\u2938",
        "cudarrr;": "\u2935",
        "cularrp;": "\u293D",
        "curarrm;": "\u293C",
        "dbkarow;": "\u290F",
        "ddagger;": "\u2021",
        "ddotseq;": "\u2A77",
        "demptyv;": "\u29B1",
        "Diamond;": "\u22C4",
        "diamond;": "\u22C4",
        "digamma;": "\u03DD",
        "dotplus;": "\u2214",
        "DownTee;": "\u22A4",
        "dwangle;": "\u29A6",
        "Element;": "\u2208",
        "Epsilon;": "\u0395",
        "epsilon;": "\u03B5",
        "eqcolon;": "\u2255",
        "equivDD;": "\u2A78",
        "gesdoto;": "\u2A82",
        "gtquest;": "\u2A7C",
        "gtrless;": "\u2277",
        "harrcir;": "\u2948",
        "Implies;": "\u21D2",
        "intprod;": "\u2A3C",
        "isindot;": "\u22F5",
        "larrbfs;": "\u291F",
        "larrsim;": "\u2973",
        "lbrksld;": "\u298F",
        "lbrkslu;": "\u298D",
        "ldrdhar;": "\u2967",
        "LeftTee;": "\u22A3",
        "lesdoto;": "\u2A81",
        "lessdot;": "\u22D6",
        "lessgtr;": "\u2276",
        "lesssim;": "\u2272",
        "lotimes;": "\u2A34",
        "lozenge;": "\u25CA",
        "ltquest;": "\u2A7B",
        "luruhar;": "\u2966",
        "maltese;": "\u2720",
        "minusdu;": "\u2A2A",
        "napprox;": "\u2249",
        "natural;": "\u266E",
        "nearrow;": "\u2197",
        "NewLine;": "\n",
        "nexists;": "\u2204",
        "NoBreak;": "\u2060",
        "notinva;": "\u2209",
        "notinvb;": "\u22F7",
        "notinvc;": "\u22F6",
        "NotLess;": "\u226E",
        "notniva;": "\u220C",
        "notnivb;": "\u22FE",
        "notnivc;": "\u22FD",
        "npolint;": "\u2A14",
        "npreceq;": "\u2AAF\u0338",
        "nsqsube;": "\u22E2",
        "nsqsupe;": "\u22E3",
        "nsubset;": "\u2282\u20D2",
        "nsucceq;": "\u2AB0\u0338",
        "nsupset;": "\u2283\u20D2",
        "nvinfin;": "\u29DE",
        "nvltrie;": "\u22B4\u20D2",
        "nvrtrie;": "\u22B5\u20D2",
        "nwarrow;": "\u2196",
        "olcross;": "\u29BB",
        "Omicron;": "\u039F",
        "omicron;": "\u03BF",
        "orderof;": "\u2134",
        "orslope;": "\u2A57",
        "OverBar;": "\u203E",
        "pertenk;": "\u2031",
        "planckh;": "\u210E",
        "pluscir;": "\u2A22",
        "plussim;": "\u2A26",
        "plustwo;": "\u2A27",
        "precsim;": "\u227E",
        "Product;": "\u220F",
        "quatint;": "\u2A16",
        "questeq;": "\u225F",
        "rarrbfs;": "\u2920",
        "rarrsim;": "\u2974",
        "rbrksld;": "\u298E",
        "rbrkslu;": "\u2990",
        "rdldhar;": "\u2969",
        "realine;": "\u211B",
        "rotimes;": "\u2A35",
        "ruluhar;": "\u2968",
        "searrow;": "\u2198",
        "simplus;": "\u2A24",
        "simrarr;": "\u2972",
        "subedot;": "\u2AC3",
        "submult;": "\u2AC1",
        "subplus;": "\u2ABF",
        "subrarr;": "\u2979",
        "succsim;": "\u227F",
        "supdsub;": "\u2AD8",
        "supedot;": "\u2AC4",
        "suphsol;": "\u27C9",
        "suphsub;": "\u2AD7",
        "suplarr;": "\u297B",
        "supmult;": "\u2AC2",
        "supplus;": "\u2AC0",
        "swarrow;": "\u2199",
        "topfork;": "\u2ADA",
        "triplus;": "\u2A39",
        "tritime;": "\u2A3B",
        "UpArrow;": "\u2191",
        "Uparrow;": "\u21D1",
        "uparrow;": "\u2191",
        "Upsilon;": "\u03A5",
        "upsilon;": "\u03C5",
        "uwangle;": "\u29A7",
        "vzigzag;": "\u299A",
        "zigrarr;": "\u21DD",
        "andslope;": "\u2A58",
        "angmsdaa;": "\u29A8",
        "angmsdab;": "\u29A9",
        "angmsdac;": "\u29AA",
        "angmsdad;": "\u29AB",
        "angmsdae;": "\u29AC",
        "angmsdaf;": "\u29AD",
        "angmsdag;": "\u29AE",
        "angmsdah;": "\u29AF",
        "angrtvbd;": "\u299D",
        "approxeq;": "\u224A",
        "awconint;": "\u2233",
        "backcong;": "\u224C",
        "barwedge;": "\u2305",
        "bbrktbrk;": "\u23B6",
        "bigoplus;": "\u2A01",
        "bigsqcup;": "\u2A06",
        "biguplus;": "\u2A04",
        "bigwedge;": "\u22C0",
        "boxminus;": "\u229F",
        "boxtimes;": "\u22A0",
        "bsolhsub;": "\u27C8",
        "capbrcup;": "\u2A49",
        "circledR;": "\xAE",
        "circledS;": "\u24C8",
        "cirfnint;": "\u2A10",
        "clubsuit;": "\u2663",
        "cupbrcap;": "\u2A48",
        "curlyvee;": "\u22CE",
        "cwconint;": "\u2232",
        "DDotrahd;": "\u2911",
        "doteqdot;": "\u2251",
        "DotEqual;": "\u2250",
        "dotminus;": "\u2238",
        "drbkarow;": "\u2910",
        "dzigrarr;": "\u27FF",
        "elinters;": "\u23E7",
        "emptyset;": "\u2205",
        "eqvparsl;": "\u29E5",
        "fpartint;": "\u2A0D",
        "geqslant;": "\u2A7E",
        "gesdotol;": "\u2A84",
        "gnapprox;": "\u2A8A",
        "hksearow;": "\u2925",
        "hkswarow;": "\u2926",
        "imagline;": "\u2110",
        "imagpart;": "\u2111",
        "infintie;": "\u29DD",
        "integers;": "\u2124",
        "Integral;": "\u222B",
        "intercal;": "\u22BA",
        "intlarhk;": "\u2A17",
        "laemptyv;": "\u29B4",
        "ldrushar;": "\u294B",
        "leqslant;": "\u2A7D",
        "lesdotor;": "\u2A83",
        "LessLess;": "\u2AA1",
        "llcorner;": "\u231E",
        "lnapprox;": "\u2A89",
        "lrcorner;": "\u231F",
        "lurdshar;": "\u294A",
        "mapstoup;": "\u21A5",
        "multimap;": "\u22B8",
        "naturals;": "\u2115",
        "ncongdot;": "\u2A6D\u0338",
        "NotEqual;": "\u2260",
        "notindot;": "\u22F5\u0338",
        "NotTilde;": "\u2241",
        "otimesas;": "\u2A36",
        "parallel;": "\u2225",
        "PartialD;": "\u2202",
        "plusacir;": "\u2A23",
        "pointint;": "\u2A15",
        "Precedes;": "\u227A",
        "precneqq;": "\u2AB5",
        "precnsim;": "\u22E8",
        "profalar;": "\u232E",
        "profline;": "\u2312",
        "profsurf;": "\u2313",
        "raemptyv;": "\u29B3",
        "realpart;": "\u211C",
        "RightTee;": "\u22A2",
        "rppolint;": "\u2A12",
        "rtriltri;": "\u29CE",
        "scpolint;": "\u2A13",
        "setminus;": "\u2216",
        "shortmid;": "\u2223",
        "smeparsl;": "\u29E4",
        "sqsubset;": "\u228F",
        "sqsupset;": "\u2290",
        "subseteq;": "\u2286",
        "Succeeds;": "\u227B",
        "succneqq;": "\u2AB6",
        "succnsim;": "\u22E9",
        "SuchThat;": "\u220B",
        "Superset;": "\u2283",
        "supseteq;": "\u2287",
        "thetasym;": "\u03D1",
        "thicksim;": "\u223C",
        "timesbar;": "\u2A31",
        "triangle;": "\u25B5",
        "triminus;": "\u2A3A",
        "trpezium;": "\u23E2",
        "Uarrocir;": "\u2949",
        "ulcorner;": "\u231C",
        "UnderBar;": "_",
        "urcorner;": "\u231D",
        "varkappa;": "\u03F0",
        "varsigma;": "\u03C2",
        "vartheta;": "\u03D1",
        "backprime;": "\u2035",
        "backsimeq;": "\u22CD",
        "Backslash;": "\u2216",
        "bigotimes;": "\u2A02",
        "CenterDot;": "\xB7",
        "centerdot;": "\xB7",
        "checkmark;": "\u2713",
        "CircleDot;": "\u2299",
        "complexes;": "\u2102",
        "Congruent;": "\u2261",
        "Coproduct;": "\u2210",
        "dotsquare;": "\u22A1",
        "DoubleDot;": "\xA8",
        "DownArrow;": "\u2193",
        "Downarrow;": "\u21D3",
        "downarrow;": "\u2193",
        "DownBreve;": "\u0311",
        "gtrapprox;": "\u2A86",
        "gtreqless;": "\u22DB",
        "gvertneqq;": "\u2269\uFE00",
        "heartsuit;": "\u2665",
        "HumpEqual;": "\u224F",
        "LeftArrow;": "\u2190",
        "Leftarrow;": "\u21D0",
        "leftarrow;": "\u2190",
        "LeftFloor;": "\u230A",
        "lesseqgtr;": "\u22DA",
        "LessTilde;": "\u2272",
        "lvertneqq;": "\u2268\uFE00",
        "Mellintrf;": "\u2133",
        "MinusPlus;": "\u2213",
        "ngeqslant;": "\u2A7E\u0338",
        "nleqslant;": "\u2A7D\u0338",
        "NotCupCap;": "\u226D",
        "NotExists;": "\u2204",
        "NotSubset;": "\u2282\u20D2",
        "nparallel;": "\u2226",
        "nshortmid;": "\u2224",
        "nsubseteq;": "\u2288",
        "nsupseteq;": "\u2289",
        "OverBrace;": "\u23DE",
        "pitchfork;": "\u22D4",
        "PlusMinus;": "\xB1",
        "rationals;": "\u211A",
        "spadesuit;": "\u2660",
        "subseteqq;": "\u2AC5",
        "subsetneq;": "\u228A",
        "supseteqq;": "\u2AC6",
        "supsetneq;": "\u228B",
        "Therefore;": "\u2234",
        "therefore;": "\u2234",
        "ThinSpace;": "\u2009",
        "triangleq;": "\u225C",
        "TripleDot;": "\u20DB",
        "UnionPlus;": "\u228E",
        "varpropto;": "\u221D",
        "Bernoullis;": "\u212C",
        "circledast;": "\u229B",
        "CirclePlus;": "\u2295",
        "complement;": "\u2201",
        "curlywedge;": "\u22CF",
        "eqslantgtr;": "\u2A96",
        "EqualTilde;": "\u2242",
        "Fouriertrf;": "\u2131",
        "gtreqqless;": "\u2A8C",
        "ImaginaryI;": "\u2148",
        "Laplacetrf;": "\u2112",
        "LeftVector;": "\u21BC",
        "lessapprox;": "\u2A85",
        "lesseqqgtr;": "\u2A8B",
        "Lleftarrow;": "\u21DA",
        "lmoustache;": "\u23B0",
        "longmapsto;": "\u27FC",
        "mapstodown;": "\u21A7",
        "mapstoleft;": "\u21A4",
        "nLeftarrow;": "\u21CD",
        "nleftarrow;": "\u219A",
        "NotElement;": "\u2209",
        "NotGreater;": "\u226F",
        "nsubseteqq;": "\u2AC5\u0338",
        "nsupseteqq;": "\u2AC6\u0338",
        "precapprox;": "\u2AB7",
        "Proportion;": "\u2237",
        "RightArrow;": "\u2192",
        "Rightarrow;": "\u21D2",
        "rightarrow;": "\u2192",
        "RightFloor;": "\u230B",
        "rmoustache;": "\u23B1",
        "sqsubseteq;": "\u2291",
        "sqsupseteq;": "\u2292",
        "subsetneqq;": "\u2ACB",
        "succapprox;": "\u2AB8",
        "supsetneqq;": "\u2ACC",
        "ThickSpace;": "\u205F\u200A",
        "TildeEqual;": "\u2243",
        "TildeTilde;": "\u2248",
        "UnderBrace;": "\u23DF",
        "UpArrowBar;": "\u2912",
        "UpTeeArrow;": "\u21A5",
        "upuparrows;": "\u21C8",
        "varepsilon;": "\u03F5",
        "varnothing;": "\u2205",
        "backepsilon;": "\u03F6",
        "blacksquare;": "\u25AA",
        "circledcirc;": "\u229A",
        "circleddash;": "\u229D",
        "CircleMinus;": "\u2296",
        "CircleTimes;": "\u2297",
        "curlyeqprec;": "\u22DE",
        "curlyeqsucc;": "\u22DF",
        "diamondsuit;": "\u2666",
        "eqslantless;": "\u2A95",
        "Equilibrium;": "\u21CC",
        "expectation;": "\u2130",
        "GreaterLess;": "\u2277",
        "LeftCeiling;": "\u2308",
        "LessGreater;": "\u2276",
        "MediumSpace;": "\u205F",
        "NotLessLess;": "\u226A\u0338",
        "NotPrecedes;": "\u2280",
        "NotSucceeds;": "\u2281",
        "NotSuperset;": "\u2283\u20D2",
        "nRightarrow;": "\u21CF",
        "nrightarrow;": "\u219B",
        "OverBracket;": "\u23B4",
        "preccurlyeq;": "\u227C",
        "precnapprox;": "\u2AB9",
        "quaternions;": "\u210D",
        "RightVector;": "\u21C0",
        "Rrightarrow;": "\u21DB",
        "RuleDelayed;": "\u29F4",
        "SmallCircle;": "\u2218",
        "SquareUnion;": "\u2294",
        "straightphi;": "\u03D5",
        "SubsetEqual;": "\u2286",
        "succcurlyeq;": "\u227D",
        "succnapprox;": "\u2ABA",
        "thickapprox;": "\u2248",
        "UpDownArrow;": "\u2195",
        "Updownarrow;": "\u21D5",
        "updownarrow;": "\u2195",
        "VerticalBar;": "\u2223",
        "blacklozenge;": "\u29EB",
        "DownArrowBar;": "\u2913",
        "DownTeeArrow;": "\u21A7",
        "ExponentialE;": "\u2147",
        "exponentiale;": "\u2147",
        "GreaterEqual;": "\u2265",
        "GreaterTilde;": "\u2273",
        "HilbertSpace;": "\u210B",
        "HumpDownHump;": "\u224E",
        "Intersection;": "\u22C2",
        "LeftArrowBar;": "\u21E4",
        "LeftTeeArrow;": "\u21A4",
        "LeftTriangle;": "\u22B2",
        "LeftUpVector;": "\u21BF",
        "NotCongruent;": "\u2262",
        "NotHumpEqual;": "\u224F\u0338",
        "NotLessEqual;": "\u2270",
        "NotLessTilde;": "\u2274",
        "Proportional;": "\u221D",
        "RightCeiling;": "\u2309",
        "risingdotseq;": "\u2253",
        "RoundImplies;": "\u2970",
        "ShortUpArrow;": "\u2191",
        "SquareSubset;": "\u228F",
        "triangledown;": "\u25BF",
        "triangleleft;": "\u25C3",
        "UnderBracket;": "\u23B5",
        "varsubsetneq;": "\u228A\uFE00",
        "varsupsetneq;": "\u228B\uFE00",
        "VerticalLine;": "|",
        "ApplyFunction;": "\u2061",
        "bigtriangleup;": "\u25B3",
        "blacktriangle;": "\u25B4",
        "DifferentialD;": "\u2146",
        "divideontimes;": "\u22C7",
        "DoubleLeftTee;": "\u2AE4",
        "DoubleUpArrow;": "\u21D1",
        "fallingdotseq;": "\u2252",
        "hookleftarrow;": "\u21A9",
        "leftarrowtail;": "\u21A2",
        "leftharpoonup;": "\u21BC",
        "LeftTeeVector;": "\u295A",
        "LeftVectorBar;": "\u2952",
        "LessFullEqual;": "\u2266",
        "LongLeftArrow;": "\u27F5",
        "Longleftarrow;": "\u27F8",
        "longleftarrow;": "\u27F5",
        "looparrowleft;": "\u21AB",
        "measuredangle;": "\u2221",
        "NotEqualTilde;": "\u2242\u0338",
        "NotTildeEqual;": "\u2244",
        "NotTildeTilde;": "\u2249",
        "ntriangleleft;": "\u22EA",
        "Poincareplane;": "\u210C",
        "PrecedesEqual;": "\u2AAF",
        "PrecedesTilde;": "\u227E",
        "RightArrowBar;": "\u21E5",
        "RightTeeArrow;": "\u21A6",
        "RightTriangle;": "\u22B3",
        "RightUpVector;": "\u21BE",
        "shortparallel;": "\u2225",
        "smallsetminus;": "\u2216",
        "SucceedsEqual;": "\u2AB0",
        "SucceedsTilde;": "\u227F",
        "SupersetEqual;": "\u2287",
        "triangleright;": "\u25B9",
        "UpEquilibrium;": "\u296E",
        "upharpoonleft;": "\u21BF",
        "varsubsetneqq;": "\u2ACB\uFE00",
        "varsupsetneqq;": "\u2ACC\uFE00",
        "VerticalTilde;": "\u2240",
        "VeryThinSpace;": "\u200A",
        "curvearrowleft;": "\u21B6",
        "DiacriticalDot;": "\u02D9",
        "doublebarwedge;": "\u2306",
        "DoubleRightTee;": "\u22A8",
        "downdownarrows;": "\u21CA",
        "DownLeftVector;": "\u21BD",
        "GreaterGreater;": "\u2AA2",
        "hookrightarrow;": "\u21AA",
        "HorizontalLine;": "\u2500",
        "InvisibleComma;": "\u2063",
        "InvisibleTimes;": "\u2062",
        "LeftDownVector;": "\u21C3",
        "leftleftarrows;": "\u21C7",
        "LeftRightArrow;": "\u2194",
        "Leftrightarrow;": "\u21D4",
        "leftrightarrow;": "\u2194",
        "leftthreetimes;": "\u22CB",
        "LessSlantEqual;": "\u2A7D",
        "LongRightArrow;": "\u27F6",
        "Longrightarrow;": "\u27F9",
        "longrightarrow;": "\u27F6",
        "looparrowright;": "\u21AC",
        "LowerLeftArrow;": "\u2199",
        "NestedLessLess;": "\u226A",
        "NotGreaterLess;": "\u2279",
        "NotLessGreater;": "\u2278",
        "NotSubsetEqual;": "\u2288",
        "NotVerticalBar;": "\u2224",
        "nshortparallel;": "\u2226",
        "ntriangleright;": "\u22EB",
        "OpenCurlyQuote;": "\u2018",
        "ReverseElement;": "\u220B",
        "rightarrowtail;": "\u21A3",
        "rightharpoonup;": "\u21C0",
        "RightTeeVector;": "\u295B",
        "RightVectorBar;": "\u2953",
        "ShortDownArrow;": "\u2193",
        "ShortLeftArrow;": "\u2190",
        "SquareSuperset;": "\u2290",
        "TildeFullEqual;": "\u2245",
        "trianglelefteq;": "\u22B4",
        "upharpoonright;": "\u21BE",
        "UpperLeftArrow;": "\u2196",
        "ZeroWidthSpace;": "\u200B",
        "bigtriangledown;": "\u25BD",
        "circlearrowleft;": "\u21BA",
        "CloseCurlyQuote;": "\u2019",
        "ContourIntegral;": "\u222E",
        "curvearrowright;": "\u21B7",
        "DoubleDownArrow;": "\u21D3",
        "DoubleLeftArrow;": "\u21D0",
        "downharpoonleft;": "\u21C3",
        "DownRightVector;": "\u21C1",
        "leftharpoondown;": "\u21BD",
        "leftrightarrows;": "\u21C6",
        "LeftRightVector;": "\u294E",
        "LeftTriangleBar;": "\u29CF",
        "LeftUpTeeVector;": "\u2960",
        "LeftUpVectorBar;": "\u2958",
        "LowerRightArrow;": "\u2198",
        "nLeftrightarrow;": "\u21CE",
        "nleftrightarrow;": "\u21AE",
        "NotGreaterEqual;": "\u2271",
        "NotGreaterTilde;": "\u2275",
        "NotHumpDownHump;": "\u224E\u0338",
        "NotLeftTriangle;": "\u22EA",
        "NotSquareSubset;": "\u228F\u0338",
        "ntrianglelefteq;": "\u22EC",
        "OverParenthesis;": "\u23DC",
        "RightDownVector;": "\u21C2",
        "rightleftarrows;": "\u21C4",
        "rightsquigarrow;": "\u219D",
        "rightthreetimes;": "\u22CC",
        "ShortRightArrow;": "\u2192",
        "straightepsilon;": "\u03F5",
        "trianglerighteq;": "\u22B5",
        "UpperRightArrow;": "\u2197",
        "vartriangleleft;": "\u22B2",
        "circlearrowright;": "\u21BB",
        "DiacriticalAcute;": "\xB4",
        "DiacriticalGrave;": "`",
        "DiacriticalTilde;": "\u02DC",
        "DoubleRightArrow;": "\u21D2",
        "DownArrowUpArrow;": "\u21F5",
        "downharpoonright;": "\u21C2",
        "EmptySmallSquare;": "\u25FB",
        "GreaterEqualLess;": "\u22DB",
        "GreaterFullEqual;": "\u2267",
        "LeftAngleBracket;": "\u27E8",
        "LeftUpDownVector;": "\u2951",
        "LessEqualGreater;": "\u22DA",
        "NonBreakingSpace;": "\xA0",
        "NotPrecedesEqual;": "\u2AAF\u0338",
        "NotRightTriangle;": "\u22EB",
        "NotSucceedsEqual;": "\u2AB0\u0338",
        "NotSucceedsTilde;": "\u227F\u0338",
        "NotSupersetEqual;": "\u2289",
        "ntrianglerighteq;": "\u22ED",
        "rightharpoondown;": "\u21C1",
        "rightrightarrows;": "\u21C9",
        "RightTriangleBar;": "\u29D0",
        "RightUpTeeVector;": "\u295C",
        "RightUpVectorBar;": "\u2954",
        "twoheadleftarrow;": "\u219E",
        "UnderParenthesis;": "\u23DD",
        "UpArrowDownArrow;": "\u21C5",
        "vartriangleright;": "\u22B3",
        "blacktriangledown;": "\u25BE",
        "blacktriangleleft;": "\u25C2",
        "DoubleUpDownArrow;": "\u21D5",
        "DoubleVerticalBar;": "\u2225",
        "DownLeftTeeVector;": "\u295E",
        "DownLeftVectorBar;": "\u2956",
        "FilledSmallSquare;": "\u25FC",
        "GreaterSlantEqual;": "\u2A7E",
        "LeftDoubleBracket;": "\u27E6",
        "LeftDownTeeVector;": "\u2961",
        "LeftDownVectorBar;": "\u2959",
        "leftrightharpoons;": "\u21CB",
        "LeftTriangleEqual;": "\u22B4",
        "NegativeThinSpace;": "\u200B",
        "NotGreaterGreater;": "\u226B\u0338",
        "NotLessSlantEqual;": "\u2A7D\u0338",
        "NotNestedLessLess;": "\u2AA1\u0338",
        "NotReverseElement;": "\u220C",
        "NotSquareSuperset;": "\u2290\u0338",
        "NotTildeFullEqual;": "\u2247",
        "RightAngleBracket;": "\u27E9",
        "rightleftharpoons;": "\u21CC",
        "RightUpDownVector;": "\u294F",
        "SquareSubsetEqual;": "\u2291",
        "twoheadrightarrow;": "\u21A0",
        "VerticalSeparator;": "\u2758",
        "blacktriangleright;": "\u25B8",
        "DownRightTeeVector;": "\u295F",
        "DownRightVectorBar;": "\u2957",
        "LongLeftRightArrow;": "\u27F7",
        "Longleftrightarrow;": "\u27FA",
        "longleftrightarrow;": "\u27F7",
        "NegativeThickSpace;": "\u200B",
        "NotLeftTriangleBar;": "\u29CF\u0338",
        "PrecedesSlantEqual;": "\u227C",
        "ReverseEquilibrium;": "\u21CB",
        "RightDoubleBracket;": "\u27E7",
        "RightDownTeeVector;": "\u295D",
        "RightDownVectorBar;": "\u2955",
        "RightTriangleEqual;": "\u22B5",
        "SquareIntersection;": "\u2293",
        "SucceedsSlantEqual;": "\u227D",
        "DoubleLongLeftArrow;": "\u27F8",
        "DownLeftRightVector;": "\u2950",
        "LeftArrowRightArrow;": "\u21C6",
        "leftrightsquigarrow;": "\u21AD",
        "NegativeMediumSpace;": "\u200B",
        "NotGreaterFullEqual;": "\u2267\u0338",
        "NotRightTriangleBar;": "\u29D0\u0338",
        "RightArrowLeftArrow;": "\u21C4",
        "SquareSupersetEqual;": "\u2292",
        "CapitalDifferentialD;": "\u2145",
        "DoubleLeftRightArrow;": "\u21D4",
        "DoubleLongRightArrow;": "\u27F9",
        "EmptyVerySmallSquare;": "\u25AB",
        "NestedGreaterGreater;": "\u226B",
        "NotDoubleVerticalBar;": "\u2226",
        "NotGreaterSlantEqual;": "\u2A7E\u0338",
        "NotLeftTriangleEqual;": "\u22EC",
        "NotSquareSubsetEqual;": "\u22E2",
        "OpenCurlyDoubleQuote;": "\u201C",
        "ReverseUpEquilibrium;": "\u296F",
        "CloseCurlyDoubleQuote;": "\u201D",
        "DoubleContourIntegral;": "\u222F",
        "FilledVerySmallSquare;": "\u25AA",
        "NegativeVeryThinSpace;": "\u200B",
        "NotPrecedesSlantEqual;": "\u22E0",
        "NotRightTriangleEqual;": "\u22ED",
        "NotSucceedsSlantEqual;": "\u22E1",
        "DiacriticalDoubleAcute;": "\u02DD",
        "NotSquareSupersetEqual;": "\u22E3",
        "NotNestedGreaterGreater;": "\u2AA2\u0338",
        "ClockwiseContourIntegral;": "\u2232",
        "DoubleLongLeftRightArrow;": "\u27FA",
        "CounterClockwiseContourIntegral;": "\u2233"
      };
      var maxCRNameLength;
      var decodeHtml = (rawText, asAttr) => {
        let offset2 = 0;
        const end = rawText.length;
        let decodedText = "";
        function advance(length) {
          offset2 += length;
          rawText = rawText.slice(length);
        }
        while (offset2 < end) {
          const head = /&(?:#x?)?/i.exec(rawText);
          if (!head || offset2 + head.index >= end) {
            const remaining = end - offset2;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
          }
          decodedText += rawText.slice(0, head.index);
          advance(head.index);
          if (head[0] === "&") {
            let name = "";
            let value = void 0;
            if (/[0-9a-z]/i.test(rawText[1])) {
              if (!maxCRNameLength) {
                maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name2) => Math.max(max, name2.length), 0);
              }
              for (let length = maxCRNameLength; !value && length > 0; --length) {
                name = rawText.slice(1, 1 + length);
                value = namedCharacterReferences[name];
              }
              if (value) {
                const semi = name.endsWith(";");
                if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name.length + 1] || "")) {
                  decodedText += "&" + name;
                  advance(1 + name.length);
                } else {
                  decodedText += value;
                  advance(1 + name.length);
                }
              } else {
                decodedText += "&" + name;
                advance(1 + name.length);
              }
            } else {
              decodedText += "&";
              advance(1);
            }
          } else {
            const hex = head[0] === "&#x";
            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body2 = pattern.exec(rawText);
            if (!body2) {
              decodedText += head[0];
              advance(head[0].length);
            } else {
              let cp = Number.parseInt(body2[1], hex ? 16 : 10);
              if (cp === 0) {
                cp = 65533;
              } else if (cp > 1114111) {
                cp = 65533;
              } else if (cp >= 55296 && cp <= 57343) {
                cp = 65533;
              } else if (cp >= 64976 && cp <= 65007 || (cp & 65534) === 65534) ;
              else if (cp >= 1 && cp <= 8 || cp === 11 || cp >= 13 && cp <= 31 || cp >= 127 && cp <= 159) {
                cp = CCR_REPLACEMENTS[cp] || cp;
              }
              decodedText += String.fromCodePoint(cp);
              advance(body2[0].length);
            }
          }
        }
        return decodedText;
      };
      var CCR_REPLACEMENTS = {
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376
      };
      var isRawTextContainer = /* @__PURE__ */ shared.makeMap("style,iframe,script,noscript", true);
      var parserOptions = {
        isVoidTag: shared.isVoidTag,
        isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
        isPreTag: (tag) => tag === "pre",
        decodeEntities: decodeHtml,
        isBuiltInComponent: (tag) => {
          if (compilerCore.isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
          } else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
          }
        },
        // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
        getNamespace(tag, parent2) {
          let ns = parent2 ? parent2.ns : 0;
          if (parent2 && ns === 2) {
            if (parent2.tag === "annotation-xml") {
              if (tag === "svg") {
                return 1;
              }
              if (parent2.props.some((a3) => a3.type === 6 && a3.name === "encoding" && a3.value != null && (a3.value.content === "text/html" || a3.value.content === "application/xhtml+xml"))) {
                ns = 0;
              }
            } else if (/^m(?:[ions]|text)$/.test(parent2.tag) && tag !== "mglyph" && tag !== "malignmark") {
              ns = 0;
            }
          } else if (parent2 && ns === 1) {
            if (parent2.tag === "foreignObject" || parent2.tag === "desc" || parent2.tag === "title") {
              ns = 0;
            }
          }
          if (ns === 0) {
            if (tag === "svg") {
              return 1;
            }
            if (tag === "math") {
              return 2;
            }
          }
          return ns;
        },
        // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
        getTextMode({ tag, ns }) {
          if (ns === 0) {
            if (tag === "textarea" || tag === "title") {
              return 1;
            }
            if (isRawTextContainer(tag)) {
              return 2;
            }
          }
          return 0;
        }
      };
      var transformStyle = (node) => {
        if (node.type === 1) {
          node.props.forEach((p2, i4) => {
            if (p2.type === 6 && p2.name === "style" && p2.value) {
              node.props[i4] = {
                type: 7,
                name: `bind`,
                arg: compilerCore.createSimpleExpression(`style`, true, p2.loc),
                exp: parseInlineCSS(p2.value.content, p2.loc),
                modifiers: [],
                loc: p2.loc
              };
            }
          });
        }
      };
      var parseInlineCSS = (cssText, loc) => {
        const normalized = shared.parseStringStyle(cssText);
        return compilerCore.createSimpleExpression(
          JSON.stringify(normalized),
          false,
          loc,
          3
          /* CAN_STRINGIFY */
        );
      };
      function createDOMCompilerError(code, loc) {
        return compilerCore.createCompilerError(code, loc, DOMErrorMessages);
      }
      var DOMErrorMessages = {
        [
          50
          /* X_V_HTML_NO_EXPRESSION */
        ]: `v-html is missing expression.`,
        [
          51
          /* X_V_HTML_WITH_CHILDREN */
        ]: `v-html will override element children.`,
        [
          52
          /* X_V_TEXT_NO_EXPRESSION */
        ]: `v-text is missing expression.`,
        [
          53
          /* X_V_TEXT_WITH_CHILDREN */
        ]: `v-text will override element children.`,
        [
          54
          /* X_V_MODEL_ON_INVALID_ELEMENT */
        ]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
        [
          55
          /* X_V_MODEL_ARG_ON_ELEMENT */
        ]: `v-model argument is not supported on plain elements.`,
        [
          56
          /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */
        ]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
        [
          57
          /* X_V_MODEL_UNNECESSARY_VALUE */
        ]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
        [
          58
          /* X_V_SHOW_NO_EXPRESSION */
        ]: `v-show is missing expression.`,
        [
          59
          /* X_TRANSITION_INVALID_CHILDREN */
        ]: `<Transition> expects exactly one child element or component.`,
        [
          60
          /* X_IGNORED_SIDE_EFFECT_TAG */
        ]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
      };
      var transformVHtml = (dir, node, context3) => {
        const { exp, loc } = dir;
        if (!exp) {
          context3.onError(createDOMCompilerError(50, loc));
        }
        if (node.children.length) {
          context3.onError(createDOMCompilerError(51, loc));
          node.children.length = 0;
        }
        return {
          props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression("", true))
          ]
        };
      };
      var transformVText = (dir, node, context3) => {
        const { exp, loc } = dir;
        if (!exp) {
          context3.onError(createDOMCompilerError(52, loc));
        }
        if (node.children.length) {
          context3.onError(createDOMCompilerError(53, loc));
          node.children.length = 0;
        }
        return {
          props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp ? compilerCore.getConstantType(exp, context3) > 0 ? exp : compilerCore.createCallExpression(context3.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc) : compilerCore.createSimpleExpression("", true))
          ]
        };
      };
      var transformModel = (dir, node, context3) => {
        const baseResult = compilerCore.transformModel(dir, node, context3);
        if (!baseResult.props.length || node.tagType === 1) {
          return baseResult;
        }
        if (dir.arg) {
          context3.onError(createDOMCompilerError(55, dir.arg.loc));
        }
        function checkDuplicatedValue() {
          const value = compilerCore.findProp(node, "value");
          if (value) {
            context3.onError(createDOMCompilerError(57, value.loc));
          }
        }
        const { tag } = node;
        const isCustomElement = context3.isCustomElement(tag);
        if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === "input" || isCustomElement) {
            const type = compilerCore.findProp(node, `type`);
            if (type) {
              if (type.type === 7) {
                directiveToUse = V_MODEL_DYNAMIC;
              } else if (type.value) {
                switch (type.value.content) {
                  case "radio":
                    directiveToUse = V_MODEL_RADIO;
                    break;
                  case "checkbox":
                    directiveToUse = V_MODEL_CHECKBOX;
                    break;
                  case "file":
                    isInvalidType = true;
                    context3.onError(createDOMCompilerError(56, dir.loc));
                    break;
                  default:
                    checkDuplicatedValue();
                    break;
                }
              }
            } else if (compilerCore.hasDynamicKeyVBind(node)) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else {
              checkDuplicatedValue();
            }
          } else if (tag === "select") {
            directiveToUse = V_MODEL_SELECT;
          } else {
            checkDuplicatedValue();
          }
          if (!isInvalidType) {
            baseResult.needRuntime = context3.helper(directiveToUse);
          }
        } else {
          context3.onError(createDOMCompilerError(54, dir.loc));
        }
        baseResult.props = baseResult.props.filter((p2) => !(p2.key.type === 4 && p2.key.content === "modelValue"));
        return baseResult;
      };
      var isEventOptionModifier = /* @__PURE__ */ shared.makeMap(`passive,once,capture`);
      var isNonKeyModifier = /* @__PURE__ */ shared.makeMap(
        // event propagation management
        `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
      );
      var maybeKeyModifier = /* @__PURE__ */ shared.makeMap("left,right");
      var isKeyboardEvent = /* @__PURE__ */ shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);
      var resolveModifiers = (key, modifiers, context3, loc) => {
        const keyModifiers = [];
        const nonKeyModifiers = [];
        const eventOptionModifiers = [];
        for (let i4 = 0; i4 < modifiers.length; i4++) {
          const modifier = modifiers[i4];
          if (modifier === "native" && compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE", context3, loc)) {
            eventOptionModifiers.push(modifier);
          } else if (isEventOptionModifier(modifier)) {
            eventOptionModifiers.push(modifier);
          } else {
            if (maybeKeyModifier(modifier)) {
              if (compilerCore.isStaticExp(key)) {
                if (isKeyboardEvent(key.content)) {
                  keyModifiers.push(modifier);
                } else {
                  nonKeyModifiers.push(modifier);
                }
              } else {
                keyModifiers.push(modifier);
                nonKeyModifiers.push(modifier);
              }
            } else {
              if (isNonKeyModifier(modifier)) {
                nonKeyModifiers.push(modifier);
              } else {
                keyModifiers.push(modifier);
              }
            }
          }
        }
        return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
        };
      };
      var transformClick = (key, event2) => {
        const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
        return isStaticClick ? compilerCore.createSimpleExpression(event2, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
          `(`,
          key,
          `) === "onClick" ? "${event2}" : (`,
          key,
          `)`
        ]) : key;
      };
      var transformOn = (dir, node, context3) => {
        return compilerCore.transformOn(dir, node, context3, (baseResult) => {
          const { modifiers } = dir;
          if (!modifiers.length)
            return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context3, dir.loc);
          if (nonKeyModifiers.includes("right")) {
            key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes("middle")) {
            key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
            handlerExp = compilerCore.createCallExpression(context3.helper(V_ON_WITH_MODIFIERS), [
              handlerExp,
              JSON.stringify(nonKeyModifiers)
            ]);
          }
          if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
          (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = compilerCore.createCallExpression(context3.helper(V_ON_WITH_KEYS), [
              handlerExp,
              JSON.stringify(keyModifiers)
            ]);
          }
          if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
            key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
            props: [compilerCore.createObjectProperty(key, handlerExp)]
          };
        });
      };
      var transformShow = (dir, node, context3) => {
        const { exp, loc } = dir;
        if (!exp) {
          context3.onError(createDOMCompilerError(58, loc));
        }
        return {
          props: [],
          needRuntime: context3.helper(V_SHOW)
        };
      };
      var transformTransition = (node, context3) => {
        if (node.type === 1 && node.tagType === 1) {
          const component = context3.isBuiltInComponent(node.tag);
          if (component === TRANSITION) {
            return () => {
              if (!node.children.length) {
                return;
              }
              if (hasMultipleChildren(node)) {
                context3.onError(createDOMCompilerError(59, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                }));
              }
              const child = node.children[0];
              if (child.type === 1) {
                for (const p2 of child.props) {
                  if (p2.type === 7 && p2.name === "show") {
                    node.props.push({
                      type: 6,
                      name: "persisted",
                      value: void 0,
                      loc: node.loc
                    });
                  }
                }
              }
            };
          }
        }
      };
      function hasMultipleChildren(node) {
        const children2 = node.children = node.children.filter((c3) => c3.type !== 3 && !(c3.type === 2 && !c3.content.trim()));
        const child = children2[0];
        return children2.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
      }
      var expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
      var stringifyStatic = (children2, context3, parent2) => {
        if (context3.scopes.vSlot > 0) {
          return;
        }
        let nc = 0;
        let ec = 0;
        const currentChunk = [];
        const stringifyCurrentChunk = (currentIndex) => {
          if (nc >= 20 || ec >= 5) {
            const staticCall = compilerCore.createCallExpression(context3.helper(compilerCore.CREATE_STATIC), [
              JSON.stringify(currentChunk.map((node) => stringifyNode(node, context3)).join("")).replace(expReplaceRE, `" + $1 + "`),
              // the 2nd argument indicates the number of DOM nodes this static vnode
              // will insert / hydrate
              String(currentChunk.length)
            ]);
            replaceHoist(currentChunk[0], staticCall, context3);
            if (currentChunk.length > 1) {
              for (let i5 = 1; i5 < currentChunk.length; i5++) {
                replaceHoist(currentChunk[i5], null, context3);
              }
              const deleteCount = currentChunk.length - 1;
              children2.splice(currentIndex - currentChunk.length + 1, deleteCount);
              return deleteCount;
            }
          }
          return 0;
        };
        let i4 = 0;
        for (; i4 < children2.length; i4++) {
          const child = children2[i4];
          const hoisted = getHoistedNode(child);
          if (hoisted) {
            const node = child;
            const result = analyzeNode(node);
            if (result) {
              nc += result[0];
              ec += result[1];
              currentChunk.push(node);
              continue;
            }
          }
          i4 -= stringifyCurrentChunk(i4);
          nc = 0;
          ec = 0;
          currentChunk.length = 0;
        }
        stringifyCurrentChunk(i4);
      };
      var getHoistedNode = (node) => (node.type === 1 && node.tagType === 0 || node.type == 12) && node.codegenNode && node.codegenNode.type === 4 && node.codegenNode.hoisted;
      var dataAriaRE = /^(data|aria)-/;
      var isStringifiableAttr = (name, ns) => {
        return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);
      };
      var replaceHoist = (node, replacement, context3) => {
        const hoistToReplace = node.codegenNode.hoisted;
        context3.hoists[context3.hoists.indexOf(hoistToReplace)] = replacement;
      };
      var isNonStringifiable = /* @__PURE__ */ shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
      function analyzeNode(node) {
        if (node.type === 1 && isNonStringifiable(node.tag)) {
          return false;
        }
        if (node.type === 12) {
          return [1, 0];
        }
        let nc = 1;
        let ec = node.props.length > 0 ? 1 : 0;
        let bailed = false;
        const bail = () => {
          bailed = true;
          return false;
        };
        function walk(node2) {
          for (let i4 = 0; i4 < node2.props.length; i4++) {
            const p2 = node2.props[i4];
            if (p2.type === 6 && !isStringifiableAttr(p2.name, node2.ns)) {
              return bail();
            }
            if (p2.type === 7 && p2.name === "bind") {
              if (p2.arg && (p2.arg.type === 8 || p2.arg.isStatic && !isStringifiableAttr(p2.arg.content, node2.ns))) {
                return bail();
              }
              if (p2.exp && (p2.exp.type === 8 || p2.exp.constType < 3)) {
                return bail();
              }
            }
          }
          for (let i4 = 0; i4 < node2.children.length; i4++) {
            nc++;
            const child = node2.children[i4];
            if (child.type === 1) {
              if (child.props.length > 0) {
                ec++;
              }
              walk(child);
              if (bailed) {
                return false;
              }
            }
          }
          return true;
        }
        return walk(node) ? [nc, ec] : false;
      }
      function stringifyNode(node, context3) {
        if (shared.isString(node)) {
          return node;
        }
        if (shared.isSymbol(node)) {
          return ``;
        }
        switch (node.type) {
          case 1:
            return stringifyElement(node, context3);
          case 2:
            return shared.escapeHtml(node.content);
          case 3:
            return `<!--${shared.escapeHtml(node.content)}-->`;
          case 5:
            return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
          case 8:
            return shared.escapeHtml(evaluateConstant(node));
          case 12:
            return stringifyNode(node.content, context3);
          default:
            return "";
        }
      }
      function stringifyElement(node, context3) {
        let res = `<${node.tag}`;
        let innerHTML = "";
        for (let i4 = 0; i4 < node.props.length; i4++) {
          const p2 = node.props[i4];
          if (p2.type === 6) {
            res += ` ${p2.name}`;
            if (p2.value) {
              res += `="${shared.escapeHtml(p2.value.content)}"`;
            }
          } else if (p2.type === 7) {
            if (p2.name === "bind") {
              const exp = p2.exp;
              if (exp.content[0] === "_") {
                res += ` ${p2.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
                continue;
              }
              let evaluated = evaluateConstant(exp);
              if (evaluated != null) {
                const arg = p2.arg && p2.arg.content;
                if (arg === "class") {
                  evaluated = shared.normalizeClass(evaluated);
                } else if (arg === "style") {
                  evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
                }
                res += ` ${p2.arg.content}="${shared.escapeHtml(evaluated)}"`;
              }
            } else if (p2.name === "html") {
              innerHTML = evaluateConstant(p2.exp);
            } else if (p2.name === "text") {
              innerHTML = shared.escapeHtml(shared.toDisplayString(evaluateConstant(p2.exp)));
            }
          }
        }
        if (context3.scopeId) {
          res += ` ${context3.scopeId}`;
        }
        res += `>`;
        if (innerHTML) {
          res += innerHTML;
        } else {
          for (let i4 = 0; i4 < node.children.length; i4++) {
            res += stringifyNode(node.children[i4], context3);
          }
        }
        if (!shared.isVoidTag(node.tag)) {
          res += `</${node.tag}>`;
        }
        return res;
      }
      function evaluateConstant(exp) {
        if (exp.type === 4) {
          return new Function(`return ${exp.content}`)();
        } else {
          let res = ``;
          exp.children.forEach((c3) => {
            if (shared.isString(c3) || shared.isSymbol(c3)) {
              return;
            }
            if (c3.type === 2) {
              res += c3.content;
            } else if (c3.type === 5) {
              res += shared.toDisplayString(evaluateConstant(c3.content));
            } else {
              res += evaluateConstant(c3);
            }
          });
          return res;
        }
      }
      var ignoreSideEffectTags = (node, context3) => {
        if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
          context3.onError(createDOMCompilerError(60, node.loc));
          context3.removeNode();
        }
      };
      var DOMNodeTransforms = [
        transformStyle,
        ...[transformTransition]
      ];
      var DOMDirectiveTransforms = {
        cloak: compilerCore.noopDirectiveTransform,
        html: transformVHtml,
        text: transformVText,
        model: transformModel,
        on: transformOn,
        show: transformShow
      };
      function compile3(template2, options = {}) {
        return compilerCore.baseCompile(template2, shared.extend({}, parserOptions, options, {
          nodeTransforms: [
            // ignore <script> and <tag>
            // this is not put inside DOMNodeTransforms because that list is used
            // by compiler-ssr to generate vnode fallback branches
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...options.nodeTransforms || []
          ],
          directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
          transformHoist: stringifyStatic
        }));
      }
      function parse3(template2, options = {}) {
        return compilerCore.baseParse(template2, shared.extend({}, parserOptions, options));
      }
      Object.keys(compilerCore).forEach(function(k2) {
        if (k2 !== "default") exports[k2] = compilerCore[k2];
      });
      exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
      exports.DOMNodeTransforms = DOMNodeTransforms;
      exports.TRANSITION = TRANSITION;
      exports.TRANSITION_GROUP = TRANSITION_GROUP;
      exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
      exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
      exports.V_MODEL_RADIO = V_MODEL_RADIO;
      exports.V_MODEL_SELECT = V_MODEL_SELECT;
      exports.V_MODEL_TEXT = V_MODEL_TEXT;
      exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
      exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
      exports.V_SHOW = V_SHOW;
      exports.compile = compile3;
      exports.createDOMCompilerError = createDOMCompilerError;
      exports.parse = parse3;
      exports.parserOptions = parserOptions;
      exports.transformStyle = transformStyle;
    }
  });

  // node_modules/@vue/compiler-dom/index.js
  var require_compiler_dom = __commonJS({
    "node_modules/@vue/compiler-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_compiler_dom_cjs();
      }
    }
  });

  // node_modules/vue/dist/vue.cjs.js
  var require_vue_cjs = __commonJS({
    "node_modules/vue/dist/vue.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var compilerDom = require_compiler_dom();
      var runtimeDom2 = require_runtime_dom();
      var shared = require_shared();
      function _interopNamespace(e4) {
        if (e4 && e4.__esModule) return e4;
        var n4 = /* @__PURE__ */ Object.create(null);
        if (e4) {
          Object.keys(e4).forEach(function(k2) {
            n4[k2] = e4[k2];
          });
        }
        n4["default"] = e4;
        return Object.freeze(n4);
      }
      var runtimeDom__namespace = /* @__PURE__ */ _interopNamespace(runtimeDom2);
      var compileCache2 = /* @__PURE__ */ Object.create(null);
      function compileToFunction2(template2, options) {
        if (!shared.isString(template2)) {
          if (template2.nodeType) {
            template2 = template2.innerHTML;
          } else {
            runtimeDom2.warn(`invalid template option: `, template2);
            return shared.NOOP;
          }
        }
        const key = template2;
        const cached = compileCache2[key];
        if (cached) {
          return cached;
        }
        if (template2[0] === "#") {
          const el = document.querySelector(template2);
          if (!el) {
            runtimeDom2.warn(`Template element not found or is empty: ${template2}`);
          }
          template2 = el ? el.innerHTML : ``;
        }
        const { code } = compilerDom.compile(template2, shared.extend({
          hoistStatic: true,
          onError,
          onWarn: (e4) => onError(e4, true)
        }, options));
        function onError(err, asWarning = false) {
          const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
          const codeFrame = err.loc && shared.generateCodeFrame(template2, err.loc.start.offset, err.loc.end.offset);
          runtimeDom2.warn(codeFrame ? `${message}
${codeFrame}` : message);
        }
        const render6 = new Function("Vue", code)(runtimeDom__namespace);
        render6._rc = true;
        return compileCache2[key] = render6;
      }
      runtimeDom2.registerRuntimeCompiler(compileToFunction2);
      Object.keys(runtimeDom2).forEach(function(k2) {
        if (k2 !== "default") exports[k2] = runtimeDom2[k2];
      });
      exports.compile = compileToFunction2;
    }
  });

  // node_modules/vue/index.js
  var require_vue = __commonJS({
    "node_modules/vue/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_vue_cjs();
      }
    }
  });

  // node_modules/filepond/dist/filepond.js
  var require_filepond = __commonJS({
    "node_modules/filepond/dist/filepond.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.FilePond = {}));
      })(exports, function(exports2) {
        "use strict";
        var isNode2 = function isNode3(value) {
          return value instanceof HTMLElement;
        };
        var createStore = function createStore2(initialState) {
          var queries2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var actions2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          var state2 = Object.assign({}, initialState);
          var actionQueue = [];
          var dispatchQueue = [];
          var getState = function getState2() {
            return Object.assign({}, state2);
          };
          var processActionQueue = function processActionQueue2() {
            var queue = [].concat(actionQueue);
            actionQueue.length = 0;
            return queue;
          };
          var processDispatchQueue = function processDispatchQueue2() {
            var queue = [].concat(dispatchQueue);
            dispatchQueue.length = 0;
            queue.forEach(function(_ref) {
              var type = _ref.type, data2 = _ref.data;
              dispatch2(type, data2);
            });
          };
          var dispatch2 = function dispatch3(type, data2, isBlocking) {
            if (isBlocking && !document.hidden) {
              dispatchQueue.push({ type, data: data2 });
              return;
            }
            if (actionHandlers[type]) {
              actionHandlers[type](data2);
            }
            actionQueue.push({
              type,
              data: data2
            });
          };
          var query = function query2(str) {
            var _queryHandles;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return queryHandles[str] ? (_queryHandles = queryHandles)[str].apply(_queryHandles, args) : null;
          };
          var api = {
            getState,
            processActionQueue,
            processDispatchQueue,
            dispatch: dispatch2,
            query
          };
          var queryHandles = {};
          queries2.forEach(function(query2) {
            queryHandles = Object.assign({}, query2(state2), {}, queryHandles);
          });
          var actionHandlers = {};
          actions2.forEach(function(action) {
            actionHandlers = Object.assign({}, action(dispatch2, query, state2), {}, actionHandlers);
          });
          return api;
        };
        var defineProperty = function defineProperty2(obj, property, definition) {
          if (typeof definition === "function") {
            obj[property] = definition;
            return;
          }
          Object.defineProperty(obj, property, Object.assign({}, definition));
        };
        var forin = function forin2(obj, cb) {
          for (var key in obj) {
            if (!obj.hasOwnProperty(key)) {
              continue;
            }
            cb(key, obj[key]);
          }
        };
        var createObject = function createObject2(definition) {
          var obj = {};
          forin(definition, function(property) {
            defineProperty(obj, property, definition[property]);
          });
          return obj;
        };
        var attr2 = function attr3(node, name2) {
          var value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (value === null) {
            return node.getAttribute(name2) || node.hasAttribute(name2);
          }
          node.setAttribute(name2, value);
        };
        var ns = "http://www.w3.org/2000/svg";
        var svgElements = ["svg", "path"];
        var isSVGElement = function isSVGElement2(tag) {
          return svgElements.includes(tag);
        };
        var createElement = function createElement2(tag, className) {
          var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (typeof className === "object") {
            attributes = className;
            className = null;
          }
          var element = isSVGElement(tag) ? document.createElementNS(ns, tag) : document.createElement(tag);
          if (className) {
            if (isSVGElement(tag)) {
              attr2(element, "class", className);
            } else {
              element.className = className;
            }
          }
          forin(attributes, function(name2, value) {
            attr2(element, name2, value);
          });
          return element;
        };
        var appendChild = function appendChild2(parent2) {
          return function(child, index2) {
            if (typeof index2 !== "undefined" && parent2.children[index2]) {
              parent2.insertBefore(child, parent2.children[index2]);
            } else {
              parent2.appendChild(child);
            }
          };
        };
        var appendChildView = function appendChildView2(parent2, childViews) {
          return function(view, index2) {
            if (typeof index2 !== "undefined") {
              childViews.splice(index2, 0, view);
            } else {
              childViews.push(view);
            }
            return view;
          };
        };
        var removeChildView = function removeChildView2(parent2, childViews) {
          return function(view) {
            childViews.splice(childViews.indexOf(view), 1);
            if (view.element.parentNode) {
              parent2.removeChild(view.element);
            }
            return view;
          };
        };
        var IS_BROWSER = function() {
          return typeof window !== "undefined" && typeof window.document !== "undefined";
        }();
        var isBrowser = function isBrowser2() {
          return IS_BROWSER;
        };
        var testElement = isBrowser() ? createElement("svg") : {};
        var getChildCount = "children" in testElement ? function(el) {
          return el.children.length;
        } : function(el) {
          return el.childNodes.length;
        };
        var getViewRect = function getViewRect2(elementRect, childViews, offset2, scale) {
          var left = offset2[0] || elementRect.left;
          var top = offset2[1] || elementRect.top;
          var right = left + elementRect.width;
          var bottom = top + elementRect.height * (scale[1] || 1);
          var rect = {
            // the rectangle of the element itself
            element: Object.assign({}, elementRect),
            // the rectangle of the element expanded to contain its children, does not include any margins
            inner: {
              left: elementRect.left,
              top: elementRect.top,
              right: elementRect.right,
              bottom: elementRect.bottom
            },
            // the rectangle of the element expanded to contain its children including own margin and child margins
            // margins will be added after we've recalculated the size
            outer: {
              left,
              top,
              right,
              bottom
            }
          };
          childViews.filter(function(childView) {
            return !childView.isRectIgnored();
          }).map(function(childView) {
            return childView.rect;
          }).forEach(function(childViewRect) {
            expandRect(rect.inner, Object.assign({}, childViewRect.inner));
            expandRect(rect.outer, Object.assign({}, childViewRect.outer));
          });
          calculateRectSize(rect.inner);
          rect.outer.bottom += rect.element.marginBottom;
          rect.outer.right += rect.element.marginRight;
          calculateRectSize(rect.outer);
          return rect;
        };
        var expandRect = function expandRect2(parent2, child) {
          child.top += parent2.top;
          child.right += parent2.left;
          child.bottom += parent2.top;
          child.left += parent2.left;
          if (child.bottom > parent2.bottom) {
            parent2.bottom = child.bottom;
          }
          if (child.right > parent2.right) {
            parent2.right = child.right;
          }
        };
        var calculateRectSize = function calculateRectSize2(rect) {
          rect.width = rect.right - rect.left;
          rect.height = rect.bottom - rect.top;
        };
        var isNumber = function isNumber2(value) {
          return typeof value === "number";
        };
        var thereYet = function thereYet2(position, destination, velocity) {
          var errorMargin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e-3;
          return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;
        };
        var spring = (
          // default options
          function spring2() {
            var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$stiffness = _ref.stiffness, stiffness = _ref$stiffness === void 0 ? 0.5 : _ref$stiffness, _ref$damping = _ref.damping, damping = _ref$damping === void 0 ? 0.75 : _ref$damping, _ref$mass = _ref.mass, mass = _ref$mass === void 0 ? 10 : _ref$mass;
            var target = null;
            var position = null;
            var velocity = 0;
            var resting = false;
            var interpolate3 = function interpolate4(ts, skipToEndState) {
              if (resting) return;
              if (!(isNumber(target) && isNumber(position))) {
                resting = true;
                velocity = 0;
                return;
              }
              var f2 = -(position - target) * stiffness;
              velocity += f2 / mass;
              position += velocity;
              velocity *= damping;
              if (thereYet(position, target, velocity) || skipToEndState) {
                position = target;
                velocity = 0;
                resting = true;
                api.onupdate(position);
                api.oncomplete(position);
              } else {
                api.onupdate(position);
              }
            };
            var setTarget = function setTarget2(value) {
              if (isNumber(value) && !isNumber(position)) {
                position = value;
              }
              if (target === null) {
                target = value;
                position = value;
              }
              target = value;
              if (position === target || typeof target === "undefined") {
                resting = true;
                velocity = 0;
                api.onupdate(position);
                api.oncomplete(position);
                return;
              }
              resting = false;
            };
            var api = createObject({
              interpolate: interpolate3,
              target: {
                set: setTarget,
                get: function get() {
                  return target;
                }
              },
              resting: {
                get: function get() {
                  return resting;
                }
              },
              onupdate: function onupdate(value) {
              },
              oncomplete: function oncomplete(value) {
              }
            });
            return api;
          }
        );
        var easeLinear = function easeLinear2(t3) {
          return t3;
        };
        var easeInOutQuad = function easeInOutQuad2(t3) {
          return t3 < 0.5 ? 2 * t3 * t3 : -1 + (4 - 2 * t3) * t3;
        };
        var tween = (
          // default values
          function tween2() {
            var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 500 : _ref$duration, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? easeInOutQuad : _ref$easing, _ref$delay = _ref.delay, delay3 = _ref$delay === void 0 ? 0 : _ref$delay;
            var start = null;
            var t3;
            var p2;
            var resting = true;
            var reverse = false;
            var target = null;
            var interpolate3 = function interpolate4(ts, skipToEndState) {
              if (resting || target === null) return;
              if (start === null) {
                start = ts;
              }
              if (ts - start < delay3) return;
              t3 = ts - start - delay3;
              if (t3 >= duration || skipToEndState) {
                t3 = 1;
                p2 = reverse ? 0 : 1;
                api.onupdate(p2 * target);
                api.oncomplete(p2 * target);
                resting = true;
              } else {
                p2 = t3 / duration;
                api.onupdate((t3 >= 0 ? easing(reverse ? 1 - p2 : p2) : 0) * target);
              }
            };
            var api = createObject({
              interpolate: interpolate3,
              target: {
                get: function get() {
                  return reverse ? 0 : target;
                },
                set: function set3(value) {
                  if (target === null) {
                    target = value;
                    api.onupdate(value);
                    api.oncomplete(value);
                    return;
                  }
                  if (value < target) {
                    target = 1;
                    reverse = true;
                  } else {
                    reverse = false;
                    target = value;
                  }
                  resting = false;
                  start = null;
                }
              },
              resting: {
                get: function get() {
                  return resting;
                }
              },
              onupdate: function onupdate(value) {
              },
              oncomplete: function oncomplete(value) {
              }
            });
            return api;
          }
        );
        var animator = {
          spring,
          tween
        };
        var createAnimator = function createAnimator2(definition, category, property) {
          var def = definition[category] && typeof definition[category][property] === "object" ? definition[category][property] : definition[category] || definition;
          var type = typeof def === "string" ? def : def.type;
          var props = typeof def === "object" ? Object.assign({}, def) : {};
          return animator[type] ? animator[type](props) : null;
        };
        var addGetSet = function addGetSet2(keys, obj, props) {
          var overwrite = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          obj = Array.isArray(obj) ? obj : [obj];
          obj.forEach(function(o4) {
            keys.forEach(function(key) {
              var name2 = key;
              var getter = function getter2() {
                return props[key];
              };
              var setter = function setter2(value) {
                return props[key] = value;
              };
              if (typeof key === "object") {
                name2 = key.key;
                getter = key.getter || getter;
                setter = key.setter || setter;
              }
              if (o4[name2] && !overwrite) {
                return;
              }
              o4[name2] = {
                get: getter,
                set: setter
              };
            });
          });
        };
        var animations = function animations2(_ref) {
          var mixinConfig = _ref.mixinConfig, viewProps = _ref.viewProps, viewInternalAPI = _ref.viewInternalAPI, viewExternalAPI = _ref.viewExternalAPI;
          var initialProps = Object.assign({}, viewProps);
          var animations3 = [];
          forin(mixinConfig, function(property, animation) {
            var animator2 = createAnimator(animation);
            if (!animator2) {
              return;
            }
            animator2.onupdate = function(value) {
              viewProps[property] = value;
            };
            animator2.target = initialProps[property];
            var prop = {
              key: property,
              setter: function setter(value) {
                if (animator2.target === value) {
                  return;
                }
                animator2.target = value;
              },
              getter: function getter() {
                return viewProps[property];
              }
            };
            addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);
            animations3.push(animator2);
          });
          return {
            write: function write2(ts) {
              var skipToEndState = document.hidden;
              var resting = true;
              animations3.forEach(function(animation) {
                if (!animation.resting) resting = false;
                animation.interpolate(ts, skipToEndState);
              });
              return resting;
            },
            destroy: function destroy() {
            }
          };
        };
        var addEvent = function addEvent2(element) {
          return function(type, fn2) {
            element.addEventListener(type, fn2);
          };
        };
        var removeEvent = function removeEvent2(element) {
          return function(type, fn2) {
            element.removeEventListener(type, fn2);
          };
        };
        var listeners = function listeners2(_ref) {
          var mixinConfig = _ref.mixinConfig, viewProps = _ref.viewProps, viewInternalAPI = _ref.viewInternalAPI, viewExternalAPI = _ref.viewExternalAPI, viewState = _ref.viewState, view = _ref.view;
          var events2 = [];
          var add = addEvent(view.element);
          var remove2 = removeEvent(view.element);
          viewExternalAPI.on = function(type, fn2) {
            events2.push({
              type,
              fn: fn2
            });
            add(type, fn2);
          };
          viewExternalAPI.off = function(type, fn2) {
            events2.splice(
              events2.findIndex(function(event2) {
                return event2.type === type && event2.fn === fn2;
              }),
              1
            );
            remove2(type, fn2);
          };
          return {
            write: function write2() {
              return true;
            },
            destroy: function destroy() {
              events2.forEach(function(event2) {
                remove2(event2.type, event2.fn);
              });
            }
          };
        };
        var apis = function apis2(_ref) {
          var mixinConfig = _ref.mixinConfig, viewProps = _ref.viewProps, viewExternalAPI = _ref.viewExternalAPI;
          addGetSet(mixinConfig, viewExternalAPI, viewProps);
        };
        var isDefined = function isDefined2(value) {
          return value != null;
        };
        var defaults2 = {
          opacity: 1,
          scaleX: 1,
          scaleY: 1,
          translateX: 0,
          translateY: 0,
          rotateX: 0,
          rotateY: 0,
          rotateZ: 0,
          originX: 0,
          originY: 0
        };
        var styles2 = function styles3(_ref) {
          var mixinConfig = _ref.mixinConfig, viewProps = _ref.viewProps, viewInternalAPI = _ref.viewInternalAPI, viewExternalAPI = _ref.viewExternalAPI, view = _ref.view;
          var initialProps = Object.assign({}, viewProps);
          var currentProps = {};
          addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);
          var getOffset = function getOffset2() {
            return [viewProps["translateX"] || 0, viewProps["translateY"] || 0];
          };
          var getScale = function getScale2() {
            return [viewProps["scaleX"] || 0, viewProps["scaleY"] || 0];
          };
          var getRect = function getRect2() {
            return view.rect ? getViewRect(view.rect, view.childViews, getOffset(), getScale()) : null;
          };
          viewInternalAPI.rect = { get: getRect };
          viewExternalAPI.rect = { get: getRect };
          mixinConfig.forEach(function(key) {
            viewProps[key] = typeof initialProps[key] === "undefined" ? defaults2[key] : initialProps[key];
          });
          return {
            write: function write2() {
              if (!propsHaveChanged(currentProps, viewProps)) {
                return;
              }
              applyStyles(view.element, viewProps);
              Object.assign(currentProps, Object.assign({}, viewProps));
              return true;
            },
            destroy: function destroy() {
            }
          };
        };
        var propsHaveChanged = function propsHaveChanged2(currentProps, newProps) {
          if (Object.keys(currentProps).length !== Object.keys(newProps).length) {
            return true;
          }
          for (var prop in newProps) {
            if (newProps[prop] !== currentProps[prop]) {
              return true;
            }
          }
          return false;
        };
        var applyStyles = function applyStyles2(element, _ref2) {
          var opacity = _ref2.opacity, perspective = _ref2.perspective, translateX = _ref2.translateX, translateY = _ref2.translateY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, rotateX = _ref2.rotateX, rotateY = _ref2.rotateY, rotateZ = _ref2.rotateZ, originX = _ref2.originX, originY = _ref2.originY, width = _ref2.width, height = _ref2.height;
          var transforms = "";
          var styles3 = "";
          if (isDefined(originX) || isDefined(originY)) {
            styles3 += "transform-origin: " + (originX || 0) + "px " + (originY || 0) + "px;";
          }
          if (isDefined(perspective)) {
            transforms += "perspective(" + perspective + "px) ";
          }
          if (isDefined(translateX) || isDefined(translateY)) {
            transforms += "translate3d(" + (translateX || 0) + "px, " + (translateY || 0) + "px, 0) ";
          }
          if (isDefined(scaleX) || isDefined(scaleY)) {
            transforms += "scale3d(" + (isDefined(scaleX) ? scaleX : 1) + ", " + (isDefined(scaleY) ? scaleY : 1) + ", 1) ";
          }
          if (isDefined(rotateZ)) {
            transforms += "rotateZ(" + rotateZ + "rad) ";
          }
          if (isDefined(rotateX)) {
            transforms += "rotateX(" + rotateX + "rad) ";
          }
          if (isDefined(rotateY)) {
            transforms += "rotateY(" + rotateY + "rad) ";
          }
          if (transforms.length) {
            styles3 += "transform:" + transforms + ";";
          }
          if (isDefined(opacity)) {
            styles3 += "opacity:" + opacity + ";";
            if (opacity === 0) {
              styles3 += "visibility:hidden;";
            }
            if (opacity < 1) {
              styles3 += "pointer-events:none;";
            }
          }
          if (isDefined(height)) {
            styles3 += "height:" + height + "px;";
          }
          if (isDefined(width)) {
            styles3 += "width:" + width + "px;";
          }
          var elementCurrentStyle = element.elementCurrentStyle || "";
          if (styles3.length !== elementCurrentStyle.length || styles3 !== elementCurrentStyle) {
            element.style.cssText = styles3;
            element.elementCurrentStyle = styles3;
          }
        };
        var Mixins = {
          styles: styles2,
          listeners,
          animations,
          apis
        };
        var updateRect = function updateRect2() {
          var rect = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var element = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var style = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (!element.layoutCalculated) {
            rect.paddingTop = parseInt(style.paddingTop, 10) || 0;
            rect.marginTop = parseInt(style.marginTop, 10) || 0;
            rect.marginRight = parseInt(style.marginRight, 10) || 0;
            rect.marginBottom = parseInt(style.marginBottom, 10) || 0;
            rect.marginLeft = parseInt(style.marginLeft, 10) || 0;
            element.layoutCalculated = true;
          }
          rect.left = element.offsetLeft || 0;
          rect.top = element.offsetTop || 0;
          rect.width = element.offsetWidth || 0;
          rect.height = element.offsetHeight || 0;
          rect.right = rect.left + rect.width;
          rect.bottom = rect.top + rect.height;
          rect.scrollTop = element.scrollTop;
          rect.hidden = element.offsetParent === null;
          return rect;
        };
        var createView = (
          // default view definition
          function createView2() {
            var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$tag = _ref.tag, tag = _ref$tag === void 0 ? "div" : _ref$tag, _ref$name = _ref.name, name2 = _ref$name === void 0 ? null : _ref$name, _ref$attributes = _ref.attributes, attributes = _ref$attributes === void 0 ? {} : _ref$attributes, _ref$read = _ref.read, read = _ref$read === void 0 ? function() {
            } : _ref$read, _ref$write = _ref.write, write2 = _ref$write === void 0 ? function() {
            } : _ref$write, _ref$create = _ref.create, create2 = _ref$create === void 0 ? function() {
            } : _ref$create, _ref$destroy = _ref.destroy, destroy = _ref$destroy === void 0 ? function() {
            } : _ref$destroy, _ref$filterFrameActio = _ref.filterFrameActionsForChild, filterFrameActionsForChild = _ref$filterFrameActio === void 0 ? function(child, actions2) {
              return actions2;
            } : _ref$filterFrameActio, _ref$didCreateView = _ref.didCreateView, didCreateView = _ref$didCreateView === void 0 ? function() {
            } : _ref$didCreateView, _ref$didWriteView = _ref.didWriteView, didWriteView = _ref$didWriteView === void 0 ? function() {
            } : _ref$didWriteView, _ref$ignoreRect = _ref.ignoreRect, ignoreRect = _ref$ignoreRect === void 0 ? false : _ref$ignoreRect, _ref$ignoreRectUpdate = _ref.ignoreRectUpdate, ignoreRectUpdate = _ref$ignoreRectUpdate === void 0 ? false : _ref$ignoreRectUpdate, _ref$mixins = _ref.mixins, mixins = _ref$mixins === void 0 ? [] : _ref$mixins;
            return function(store) {
              var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var element = createElement(tag, "filepond--" + name2, attributes);
              var style = window.getComputedStyle(element, null);
              var rect = updateRect();
              var frameRect = null;
              var isResting = false;
              var childViews = [];
              var activeMixins = [];
              var ref2 = {};
              var state2 = {};
              var writers = [
                write2
                // default writer
              ];
              var readers = [
                read
                // default reader
              ];
              var destroyers = [
                destroy
                // default destroy
              ];
              var getElement = function getElement2() {
                return element;
              };
              var getChildViews = function getChildViews2() {
                return childViews.concat();
              };
              var getReference = function getReference2() {
                return ref2;
              };
              var createChildView = function createChildView2(store2) {
                return function(view, props2) {
                  return view(store2, props2);
                };
              };
              var getRect = function getRect2() {
                if (frameRect) {
                  return frameRect;
                }
                frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);
                return frameRect;
              };
              var getStyle = function getStyle2() {
                return style;
              };
              var _read = function _read2() {
                frameRect = null;
                childViews.forEach(function(child) {
                  return child._read();
                });
                var shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);
                if (shouldUpdate) {
                  updateRect(rect, element, style);
                }
                var api = { root: internalAPI, props, rect };
                readers.forEach(function(reader) {
                  return reader(api);
                });
              };
              var _write = function _write2(ts, frameActions, shouldOptimize) {
                var resting = frameActions.length === 0;
                writers.forEach(function(writer) {
                  var writerResting = writer({
                    props,
                    root: internalAPI,
                    actions: frameActions,
                    timestamp: ts,
                    shouldOptimize
                  });
                  if (writerResting === false) {
                    resting = false;
                  }
                });
                activeMixins.forEach(function(mixin) {
                  var mixinResting = mixin.write(ts);
                  if (mixinResting === false) {
                    resting = false;
                  }
                });
                childViews.filter(function(child) {
                  return !!child.element.parentNode;
                }).forEach(function(child) {
                  var childResting = child._write(
                    ts,
                    filterFrameActionsForChild(child, frameActions),
                    shouldOptimize
                  );
                  if (!childResting) {
                    resting = false;
                  }
                });
                childViews.forEach(function(child, index2) {
                  if (child.element.parentNode) {
                    return;
                  }
                  internalAPI.appendChild(child.element, index2);
                  child._read();
                  child._write(
                    ts,
                    filterFrameActionsForChild(child, frameActions),
                    shouldOptimize
                  );
                  resting = false;
                });
                isResting = resting;
                didWriteView({
                  props,
                  root: internalAPI,
                  actions: frameActions,
                  timestamp: ts
                });
                return resting;
              };
              var _destroy = function _destroy2() {
                activeMixins.forEach(function(mixin) {
                  return mixin.destroy();
                });
                destroyers.forEach(function(destroyer) {
                  destroyer({ root: internalAPI, props });
                });
                childViews.forEach(function(child) {
                  return child._destroy();
                });
              };
              var sharedAPIDefinition = {
                element: {
                  get: getElement
                },
                style: {
                  get: getStyle
                },
                childViews: {
                  get: getChildViews
                }
              };
              var internalAPIDefinition = Object.assign({}, sharedAPIDefinition, {
                rect: {
                  get: getRect
                },
                // access to custom children references
                ref: {
                  get: getReference
                },
                // dom modifiers
                is: function is2(needle) {
                  return name2 === needle;
                },
                appendChild: appendChild(element),
                createChildView: createChildView(store),
                linkView: function linkView(view) {
                  childViews.push(view);
                  return view;
                },
                unlinkView: function unlinkView(view) {
                  childViews.splice(childViews.indexOf(view), 1);
                },
                appendChildView: appendChildView(element, childViews),
                removeChildView: removeChildView(element, childViews),
                registerWriter: function registerWriter(writer) {
                  return writers.push(writer);
                },
                registerReader: function registerReader(reader) {
                  return readers.push(reader);
                },
                registerDestroyer: function registerDestroyer(destroyer) {
                  return destroyers.push(destroyer);
                },
                invalidateLayout: function invalidateLayout() {
                  return element.layoutCalculated = false;
                },
                // access to data store
                dispatch: store.dispatch,
                query: store.query
              });
              var externalAPIDefinition = {
                element: {
                  get: getElement
                },
                childViews: {
                  get: getChildViews
                },
                rect: {
                  get: getRect
                },
                resting: {
                  get: function get() {
                    return isResting;
                  }
                },
                isRectIgnored: function isRectIgnored() {
                  return ignoreRect;
                },
                _read,
                _write,
                _destroy
              };
              var mixinAPIDefinition = Object.assign({}, sharedAPIDefinition, {
                rect: {
                  get: function get() {
                    return rect;
                  }
                }
              });
              Object.keys(mixins).sort(function(a3, b2) {
                if (a3 === "styles") {
                  return 1;
                } else if (b2 === "styles") {
                  return -1;
                }
                return 0;
              }).forEach(function(key) {
                var mixinAPI = Mixins[key]({
                  mixinConfig: mixins[key],
                  viewProps: props,
                  viewState: state2,
                  viewInternalAPI: internalAPIDefinition,
                  viewExternalAPI: externalAPIDefinition,
                  view: createObject(mixinAPIDefinition)
                });
                if (mixinAPI) {
                  activeMixins.push(mixinAPI);
                }
              });
              var internalAPI = createObject(internalAPIDefinition);
              create2({
                root: internalAPI,
                props
              });
              var childCount = getChildCount(element);
              childViews.forEach(function(child, index2) {
                internalAPI.appendChild(child.element, childCount + index2);
              });
              didCreateView(internalAPI);
              return createObject(externalAPIDefinition);
            };
          }
        );
        var createPainter = function createPainter2(read, write2) {
          var fps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 60;
          var name2 = "__framePainter";
          if (window[name2]) {
            window[name2].readers.push(read);
            window[name2].writers.push(write2);
            return;
          }
          window[name2] = {
            readers: [read],
            writers: [write2]
          };
          var painter = window[name2];
          var interval = 1e3 / fps;
          var last = null;
          var id2 = null;
          var requestTick = null;
          var cancelTick = null;
          var setTimerType = function setTimerType2() {
            if (document.hidden) {
              requestTick = function requestTick2() {
                return window.setTimeout(function() {
                  return tick(performance.now());
                }, interval);
              };
              cancelTick = function cancelTick2() {
                return window.clearTimeout(id2);
              };
            } else {
              requestTick = function requestTick2() {
                return window.requestAnimationFrame(tick);
              };
              cancelTick = function cancelTick2() {
                return window.cancelAnimationFrame(id2);
              };
            }
          };
          document.addEventListener("visibilitychange", function() {
            if (cancelTick) cancelTick();
            setTimerType();
            tick(performance.now());
          });
          var tick = function tick2(ts) {
            id2 = requestTick(tick2);
            if (!last) {
              last = ts;
            }
            var delta = ts - last;
            if (delta <= interval) {
              return;
            }
            last = ts - delta % interval;
            painter.readers.forEach(function(read2) {
              return read2();
            });
            painter.writers.forEach(function(write3) {
              return write3(ts);
            });
          };
          setTimerType();
          tick(performance.now());
          return {
            pause: function pause() {
              cancelTick(id2);
            }
          };
        };
        var createRoute = function createRoute2(routes, fn2) {
          return function(_ref) {
            var root2 = _ref.root, props = _ref.props, _ref$actions = _ref.actions, actions2 = _ref$actions === void 0 ? [] : _ref$actions, timestamp = _ref.timestamp, shouldOptimize = _ref.shouldOptimize;
            actions2.filter(function(action) {
              return routes[action.type];
            }).forEach(function(action) {
              return routes[action.type]({
                root: root2,
                props,
                action: action.data,
                timestamp,
                shouldOptimize
              });
            });
            if (fn2) {
              fn2({
                root: root2,
                props,
                actions: actions2,
                timestamp,
                shouldOptimize
              });
            }
          };
        };
        var insertBefore = function insertBefore2(newNode, referenceNode) {
          return referenceNode.parentNode.insertBefore(newNode, referenceNode);
        };
        var insertAfter = function insertAfter2(newNode, referenceNode) {
          return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
        };
        var isArray3 = function isArray4(value) {
          return Array.isArray(value);
        };
        var isEmpty = function isEmpty2(value) {
          return value == null;
        };
        var trim = function trim2(str) {
          return str.trim();
        };
        var toString = function toString2(value) {
          return "" + value;
        };
        var toArray3 = function toArray4(value) {
          var splitter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
          if (isEmpty(value)) {
            return [];
          }
          if (isArray3(value)) {
            return value;
          }
          return toString(value).split(splitter).map(trim).filter(function(str) {
            return str.length;
          });
        };
        var isBoolean = function isBoolean2(value) {
          return typeof value === "boolean";
        };
        var toBoolean = function toBoolean2(value) {
          return isBoolean(value) ? value : value === "true";
        };
        var isString2 = function isString3(value) {
          return typeof value === "string";
        };
        var toNumber = function toNumber2(value) {
          return isNumber(value) ? value : isString2(value) ? toString(value).replace(/[a-z]+/gi, "") : 0;
        };
        var toInt = function toInt2(value) {
          return parseInt(toNumber(value), 10);
        };
        var toFloat = function toFloat2(value) {
          return parseFloat(toNumber(value));
        };
        var isInt = function isInt2(value) {
          return isNumber(value) && isFinite(value) && Math.floor(value) === value;
        };
        var toBytes = function toBytes2(value) {
          var base = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
          if (isInt(value)) {
            return value;
          }
          var naturalFileSize = toString(value).trim();
          if (/MB$/i.test(naturalFileSize)) {
            naturalFileSize = naturalFileSize.replace(/MB$i/, "").trim();
            return toInt(naturalFileSize) * base * base;
          }
          if (/KB/i.test(naturalFileSize)) {
            naturalFileSize = naturalFileSize.replace(/KB$i/, "").trim();
            return toInt(naturalFileSize) * base;
          }
          return toInt(naturalFileSize);
        };
        var isFunction2 = function isFunction3(value) {
          return typeof value === "function";
        };
        var toFunctionReference = function toFunctionReference2(string) {
          var ref2 = self;
          var levels = string.split(".");
          var level = null;
          while (level = levels.shift()) {
            ref2 = ref2[level];
            if (!ref2) {
              return null;
            }
          }
          return ref2;
        };
        var methods = {
          process: "POST",
          patch: "PATCH",
          revert: "DELETE",
          fetch: "GET",
          restore: "GET",
          load: "GET"
        };
        var createServerAPI = function createServerAPI2(outline) {
          var api = {};
          api.url = isString2(outline) ? outline : outline.url || "";
          api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;
          api.headers = outline.headers ? outline.headers : {};
          forin(methods, function(key) {
            api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);
          });
          api.process = outline.process || isString2(outline) || outline.url ? api.process : null;
          api.remove = outline.remove || null;
          delete api.headers;
          return api;
        };
        var createAction = function createAction2(name2, outline, method, timeout, headers) {
          if (outline === null) {
            return null;
          }
          if (typeof outline === "function") {
            return outline;
          }
          var action = {
            url: method === "GET" || method === "PATCH" ? "?" + name2 + "=" : "",
            method,
            headers,
            withCredentials: false,
            timeout,
            onload: null,
            ondata: null,
            onerror: null
          };
          if (isString2(outline)) {
            action.url = outline;
            return action;
          }
          Object.assign(action, outline);
          if (isString2(action.headers)) {
            var parts = action.headers.split(/:(.+)/);
            action.headers = {
              header: parts[0],
              value: parts[1]
            };
          }
          action.withCredentials = toBoolean(action.withCredentials);
          return action;
        };
        var toServerAPI = function toServerAPI2(value) {
          return createServerAPI(value);
        };
        var isNull = function isNull2(value) {
          return value === null;
        };
        var isObject3 = function isObject4(value) {
          return typeof value === "object" && value !== null;
        };
        var isAPI = function isAPI2(value) {
          return isObject3(value) && isString2(value.url) && isObject3(value.process) && isObject3(value.revert) && isObject3(value.restore) && isObject3(value.fetch);
        };
        var getType = function getType2(value) {
          if (isArray3(value)) {
            return "array";
          }
          if (isNull(value)) {
            return "null";
          }
          if (isInt(value)) {
            return "int";
          }
          if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {
            return "bytes";
          }
          if (isAPI(value)) {
            return "api";
          }
          return typeof value;
        };
        var replaceSingleQuotes = function replaceSingleQuotes2(str) {
          return str.replace(/{\s*'/g, '{"').replace(/'\s*}/g, '"}').replace(/'\s*:/g, '":').replace(/:\s*'/g, ':"').replace(/,\s*'/g, ',"').replace(/'\s*,/g, '",');
        };
        var conversionTable = {
          array: toArray3,
          boolean: toBoolean,
          int: function int(value) {
            return getType(value) === "bytes" ? toBytes(value) : toInt(value);
          },
          number: toFloat,
          float: toFloat,
          bytes: toBytes,
          string: function string(value) {
            return isFunction2(value) ? value : toString(value);
          },
          function: function _function(value) {
            return toFunctionReference(value);
          },
          serverapi: toServerAPI,
          object: function object(value) {
            try {
              return JSON.parse(replaceSingleQuotes(value));
            } catch (e4) {
              return null;
            }
          }
        };
        var convertTo = function convertTo2(value, type) {
          return conversionTable[type](value);
        };
        var getValueByType = function getValueByType2(newValue, defaultValue, valueType) {
          if (newValue === defaultValue) {
            return newValue;
          }
          var newValueType = getType(newValue);
          if (newValueType !== valueType) {
            var convertedValue = convertTo(newValue, valueType);
            newValueType = getType(convertedValue);
            if (convertedValue === null) {
              throw 'Trying to assign value with incorrect type to "' + option + '", allowed type: "' + valueType + '"';
            } else {
              newValue = convertedValue;
            }
          }
          return newValue;
        };
        var createOption = function createOption2(defaultValue, valueType) {
          var currentValue = defaultValue;
          return {
            enumerable: true,
            get: function get() {
              return currentValue;
            },
            set: function set3(newValue) {
              currentValue = getValueByType(newValue, defaultValue, valueType);
            }
          };
        };
        var createOptions = function createOptions2(options) {
          var obj = {};
          forin(options, function(prop) {
            var optionDefinition = options[prop];
            obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);
          });
          return createObject(obj);
        };
        var createInitialState = function createInitialState2(options) {
          return {
            // model
            items: [],
            // timeout used for calling update items
            listUpdateTimeout: null,
            // timeout used for stacking metadata updates
            itemUpdateTimeout: null,
            // queue of items waiting to be processed
            processingQueue: [],
            // options
            options: createOptions(options)
          };
        };
        var fromCamels = function fromCamels2(string) {
          var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "-";
          return string.split(/(?=[A-Z])/).map(function(part) {
            return part.toLowerCase();
          }).join(separator);
        };
        var createOptionAPI = function createOptionAPI2(store, options) {
          var obj = {};
          forin(options, function(key) {
            obj[key] = {
              get: function get() {
                return store.getState().options[key];
              },
              set: function set3(value) {
                store.dispatch("SET_" + fromCamels(key, "_").toUpperCase(), {
                  value
                });
              }
            };
          });
          return obj;
        };
        var createOptionActions = function createOptionActions2(options) {
          return function(dispatch2, query, state2) {
            var obj = {};
            forin(options, function(key) {
              var name2 = fromCamels(key, "_").toUpperCase();
              obj["SET_" + name2] = function(action) {
                try {
                  state2.options[key] = action.value;
                } catch (e4) {
                }
                dispatch2("DID_SET_" + name2, { value: state2.options[key] });
              };
            });
            return obj;
          };
        };
        var createOptionQueries = function createOptionQueries2(options) {
          return function(state2) {
            var obj = {};
            forin(options, function(key) {
              obj["GET_" + fromCamels(key, "_").toUpperCase()] = function(action) {
                return state2.options[key];
              };
            });
            return obj;
          };
        };
        var InteractionMethod = {
          API: 1,
          DROP: 2,
          BROWSE: 3,
          PASTE: 4,
          NONE: 5
        };
        var getUniqueId = function getUniqueId2() {
          return Math.random().toString(36).substring(2, 11);
        };
        function _typeof2(obj) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var REACT_ELEMENT_TYPE;
        function _jsx(type, props, key, children2) {
          if (!REACT_ELEMENT_TYPE) {
            REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 60103;
          }
          var defaultProps = type && type.defaultProps;
          var childrenLength = arguments.length - 3;
          if (!props && childrenLength !== 0) {
            props = {
              children: void 0
            };
          }
          if (props && defaultProps) {
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          } else if (!props) {
            props = defaultProps || {};
          }
          if (childrenLength === 1) {
            props.children = children2;
          } else if (childrenLength > 1) {
            var childArray = new Array(childrenLength);
            for (var i4 = 0; i4 < childrenLength; i4++) {
              childArray[i4] = arguments[i4 + 3];
            }
            props.children = childArray;
          }
          return {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key: key === void 0 ? null : "" + key,
            ref: null,
            props,
            _owner: null
          };
        }
        function _asyncIterator(iterable) {
          var method;
          if (typeof Symbol !== "undefined") {
            if (Symbol.asyncIterator) {
              method = iterable[Symbol.asyncIterator];
              if (method != null) return method.call(iterable);
            }
            if (Symbol.iterator) {
              method = iterable[Symbol.iterator];
              if (method != null) return method.call(iterable);
            }
          }
          throw new TypeError("Object is not async iterable");
        }
        function _AwaitValue(value) {
          this.wrapped = value;
        }
        function _AsyncGenerator(gen) {
          var front, back;
          function send(key, arg) {
            return new Promise(function(resolve, reject) {
              var request = {
                key,
                arg,
                resolve,
                reject,
                next: null
              };
              if (back) {
                back = back.next = request;
              } else {
                front = back = request;
                resume(key, arg);
              }
            });
          }
          function resume(key, arg) {
            try {
              var result = gen[key](arg);
              var value = result.value;
              var wrappedAwait = value instanceof _AwaitValue;
              Promise.resolve(wrappedAwait ? value.wrapped : value).then(
                function(arg2) {
                  if (wrappedAwait) {
                    resume("next", arg2);
                    return;
                  }
                  settle(result.done ? "return" : "normal", arg2);
                },
                function(err) {
                  resume("throw", err);
                }
              );
            } catch (err) {
              settle("throw", err);
            }
          }
          function settle(type, value) {
            switch (type) {
              case "return":
                front.resolve({
                  value,
                  done: true
                });
                break;
              case "throw":
                front.reject(value);
                break;
              default:
                front.resolve({
                  value,
                  done: false
                });
                break;
            }
            front = front.next;
            if (front) {
              resume(front.key, front.arg);
            } else {
              back = null;
            }
          }
          this._invoke = send;
          if (typeof gen.return !== "function") {
            this.return = void 0;
          }
        }
        if (typeof Symbol === "function" && Symbol.asyncIterator) {
          _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
            return this;
          };
        }
        _AsyncGenerator.prototype.next = function(arg) {
          return this._invoke("next", arg);
        };
        _AsyncGenerator.prototype.throw = function(arg) {
          return this._invoke("throw", arg);
        };
        _AsyncGenerator.prototype.return = function(arg) {
          return this._invoke("return", arg);
        };
        function _wrapAsyncGenerator(fn2) {
          return function() {
            return new _AsyncGenerator(fn2.apply(this, arguments));
          };
        }
        function _awaitAsyncGenerator(value) {
          return new _AwaitValue(value);
        }
        function _asyncGeneratorDelegate(inner, awaitWrap) {
          var iter = {}, waiting = false;
          function pump(key, value) {
            waiting = true;
            value = new Promise(function(resolve) {
              resolve(inner[key](value));
            });
            return {
              done: false,
              value: awaitWrap(value)
            };
          }
          if (typeof Symbol === "function" && Symbol.iterator) {
            iter[Symbol.iterator] = function() {
              return this;
            };
          }
          iter.next = function(value) {
            if (waiting) {
              waiting = false;
              return value;
            }
            return pump("next", value);
          };
          if (typeof inner.throw === "function") {
            iter.throw = function(value) {
              if (waiting) {
                waiting = false;
                throw value;
              }
              return pump("throw", value);
            };
          }
          if (typeof inner.return === "function") {
            iter.return = function(value) {
              return pump("return", value);
            };
          }
          return iter;
        }
        function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error2) {
            reject(error2);
            return;
          }
          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }
        function _asyncToGenerator(fn2) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve, reject) {
              var gen = fn2.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target, props) {
          for (var i4 = 0; i4 < props.length; i4++) {
            var descriptor = props[i4];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _defineEnumerableProperties(obj, descs) {
          for (var key in descs) {
            var desc = descs[key];
            desc.configurable = desc.enumerable = true;
            if ("value" in desc) desc.writable = true;
            Object.defineProperty(obj, key, desc);
          }
          if (Object.getOwnPropertySymbols) {
            var objectSymbols = Object.getOwnPropertySymbols(descs);
            for (var i4 = 0; i4 < objectSymbols.length; i4++) {
              var sym = objectSymbols[i4];
              var desc = descs[sym];
              desc.configurable = desc.enumerable = true;
              if ("value" in desc) desc.writable = true;
              Object.defineProperty(obj, sym, desc);
            }
          }
          return obj;
        }
        function _defaults2(obj, defaults3) {
          var keys = Object.getOwnPropertyNames(defaults3);
          for (var i4 = 0; i4 < keys.length; i4++) {
            var key = keys[i4];
            var value = Object.getOwnPropertyDescriptor(defaults3, key);
            if (value && value.configurable && obj[key] === void 0) {
              Object.defineProperty(obj, key, value);
            }
          }
          return obj;
        }
        function _defineProperty3(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _extends2() {
          _extends2 = Object.assign || function(target) {
            for (var i4 = 1; i4 < arguments.length; i4++) {
              var source = arguments[i4];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends2.apply(this, arguments);
        }
        function _objectSpread(target) {
          for (var i4 = 1; i4 < arguments.length; i4++) {
            var source = arguments[i4] != null ? arguments[i4] : {};
            var ownKeys3 = Object.keys(source);
            if (typeof Object.getOwnPropertySymbols === "function") {
              ownKeys3 = ownKeys3.concat(
                Object.getOwnPropertySymbols(source).filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })
              );
            }
            ownKeys3.forEach(function(key) {
              _defineProperty3(target, key, source[key]);
            });
          }
          return target;
        }
        function ownKeys2(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread22(target) {
          for (var i4 = 1; i4 < arguments.length; i4++) {
            var source = arguments[i4] != null ? arguments[i4] : {};
            if (i4 % 2) {
              ownKeys2(source, true).forEach(function(key) {
                _defineProperty3(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys2(source).forEach(function(key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                );
              });
            }
          }
          return target;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        function _getPrototypeOf(o4) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o5) {
            return o5.__proto__ || Object.getPrototypeOf(o5);
          };
          return _getPrototypeOf(o4);
        }
        function _setPrototypeOf(o4, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o5, p3) {
            o5.__proto__ = p3;
            return o5;
          };
          return _setPrototypeOf(o4, p2);
        }
        function isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e4) {
            return false;
          }
        }
        function _construct(Parent, args, Class) {
          if (isNativeReflectConstruct()) {
            _construct = Reflect.construct;
          } else {
            _construct = function _construct2(Parent2, args2, Class2) {
              var a3 = [null];
              a3.push.apply(a3, args2);
              var Constructor = Function.bind.apply(Parent2, a3);
              var instance = new Constructor();
              if (Class2) _setPrototypeOf(instance, Class2.prototype);
              return instance;
            };
          }
          return _construct.apply(null, arguments);
        }
        function _isNativeFunction(fn2) {
          return Function.toString.call(fn2).indexOf("[native code]") !== -1;
        }
        function _wrapNativeSuper(Class) {
          var _cache2 = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
          _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
            if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
            if (typeof Class2 !== "function") {
              throw new TypeError("Super expression must either be null or a function");
            }
            if (typeof _cache2 !== "undefined") {
              if (_cache2.has(Class2)) return _cache2.get(Class2);
              _cache2.set(Class2, Wrapper);
            }
            function Wrapper() {
              return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
            }
            Wrapper.prototype = Object.create(Class2.prototype, {
              constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            return _setPrototypeOf(Wrapper, Class2);
          };
          return _wrapNativeSuper(Class);
        }
        function _instanceof(left, right) {
          if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
            return !!right[Symbol.hasInstance](left);
          } else {
            return left instanceof right;
          }
        }
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            default: obj
          };
        }
        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};
            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
                  if (desc.get || desc.set) {
                    Object.defineProperty(newObj, key, desc);
                  } else {
                    newObj[key] = obj[key];
                  }
                }
              }
            }
            newObj.default = obj;
            return newObj;
          }
        }
        function _newArrowCheck(innerThis, boundThis) {
          if (innerThis !== boundThis) {
            throw new TypeError("Cannot instantiate an arrow function");
          }
        }
        function _objectDestructuringEmpty(obj) {
          if (obj == null) throw new TypeError("Cannot destructure undefined");
        }
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null) return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i4;
          for (i4 = 0; i4 < sourceKeys.length; i4++) {
            key = sourceKeys[i4];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
          }
          return target;
        }
        function _objectWithoutProperties(source, excluded) {
          if (source == null) return {};
          var target = _objectWithoutPropertiesLoose(source, excluded);
          var key, i4;
          if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
            for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
              key = sourceSymbolKeys[i4];
              if (excluded.indexOf(key) >= 0) continue;
              if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
              target[key] = source[key];
            }
          }
          return target;
        }
        function _assertThisInitialized2(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _possibleConstructorReturn(self2, call) {
          if (call && (typeof call === "object" || typeof call === "function")) {
            return call;
          }
          return _assertThisInitialized2(self2);
        }
        function _superPropBase(object, property) {
          while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf(object);
            if (object === null) break;
          }
          return object;
        }
        function _get3(target, property, receiver) {
          if (typeof Reflect !== "undefined" && Reflect.get) {
            _get3 = Reflect.get;
          } else {
            _get3 = function _get4(target2, property2, receiver2) {
              var base = _superPropBase(target2, property2);
              if (!base) return;
              var desc = Object.getOwnPropertyDescriptor(base, property2);
              if (desc.get) {
                return desc.get.call(receiver2);
              }
              return desc.value;
            };
          }
          return _get3(target, property, receiver || target);
        }
        function set2(target, property, value, receiver) {
          if (typeof Reflect !== "undefined" && Reflect.set) {
            set2 = Reflect.set;
          } else {
            set2 = function set3(target2, property2, value2, receiver2) {
              var base = _superPropBase(target2, property2);
              var desc;
              if (base) {
                desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.set) {
                  desc.set.call(receiver2, value2);
                  return true;
                } else if (!desc.writable) {
                  return false;
                }
              }
              desc = Object.getOwnPropertyDescriptor(receiver2, property2);
              if (desc) {
                if (!desc.writable) {
                  return false;
                }
                desc.value = value2;
                Object.defineProperty(receiver2, property2, desc);
              } else {
                _defineProperty3(receiver2, property2, value2);
              }
              return true;
            };
          }
          return set2(target, property, value, receiver);
        }
        function _set(target, property, value, receiver, isStrict) {
          var s4 = set2(target, property, value, receiver || target);
          if (!s4 && isStrict) {
            throw new Error("failed to set property");
          }
          return value;
        }
        function _taggedTemplateLiteral(strings, raw) {
          if (!raw) {
            raw = strings.slice(0);
          }
          return Object.freeze(
            Object.defineProperties(strings, {
              raw: {
                value: Object.freeze(raw)
              }
            })
          );
        }
        function _taggedTemplateLiteralLoose(strings, raw) {
          if (!raw) {
            raw = strings.slice(0);
          }
          strings.raw = raw;
          return strings;
        }
        function _temporalRef(val, name2) {
          if (val === _temporalUndefined) {
            throw new ReferenceError(name2 + " is not defined - temporal dead zone");
          } else {
            return val;
          }
        }
        function _readOnlyError(name2) {
          throw new Error('"' + name2 + '" is read-only');
        }
        function _classNameTDZError(name2) {
          throw new Error('Class "' + name2 + '" cannot be referenced in computed property keys.');
        }
        var _temporalUndefined = {};
        function _slicedToArray2(arr, i4) {
          return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i4) || _nonIterableRest2();
        }
        function _slicedToArrayLoose(arr, i4) {
          return _arrayWithHoles2(arr) || _iterableToArrayLimitLoose(arr, i4) || _nonIterableRest2();
        }
        function _toArray3(arr) {
          return _arrayWithHoles2(arr) || _iterableToArray2(arr) || _nonIterableRest2();
        }
        function _toConsumableArray2(arr) {
          return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _nonIterableSpread2();
        }
        function _arrayWithoutHoles2(arr) {
          if (Array.isArray(arr)) {
            for (var i4 = 0, arr2 = new Array(arr.length); i4 < arr.length; i4++) arr2[i4] = arr[i4];
            return arr2;
          }
        }
        function _arrayWithHoles2(arr) {
          if (Array.isArray(arr)) return arr;
        }
        function _iterableToArray2(iter) {
          if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
            return Array.from(iter);
        }
        function _iterableToArrayLimit2(arr, i4) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e2 = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i4 && _arr.length === i4) break;
            }
          } catch (err) {
            _d = true;
            _e2 = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e2;
            }
          }
          return _arr;
        }
        function _iterableToArrayLimitLoose(arr, i4) {
          var _arr = [];
          for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done; ) {
            _arr.push(_step.value);
            if (i4 && _arr.length === i4) break;
          }
          return _arr;
        }
        function _nonIterableSpread2() {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }
        function _nonIterableRest2() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
        function _skipFirstGeneratorNext(fn2) {
          return function() {
            var it = fn2.apply(this, arguments);
            it.next();
            return it;
          };
        }
        function _toPrimitive(input, hint) {
          if (typeof input !== "object" || input === null) return input;
          var prim = input[Symbol.toPrimitive];
          if (prim !== void 0) {
            var res2 = prim.call(input, hint || "default");
            if (typeof res2 !== "object") return res2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (hint === "string" ? String : Number)(input);
        }
        function _toPropertyKey(arg) {
          var key = _toPrimitive(arg, "string");
          return typeof key === "symbol" ? key : String(key);
        }
        function _initializerWarningHelper(descriptor, context3) {
          throw new Error(
            "Decorating class property failed. Please ensure that proposal-class-properties is enabled and set to use loose mode. To use proposal-class-properties in spec mode with decorators, wait for the next major version of decorators in stage 2."
          );
        }
        function _initializerDefineProperty(target, property, descriptor, context3) {
          if (!descriptor) return;
          Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context3) : void 0
          });
        }
        function _applyDecoratedDescriptor(target, property, decorators, descriptor, context3) {
          var desc = {};
          Object.keys(descriptor).forEach(function(key) {
            desc[key] = descriptor[key];
          });
          desc.enumerable = !!desc.enumerable;
          desc.configurable = !!desc.configurable;
          if ("value" in desc || desc.initializer) {
            desc.writable = true;
          }
          desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
            return decorator(target, property, desc2) || desc2;
          }, desc);
          if (context3 && desc.initializer !== void 0) {
            desc.value = desc.initializer ? desc.initializer.call(context3) : void 0;
            desc.initializer = void 0;
          }
          if (desc.initializer === void 0) {
            Object.defineProperty(target, property, desc);
            desc = null;
          }
          return desc;
        }
        var id = 0;
        function _classPrivateFieldLooseKey(name2) {
          return "__private_" + id++ + "_" + name2;
        }
        function _classPrivateFieldLooseBase(receiver, privateKey) {
          if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
            throw new TypeError("attempted to use private field on non-instance");
          }
          return receiver;
        }
        function _classPrivateFieldGet(receiver, privateMap) {
          var descriptor = privateMap.get(receiver);
          if (!descriptor) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          if (descriptor.get) {
            return descriptor.get.call(receiver);
          }
          return descriptor.value;
        }
        function _classPrivateFieldSet(receiver, privateMap, value) {
          var descriptor = privateMap.get(receiver);
          if (!descriptor) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          if (descriptor.set) {
            descriptor.set.call(receiver, value);
          } else {
            if (!descriptor.writable) {
              throw new TypeError("attempted to set read only private field");
            }
            descriptor.value = value;
          }
          return value;
        }
        function _classPrivateFieldDestructureSet(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          var descriptor = privateMap.get(receiver);
          if (descriptor.set) {
            if (!("__destrObj" in descriptor)) {
              descriptor.__destrObj = {
                set value(v2) {
                  descriptor.set.call(receiver, v2);
                }
              };
            }
            return descriptor.__destrObj;
          } else {
            if (!descriptor.writable) {
              throw new TypeError("attempted to set read only private field");
            }
            return descriptor;
          }
        }
        function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
          if (receiver !== classConstructor) {
            throw new TypeError("Private static access of wrong provenance");
          }
          return descriptor.value;
        }
        function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
          if (receiver !== classConstructor) {
            throw new TypeError("Private static access of wrong provenance");
          }
          if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
          }
          descriptor.value = value;
          return value;
        }
        function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
          if (receiver !== classConstructor) {
            throw new TypeError("Private static access of wrong provenance");
          }
          return method;
        }
        function _classStaticPrivateMethodSet() {
          throw new TypeError("attempted to set read only static private field");
        }
        function _decorate(decorators, factory, superClass, mixins) {
          var api = _getDecoratorsApi();
          if (mixins) {
            for (var i4 = 0; i4 < mixins.length; i4++) {
              api = mixins[i4](api);
            }
          }
          var r3 = factory(function initialize(O2) {
            api.initializeInstanceElements(O2, decorated.elements);
          }, superClass);
          var decorated = api.decorateClass(
            _coalesceClassElements(r3.d.map(_createElementDescriptor)),
            decorators
          );
          api.initializeClassElements(r3.F, decorated.elements);
          return api.runClassFinishers(r3.F, decorated.finishers);
        }
        function _getDecoratorsApi() {
          _getDecoratorsApi = function() {
            return api;
          };
          var api = {
            elementsDefinitionOrder: [["method"], ["field"]],
            initializeInstanceElements: function(O2, elements) {
              ["method", "field"].forEach(function(kind) {
                elements.forEach(function(element) {
                  if (element.kind === kind && element.placement === "own") {
                    this.defineClassElement(O2, element);
                  }
                }, this);
              }, this);
            },
            initializeClassElements: function(F2, elements) {
              var proto = F2.prototype;
              ["method", "field"].forEach(function(kind) {
                elements.forEach(function(element) {
                  var placement = element.placement;
                  if (element.kind === kind && (placement === "static" || placement === "prototype")) {
                    var receiver = placement === "static" ? F2 : proto;
                    this.defineClassElement(receiver, element);
                  }
                }, this);
              }, this);
            },
            defineClassElement: function(receiver, element) {
              var descriptor = element.descriptor;
              if (element.kind === "field") {
                var initializer = element.initializer;
                descriptor = {
                  enumerable: descriptor.enumerable,
                  writable: descriptor.writable,
                  configurable: descriptor.configurable,
                  value: initializer === void 0 ? void 0 : initializer.call(receiver)
                };
              }
              Object.defineProperty(receiver, element.key, descriptor);
            },
            decorateClass: function(elements, decorators) {
              var newElements = [];
              var finishers = [];
              var placements = {
                static: [],
                prototype: [],
                own: []
              };
              elements.forEach(function(element) {
                this.addElementPlacement(element, placements);
              }, this);
              elements.forEach(function(element) {
                if (!_hasDecorators(element)) return newElements.push(element);
                var elementFinishersExtras = this.decorateElement(element, placements);
                newElements.push(elementFinishersExtras.element);
                newElements.push.apply(newElements, elementFinishersExtras.extras);
                finishers.push.apply(finishers, elementFinishersExtras.finishers);
              }, this);
              if (!decorators) {
                return {
                  elements: newElements,
                  finishers
                };
              }
              var result = this.decorateConstructor(newElements, decorators);
              finishers.push.apply(finishers, result.finishers);
              result.finishers = finishers;
              return result;
            },
            addElementPlacement: function(element, placements, silent) {
              var keys = placements[element.placement];
              if (!silent && keys.indexOf(element.key) !== -1) {
                throw new TypeError("Duplicated element (" + element.key + ")");
              }
              keys.push(element.key);
            },
            decorateElement: function(element, placements) {
              var extras = [];
              var finishers = [];
              for (var decorators = element.decorators, i4 = decorators.length - 1; i4 >= 0; i4--) {
                var keys = placements[element.placement];
                keys.splice(keys.indexOf(element.key), 1);
                var elementObject = this.fromElementDescriptor(element);
                var elementFinisherExtras = this.toElementFinisherExtras(
                  (0, decorators[i4])(elementObject) || elementObject
                );
                element = elementFinisherExtras.element;
                this.addElementPlacement(element, placements);
                if (elementFinisherExtras.finisher) {
                  finishers.push(elementFinisherExtras.finisher);
                }
                var newExtras = elementFinisherExtras.extras;
                if (newExtras) {
                  for (var j2 = 0; j2 < newExtras.length; j2++) {
                    this.addElementPlacement(newExtras[j2], placements);
                  }
                  extras.push.apply(extras, newExtras);
                }
              }
              return {
                element,
                finishers,
                extras
              };
            },
            decorateConstructor: function(elements, decorators) {
              var finishers = [];
              for (var i4 = decorators.length - 1; i4 >= 0; i4--) {
                var obj = this.fromClassDescriptor(elements);
                var elementsAndFinisher = this.toClassDescriptor(
                  (0, decorators[i4])(obj) || obj
                );
                if (elementsAndFinisher.finisher !== void 0) {
                  finishers.push(elementsAndFinisher.finisher);
                }
                if (elementsAndFinisher.elements !== void 0) {
                  elements = elementsAndFinisher.elements;
                  for (var j2 = 0; j2 < elements.length - 1; j2++) {
                    for (var k2 = j2 + 1; k2 < elements.length; k2++) {
                      if (elements[j2].key === elements[k2].key && elements[j2].placement === elements[k2].placement) {
                        throw new TypeError(
                          "Duplicated element (" + elements[j2].key + ")"
                        );
                      }
                    }
                  }
                }
              }
              return {
                elements,
                finishers
              };
            },
            fromElementDescriptor: function(element) {
              var obj = {
                kind: element.kind,
                key: element.key,
                placement: element.placement,
                descriptor: element.descriptor
              };
              var desc = {
                value: "Descriptor",
                configurable: true
              };
              Object.defineProperty(obj, Symbol.toStringTag, desc);
              if (element.kind === "field") obj.initializer = element.initializer;
              return obj;
            },
            toElementDescriptors: function(elementObjects) {
              if (elementObjects === void 0) return;
              return _toArray3(elementObjects).map(function(elementObject) {
                var element = this.toElementDescriptor(elementObject);
                this.disallowProperty(elementObject, "finisher", "An element descriptor");
                this.disallowProperty(elementObject, "extras", "An element descriptor");
                return element;
              }, this);
            },
            toElementDescriptor: function(elementObject) {
              var kind = String(elementObject.kind);
              if (kind !== "method" && kind !== "field") {
                throw new TypeError(
                  `An element descriptor's .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "` + kind + '"'
                );
              }
              var key = _toPropertyKey(elementObject.key);
              var placement = String(elementObject.placement);
              if (placement !== "static" && placement !== "prototype" && placement !== "own") {
                throw new TypeError(
                  `An element descriptor's .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "` + placement + '"'
                );
              }
              var descriptor = elementObject.descriptor;
              this.disallowProperty(elementObject, "elements", "An element descriptor");
              var element = {
                kind,
                key,
                placement,
                descriptor: Object.assign({}, descriptor)
              };
              if (kind !== "field") {
                this.disallowProperty(elementObject, "initializer", "A method descriptor");
              } else {
                this.disallowProperty(
                  descriptor,
                  "get",
                  "The property descriptor of a field descriptor"
                );
                this.disallowProperty(
                  descriptor,
                  "set",
                  "The property descriptor of a field descriptor"
                );
                this.disallowProperty(
                  descriptor,
                  "value",
                  "The property descriptor of a field descriptor"
                );
                element.initializer = elementObject.initializer;
              }
              return element;
            },
            toElementFinisherExtras: function(elementObject) {
              var element = this.toElementDescriptor(elementObject);
              var finisher = _optionalCallableProperty(elementObject, "finisher");
              var extras = this.toElementDescriptors(elementObject.extras);
              return {
                element,
                finisher,
                extras
              };
            },
            fromClassDescriptor: function(elements) {
              var obj = {
                kind: "class",
                elements: elements.map(this.fromElementDescriptor, this)
              };
              var desc = {
                value: "Descriptor",
                configurable: true
              };
              Object.defineProperty(obj, Symbol.toStringTag, desc);
              return obj;
            },
            toClassDescriptor: function(obj) {
              var kind = String(obj.kind);
              if (kind !== "class") {
                throw new TypeError(
                  `A class descriptor's .kind property must be "class", but a decorator created a class descriptor with .kind "` + kind + '"'
                );
              }
              this.disallowProperty(obj, "key", "A class descriptor");
              this.disallowProperty(obj, "placement", "A class descriptor");
              this.disallowProperty(obj, "descriptor", "A class descriptor");
              this.disallowProperty(obj, "initializer", "A class descriptor");
              this.disallowProperty(obj, "extras", "A class descriptor");
              var finisher = _optionalCallableProperty(obj, "finisher");
              var elements = this.toElementDescriptors(obj.elements);
              return {
                elements,
                finisher
              };
            },
            runClassFinishers: function(constructor, finishers) {
              for (var i4 = 0; i4 < finishers.length; i4++) {
                var newConstructor = (0, finishers[i4])(constructor);
                if (newConstructor !== void 0) {
                  if (typeof newConstructor !== "function") {
                    throw new TypeError("Finishers must return a constructor.");
                  }
                  constructor = newConstructor;
                }
              }
              return constructor;
            },
            disallowProperty: function(obj, name2, objectType) {
              if (obj[name2] !== void 0) {
                throw new TypeError(objectType + " can't have a ." + name2 + " property.");
              }
            }
          };
          return api;
        }
        function _createElementDescriptor(def) {
          var key = _toPropertyKey(def.key);
          var descriptor;
          if (def.kind === "method") {
            descriptor = {
              value: def.value,
              writable: true,
              configurable: true,
              enumerable: false
            };
          } else if (def.kind === "get") {
            descriptor = {
              get: def.value,
              configurable: true,
              enumerable: false
            };
          } else if (def.kind === "set") {
            descriptor = {
              set: def.value,
              configurable: true,
              enumerable: false
            };
          } else if (def.kind === "field") {
            descriptor = {
              configurable: true,
              writable: true,
              enumerable: true
            };
          }
          var element = {
            kind: def.kind === "field" ? "field" : "method",
            key,
            placement: def.static ? "static" : def.kind === "field" ? "own" : "prototype",
            descriptor
          };
          if (def.decorators) element.decorators = def.decorators;
          if (def.kind === "field") element.initializer = def.value;
          return element;
        }
        function _coalesceGetterSetter(element, other) {
          if (element.descriptor.get !== void 0) {
            other.descriptor.get = element.descriptor.get;
          } else {
            other.descriptor.set = element.descriptor.set;
          }
        }
        function _coalesceClassElements(elements) {
          var newElements = [];
          var isSameElement = function(other2) {
            return other2.kind === "method" && other2.key === element.key && other2.placement === element.placement;
          };
          for (var i4 = 0; i4 < elements.length; i4++) {
            var element = elements[i4];
            var other;
            if (element.kind === "method" && (other = newElements.find(isSameElement))) {
              if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
                if (_hasDecorators(element) || _hasDecorators(other)) {
                  throw new ReferenceError(
                    "Duplicated methods (" + element.key + ") can't be decorated."
                  );
                }
                other.descriptor = element.descriptor;
              } else {
                if (_hasDecorators(element)) {
                  if (_hasDecorators(other)) {
                    throw new ReferenceError(
                      "Decorators can't be placed on different accessors with for the same property (" + element.key + ")."
                    );
                  }
                  other.decorators = element.decorators;
                }
                _coalesceGetterSetter(element, other);
              }
            } else {
              newElements.push(element);
            }
          }
          return newElements;
        }
        function _hasDecorators(element) {
          return element.decorators && element.decorators.length;
        }
        function _isDataDescriptor(desc) {
          return desc !== void 0 && !(desc.value === void 0 && desc.writable === void 0);
        }
        function _optionalCallableProperty(obj, name2) {
          var value = obj[name2];
          if (value !== void 0 && typeof value !== "function") {
            throw new TypeError("Expected '" + name2 + "' to be a function");
          }
          return value;
        }
        function _classPrivateMethodGet(receiver, privateSet, fn2) {
          if (!privateSet.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return fn2;
        }
        function _classPrivateMethodSet() {
          throw new TypeError("attempted to reassign private method");
        }
        function _wrapRegExp(re2, groups) {
          _wrapRegExp = function(re3, groups2) {
            return new BabelRegExp(re3, groups2);
          };
          var _RegExp = _wrapNativeSuper(RegExp);
          var _super = RegExp.prototype;
          var _groups = /* @__PURE__ */ new WeakMap();
          function BabelRegExp(re3, groups2) {
            var _this = _RegExp.call(this, re3);
            _groups.set(_this, groups2);
            return _this;
          }
          _inherits(BabelRegExp, _RegExp);
          BabelRegExp.prototype.exec = function(str) {
            var result = _super.exec.call(this, str);
            if (result) result.groups = buildGroups(result, this);
            return result;
          };
          BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {
            if (typeof substitution === "string") {
              var groups2 = _groups.get(this);
              return _super[Symbol.replace].call(
                this,
                str,
                substitution.replace(/\$<([^>]+)>/g, function(_2, name2) {
                  return "$" + groups2[name2];
                })
              );
            } else if (typeof substitution === "function") {
              var _this = this;
              return _super[Symbol.replace].call(this, str, function() {
                var args = [];
                args.push.apply(args, arguments);
                if (typeof args[args.length - 1] !== "object") {
                  args.push(buildGroups(args, _this));
                }
                return substitution.apply(this, args);
              });
            } else {
              return _super[Symbol.replace].call(this, str, substitution);
            }
          };
          function buildGroups(result, re3) {
            var g2 = _groups.get(re3);
            return Object.keys(g2).reduce(function(groups2, name2) {
              groups2[name2] = result[g2[name2]];
              return groups2;
            }, /* @__PURE__ */ Object.create(null));
          }
          return _wrapRegExp.apply(this, arguments);
        }
        var arrayRemove = function arrayRemove2(arr, index2) {
          return arr.splice(index2, 1);
        };
        var run = function run2(cb, sync) {
          if (sync) {
            cb();
          } else if (document.hidden) {
            Promise.resolve(1).then(cb);
          } else {
            setTimeout(cb, 0);
          }
        };
        var on2 = function on3() {
          var listeners2 = [];
          var off2 = function off3(event2, cb) {
            arrayRemove(
              listeners2,
              listeners2.findIndex(function(listener) {
                return listener.event === event2 && (listener.cb === cb || !cb);
              })
            );
          };
          var _fire = function fire(event2, args, sync) {
            listeners2.filter(function(listener) {
              return listener.event === event2;
            }).map(function(listener) {
              return listener.cb;
            }).forEach(function(cb) {
              return run(function() {
                return cb.apply(void 0, _toConsumableArray2(args));
              }, sync);
            });
          };
          return {
            fireSync: function fireSync(event2) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              _fire(event2, args, true);
            },
            fire: function fire(event2) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              _fire(event2, args, false);
            },
            on: function on4(event2, cb) {
              listeners2.push({ event: event2, cb });
            },
            onOnce: function onOnce(event2, _cb) {
              listeners2.push({
                event: event2,
                cb: function cb() {
                  off2(event2, _cb);
                  _cb.apply(void 0, arguments);
                }
              });
            },
            off: off2
          };
        };
        var copyObjectPropertiesToObject = function copyObjectPropertiesToObject2(src, target, excluded) {
          Object.getOwnPropertyNames(src).filter(function(property) {
            return !excluded.includes(property);
          }).forEach(function(key) {
            return Object.defineProperty(
              target,
              key,
              Object.getOwnPropertyDescriptor(src, key)
            );
          });
        };
        var PRIVATE = [
          "fire",
          "process",
          "revert",
          "load",
          "on",
          "off",
          "onOnce",
          "retryLoad",
          "extend",
          "archive",
          "archived",
          "release",
          "released",
          "requestProcessing",
          "freeze"
        ];
        var createItemAPI = function createItemAPI2(item2) {
          var api = {};
          copyObjectPropertiesToObject(item2, api, PRIVATE);
          return api;
        };
        var removeReleasedItems = function removeReleasedItems2(items) {
          items.forEach(function(item2, index2) {
            if (item2.released) {
              arrayRemove(items, index2);
            }
          });
        };
        var ItemStatus = {
          INIT: 1,
          IDLE: 2,
          PROCESSING_QUEUED: 9,
          PROCESSING: 3,
          PROCESSING_COMPLETE: 5,
          PROCESSING_ERROR: 6,
          PROCESSING_REVERT_ERROR: 10,
          LOADING: 7,
          LOAD_ERROR: 8
        };
        var FileOrigin = {
          INPUT: 1,
          LIMBO: 2,
          LOCAL: 3
        };
        var getNonNumeric = function getNonNumeric2(str) {
          return /[^0-9]+/.exec(str);
        };
        var getDecimalSeparator = function getDecimalSeparator2() {
          return getNonNumeric(1.1.toLocaleString())[0];
        };
        var getThousandsSeparator = function getThousandsSeparator2() {
          var decimalSeparator = getDecimalSeparator();
          var thousandsStringWithSeparator = 1e3.toLocaleString();
          var thousandsStringWithoutSeparator = 1e3.toString();
          if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {
            return getNonNumeric(thousandsStringWithSeparator)[0];
          }
          return decimalSeparator === "." ? "," : ".";
        };
        var Type = {
          BOOLEAN: "boolean",
          INT: "int",
          NUMBER: "number",
          STRING: "string",
          ARRAY: "array",
          OBJECT: "object",
          FUNCTION: "function",
          ACTION: "action",
          SERVER_API: "serverapi",
          REGEX: "regex"
        };
        var filters = [];
        var applyFilterChain = function applyFilterChain2(key, value, utils) {
          return new Promise(function(resolve, reject) {
            var matchingFilters = filters.filter(function(f2) {
              return f2.key === key;
            }).map(function(f2) {
              return f2.cb;
            });
            if (matchingFilters.length === 0) {
              resolve(value);
              return;
            }
            var initialFilter = matchingFilters.shift();
            matchingFilters.reduce(
              // loop over promises passing value to next promise
              function(current, next2) {
                return current.then(function(value2) {
                  return next2(value2, utils);
                });
              },
              // call initial filter, will return a promise
              initialFilter(value, utils)
              // all executed
            ).then(function(value2) {
              return resolve(value2);
            }).catch(function(error2) {
              return reject(error2);
            });
          });
        };
        var applyFilters = function applyFilters2(key, value, utils) {
          return filters.filter(function(f2) {
            return f2.key === key;
          }).map(function(f2) {
            return f2.cb(value, utils);
          });
        };
        var addFilter = function addFilter2(key, cb) {
          return filters.push({ key, cb });
        };
        var extendDefaultOptions = function extendDefaultOptions2(additionalOptions) {
          return Object.assign(defaultOptions, additionalOptions);
        };
        var getOptions = function getOptions2() {
          return Object.assign({}, defaultOptions);
        };
        var setOptions = function setOptions2(opts) {
          forin(opts, function(key, value) {
            if (!defaultOptions[key]) {
              return;
            }
            defaultOptions[key][0] = getValueByType(
              value,
              defaultOptions[key][0],
              defaultOptions[key][1]
            );
          });
        };
        var defaultOptions = {
          // the id to add to the root element
          id: [null, Type.STRING],
          // input field name to use
          name: ["filepond", Type.STRING],
          // disable the field
          disabled: [false, Type.BOOLEAN],
          // classname to put on wrapper
          className: [null, Type.STRING],
          // is the field required
          required: [false, Type.BOOLEAN],
          // Allow media capture when value is set
          captureMethod: [null, Type.STRING],
          // - "camera", "microphone" or "camcorder",
          // - Does not work with multiple on apple devices
          // - If set, acceptedFileTypes must be made to match with media wildcard "image/*", "audio/*" or "video/*"
          // sync `acceptedFileTypes` property with `accept` attribute
          allowSyncAcceptAttribute: [true, Type.BOOLEAN],
          // Feature toggles
          allowDrop: [true, Type.BOOLEAN],
          // Allow dropping of files
          allowBrowse: [true, Type.BOOLEAN],
          // Allow browsing the file system
          allowPaste: [true, Type.BOOLEAN],
          // Allow pasting files
          allowMultiple: [false, Type.BOOLEAN],
          // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)
          allowReplace: [true, Type.BOOLEAN],
          // Allow dropping a file on other file to replace it (only works when multiple is set to false)
          allowRevert: [true, Type.BOOLEAN],
          // Allows user to revert file upload
          allowRemove: [true, Type.BOOLEAN],
          // Allow user to remove a file
          allowProcess: [true, Type.BOOLEAN],
          // Allows user to process a file, when set to false, this removes the file upload button
          allowReorder: [false, Type.BOOLEAN],
          // Allow reordering of files
          allowDirectoriesOnly: [false, Type.BOOLEAN],
          // Allow only selecting directories with browse (no support for filtering dnd at this point)
          // Try store file if `server` not set
          storeAsFile: [false, Type.BOOLEAN],
          // Revert mode
          forceRevert: [false, Type.BOOLEAN],
          // Set to 'force' to require the file to be reverted before removal
          // Input requirements
          maxFiles: [null, Type.INT],
          // Max number of files
          checkValidity: [false, Type.BOOLEAN],
          // Enables custom validity messages
          // Where to put file
          itemInsertLocationFreedom: [true, Type.BOOLEAN],
          // Set to false to always add items to begin or end of list
          itemInsertLocation: ["before", Type.STRING],
          // Default index in list to add items that have been dropped at the top of the list
          itemInsertInterval: [75, Type.INT],
          // Drag 'n Drop related
          dropOnPage: [false, Type.BOOLEAN],
          // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)
          dropOnElement: [true, Type.BOOLEAN],
          // Drop needs to happen on element (set to false to also load drops outside of Up)
          dropValidation: [false, Type.BOOLEAN],
          // Enable or disable validating files on drop
          ignoredFiles: [[".ds_store", "thumbs.db", "desktop.ini"], Type.ARRAY],
          // Upload related
          instantUpload: [true, Type.BOOLEAN],
          // Should upload files immediately on drop
          maxParallelUploads: [2, Type.INT],
          // Maximum files to upload in parallel
          allowMinimumUploadDuration: [true, Type.BOOLEAN],
          // if true uploads take at least 750 ms, this ensures the user sees the upload progress giving trust the upload actually happened
          // Chunks
          chunkUploads: [false, Type.BOOLEAN],
          // Enable chunked uploads
          chunkForce: [false, Type.BOOLEAN],
          // Force use of chunk uploads even for files smaller than chunk size
          chunkSize: [5e6, Type.INT],
          // Size of chunks (5MB default)
          chunkRetryDelays: [[500, 1e3, 3e3], Type.ARRAY],
          // Amount of times to retry upload of a chunk when it fails
          // The server api end points to use for uploading (see docs)
          server: [null, Type.SERVER_API],
          // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000
          fileSizeBase: [1e3, Type.INT],
          // Labels and status messages
          labelFileSizeBytes: ["bytes", Type.STRING],
          labelFileSizeKilobytes: ["KB", Type.STRING],
          labelFileSizeMegabytes: ["MB", Type.STRING],
          labelFileSizeGigabytes: ["GB", Type.STRING],
          labelDecimalSeparator: [getDecimalSeparator(), Type.STRING],
          // Default is locale separator
          labelThousandsSeparator: [getThousandsSeparator(), Type.STRING],
          // Default is locale separator
          labelIdle: [
            'Drag & Drop your files or <span class="filepond--label-action">Browse</span>',
            Type.STRING
          ],
          labelInvalidField: ["Field contains invalid files", Type.STRING],
          labelFileWaitingForSize: ["Waiting for size", Type.STRING],
          labelFileSizeNotAvailable: ["Size not available", Type.STRING],
          labelFileCountSingular: ["file in list", Type.STRING],
          labelFileCountPlural: ["files in list", Type.STRING],
          labelFileLoading: ["Loading", Type.STRING],
          labelFileAdded: ["Added", Type.STRING],
          // assistive only
          labelFileLoadError: ["Error during load", Type.STRING],
          labelFileRemoved: ["Removed", Type.STRING],
          // assistive only
          labelFileRemoveError: ["Error during remove", Type.STRING],
          labelFileProcessing: ["Uploading", Type.STRING],
          labelFileProcessingComplete: ["Upload complete", Type.STRING],
          labelFileProcessingAborted: ["Upload cancelled", Type.STRING],
          labelFileProcessingError: ["Error during upload", Type.STRING],
          labelFileProcessingRevertError: ["Error during revert", Type.STRING],
          labelTapToCancel: ["tap to cancel", Type.STRING],
          labelTapToRetry: ["tap to retry", Type.STRING],
          labelTapToUndo: ["tap to undo", Type.STRING],
          labelButtonRemoveItem: ["Remove", Type.STRING],
          labelButtonAbortItemLoad: ["Abort", Type.STRING],
          labelButtonRetryItemLoad: ["Retry", Type.STRING],
          labelButtonAbortItemProcessing: ["Cancel", Type.STRING],
          labelButtonUndoItemProcessing: ["Undo", Type.STRING],
          labelButtonRetryItemProcessing: ["Retry", Type.STRING],
          labelButtonProcessItem: ["Upload", Type.STRING],
          // make sure width and height plus viewpox are even numbers so icons are nicely centered
          iconRemove: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z" fill="currentColor" fill-rule="nonzero"/></svg>',
            Type.STRING
          ],
          iconProcess: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z" fill="currentColor" fill-rule="evenodd"/></svg>',
            Type.STRING
          ],
          iconRetry: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z" fill="currentColor" fill-rule="nonzero"/></svg>',
            Type.STRING
          ],
          iconUndo: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z" fill="currentColor" fill-rule="nonzero"/></svg>',
            Type.STRING
          ],
          iconDone: [
            '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z" fill="currentColor" fill-rule="nonzero"/></svg>',
            Type.STRING
          ],
          // event handlers
          oninit: [null, Type.FUNCTION],
          onwarning: [null, Type.FUNCTION],
          onerror: [null, Type.FUNCTION],
          onactivatefile: [null, Type.FUNCTION],
          oninitfile: [null, Type.FUNCTION],
          onaddfilestart: [null, Type.FUNCTION],
          onaddfileprogress: [null, Type.FUNCTION],
          onaddfile: [null, Type.FUNCTION],
          onprocessfilestart: [null, Type.FUNCTION],
          onprocessfileprogress: [null, Type.FUNCTION],
          onprocessfileabort: [null, Type.FUNCTION],
          onprocessfilerevert: [null, Type.FUNCTION],
          onprocessfile: [null, Type.FUNCTION],
          onprocessfiles: [null, Type.FUNCTION],
          onremovefile: [null, Type.FUNCTION],
          onpreparefile: [null, Type.FUNCTION],
          onupdatefiles: [null, Type.FUNCTION],
          onreorderfiles: [null, Type.FUNCTION],
          // hooks
          beforeDropFile: [null, Type.FUNCTION],
          beforeAddFile: [null, Type.FUNCTION],
          beforeRemoveFile: [null, Type.FUNCTION],
          beforePrepareFile: [null, Type.FUNCTION],
          // styles
          stylePanelLayout: [null, Type.STRING],
          // null 'integrated', 'compact', 'circle'
          stylePanelAspectRatio: [null, Type.STRING],
          // null or '3:2' or 1
          styleItemPanelAspectRatio: [null, Type.STRING],
          styleButtonRemoveItemPosition: ["left", Type.STRING],
          styleButtonProcessItemPosition: ["right", Type.STRING],
          styleLoadIndicatorPosition: ["right", Type.STRING],
          styleProgressIndicatorPosition: ["right", Type.STRING],
          styleButtonRemoveItemAlign: [false, Type.BOOLEAN],
          // custom initial files array
          files: [[], Type.ARRAY],
          // show support by displaying credits
          credits: [["https://pqina.nl/", "Powered by PQINA"], Type.ARRAY]
        };
        var getItemByQuery = function getItemByQuery2(items, query) {
          if (isEmpty(query)) {
            return items[0] || null;
          }
          if (isInt(query)) {
            return items[query] || null;
          }
          if (typeof query === "object") {
            query = query.id;
          }
          return items.find(function(item2) {
            return item2.id === query;
          }) || null;
        };
        var getNumericAspectRatioFromString = function getNumericAspectRatioFromString2(aspectRatio) {
          if (isEmpty(aspectRatio)) {
            return aspectRatio;
          }
          if (/:/.test(aspectRatio)) {
            var parts = aspectRatio.split(":");
            return parts[1] / parts[0];
          }
          return parseFloat(aspectRatio);
        };
        var getActiveItems = function getActiveItems2(items) {
          return items.filter(function(item2) {
            return !item2.archived;
          });
        };
        var Status = {
          EMPTY: 0,
          IDLE: 1,
          // waiting
          ERROR: 2,
          // a file is in error state
          BUSY: 3,
          // busy processing or loading
          READY: 4
          // all files uploaded
        };
        var res = null;
        var canUpdateFileInput = function canUpdateFileInput2() {
          if (res === null) {
            try {
              var dataTransfer = new DataTransfer();
              dataTransfer.items.add(new File(["hello world"], "This_Works.txt"));
              var el = document.createElement("input");
              el.setAttribute("type", "file");
              el.files = dataTransfer.files;
              res = el.files.length === 1;
            } catch (err) {
              res = false;
            }
          }
          return res;
        };
        var ITEM_ERROR = [
          ItemStatus.LOAD_ERROR,
          ItemStatus.PROCESSING_ERROR,
          ItemStatus.PROCESSING_REVERT_ERROR
        ];
        var ITEM_BUSY = [
          ItemStatus.LOADING,
          ItemStatus.PROCESSING,
          ItemStatus.PROCESSING_QUEUED,
          ItemStatus.INIT
        ];
        var ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];
        var isItemInErrorState = function isItemInErrorState2(item2) {
          return ITEM_ERROR.includes(item2.status);
        };
        var isItemInBusyState = function isItemInBusyState2(item2) {
          return ITEM_BUSY.includes(item2.status);
        };
        var isItemInReadyState = function isItemInReadyState2(item2) {
          return ITEM_READY.includes(item2.status);
        };
        var isAsync = function isAsync2(state2) {
          return isObject3(state2.options.server) && (isObject3(state2.options.server.process) || isFunction2(state2.options.server.process));
        };
        var queries = function queries2(state2) {
          return {
            GET_STATUS: function GET_STATUS() {
              var items = getActiveItems(state2.items);
              var EMPTY = Status.EMPTY, ERROR = Status.ERROR, BUSY = Status.BUSY, IDLE = Status.IDLE, READY = Status.READY;
              if (items.length === 0) return EMPTY;
              if (items.some(isItemInErrorState)) return ERROR;
              if (items.some(isItemInBusyState)) return BUSY;
              if (items.some(isItemInReadyState)) return READY;
              return IDLE;
            },
            GET_ITEM: function GET_ITEM(query) {
              return getItemByQuery(state2.items, query);
            },
            GET_ACTIVE_ITEM: function GET_ACTIVE_ITEM(query) {
              return getItemByQuery(getActiveItems(state2.items), query);
            },
            GET_ACTIVE_ITEMS: function GET_ACTIVE_ITEMS() {
              return getActiveItems(state2.items);
            },
            GET_ITEMS: function GET_ITEMS() {
              return state2.items;
            },
            GET_ITEM_NAME: function GET_ITEM_NAME(query) {
              var item2 = getItemByQuery(state2.items, query);
              return item2 ? item2.filename : null;
            },
            GET_ITEM_SIZE: function GET_ITEM_SIZE(query) {
              var item2 = getItemByQuery(state2.items, query);
              return item2 ? item2.fileSize : null;
            },
            GET_STYLES: function GET_STYLES() {
              return Object.keys(state2.options).filter(function(key) {
                return /^style/.test(key);
              }).map(function(option2) {
                return {
                  name: option2,
                  value: state2.options[option2]
                };
              });
            },
            GET_PANEL_ASPECT_RATIO: function GET_PANEL_ASPECT_RATIO() {
              var isShapeCircle = /circle/.test(state2.options.stylePanelLayout);
              var aspectRatio = isShapeCircle ? 1 : getNumericAspectRatioFromString(state2.options.stylePanelAspectRatio);
              return aspectRatio;
            },
            GET_ITEM_PANEL_ASPECT_RATIO: function GET_ITEM_PANEL_ASPECT_RATIO() {
              return state2.options.styleItemPanelAspectRatio;
            },
            GET_ITEMS_BY_STATUS: function GET_ITEMS_BY_STATUS(status) {
              return getActiveItems(state2.items).filter(function(item2) {
                return item2.status === status;
              });
            },
            GET_TOTAL_ITEMS: function GET_TOTAL_ITEMS() {
              return getActiveItems(state2.items).length;
            },
            SHOULD_UPDATE_FILE_INPUT: function SHOULD_UPDATE_FILE_INPUT() {
              return state2.options.storeAsFile && canUpdateFileInput() && !isAsync(state2);
            },
            IS_ASYNC: function IS_ASYNC() {
              return isAsync(state2);
            },
            GET_FILE_SIZE_LABELS: function GET_FILE_SIZE_LABELS(query) {
              return {
                labelBytes: query("GET_LABEL_FILE_SIZE_BYTES") || void 0,
                labelKilobytes: query("GET_LABEL_FILE_SIZE_KILOBYTES") || void 0,
                labelMegabytes: query("GET_LABEL_FILE_SIZE_MEGABYTES") || void 0,
                labelGigabytes: query("GET_LABEL_FILE_SIZE_GIGABYTES") || void 0
              };
            }
          };
        };
        var hasRoomForItem = function hasRoomForItem2(state2) {
          var count = getActiveItems(state2.items).length;
          if (!state2.options.allowMultiple) {
            return count === 0;
          }
          var maxFileCount = state2.options.maxFiles;
          if (maxFileCount === null) {
            return true;
          }
          if (count < maxFileCount) {
            return true;
          }
          return false;
        };
        var limit = function limit2(value, min, max) {
          return Math.max(Math.min(max, value), min);
        };
        var arrayInsert = function arrayInsert2(arr, index2, item2) {
          return arr.splice(index2, 0, item2);
        };
        var insertItem = function insertItem2(items, item2, index2) {
          if (isEmpty(item2)) {
            return null;
          }
          if (typeof index2 === "undefined") {
            items.push(item2);
            return item2;
          }
          index2 = limit(index2, 0, items.length);
          arrayInsert(items, index2, item2);
          return item2;
        };
        var isBase64DataURI = function isBase64DataURI2(str) {
          return /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*)\s*$/i.test(
            str
          );
        };
        var getFilenameFromURL = function getFilenameFromURL2(url) {
          return url.split("/").pop().split("?").shift();
        };
        var getExtensionFromFilename = function getExtensionFromFilename2(name2) {
          return name2.split(".").pop();
        };
        var guesstimateExtension = function guesstimateExtension2(type) {
          if (typeof type !== "string") {
            return "";
          }
          var subtype = type.split("/").pop();
          if (/svg/.test(subtype)) {
            return "svg";
          }
          if (/zip|compressed/.test(subtype)) {
            return "zip";
          }
          if (/plain/.test(subtype)) {
            return "txt";
          }
          if (/msword/.test(subtype)) {
            return "doc";
          }
          if (/[a-z]+/.test(subtype)) {
            if (subtype === "jpeg") {
              return "jpg";
            }
            return subtype;
          }
          return "";
        };
        var leftPad = function leftPad2(value) {
          var padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          return (padding + value).slice(-padding.length);
        };
        var getDateString = function getDateString2() {
          var date = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Date();
          return date.getFullYear() + "-" + leftPad(date.getMonth() + 1, "00") + "-" + leftPad(date.getDate(), "00") + "_" + leftPad(date.getHours(), "00") + "-" + leftPad(date.getMinutes(), "00") + "-" + leftPad(date.getSeconds(), "00");
        };
        var getFileFromBlob = function getFileFromBlob2(blob2, filename) {
          var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var extension = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          var file2 = typeof type === "string" ? blob2.slice(0, blob2.size, type) : blob2.slice(0, blob2.size, blob2.type);
          file2.lastModifiedDate = /* @__PURE__ */ new Date();
          if (blob2._relativePath) file2._relativePath = blob2._relativePath;
          if (!isString2(filename)) {
            filename = getDateString();
          }
          if (filename && extension === null && getExtensionFromFilename(filename)) {
            file2.name = filename;
          } else {
            extension = extension || guesstimateExtension(file2.type);
            file2.name = filename + (extension ? "." + extension : "");
          }
          return file2;
        };
        var getBlobBuilder = function getBlobBuilder2() {
          return window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
        };
        var createBlob = function createBlob2(arrayBuffer, mimeType) {
          var BB = getBlobBuilder();
          if (BB) {
            var bb = new BB();
            bb.append(arrayBuffer);
            return bb.getBlob(mimeType);
          }
          return new Blob([arrayBuffer], {
            type: mimeType
          });
        };
        var getBlobFromByteStringWithMimeType = function getBlobFromByteStringWithMimeType2(byteString, mimeType) {
          var ab = new ArrayBuffer(byteString.length);
          var ia = new Uint8Array(ab);
          for (var i4 = 0; i4 < byteString.length; i4++) {
            ia[i4] = byteString.charCodeAt(i4);
          }
          return createBlob(ab, mimeType);
        };
        var getMimeTypeFromBase64DataURI = function getMimeTypeFromBase64DataURI2(dataURI) {
          return (/^data:(.+);/.exec(dataURI) || [])[1] || null;
        };
        var getBase64DataFromBase64DataURI = function getBase64DataFromBase64DataURI2(dataURI) {
          var data2 = dataURI.split(",")[1];
          return data2.replace(/\s/g, "");
        };
        var getByteStringFromBase64DataURI = function getByteStringFromBase64DataURI2(dataURI) {
          return atob(getBase64DataFromBase64DataURI(dataURI));
        };
        var getBlobFromBase64DataURI = function getBlobFromBase64DataURI2(dataURI) {
          var mimeType = getMimeTypeFromBase64DataURI(dataURI);
          var byteString = getByteStringFromBase64DataURI(dataURI);
          return getBlobFromByteStringWithMimeType(byteString, mimeType);
        };
        var getFileFromBase64DataURI = function getFileFromBase64DataURI2(dataURI, filename, extension) {
          return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);
        };
        var getFileNameFromHeader = function getFileNameFromHeader2(header) {
          if (!/^content-disposition:/i.test(header)) return null;
          var matches2 = header.split(/filename=|filename\*=.+''/).splice(1).map(function(name2) {
            return name2.trim().replace(/^["']|[;"']{0,2}$/g, "");
          }).filter(function(name2) {
            return name2.length;
          });
          return matches2.length ? decodeURI(matches2[matches2.length - 1]) : null;
        };
        var getFileSizeFromHeader = function getFileSizeFromHeader2(header) {
          if (/content-length:/i.test(header)) {
            var size = header.match(/[0-9]+/)[0];
            return size ? parseInt(size, 10) : null;
          }
          return null;
        };
        var getTranfserIdFromHeader = function getTranfserIdFromHeader2(header) {
          if (/x-content-transfer-id:/i.test(header)) {
            var id2 = (header.split(":")[1] || "").trim();
            return id2 || null;
          }
          return null;
        };
        var getFileInfoFromHeaders = function getFileInfoFromHeaders2(headers) {
          var info = {
            source: null,
            name: null,
            size: null
          };
          var rows = headers.split("\n");
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = rows[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var header = _step.value;
              var name2 = getFileNameFromHeader(header);
              if (name2) {
                info.name = name2;
                continue;
              }
              var size = getFileSizeFromHeader(header);
              if (size) {
                info.size = size;
                continue;
              }
              var source = getTranfserIdFromHeader(header);
              if (source) {
                info.source = source;
                continue;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return info;
        };
        var createFileLoader = function createFileLoader2(fetchFn) {
          var state2 = {
            source: null,
            complete: false,
            progress: 0,
            size: null,
            timestamp: null,
            duration: 0,
            request: null
          };
          var getProgress = function getProgress2() {
            return state2.progress;
          };
          var abort = function abort2() {
            if (state2.request && state2.request.abort) {
              state2.request.abort();
            }
          };
          var load = function load2() {
            var source = state2.source;
            api.fire("init", source);
            if (source instanceof File) {
              api.fire("load", source);
            } else if (source instanceof Blob) {
              api.fire("load", getFileFromBlob(source, source.name));
            } else if (isBase64DataURI(source)) {
              api.fire("load", getFileFromBase64DataURI(source));
            } else {
              loadURL(source);
            }
          };
          var loadURL = function loadURL2(url) {
            if (!fetchFn) {
              api.fire("error", {
                type: "error",
                body: "Can't load URL",
                code: 400
              });
              return;
            }
            state2.timestamp = Date.now();
            state2.request = fetchFn(
              url,
              function(response) {
                state2.duration = Date.now() - state2.timestamp;
                state2.complete = true;
                if (response instanceof Blob) {
                  response = getFileFromBlob(
                    response,
                    response.name || getFilenameFromURL(url)
                  );
                }
                api.fire(
                  "load",
                  // if has received blob, we go with blob, if no response, we return null
                  response instanceof Blob ? response : response ? response.body : null
                );
              },
              function(error2) {
                api.fire(
                  "error",
                  typeof error2 === "string" ? {
                    type: "error",
                    code: 0,
                    body: error2
                  } : error2
                );
              },
              function(computable, current, total) {
                if (total) {
                  state2.size = total;
                }
                state2.duration = Date.now() - state2.timestamp;
                if (!computable) {
                  state2.progress = null;
                  return;
                }
                state2.progress = current / total;
                api.fire("progress", state2.progress);
              },
              function() {
                api.fire("abort");
              },
              function(response) {
                var fileinfo = getFileInfoFromHeaders(
                  typeof response === "string" ? response : response.headers
                );
                api.fire("meta", {
                  size: state2.size || fileinfo.size,
                  filename: fileinfo.name,
                  source: fileinfo.source
                });
              }
            );
          };
          var api = Object.assign({}, on2(), {
            setSource: function setSource(source) {
              return state2.source = source;
            },
            getProgress,
            // file load progress
            abort,
            // abort file load
            load
            // start load
          });
          return api;
        };
        var isGet = function isGet2(method) {
          return /GET|HEAD/.test(method);
        };
        var sendRequest = function sendRequest2(data2, url, options) {
          var api = {
            onheaders: function onheaders() {
            },
            onprogress: function onprogress() {
            },
            onload: function onload() {
            },
            ontimeout: function ontimeout() {
            },
            onerror: function onerror() {
            },
            onabort: function onabort() {
            },
            abort: function abort() {
              aborted = true;
              xhr.abort();
            }
          };
          var aborted = false;
          var headersReceived = false;
          options = Object.assign(
            {
              method: "POST",
              headers: {},
              withCredentials: false
            },
            options
          );
          url = encodeURI(url);
          if (isGet(options.method) && data2) {
            url = "" + url + encodeURIComponent(typeof data2 === "string" ? data2 : JSON.stringify(data2));
          }
          var xhr = new XMLHttpRequest();
          var process2 = isGet(options.method) ? xhr : xhr.upload;
          process2.onprogress = function(e4) {
            if (aborted) {
              return;
            }
            api.onprogress(e4.lengthComputable, e4.loaded, e4.total);
          };
          xhr.onreadystatechange = function() {
            if (xhr.readyState < 2) {
              return;
            }
            if (xhr.readyState === 4 && xhr.status === 0) {
              return;
            }
            if (headersReceived) {
              return;
            }
            headersReceived = true;
            api.onheaders(xhr);
          };
          xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300) {
              api.onload(xhr);
            } else {
              api.onerror(xhr);
            }
          };
          xhr.onerror = function() {
            return api.onerror(xhr);
          };
          xhr.onabort = function() {
            aborted = true;
            api.onabort();
          };
          xhr.ontimeout = function() {
            return api.ontimeout(xhr);
          };
          xhr.open(options.method, url, true);
          if (isInt(options.timeout)) {
            xhr.timeout = options.timeout;
          }
          Object.keys(options.headers).forEach(function(key) {
            var value = unescape(encodeURIComponent(options.headers[key]));
            xhr.setRequestHeader(key, value);
          });
          if (options.responseType) {
            xhr.responseType = options.responseType;
          }
          if (options.withCredentials) {
            xhr.withCredentials = true;
          }
          xhr.send(data2);
          return api;
        };
        var createResponse = function createResponse2(type, code, body2, headers) {
          return {
            type,
            code,
            body: body2,
            headers
          };
        };
        var createTimeoutResponse = function createTimeoutResponse2(cb) {
          return function(xhr) {
            cb(createResponse("error", 0, "Timeout", xhr.getAllResponseHeaders()));
          };
        };
        var hasQS = function hasQS2(str) {
          return /\?/.test(str);
        };
        var buildURL = function buildURL2() {
          var url = "";
          for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
            parts[_key] = arguments[_key];
          }
          parts.forEach(function(part) {
            url += hasQS(url) && hasQS(part) ? part.replace(/\?/, "&") : part;
          });
          return url;
        };
        var createFetchFunction = function createFetchFunction2() {
          var apiUrl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var action = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof action === "function") {
            return action;
          }
          if (!action || !isString2(action.url)) {
            return null;
          }
          var onload = action.onload || function(res2) {
            return res2;
          };
          var onerror = action.onerror || function(res2) {
            return null;
          };
          return function(url, load, error2, progress, abort, headers) {
            var request = sendRequest(
              url,
              buildURL(apiUrl, action.url),
              Object.assign({}, action, {
                responseType: "blob"
              })
            );
            request.onload = function(xhr) {
              var headers2 = xhr.getAllResponseHeaders();
              var filename = getFileInfoFromHeaders(headers2).name || getFilenameFromURL(url);
              load(
                createResponse(
                  "load",
                  xhr.status,
                  action.method === "HEAD" ? null : getFileFromBlob(onload(xhr.response), filename),
                  headers2
                )
              );
            };
            request.onerror = function(xhr) {
              error2(
                createResponse(
                  "error",
                  xhr.status,
                  onerror(xhr.response) || xhr.statusText,
                  xhr.getAllResponseHeaders()
                )
              );
            };
            request.onheaders = function(xhr) {
              headers(createResponse("headers", xhr.status, null, xhr.getAllResponseHeaders()));
            };
            request.ontimeout = createTimeoutResponse(error2);
            request.onprogress = progress;
            request.onabort = abort;
            return request;
          };
        };
        var ChunkStatus = {
          QUEUED: 0,
          COMPLETE: 1,
          PROCESSING: 2,
          ERROR: 3,
          WAITING: 4
        };
        var processFileChunked = function processFileChunked2(apiUrl, action, name2, file2, metadata, load, error2, progress, abort, transfer, options) {
          var chunks = [];
          var chunkTransferId = options.chunkTransferId, chunkServer = options.chunkServer, chunkSize = options.chunkSize, chunkRetryDelays = options.chunkRetryDelays;
          var state2 = {
            serverId: chunkTransferId,
            aborted: false
          };
          var ondata = action.ondata || function(fd) {
            return fd;
          };
          var onload = action.onload || function(xhr, method) {
            return method === "HEAD" ? xhr.getResponseHeader("Upload-Offset") : xhr.response;
          };
          var onerror = action.onerror || function(res2) {
            return null;
          };
          var requestTransferId = function requestTransferId2(cb) {
            var formData = new FormData();
            if (isObject3(metadata)) formData.append(name2, JSON.stringify(metadata));
            var headers = typeof action.headers === "function" ? action.headers(file2, metadata) : Object.assign({}, action.headers, {
              "Upload-Length": file2.size
            });
            var requestParams = Object.assign({}, action, {
              headers
            });
            var request = sendRequest(
              ondata(formData),
              buildURL(apiUrl, action.url),
              requestParams
            );
            request.onload = function(xhr) {
              return cb(onload(xhr, requestParams.method));
            };
            request.onerror = function(xhr) {
              return error2(
                createResponse(
                  "error",
                  xhr.status,
                  onerror(xhr.response) || xhr.statusText,
                  xhr.getAllResponseHeaders()
                )
              );
            };
            request.ontimeout = createTimeoutResponse(error2);
          };
          var requestTransferOffset = function requestTransferOffset2(cb) {
            var requestUrl = buildURL(apiUrl, chunkServer.url, state2.serverId);
            var headers = typeof action.headers === "function" ? action.headers(state2.serverId) : Object.assign({}, action.headers);
            var requestParams = {
              headers,
              method: "HEAD"
            };
            var request = sendRequest(null, requestUrl, requestParams);
            request.onload = function(xhr) {
              return cb(onload(xhr, requestParams.method));
            };
            request.onerror = function(xhr) {
              return error2(
                createResponse(
                  "error",
                  xhr.status,
                  onerror(xhr.response) || xhr.statusText,
                  xhr.getAllResponseHeaders()
                )
              );
            };
            request.ontimeout = createTimeoutResponse(error2);
          };
          var lastChunkIndex = Math.floor(file2.size / chunkSize);
          for (var i4 = 0; i4 <= lastChunkIndex; i4++) {
            var offset2 = i4 * chunkSize;
            var data2 = file2.slice(offset2, offset2 + chunkSize, "application/offset+octet-stream");
            chunks[i4] = {
              index: i4,
              size: data2.size,
              offset: offset2,
              data: data2,
              file: file2,
              progress: 0,
              retries: _toConsumableArray2(chunkRetryDelays),
              status: ChunkStatus.QUEUED,
              error: null,
              request: null,
              timeout: null
            };
          }
          var completeProcessingChunks = function completeProcessingChunks2() {
            return load(state2.serverId);
          };
          var canProcessChunk = function canProcessChunk2(chunk) {
            return chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;
          };
          var processChunk = function processChunk2(chunk) {
            if (state2.aborted) return;
            chunk = chunk || chunks.find(canProcessChunk);
            if (!chunk) {
              if (chunks.every(function(chunk2) {
                return chunk2.status === ChunkStatus.COMPLETE;
              })) {
                completeProcessingChunks();
              }
              return;
            }
            chunk.status = ChunkStatus.PROCESSING;
            chunk.progress = null;
            var ondata2 = chunkServer.ondata || function(fd) {
              return fd;
            };
            var onerror2 = chunkServer.onerror || function(res2) {
              return null;
            };
            var requestUrl = buildURL(apiUrl, chunkServer.url, state2.serverId);
            var headers = typeof chunkServer.headers === "function" ? chunkServer.headers(chunk) : Object.assign({}, chunkServer.headers, {
              "Content-Type": "application/offset+octet-stream",
              "Upload-Offset": chunk.offset,
              "Upload-Length": file2.size,
              "Upload-Name": file2.name
            });
            var request = chunk.request = sendRequest(
              ondata2(chunk.data),
              requestUrl,
              Object.assign({}, chunkServer, {
                headers
              })
            );
            request.onload = function() {
              chunk.status = ChunkStatus.COMPLETE;
              chunk.request = null;
              processChunks();
            };
            request.onprogress = function(lengthComputable, loaded, total) {
              chunk.progress = lengthComputable ? loaded : null;
              updateTotalProgress();
            };
            request.onerror = function(xhr) {
              chunk.status = ChunkStatus.ERROR;
              chunk.request = null;
              chunk.error = onerror2(xhr.response) || xhr.statusText;
              if (!retryProcessChunk(chunk)) {
                error2(
                  createResponse(
                    "error",
                    xhr.status,
                    onerror2(xhr.response) || xhr.statusText,
                    xhr.getAllResponseHeaders()
                  )
                );
              }
            };
            request.ontimeout = function(xhr) {
              chunk.status = ChunkStatus.ERROR;
              chunk.request = null;
              if (!retryProcessChunk(chunk)) {
                createTimeoutResponse(error2)(xhr);
              }
            };
            request.onabort = function() {
              chunk.status = ChunkStatus.QUEUED;
              chunk.request = null;
              abort();
            };
          };
          var retryProcessChunk = function retryProcessChunk2(chunk) {
            if (chunk.retries.length === 0) return false;
            chunk.status = ChunkStatus.WAITING;
            clearTimeout(chunk.timeout);
            chunk.timeout = setTimeout(function() {
              processChunk(chunk);
            }, chunk.retries.shift());
            return true;
          };
          var updateTotalProgress = function updateTotalProgress2() {
            var totalBytesTransfered = chunks.reduce(function(p2, chunk) {
              if (p2 === null || chunk.progress === null) return null;
              return p2 + chunk.progress;
            }, 0);
            if (totalBytesTransfered === null) return progress(false, 0, 0);
            var totalSize = chunks.reduce(function(total, chunk) {
              return total + chunk.size;
            }, 0);
            progress(true, totalBytesTransfered, totalSize);
          };
          var processChunks = function processChunks2() {
            var totalProcessing = chunks.filter(function(chunk) {
              return chunk.status === ChunkStatus.PROCESSING;
            }).length;
            if (totalProcessing >= 1) return;
            processChunk();
          };
          var abortChunks = function abortChunks2() {
            chunks.forEach(function(chunk) {
              clearTimeout(chunk.timeout);
              if (chunk.request) {
                chunk.request.abort();
              }
            });
          };
          if (!state2.serverId) {
            requestTransferId(function(serverId) {
              if (state2.aborted) return;
              transfer(serverId);
              state2.serverId = serverId;
              processChunks();
            });
          } else {
            requestTransferOffset(function(offset3) {
              if (state2.aborted) return;
              chunks.filter(function(chunk) {
                return chunk.offset < offset3;
              }).forEach(function(chunk) {
                chunk.status = ChunkStatus.COMPLETE;
                chunk.progress = chunk.size;
              });
              processChunks();
            });
          }
          return {
            abort: function abort2() {
              state2.aborted = true;
              abortChunks();
            }
          };
        };
        var createFileProcessorFunction = function createFileProcessorFunction2(apiUrl, action, name2, options) {
          return function(file2, metadata, load, error2, progress, abort, transfer) {
            if (!file2) return;
            var canChunkUpload = options.chunkUploads;
            var shouldChunkUpload = canChunkUpload && file2.size > options.chunkSize;
            var willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);
            if (file2 instanceof Blob && willChunkUpload)
              return processFileChunked(
                apiUrl,
                action,
                name2,
                file2,
                metadata,
                load,
                error2,
                progress,
                abort,
                transfer,
                options
              );
            var ondata = action.ondata || function(fd) {
              return fd;
            };
            var onload = action.onload || function(res2) {
              return res2;
            };
            var onerror = action.onerror || function(res2) {
              return null;
            };
            var headers = typeof action.headers === "function" ? action.headers(file2, metadata) || {} : Object.assign(
              {},
              action.headers
            );
            var requestParams = Object.assign({}, action, {
              headers
            });
            var formData = new FormData();
            if (isObject3(metadata)) {
              formData.append(name2, JSON.stringify(metadata));
            }
            (file2 instanceof Blob ? [{ name: null, file: file2 }] : file2).forEach(function(item2) {
              formData.append(
                name2,
                item2.file,
                item2.name === null ? item2.file.name : "" + item2.name + item2.file.name
              );
            });
            var request = sendRequest(
              ondata(formData),
              buildURL(apiUrl, action.url),
              requestParams
            );
            request.onload = function(xhr) {
              load(
                createResponse(
                  "load",
                  xhr.status,
                  onload(xhr.response),
                  xhr.getAllResponseHeaders()
                )
              );
            };
            request.onerror = function(xhr) {
              error2(
                createResponse(
                  "error",
                  xhr.status,
                  onerror(xhr.response) || xhr.statusText,
                  xhr.getAllResponseHeaders()
                )
              );
            };
            request.ontimeout = createTimeoutResponse(error2);
            request.onprogress = progress;
            request.onabort = abort;
            return request;
          };
        };
        var createProcessorFunction = function createProcessorFunction2() {
          var apiUrl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var action = arguments.length > 1 ? arguments[1] : void 0;
          var name2 = arguments.length > 2 ? arguments[2] : void 0;
          var options = arguments.length > 3 ? arguments[3] : void 0;
          if (typeof action === "function")
            return function() {
              for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
                params[_key] = arguments[_key];
              }
              return action.apply(void 0, [name2].concat(params, [options]));
            };
          if (!action || !isString2(action.url)) return null;
          return createFileProcessorFunction(apiUrl, action, name2, options);
        };
        var createRevertFunction = function createRevertFunction2() {
          var apiUrl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var action = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof action === "function") {
            return action;
          }
          if (!action || !isString2(action.url)) {
            return function(uniqueFileId, load) {
              return load();
            };
          }
          var onload = action.onload || function(res2) {
            return res2;
          };
          var onerror = action.onerror || function(res2) {
            return null;
          };
          return function(uniqueFileId, load, error2) {
            var request = sendRequest(
              uniqueFileId,
              apiUrl + action.url,
              action
              // contains method, headers and withCredentials properties
            );
            request.onload = function(xhr) {
              load(
                createResponse(
                  "load",
                  xhr.status,
                  onload(xhr.response),
                  xhr.getAllResponseHeaders()
                )
              );
            };
            request.onerror = function(xhr) {
              error2(
                createResponse(
                  "error",
                  xhr.status,
                  onerror(xhr.response) || xhr.statusText,
                  xhr.getAllResponseHeaders()
                )
              );
            };
            request.ontimeout = createTimeoutResponse(error2);
            return request;
          };
        };
        var getRandomNumber = function getRandomNumber2() {
          var min = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var max = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return min + Math.random() * (max - min);
        };
        var createPerceivedPerformanceUpdater = function createPerceivedPerformanceUpdater2(cb) {
          var duration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
          var offset2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var tickMin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 25;
          var tickMax = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 250;
          var timeout = null;
          var start = Date.now();
          var tick = function tick2() {
            var runtime = Date.now() - start;
            var delay3 = getRandomNumber(tickMin, tickMax);
            if (runtime + delay3 > duration) {
              delay3 = runtime + delay3 - duration;
            }
            var progress = runtime / duration;
            if (progress >= 1 || document.hidden) {
              cb(1);
              return;
            }
            cb(progress);
            timeout = setTimeout(tick2, delay3);
          };
          if (duration > 0) tick();
          return {
            clear: function clear2() {
              clearTimeout(timeout);
            }
          };
        };
        var createFileProcessor = function createFileProcessor2(processFn, options) {
          var state2 = {
            complete: false,
            perceivedProgress: 0,
            perceivedPerformanceUpdater: null,
            progress: null,
            timestamp: null,
            perceivedDuration: 0,
            duration: 0,
            request: null,
            response: null
          };
          var allowMinimumUploadDuration = options.allowMinimumUploadDuration;
          var process2 = function process3(file2, metadata) {
            var progressFn = function progressFn2() {
              if (state2.duration === 0 || state2.progress === null) return;
              api.fire("progress", api.getProgress());
            };
            var completeFn = function completeFn2() {
              state2.complete = true;
              api.fire("load-perceived", state2.response.body);
            };
            api.fire("start");
            state2.timestamp = Date.now();
            state2.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(
              function(progress) {
                state2.perceivedProgress = progress;
                state2.perceivedDuration = Date.now() - state2.timestamp;
                progressFn();
                if (state2.response && state2.perceivedProgress === 1 && !state2.complete) {
                  completeFn();
                }
              },
              // random delay as in a list of files you start noticing
              // files uploading at the exact same speed
              allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0
            );
            state2.request = processFn(
              // the file to process
              file2,
              // the metadata to send along
              metadata,
              // callbacks (load, error, progress, abort, transfer)
              // load expects the body to be a server id if
              // you want to make use of revert
              function(response) {
                state2.response = isObject3(response) ? response : {
                  type: "load",
                  code: 200,
                  body: "" + response,
                  headers: {}
                };
                state2.duration = Date.now() - state2.timestamp;
                state2.progress = 1;
                api.fire("load", state2.response.body);
                if (!allowMinimumUploadDuration || allowMinimumUploadDuration && state2.perceivedProgress === 1) {
                  completeFn();
                }
              },
              // error is expected to be an object with type, code, body
              function(error2) {
                state2.perceivedPerformanceUpdater.clear();
                api.fire(
                  "error",
                  isObject3(error2) ? error2 : {
                    type: "error",
                    code: 0,
                    body: "" + error2
                  }
                );
              },
              // actual processing progress
              function(computable, current, total) {
                state2.duration = Date.now() - state2.timestamp;
                state2.progress = computable ? current / total : null;
                progressFn();
              },
              // abort does not expect a value
              function() {
                state2.perceivedPerformanceUpdater.clear();
                api.fire("abort", state2.response ? state2.response.body : null);
              },
              // register the id for this transfer
              function(transferId) {
                api.fire("transfer", transferId);
              }
            );
          };
          var abort = function abort2() {
            if (!state2.request) return;
            state2.perceivedPerformanceUpdater.clear();
            if (state2.request.abort) state2.request.abort();
            state2.complete = true;
          };
          var reset = function reset2() {
            abort();
            state2.complete = false;
            state2.perceivedProgress = 0;
            state2.progress = 0;
            state2.timestamp = null;
            state2.perceivedDuration = 0;
            state2.duration = 0;
            state2.request = null;
            state2.response = null;
          };
          var getProgress = allowMinimumUploadDuration ? function() {
            return state2.progress ? Math.min(state2.progress, state2.perceivedProgress) : null;
          } : function() {
            return state2.progress || null;
          };
          var getDuration = allowMinimumUploadDuration ? function() {
            return Math.min(state2.duration, state2.perceivedDuration);
          } : function() {
            return state2.duration;
          };
          var api = Object.assign({}, on2(), {
            process: process2,
            // start processing file
            abort,
            // abort active process request
            getProgress,
            getDuration,
            reset
          });
          return api;
        };
        var getFilenameWithoutExtension = function getFilenameWithoutExtension2(name2) {
          return name2.substring(0, name2.lastIndexOf(".")) || name2;
        };
        var createFileStub = function createFileStub2(source) {
          var data2 = [source.name, source.size, source.type];
          if (source instanceof Blob || isBase64DataURI(source)) {
            data2[0] = source.name || getDateString();
          } else if (isBase64DataURI(source)) {
            data2[1] = source.length;
            data2[2] = getMimeTypeFromBase64DataURI(source);
          } else if (isString2(source)) {
            data2[0] = getFilenameFromURL(source);
            data2[1] = 0;
            data2[2] = "application/octet-stream";
          }
          return {
            name: data2[0],
            size: data2[1],
            type: data2[2]
          };
        };
        var isFile = function isFile2(value) {
          return !!(value instanceof File || value instanceof Blob && value.name);
        };
        var deepCloneObject = function deepCloneObject2(src) {
          if (!isObject3(src)) return src;
          var target = isArray3(src) ? [] : {};
          for (var key in src) {
            if (!src.hasOwnProperty(key)) continue;
            var v2 = src[key];
            target[key] = v2 && isObject3(v2) ? deepCloneObject2(v2) : v2;
          }
          return target;
        };
        var createItem = function createItem2() {
          var origin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var serverFileReference = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var file2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var id2 = getUniqueId();
          var state2 = {
            // is archived
            archived: false,
            // if is frozen, no longer fires events
            frozen: false,
            // removed from view
            released: false,
            // original source
            source: null,
            // file model reference
            file: file2,
            // id of file on server
            serverFileReference,
            // id of file transfer on server
            transferId: null,
            // is aborted
            processingAborted: false,
            // current item status
            status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,
            // active processes
            activeLoader: null,
            activeProcessor: null
          };
          var abortProcessingRequestComplete = null;
          var metadata = {};
          var setStatus = function setStatus2(status) {
            return state2.status = status;
          };
          var fire = function fire2(event2) {
            if (state2.released || state2.frozen) return;
            for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              params[_key - 1] = arguments[_key];
            }
            api.fire.apply(api, [event2].concat(params));
          };
          var getFileExtension = function getFileExtension2() {
            return getExtensionFromFilename(state2.file.name);
          };
          var getFileType = function getFileType2() {
            return state2.file.type;
          };
          var getFileSize = function getFileSize2() {
            return state2.file.size;
          };
          var getFile = function getFile2() {
            return state2.file;
          };
          var load = function load2(source, loader, onload) {
            state2.source = source;
            api.fireSync("init");
            if (state2.file) {
              api.fireSync("load-skip");
              return;
            }
            state2.file = createFileStub(source);
            loader.on("init", function() {
              fire("load-init");
            });
            loader.on("meta", function(meta) {
              state2.file.size = meta.size;
              state2.file.filename = meta.filename;
              if (meta.source) {
                origin = FileOrigin.LIMBO;
                state2.serverFileReference = meta.source;
                state2.status = ItemStatus.PROCESSING_COMPLETE;
              }
              fire("load-meta");
            });
            loader.on("progress", function(progress) {
              setStatus(ItemStatus.LOADING);
              fire("load-progress", progress);
            });
            loader.on("error", function(error2) {
              setStatus(ItemStatus.LOAD_ERROR);
              fire("load-request-error", error2);
            });
            loader.on("abort", function() {
              setStatus(ItemStatus.INIT);
              fire("load-abort");
            });
            loader.on("load", function(file3) {
              state2.activeLoader = null;
              var success = function success2(result) {
                state2.file = isFile(result) ? result : state2.file;
                if (origin === FileOrigin.LIMBO && state2.serverFileReference) {
                  setStatus(ItemStatus.PROCESSING_COMPLETE);
                } else {
                  setStatus(ItemStatus.IDLE);
                }
                fire("load");
              };
              var error2 = function error3(result) {
                state2.file = file3;
                fire("load-meta");
                setStatus(ItemStatus.LOAD_ERROR);
                fire("load-file-error", result);
              };
              if (state2.serverFileReference) {
                success(file3);
                return;
              }
              onload(file3, success, error2);
            });
            loader.setSource(source);
            state2.activeLoader = loader;
            loader.load();
          };
          var retryLoad = function retryLoad2() {
            if (!state2.activeLoader) {
              return;
            }
            state2.activeLoader.load();
          };
          var abortLoad = function abortLoad2() {
            if (state2.activeLoader) {
              state2.activeLoader.abort();
              return;
            }
            setStatus(ItemStatus.INIT);
            fire("load-abort");
          };
          var process2 = function process3(processor, onprocess) {
            if (state2.processingAborted) {
              state2.processingAborted = false;
              return;
            }
            setStatus(ItemStatus.PROCESSING);
            abortProcessingRequestComplete = null;
            if (!(state2.file instanceof Blob)) {
              api.on("load", function() {
                process3(processor, onprocess);
              });
              return;
            }
            processor.on("load", function(serverFileReference2) {
              state2.transferId = null;
              state2.serverFileReference = serverFileReference2;
            });
            processor.on("transfer", function(transferId) {
              state2.transferId = transferId;
            });
            processor.on("load-perceived", function(serverFileReference2) {
              state2.activeProcessor = null;
              state2.transferId = null;
              state2.serverFileReference = serverFileReference2;
              setStatus(ItemStatus.PROCESSING_COMPLETE);
              fire("process-complete", serverFileReference2);
            });
            processor.on("start", function() {
              fire("process-start");
            });
            processor.on("error", function(error3) {
              state2.activeProcessor = null;
              setStatus(ItemStatus.PROCESSING_ERROR);
              fire("process-error", error3);
            });
            processor.on("abort", function(serverFileReference2) {
              state2.activeProcessor = null;
              state2.serverFileReference = serverFileReference2;
              setStatus(ItemStatus.IDLE);
              fire("process-abort");
              if (abortProcessingRequestComplete) {
                abortProcessingRequestComplete();
              }
            });
            processor.on("progress", function(progress) {
              fire("process-progress", progress);
            });
            var success = function success2(file3) {
              if (state2.archived) return;
              processor.process(file3, Object.assign({}, metadata));
            };
            var error2 = console.error;
            onprocess(state2.file, success, error2);
            state2.activeProcessor = processor;
          };
          var requestProcessing = function requestProcessing2() {
            state2.processingAborted = false;
            setStatus(ItemStatus.PROCESSING_QUEUED);
          };
          var abortProcessing = function abortProcessing2() {
            return new Promise(function(resolve) {
              if (!state2.activeProcessor) {
                state2.processingAborted = true;
                setStatus(ItemStatus.IDLE);
                fire("process-abort");
                resolve();
                return;
              }
              abortProcessingRequestComplete = function abortProcessingRequestComplete2() {
                resolve();
              };
              state2.activeProcessor.abort();
            });
          };
          var revert = function revert2(revertFileUpload, forceRevert) {
            return new Promise(function(resolve, reject) {
              var serverTransferId = state2.serverFileReference !== null ? state2.serverFileReference : state2.transferId;
              if (serverTransferId === null) {
                resolve();
                return;
              }
              revertFileUpload(
                serverTransferId,
                function() {
                  state2.serverFileReference = null;
                  state2.transferId = null;
                  resolve();
                },
                function(error2) {
                  if (!forceRevert) {
                    resolve();
                    return;
                  }
                  setStatus(ItemStatus.PROCESSING_REVERT_ERROR);
                  fire("process-revert-error");
                  reject(error2);
                }
              );
              setStatus(ItemStatus.IDLE);
              fire("process-revert");
            });
          };
          var _setMetadata = function setMetadata(key, value, silent) {
            var keys = key.split(".");
            var root2 = keys[0];
            var last = keys.pop();
            var data2 = metadata;
            keys.forEach(function(key2) {
              return data2 = data2[key2];
            });
            if (JSON.stringify(data2[last]) === JSON.stringify(value)) return;
            data2[last] = value;
            fire("metadata-update", {
              key: root2,
              value: metadata[root2],
              silent
            });
          };
          var getMetadata = function getMetadata2(key) {
            return deepCloneObject(key ? metadata[key] : metadata);
          };
          var api = Object.assign(
            {
              id: {
                get: function get() {
                  return id2;
                }
              },
              origin: {
                get: function get() {
                  return origin;
                },
                set: function set3(value) {
                  return origin = value;
                }
              },
              serverId: {
                get: function get() {
                  return state2.serverFileReference;
                }
              },
              transferId: {
                get: function get() {
                  return state2.transferId;
                }
              },
              status: {
                get: function get() {
                  return state2.status;
                }
              },
              filename: {
                get: function get() {
                  return state2.file.name;
                }
              },
              filenameWithoutExtension: {
                get: function get() {
                  return getFilenameWithoutExtension(state2.file.name);
                }
              },
              fileExtension: { get: getFileExtension },
              fileType: { get: getFileType },
              fileSize: { get: getFileSize },
              file: { get: getFile },
              relativePath: {
                get: function get() {
                  return state2.file._relativePath;
                }
              },
              source: {
                get: function get() {
                  return state2.source;
                }
              },
              getMetadata,
              setMetadata: function setMetadata(key, value, silent) {
                if (isObject3(key)) {
                  var data2 = key;
                  Object.keys(data2).forEach(function(key2) {
                    _setMetadata(key2, data2[key2], value);
                  });
                  return key;
                }
                _setMetadata(key, value, silent);
                return value;
              },
              extend: function extend4(name2, handler) {
                return itemAPI[name2] = handler;
              },
              abortLoad,
              retryLoad,
              requestProcessing,
              abortProcessing,
              load,
              process: process2,
              revert
            },
            on2(),
            {
              freeze: function freeze() {
                return state2.frozen = true;
              },
              release: function release() {
                return state2.released = true;
              },
              released: {
                get: function get() {
                  return state2.released;
                }
              },
              archive: function archive() {
                return state2.archived = true;
              },
              archived: {
                get: function get() {
                  return state2.archived;
                }
              }
            }
          );
          var itemAPI = createObject(api);
          return itemAPI;
        };
        var getItemIndexByQuery = function getItemIndexByQuery2(items, query) {
          if (isEmpty(query)) {
            return 0;
          }
          if (!isString2(query)) {
            return -1;
          }
          return items.findIndex(function(item2) {
            return item2.id === query;
          });
        };
        var getItemById = function getItemById2(items, itemId) {
          var index2 = getItemIndexByQuery(items, itemId);
          if (index2 < 0) {
            return;
          }
          return items[index2] || null;
        };
        var fetchBlob = function fetchBlob2(url, load, error2, progress, abort, headers) {
          var request = sendRequest(null, url, {
            method: "GET",
            responseType: "blob"
          });
          request.onload = function(xhr) {
            var headers2 = xhr.getAllResponseHeaders();
            var filename = getFileInfoFromHeaders(headers2).name || getFilenameFromURL(url);
            load(
              createResponse("load", xhr.status, getFileFromBlob(xhr.response, filename), headers2)
            );
          };
          request.onerror = function(xhr) {
            error2(createResponse("error", xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));
          };
          request.onheaders = function(xhr) {
            headers(createResponse("headers", xhr.status, null, xhr.getAllResponseHeaders()));
          };
          request.ontimeout = createTimeoutResponse(error2);
          request.onprogress = progress;
          request.onabort = abort;
          return request;
        };
        var getDomainFromURL = function getDomainFromURL2(url) {
          if (url.indexOf("//") === 0) {
            url = location.protocol + url;
          }
          return url.toLowerCase().replace("blob:", "").replace(/([a-z])?:\/\//, "$1").split("/")[0];
        };
        var isExternalURL = function isExternalURL2(url) {
          return (url.indexOf(":") > -1 || url.indexOf("//") > -1) && getDomainFromURL(location.href) !== getDomainFromURL(url);
        };
        var dynamicLabel = function dynamicLabel2(label) {
          return function() {
            return isFunction2(label) ? label.apply(void 0, arguments) : label;
          };
        };
        var isMockItem = function isMockItem2(item2) {
          return !isFile(item2.file);
        };
        var listUpdated = function listUpdated2(dispatch2, state2) {
          clearTimeout(state2.listUpdateTimeout);
          state2.listUpdateTimeout = setTimeout(function() {
            dispatch2("DID_UPDATE_ITEMS", { items: getActiveItems(state2.items) });
          }, 0);
        };
        var optionalPromise = function optionalPromise2(fn2) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          return new Promise(function(resolve) {
            if (!fn2) {
              return resolve(true);
            }
            var result = fn2.apply(void 0, params);
            if (result == null) {
              return resolve(true);
            }
            if (typeof result === "boolean") {
              return resolve(result);
            }
            if (typeof result.then === "function") {
              result.then(resolve);
            }
          });
        };
        var sortItems = function sortItems2(state2, compare) {
          state2.items.sort(function(a3, b2) {
            return compare(createItemAPI(a3), createItemAPI(b2));
          });
        };
        var getItemByQueryFromState = function getItemByQueryFromState2(state2, itemHandler) {
          return function() {
            var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var query = _ref.query, _ref$success = _ref.success, success = _ref$success === void 0 ? function() {
            } : _ref$success, _ref$failure = _ref.failure, failure = _ref$failure === void 0 ? function() {
            } : _ref$failure, options = _objectWithoutProperties(_ref, ["query", "success", "failure"]);
            var item2 = getItemByQuery(state2.items, query);
            if (!item2) {
              failure({
                error: createResponse("error", 0, "Item not found"),
                file: null
              });
              return;
            }
            itemHandler(item2, success, failure, options || {});
          };
        };
        var actions = function actions2(dispatch2, query, state2) {
          return {
            /**
             * Aborts all ongoing processes
             */
            ABORT_ALL: function ABORT_ALL() {
              getActiveItems(state2.items).forEach(function(item2) {
                item2.freeze();
                item2.abortLoad();
                item2.abortProcessing();
              });
            },
            /**
             * Sets initial files
             */
            DID_SET_FILES: function DID_SET_FILES(_ref2) {
              var _ref2$value = _ref2.value, value = _ref2$value === void 0 ? [] : _ref2$value;
              var files = value.map(function(file2) {
                return {
                  source: file2.source ? file2.source : file2,
                  options: file2.options
                };
              });
              var activeItems = getActiveItems(state2.items);
              activeItems.forEach(function(item2) {
                if (!files.find(function(file2) {
                  return file2.source === item2.source || file2.source === item2.file;
                })) {
                  dispatch2("REMOVE_ITEM", { query: item2, remove: false });
                }
              });
              activeItems = getActiveItems(state2.items);
              files.forEach(function(file2, index2) {
                if (activeItems.find(function(item2) {
                  return item2.source === file2.source || item2.file === file2.source;
                }))
                  return;
                dispatch2(
                  "ADD_ITEM",
                  Object.assign({}, file2, {
                    interactionMethod: InteractionMethod.NONE,
                    index: index2
                  })
                );
              });
            },
            DID_UPDATE_ITEM_METADATA: function DID_UPDATE_ITEM_METADATA(_ref3) {
              var id2 = _ref3.id, action = _ref3.action, change2 = _ref3.change;
              if (change2.silent) return;
              clearTimeout(state2.itemUpdateTimeout);
              state2.itemUpdateTimeout = setTimeout(function() {
                var item2 = getItemById(state2.items, id2);
                if (!query("IS_ASYNC")) {
                  applyFilterChain("SHOULD_PREPARE_OUTPUT", false, {
                    item: item2,
                    query,
                    action,
                    change: change2
                  }).then(function(shouldPrepareOutput) {
                    var beforePrepareFile = query("GET_BEFORE_PREPARE_FILE");
                    if (beforePrepareFile)
                      shouldPrepareOutput = beforePrepareFile(item2, shouldPrepareOutput);
                    if (!shouldPrepareOutput) return;
                    dispatch2(
                      "REQUEST_PREPARE_OUTPUT",
                      {
                        query: id2,
                        item: item2,
                        success: function success(file2) {
                          dispatch2("DID_PREPARE_OUTPUT", { id: id2, file: file2 });
                        }
                      },
                      true
                    );
                  });
                  return;
                }
                if (item2.origin === FileOrigin.LOCAL) {
                  dispatch2("DID_LOAD_ITEM", {
                    id: item2.id,
                    error: null,
                    serverFileReference: item2.source
                  });
                }
                var upload = function upload2() {
                  setTimeout(function() {
                    dispatch2("REQUEST_ITEM_PROCESSING", { query: id2 });
                  }, 32);
                };
                var revert = function revert2(doUpload) {
                  item2.revert(
                    createRevertFunction(
                      state2.options.server.url,
                      state2.options.server.revert
                    ),
                    query("GET_FORCE_REVERT")
                  ).then(doUpload ? upload : function() {
                  }).catch(function() {
                  });
                };
                var abort = function abort2(doUpload) {
                  item2.abortProcessing().then(doUpload ? upload : function() {
                  });
                };
                if (item2.status === ItemStatus.PROCESSING_COMPLETE) {
                  return revert(state2.options.instantUpload);
                }
                if (item2.status === ItemStatus.PROCESSING) {
                  return abort(state2.options.instantUpload);
                }
                if (state2.options.instantUpload) {
                  upload();
                }
              }, 0);
            },
            MOVE_ITEM: function MOVE_ITEM(_ref4) {
              var query2 = _ref4.query, index2 = _ref4.index;
              var item2 = getItemByQuery(state2.items, query2);
              if (!item2) return;
              var currentIndex = state2.items.indexOf(item2);
              index2 = limit(index2, 0, state2.items.length - 1);
              if (currentIndex === index2) return;
              state2.items.splice(index2, 0, state2.items.splice(currentIndex, 1)[0]);
            },
            SORT: function SORT(_ref5) {
              var compare = _ref5.compare;
              sortItems(state2, compare);
              dispatch2("DID_SORT_ITEMS", {
                items: query("GET_ACTIVE_ITEMS")
              });
            },
            ADD_ITEMS: function ADD_ITEMS(_ref6) {
              var items = _ref6.items, index2 = _ref6.index, interactionMethod = _ref6.interactionMethod, _ref6$success = _ref6.success, success = _ref6$success === void 0 ? function() {
              } : _ref6$success, _ref6$failure = _ref6.failure, failure = _ref6$failure === void 0 ? function() {
              } : _ref6$failure;
              var currentIndex = index2;
              if (index2 === -1 || typeof index2 === "undefined") {
                var insertLocation = query("GET_ITEM_INSERT_LOCATION");
                var totalItems = query("GET_TOTAL_ITEMS");
                currentIndex = insertLocation === "before" ? 0 : totalItems;
              }
              var ignoredFiles = query("GET_IGNORED_FILES");
              var isValidFile = function isValidFile2(source) {
                return isFile(source) ? !ignoredFiles.includes(source.name.toLowerCase()) : !isEmpty(source);
              };
              var validItems = items.filter(isValidFile);
              var promises = validItems.map(function(source) {
                return new Promise(function(resolve, reject) {
                  dispatch2("ADD_ITEM", {
                    interactionMethod,
                    source: source.source || source,
                    success: resolve,
                    failure: reject,
                    index: currentIndex++,
                    options: source.options || {}
                  });
                });
              });
              Promise.all(promises).then(success).catch(failure);
            },
            /**
             * @param source
             * @param index
             * @param interactionMethod
             */
            ADD_ITEM: function ADD_ITEM(_ref7) {
              var source = _ref7.source, _ref7$index = _ref7.index, index2 = _ref7$index === void 0 ? -1 : _ref7$index, interactionMethod = _ref7.interactionMethod, _ref7$success = _ref7.success, success = _ref7$success === void 0 ? function() {
              } : _ref7$success, _ref7$failure = _ref7.failure, failure = _ref7$failure === void 0 ? function() {
              } : _ref7$failure, _ref7$options = _ref7.options, options = _ref7$options === void 0 ? {} : _ref7$options;
              if (isEmpty(source)) {
                failure({
                  error: createResponse("error", 0, "No source"),
                  file: null
                });
                return;
              }
              if (isFile(source) && state2.options.ignoredFiles.includes(source.name.toLowerCase())) {
                return;
              }
              if (!hasRoomForItem(state2)) {
                if (state2.options.allowMultiple || !state2.options.allowMultiple && !state2.options.allowReplace) {
                  var error2 = createResponse("warning", 0, "Max files");
                  dispatch2("DID_THROW_MAX_FILES", {
                    source,
                    error: error2
                  });
                  failure({ error: error2, file: null });
                  return;
                }
                var _item = getActiveItems(state2.items)[0];
                if (_item.status === ItemStatus.PROCESSING_COMPLETE || _item.status === ItemStatus.PROCESSING_REVERT_ERROR) {
                  var forceRevert = query("GET_FORCE_REVERT");
                  _item.revert(
                    createRevertFunction(
                      state2.options.server.url,
                      state2.options.server.revert
                    ),
                    forceRevert
                  ).then(function() {
                    if (!forceRevert) return;
                    dispatch2("ADD_ITEM", {
                      source,
                      index: index2,
                      interactionMethod,
                      success,
                      failure,
                      options
                    });
                  }).catch(function() {
                  });
                  if (forceRevert) return;
                }
                dispatch2("REMOVE_ITEM", { query: _item.id });
              }
              var origin = options.type === "local" ? FileOrigin.LOCAL : options.type === "limbo" ? FileOrigin.LIMBO : FileOrigin.INPUT;
              var item2 = createItem(
                // where did this file come from
                origin,
                // an input file never has a server file reference
                origin === FileOrigin.INPUT ? null : source,
                // file mock data, if defined
                options.file
              );
              Object.keys(options.metadata || {}).forEach(function(key) {
                item2.setMetadata(key, options.metadata[key]);
              });
              applyFilters("DID_CREATE_ITEM", item2, { query, dispatch: dispatch2 });
              var itemInsertLocation = query("GET_ITEM_INSERT_LOCATION");
              if (!state2.options.itemInsertLocationFreedom) {
                index2 = itemInsertLocation === "before" ? -1 : state2.items.length;
              }
              insertItem(state2.items, item2, index2);
              if (isFunction2(itemInsertLocation) && source) {
                sortItems(state2, itemInsertLocation);
              }
              var id2 = item2.id;
              item2.on("init", function() {
                dispatch2("DID_INIT_ITEM", { id: id2 });
              });
              item2.on("load-init", function() {
                dispatch2("DID_START_ITEM_LOAD", { id: id2 });
              });
              item2.on("load-meta", function() {
                dispatch2("DID_UPDATE_ITEM_META", { id: id2 });
              });
              item2.on("load-progress", function(progress) {
                dispatch2("DID_UPDATE_ITEM_LOAD_PROGRESS", { id: id2, progress });
              });
              item2.on("load-request-error", function(error3) {
                var mainStatus = dynamicLabel(state2.options.labelFileLoadError)(error3);
                if (error3.code >= 400 && error3.code < 500) {
                  dispatch2("DID_THROW_ITEM_INVALID", {
                    id: id2,
                    error: error3,
                    status: {
                      main: mainStatus,
                      sub: error3.code + " (" + error3.body + ")"
                    }
                  });
                  failure({ error: error3, file: createItemAPI(item2) });
                  return;
                }
                dispatch2("DID_THROW_ITEM_LOAD_ERROR", {
                  id: id2,
                  error: error3,
                  status: {
                    main: mainStatus,
                    sub: state2.options.labelTapToRetry
                  }
                });
              });
              item2.on("load-file-error", function(error3) {
                dispatch2("DID_THROW_ITEM_INVALID", {
                  id: id2,
                  error: error3.status,
                  status: error3.status
                });
                failure({ error: error3.status, file: createItemAPI(item2) });
              });
              item2.on("load-abort", function() {
                dispatch2("REMOVE_ITEM", { query: id2 });
              });
              item2.on("load-skip", function() {
                dispatch2("COMPLETE_LOAD_ITEM", {
                  query: id2,
                  item: item2,
                  data: {
                    source,
                    success
                  }
                });
              });
              item2.on("load", function() {
                var handleAdd = function handleAdd2(shouldAdd) {
                  if (!shouldAdd) {
                    dispatch2("REMOVE_ITEM", {
                      query: id2
                    });
                    return;
                  }
                  item2.on("metadata-update", function(change2) {
                    dispatch2("DID_UPDATE_ITEM_METADATA", { id: id2, change: change2 });
                  });
                  applyFilterChain("SHOULD_PREPARE_OUTPUT", false, {
                    item: item2,
                    query
                  }).then(function(shouldPrepareOutput) {
                    var beforePrepareFile = query("GET_BEFORE_PREPARE_FILE");
                    if (beforePrepareFile)
                      shouldPrepareOutput = beforePrepareFile(item2, shouldPrepareOutput);
                    var loadComplete = function loadComplete2() {
                      dispatch2("COMPLETE_LOAD_ITEM", {
                        query: id2,
                        item: item2,
                        data: {
                          source,
                          success
                        }
                      });
                      listUpdated(dispatch2, state2);
                    };
                    if (shouldPrepareOutput) {
                      dispatch2(
                        "REQUEST_PREPARE_OUTPUT",
                        {
                          query: id2,
                          item: item2,
                          success: function success2(file2) {
                            dispatch2("DID_PREPARE_OUTPUT", { id: id2, file: file2 });
                            loadComplete();
                          }
                        },
                        true
                      );
                      return;
                    }
                    loadComplete();
                  });
                };
                applyFilterChain("DID_LOAD_ITEM", item2, { query, dispatch: dispatch2 }).then(function() {
                  optionalPromise(query("GET_BEFORE_ADD_FILE"), createItemAPI(item2)).then(
                    handleAdd
                  );
                }).catch(function(e4) {
                  if (!e4 || !e4.error || !e4.status) return handleAdd(false);
                  dispatch2("DID_THROW_ITEM_INVALID", {
                    id: id2,
                    error: e4.error,
                    status: e4.status
                  });
                });
              });
              item2.on("process-start", function() {
                dispatch2("DID_START_ITEM_PROCESSING", { id: id2 });
              });
              item2.on("process-progress", function(progress) {
                dispatch2("DID_UPDATE_ITEM_PROCESS_PROGRESS", { id: id2, progress });
              });
              item2.on("process-error", function(error3) {
                dispatch2("DID_THROW_ITEM_PROCESSING_ERROR", {
                  id: id2,
                  error: error3,
                  status: {
                    main: dynamicLabel(state2.options.labelFileProcessingError)(error3),
                    sub: state2.options.labelTapToRetry
                  }
                });
              });
              item2.on("process-revert-error", function(error3) {
                dispatch2("DID_THROW_ITEM_PROCESSING_REVERT_ERROR", {
                  id: id2,
                  error: error3,
                  status: {
                    main: dynamicLabel(state2.options.labelFileProcessingRevertError)(error3),
                    sub: state2.options.labelTapToRetry
                  }
                });
              });
              item2.on("process-complete", function(serverFileReference) {
                dispatch2("DID_COMPLETE_ITEM_PROCESSING", {
                  id: id2,
                  error: null,
                  serverFileReference
                });
                dispatch2("DID_DEFINE_VALUE", { id: id2, value: serverFileReference });
              });
              item2.on("process-abort", function() {
                dispatch2("DID_ABORT_ITEM_PROCESSING", { id: id2 });
              });
              item2.on("process-revert", function() {
                dispatch2("DID_REVERT_ITEM_PROCESSING", { id: id2 });
                dispatch2("DID_DEFINE_VALUE", { id: id2, value: null });
              });
              dispatch2("DID_ADD_ITEM", {
                id: id2,
                index: index2,
                interactionMethod
              });
              listUpdated(dispatch2, state2);
              var _ref8 = state2.options.server || {}, url = _ref8.url, load = _ref8.load, restore = _ref8.restore, fetch2 = _ref8.fetch;
              item2.load(
                source,
                // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)
                createFileLoader(
                  origin === FileOrigin.INPUT ? (
                    // input, if is remote, see if should use custom fetch, else use default fetchBlob
                    isString2(source) && isExternalURL(source) ? fetch2 ? createFetchFunction(url, fetch2) : fetchBlob : fetchBlob
                  ) : (
                    // limbo or local
                    origin === FileOrigin.LIMBO ? createFetchFunction(url, restore) : createFetchFunction(url, load)
                  )
                  // local
                ),
                // called when the file is loaded so it can be piped through the filters
                function(file2, success2, error3) {
                  applyFilterChain("LOAD_FILE", file2, { query }).then(success2).catch(error3);
                }
              );
            },
            REQUEST_PREPARE_OUTPUT: function REQUEST_PREPARE_OUTPUT(_ref9) {
              var item2 = _ref9.item, success = _ref9.success, _ref9$failure = _ref9.failure, failure = _ref9$failure === void 0 ? function() {
              } : _ref9$failure;
              var err = {
                error: createResponse("error", 0, "Item not found"),
                file: null
              };
              if (item2.archived) return failure(err);
              applyFilterChain("PREPARE_OUTPUT", item2.file, { query, item: item2 }).then(
                function(result) {
                  applyFilterChain("COMPLETE_PREPARE_OUTPUT", result, {
                    query,
                    item: item2
                  }).then(function(result2) {
                    if (item2.archived) return failure(err);
                    success(result2);
                  });
                }
              );
            },
            COMPLETE_LOAD_ITEM: function COMPLETE_LOAD_ITEM(_ref10) {
              var item2 = _ref10.item, data2 = _ref10.data;
              var success = data2.success, source = data2.source;
              var itemInsertLocation = query("GET_ITEM_INSERT_LOCATION");
              if (isFunction2(itemInsertLocation) && source) {
                sortItems(state2, itemInsertLocation);
              }
              dispatch2("DID_LOAD_ITEM", {
                id: item2.id,
                error: null,
                serverFileReference: item2.origin === FileOrigin.INPUT ? null : source
              });
              success(createItemAPI(item2));
              if (item2.origin === FileOrigin.LOCAL) {
                dispatch2("DID_LOAD_LOCAL_ITEM", { id: item2.id });
                return;
              }
              if (item2.origin === FileOrigin.LIMBO) {
                dispatch2("DID_COMPLETE_ITEM_PROCESSING", {
                  id: item2.id,
                  error: null,
                  serverFileReference: source
                });
                dispatch2("DID_DEFINE_VALUE", {
                  id: item2.id,
                  value: item2.serverId || source
                });
                return;
              }
              if (query("IS_ASYNC") && state2.options.instantUpload) {
                dispatch2("REQUEST_ITEM_PROCESSING", { query: item2.id });
              }
            },
            RETRY_ITEM_LOAD: getItemByQueryFromState(state2, function(item2) {
              item2.retryLoad();
            }),
            REQUEST_ITEM_PREPARE: getItemByQueryFromState(state2, function(item2, _success, failure) {
              dispatch2(
                "REQUEST_PREPARE_OUTPUT",
                {
                  query: item2.id,
                  item: item2,
                  success: function success(file2) {
                    dispatch2("DID_PREPARE_OUTPUT", { id: item2.id, file: file2 });
                    _success({
                      file: item2,
                      output: file2
                    });
                  },
                  failure
                },
                true
              );
            }),
            REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state2, function(item2, success, failure) {
              var itemCanBeQueuedForProcessing = (
                // waiting for something
                item2.status === ItemStatus.IDLE || // processing went wrong earlier
                item2.status === ItemStatus.PROCESSING_ERROR
              );
              if (!itemCanBeQueuedForProcessing) {
                var processNow = function processNow2() {
                  return dispatch2("REQUEST_ITEM_PROCESSING", {
                    query: item2,
                    success,
                    failure
                  });
                };
                var process2 = function process3() {
                  return document.hidden ? processNow() : setTimeout(processNow, 32);
                };
                if (item2.status === ItemStatus.PROCESSING_COMPLETE || item2.status === ItemStatus.PROCESSING_REVERT_ERROR) {
                  item2.revert(
                    createRevertFunction(
                      state2.options.server.url,
                      state2.options.server.revert
                    ),
                    query("GET_FORCE_REVERT")
                  ).then(process2).catch(function() {
                  });
                } else if (item2.status === ItemStatus.PROCESSING) {
                  item2.abortProcessing().then(process2);
                }
                return;
              }
              if (item2.status === ItemStatus.PROCESSING_QUEUED) return;
              item2.requestProcessing();
              dispatch2("DID_REQUEST_ITEM_PROCESSING", { id: item2.id });
              dispatch2("PROCESS_ITEM", { query: item2, success, failure }, true);
            }),
            PROCESS_ITEM: getItemByQueryFromState(state2, function(item2, success, failure) {
              var maxParallelUploads = query("GET_MAX_PARALLEL_UPLOADS");
              var totalCurrentUploads = query("GET_ITEMS_BY_STATUS", ItemStatus.PROCESSING).length;
              if (totalCurrentUploads === maxParallelUploads) {
                state2.processingQueue.push({
                  id: item2.id,
                  success,
                  failure
                });
                return;
              }
              if (item2.status === ItemStatus.PROCESSING) return;
              var processNext = function processNext2() {
                var queueEntry = state2.processingQueue.shift();
                if (!queueEntry) return;
                var id2 = queueEntry.id, success2 = queueEntry.success, failure2 = queueEntry.failure;
                var itemReference = getItemByQuery(state2.items, id2);
                if (!itemReference || itemReference.archived) {
                  processNext2();
                  return;
                }
                dispatch2(
                  "PROCESS_ITEM",
                  { query: id2, success: success2, failure: failure2 },
                  true
                );
              };
              item2.onOnce("process-complete", function() {
                success(createItemAPI(item2));
                processNext();
                var server = state2.options.server;
                var instantUpload = state2.options.instantUpload;
                if (instantUpload && item2.origin === FileOrigin.LOCAL && isFunction2(server.remove)) {
                  var noop = function noop2() {
                  };
                  item2.origin = FileOrigin.LIMBO;
                  state2.options.server.remove(item2.source, noop, noop);
                }
                var allItemsProcessed = query("GET_ITEMS_BY_STATUS", ItemStatus.PROCESSING_COMPLETE).length === state2.items.length;
                if (allItemsProcessed) {
                  dispatch2("DID_COMPLETE_ITEM_PROCESSING_ALL");
                }
              });
              item2.onOnce("process-error", function(error2) {
                failure({ error: error2, file: createItemAPI(item2) });
                processNext();
              });
              var options = state2.options;
              item2.process(
                createFileProcessor(
                  createProcessorFunction(
                    options.server.url,
                    options.server.process,
                    options.name,
                    {
                      chunkTransferId: item2.transferId,
                      chunkServer: options.server.patch,
                      chunkUploads: options.chunkUploads,
                      chunkForce: options.chunkForce,
                      chunkSize: options.chunkSize,
                      chunkRetryDelays: options.chunkRetryDelays
                    }
                  ),
                  {
                    allowMinimumUploadDuration: query("GET_ALLOW_MINIMUM_UPLOAD_DURATION")
                  }
                ),
                // called when the file is about to be processed so it can be piped through the transform filters
                function(file2, success2, error2) {
                  applyFilterChain("PREPARE_OUTPUT", file2, { query, item: item2 }).then(function(file3) {
                    dispatch2("DID_PREPARE_OUTPUT", { id: item2.id, file: file3 });
                    success2(file3);
                  }).catch(error2);
                }
              );
            }),
            RETRY_ITEM_PROCESSING: getItemByQueryFromState(state2, function(item2) {
              dispatch2("REQUEST_ITEM_PROCESSING", { query: item2 });
            }),
            REQUEST_REMOVE_ITEM: getItemByQueryFromState(state2, function(item2) {
              optionalPromise(query("GET_BEFORE_REMOVE_FILE"), createItemAPI(item2)).then(function(shouldRemove) {
                if (!shouldRemove) {
                  return;
                }
                dispatch2("REMOVE_ITEM", { query: item2 });
              });
            }),
            RELEASE_ITEM: getItemByQueryFromState(state2, function(item2) {
              item2.release();
            }),
            REMOVE_ITEM: getItemByQueryFromState(state2, function(item2, success, failure, options) {
              var removeFromView = function removeFromView2() {
                var id2 = item2.id;
                getItemById(state2.items, id2).archive();
                dispatch2("DID_REMOVE_ITEM", { error: null, id: id2, item: item2 });
                listUpdated(dispatch2, state2);
                success(createItemAPI(item2));
              };
              var server = state2.options.server;
              if (item2.origin === FileOrigin.LOCAL && server && isFunction2(server.remove) && options.remove !== false) {
                dispatch2("DID_START_ITEM_REMOVE", { id: item2.id });
                server.remove(
                  item2.source,
                  function() {
                    return removeFromView();
                  },
                  function(status) {
                    dispatch2("DID_THROW_ITEM_REMOVE_ERROR", {
                      id: item2.id,
                      error: createResponse("error", 0, status, null),
                      status: {
                        main: dynamicLabel(state2.options.labelFileRemoveError)(status),
                        sub: state2.options.labelTapToRetry
                      }
                    });
                  }
                );
              } else {
                if (options.revert && item2.origin !== FileOrigin.LOCAL && item2.serverId !== null || // if chunked uploads are enabled and we're uploading in chunks for this specific file
                // or if the file isn't big enough for chunked uploads but chunkForce is set then call
                // revert before removing from the view...
                state2.options.chunkUploads && item2.file.size > state2.options.chunkSize || state2.options.chunkUploads && state2.options.chunkForce) {
                  item2.revert(
                    createRevertFunction(
                      state2.options.server.url,
                      state2.options.server.revert
                    ),
                    query("GET_FORCE_REVERT")
                  );
                }
                removeFromView();
              }
            }),
            ABORT_ITEM_LOAD: getItemByQueryFromState(state2, function(item2) {
              item2.abortLoad();
            }),
            ABORT_ITEM_PROCESSING: getItemByQueryFromState(state2, function(item2) {
              if (item2.serverId) {
                dispatch2("REVERT_ITEM_PROCESSING", { id: item2.id });
                return;
              }
              item2.abortProcessing().then(function() {
                var shouldRemove = state2.options.instantUpload;
                if (shouldRemove) {
                  dispatch2("REMOVE_ITEM", { query: item2.id });
                }
              });
            }),
            REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state2, function(item2) {
              if (!state2.options.instantUpload) {
                dispatch2("REVERT_ITEM_PROCESSING", { query: item2 });
                return;
              }
              var handleRevert = function handleRevert2(shouldRevert) {
                if (!shouldRevert) return;
                dispatch2("REVERT_ITEM_PROCESSING", { query: item2 });
              };
              var fn2 = query("GET_BEFORE_REMOVE_FILE");
              if (!fn2) {
                return handleRevert(true);
              }
              var requestRemoveResult = fn2(createItemAPI(item2));
              if (requestRemoveResult == null) {
                return handleRevert(true);
              }
              if (typeof requestRemoveResult === "boolean") {
                return handleRevert(requestRemoveResult);
              }
              if (typeof requestRemoveResult.then === "function") {
                requestRemoveResult.then(handleRevert);
              }
            }),
            REVERT_ITEM_PROCESSING: getItemByQueryFromState(state2, function(item2) {
              item2.revert(
                createRevertFunction(state2.options.server.url, state2.options.server.revert),
                query("GET_FORCE_REVERT")
              ).then(function() {
                var shouldRemove = state2.options.instantUpload || isMockItem(item2);
                if (shouldRemove) {
                  dispatch2("REMOVE_ITEM", { query: item2.id });
                }
              }).catch(function() {
              });
            }),
            SET_OPTIONS: function SET_OPTIONS(_ref11) {
              var options = _ref11.options;
              var optionKeys = Object.keys(options);
              var prioritizedOptionKeys = PrioritizedOptions.filter(function(key) {
                return optionKeys.includes(key);
              });
              var orderedOptionKeys = [].concat(
                _toConsumableArray2(prioritizedOptionKeys),
                _toConsumableArray2(
                  Object.keys(options).filter(function(key) {
                    return !prioritizedOptionKeys.includes(key);
                  })
                )
              );
              orderedOptionKeys.forEach(function(key) {
                dispatch2("SET_" + fromCamels(key, "_").toUpperCase(), {
                  value: options[key]
                });
              });
            }
          };
        };
        var PrioritizedOptions = ["server"];
        var formatFilename = function formatFilename2(name2) {
          return name2;
        };
        var createElement$1 = function createElement2(tagName) {
          return document.createElement(tagName);
        };
        var text2 = function text3(node, value) {
          var textNode = node.childNodes[0];
          if (!textNode) {
            textNode = document.createTextNode(value);
            node.appendChild(textNode);
          } else if (value !== textNode.nodeValue) {
            textNode.nodeValue = value;
          }
        };
        var polarToCartesian = function polarToCartesian2(centerX, centerY, radius, angleInDegrees) {
          var angleInRadians = (angleInDegrees % 360 - 90) * Math.PI / 180;
          return {
            x: centerX + radius * Math.cos(angleInRadians),
            y: centerY + radius * Math.sin(angleInRadians)
          };
        };
        var describeArc = function describeArc2(x2, y2, radius, startAngle, endAngle, arcSweep) {
          var start = polarToCartesian(x2, y2, radius, endAngle);
          var end = polarToCartesian(x2, y2, radius, startAngle);
          return ["M", start.x, start.y, "A", radius, radius, 0, arcSweep, 0, end.x, end.y].join(" ");
        };
        var percentageArc = function percentageArc2(x2, y2, radius, from, to) {
          var arcSweep = 1;
          if (to > from && to - from <= 0.5) {
            arcSweep = 0;
          }
          if (from > to && from - to >= 0.5) {
            arcSweep = 0;
          }
          return describeArc(
            x2,
            y2,
            radius,
            Math.min(0.9999, from) * 360,
            Math.min(0.9999, to) * 360,
            arcSweep
          );
        };
        var create = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          props.spin = false;
          props.progress = 0;
          props.opacity = 0;
          var svg = createElement("svg");
          root2.ref.path = createElement("path", {
            "stroke-width": 2,
            "stroke-linecap": "round"
          });
          svg.appendChild(root2.ref.path);
          root2.ref.svg = svg;
          root2.appendChild(svg);
        };
        var write = function write2(_ref2) {
          var root2 = _ref2.root, props = _ref2.props;
          if (props.opacity === 0) {
            return;
          }
          if (props.align) {
            root2.element.dataset.align = props.align;
          }
          var ringStrokeWidth = parseInt(attr2(root2.ref.path, "stroke-width"), 10);
          var size = root2.rect.element.width * 0.5;
          var ringFrom = 0;
          var ringTo = 0;
          if (props.spin) {
            ringFrom = 0;
            ringTo = 0.5;
          } else {
            ringFrom = 0;
            ringTo = props.progress;
          }
          var coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);
          attr2(root2.ref.path, "d", coordinates);
          attr2(root2.ref.path, "stroke-opacity", props.spin || props.progress > 0 ? 1 : 0);
        };
        var progressIndicator = createView({
          tag: "div",
          name: "progress-indicator",
          ignoreRectUpdate: true,
          ignoreRect: true,
          create,
          write,
          mixins: {
            apis: ["progress", "spin", "align"],
            styles: ["opacity"],
            animations: {
              opacity: { type: "tween", duration: 500 },
              progress: {
                type: "spring",
                stiffness: 0.95,
                damping: 0.65,
                mass: 10
              }
            }
          }
        });
        var create$1 = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          root2.element.innerHTML = (props.icon || "") + ("<span>" + props.label + "</span>");
          props.isDisabled = false;
        };
        var write$1 = function write2(_ref2) {
          var root2 = _ref2.root, props = _ref2.props;
          var isDisabled = props.isDisabled;
          var shouldDisable = root2.query("GET_DISABLED") || props.opacity === 0;
          if (shouldDisable && !isDisabled) {
            props.isDisabled = true;
            attr2(root2.element, "disabled", "disabled");
          } else if (!shouldDisable && isDisabled) {
            props.isDisabled = false;
            root2.element.removeAttribute("disabled");
          }
        };
        var fileActionButton = createView({
          tag: "button",
          attributes: {
            type: "button"
          },
          ignoreRect: true,
          ignoreRectUpdate: true,
          name: "file-action-button",
          mixins: {
            apis: ["label"],
            styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
            animations: {
              scaleX: "spring",
              scaleY: "spring",
              translateX: "spring",
              translateY: "spring",
              opacity: { type: "tween", duration: 250 }
            },
            listeners: true
          },
          create: create$1,
          write: write$1
        });
        var toNaturalFileSize = function toNaturalFileSize2(bytes) {
          var decimalSeparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ".";
          var base = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var _options$labelBytes = options.labelBytes, labelBytes = _options$labelBytes === void 0 ? "bytes" : _options$labelBytes, _options$labelKilobyt = options.labelKilobytes, labelKilobytes = _options$labelKilobyt === void 0 ? "KB" : _options$labelKilobyt, _options$labelMegabyt = options.labelMegabytes, labelMegabytes = _options$labelMegabyt === void 0 ? "MB" : _options$labelMegabyt, _options$labelGigabyt = options.labelGigabytes, labelGigabytes = _options$labelGigabyt === void 0 ? "GB" : _options$labelGigabyt;
          bytes = Math.round(Math.abs(bytes));
          var KB = base;
          var MB = base * base;
          var GB = base * base * base;
          if (bytes < KB) {
            return bytes + " " + labelBytes;
          }
          if (bytes < MB) {
            return Math.floor(bytes / KB) + " " + labelKilobytes;
          }
          if (bytes < GB) {
            return removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator) + " " + labelMegabytes;
          }
          return removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator) + " " + labelGigabytes;
        };
        var removeDecimalsWhenZero = function removeDecimalsWhenZero2(value, decimalCount, separator) {
          return value.toFixed(decimalCount).split(".").filter(function(part) {
            return part !== "0";
          }).join(separator);
        };
        var create$2 = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          var fileName = createElement$1("span");
          fileName.className = "filepond--file-info-main";
          attr2(fileName, "aria-hidden", "true");
          root2.appendChild(fileName);
          root2.ref.fileName = fileName;
          var fileSize = createElement$1("span");
          fileSize.className = "filepond--file-info-sub";
          root2.appendChild(fileSize);
          root2.ref.fileSize = fileSize;
          text2(fileSize, root2.query("GET_LABEL_FILE_WAITING_FOR_SIZE"));
          text2(fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
        };
        var updateFile = function updateFile2(_ref2) {
          var root2 = _ref2.root, props = _ref2.props;
          text2(
            root2.ref.fileSize,
            toNaturalFileSize(
              root2.query("GET_ITEM_SIZE", props.id),
              ".",
              root2.query("GET_FILE_SIZE_BASE"),
              root2.query("GET_FILE_SIZE_LABELS", root2.query)
            )
          );
          text2(root2.ref.fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
        };
        var updateFileSizeOnError = function updateFileSizeOnError2(_ref3) {
          var root2 = _ref3.root, props = _ref3.props;
          if (isInt(root2.query("GET_ITEM_SIZE", props.id))) {
            updateFile({ root: root2, props });
            return;
          }
          text2(root2.ref.fileSize, root2.query("GET_LABEL_FILE_SIZE_NOT_AVAILABLE"));
        };
        var fileInfo = createView({
          name: "file-info",
          ignoreRect: true,
          ignoreRectUpdate: true,
          write: createRoute({
            DID_LOAD_ITEM: updateFile,
            DID_UPDATE_ITEM_META: updateFile,
            DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,
            DID_THROW_ITEM_INVALID: updateFileSizeOnError
          }),
          didCreateView: function didCreateView(root2) {
            applyFilters("CREATE_VIEW", Object.assign({}, root2, { view: root2 }));
          },
          create: create$2,
          mixins: {
            styles: ["translateX", "translateY"],
            animations: {
              translateX: "spring",
              translateY: "spring"
            }
          }
        });
        var toPercentage = function toPercentage2(value) {
          return Math.round(value * 100);
        };
        var create$3 = function create2(_ref) {
          var root2 = _ref.root;
          var main = createElement$1("span");
          main.className = "filepond--file-status-main";
          root2.appendChild(main);
          root2.ref.main = main;
          var sub = createElement$1("span");
          sub.className = "filepond--file-status-sub";
          root2.appendChild(sub);
          root2.ref.sub = sub;
          didSetItemLoadProgress({ root: root2, action: { progress: null } });
        };
        var didSetItemLoadProgress = function didSetItemLoadProgress2(_ref2) {
          var root2 = _ref2.root, action = _ref2.action;
          var title = action.progress === null ? root2.query("GET_LABEL_FILE_LOADING") : root2.query("GET_LABEL_FILE_LOADING") + " " + toPercentage(action.progress) + "%";
          text2(root2.ref.main, title);
          text2(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
        };
        var didSetItemProcessProgress = function didSetItemProcessProgress2(_ref3) {
          var root2 = _ref3.root, action = _ref3.action;
          var title = action.progress === null ? root2.query("GET_LABEL_FILE_PROCESSING") : root2.query("GET_LABEL_FILE_PROCESSING") + " " + toPercentage(action.progress) + "%";
          text2(root2.ref.main, title);
          text2(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
        };
        var didRequestItemProcessing = function didRequestItemProcessing2(_ref4) {
          var root2 = _ref4.root;
          text2(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING"));
          text2(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
        };
        var didAbortItemProcessing = function didAbortItemProcessing2(_ref5) {
          var root2 = _ref5.root;
          text2(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING_ABORTED"));
          text2(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_RETRY"));
        };
        var didCompleteItemProcessing = function didCompleteItemProcessing2(_ref6) {
          var root2 = _ref6.root;
          text2(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING_COMPLETE"));
          text2(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_UNDO"));
        };
        var clear = function clear2(_ref7) {
          var root2 = _ref7.root;
          text2(root2.ref.main, "");
          text2(root2.ref.sub, "");
        };
        var error = function error2(_ref8) {
          var root2 = _ref8.root, action = _ref8.action;
          text2(root2.ref.main, action.status.main);
          text2(root2.ref.sub, action.status.sub);
        };
        var fileStatus = createView({
          name: "file-status",
          ignoreRect: true,
          ignoreRectUpdate: true,
          write: createRoute({
            DID_LOAD_ITEM: clear,
            DID_REVERT_ITEM_PROCESSING: clear,
            DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,
            DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,
            DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,
            DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,
            DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,
            DID_THROW_ITEM_LOAD_ERROR: error,
            DID_THROW_ITEM_INVALID: error,
            DID_THROW_ITEM_PROCESSING_ERROR: error,
            DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,
            DID_THROW_ITEM_REMOVE_ERROR: error
          }),
          didCreateView: function didCreateView(root2) {
            applyFilters("CREATE_VIEW", Object.assign({}, root2, { view: root2 }));
          },
          create: create$3,
          mixins: {
            styles: ["translateX", "translateY", "opacity"],
            animations: {
              opacity: { type: "tween", duration: 250 },
              translateX: "spring",
              translateY: "spring"
            }
          }
        });
        var Buttons = {
          AbortItemLoad: {
            label: "GET_LABEL_BUTTON_ABORT_ITEM_LOAD",
            action: "ABORT_ITEM_LOAD",
            className: "filepond--action-abort-item-load",
            align: "LOAD_INDICATOR_POSITION"
            // right
          },
          RetryItemLoad: {
            label: "GET_LABEL_BUTTON_RETRY_ITEM_LOAD",
            action: "RETRY_ITEM_LOAD",
            icon: "GET_ICON_RETRY",
            className: "filepond--action-retry-item-load",
            align: "BUTTON_PROCESS_ITEM_POSITION"
            // right
          },
          RemoveItem: {
            label: "GET_LABEL_BUTTON_REMOVE_ITEM",
            action: "REQUEST_REMOVE_ITEM",
            icon: "GET_ICON_REMOVE",
            className: "filepond--action-remove-item",
            align: "BUTTON_REMOVE_ITEM_POSITION"
            // left
          },
          ProcessItem: {
            label: "GET_LABEL_BUTTON_PROCESS_ITEM",
            action: "REQUEST_ITEM_PROCESSING",
            icon: "GET_ICON_PROCESS",
            className: "filepond--action-process-item",
            align: "BUTTON_PROCESS_ITEM_POSITION"
            // right
          },
          AbortItemProcessing: {
            label: "GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING",
            action: "ABORT_ITEM_PROCESSING",
            className: "filepond--action-abort-item-processing",
            align: "BUTTON_PROCESS_ITEM_POSITION"
            // right
          },
          RetryItemProcessing: {
            label: "GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING",
            action: "RETRY_ITEM_PROCESSING",
            icon: "GET_ICON_RETRY",
            className: "filepond--action-retry-item-processing",
            align: "BUTTON_PROCESS_ITEM_POSITION"
            // right
          },
          RevertItemProcessing: {
            label: "GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING",
            action: "REQUEST_REVERT_ITEM_PROCESSING",
            icon: "GET_ICON_UNDO",
            className: "filepond--action-revert-item-processing",
            align: "BUTTON_PROCESS_ITEM_POSITION"
            // right
          }
        };
        var ButtonKeys = [];
        forin(Buttons, function(key) {
          ButtonKeys.push(key);
        });
        var calculateFileInfoOffset = function calculateFileInfoOffset2(root2) {
          if (getRemoveIndicatorAligment(root2) === "right") return 0;
          var buttonRect = root2.ref.buttonRemoveItem.rect.element;
          return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;
        };
        var calculateButtonWidth = function calculateButtonWidth2(root2) {
          var buttonRect = root2.ref.buttonAbortItemLoad.rect.element;
          return buttonRect.width;
        };
        var calculateFileVerticalCenterOffset = function calculateFileVerticalCenterOffset2(root2) {
          return Math.floor(root2.ref.buttonRemoveItem.rect.element.height / 4);
        };
        var calculateFileHorizontalCenterOffset = function calculateFileHorizontalCenterOffset2(root2) {
          return Math.floor(root2.ref.buttonRemoveItem.rect.element.left / 2);
        };
        var getLoadIndicatorAlignment = function getLoadIndicatorAlignment2(root2) {
          return root2.query("GET_STYLE_LOAD_INDICATOR_POSITION");
        };
        var getProcessIndicatorAlignment = function getProcessIndicatorAlignment2(root2) {
          return root2.query("GET_STYLE_PROGRESS_INDICATOR_POSITION");
        };
        var getRemoveIndicatorAligment = function getRemoveIndicatorAligment2(root2) {
          return root2.query("GET_STYLE_BUTTON_REMOVE_ITEM_POSITION");
        };
        var DefaultStyle = {
          buttonAbortItemLoad: { opacity: 0 },
          buttonRetryItemLoad: { opacity: 0 },
          buttonRemoveItem: { opacity: 0 },
          buttonProcessItem: { opacity: 0 },
          buttonAbortItemProcessing: { opacity: 0 },
          buttonRetryItemProcessing: { opacity: 0 },
          buttonRevertItemProcessing: { opacity: 0 },
          loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },
          processProgressIndicator: { opacity: 0, align: getProcessIndicatorAlignment },
          processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },
          info: { translateX: 0, translateY: 0, opacity: 0 },
          status: { translateX: 0, translateY: 0, opacity: 0 }
        };
        var IdleStyle = {
          buttonRemoveItem: { opacity: 1 },
          buttonProcessItem: { opacity: 1 },
          info: { translateX: calculateFileInfoOffset },
          status: { translateX: calculateFileInfoOffset }
        };
        var ProcessingStyle = {
          buttonAbortItemProcessing: { opacity: 1 },
          processProgressIndicator: { opacity: 1 },
          status: { opacity: 1 }
        };
        var StyleMap = {
          DID_THROW_ITEM_INVALID: {
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { translateX: calculateFileInfoOffset, opacity: 1 }
          },
          DID_START_ITEM_LOAD: {
            buttonAbortItemLoad: { opacity: 1 },
            loadProgressIndicator: { opacity: 1 },
            status: { opacity: 1 }
          },
          DID_THROW_ITEM_LOAD_ERROR: {
            buttonRetryItemLoad: { opacity: 1 },
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { opacity: 1 }
          },
          DID_START_ITEM_REMOVE: {
            processProgressIndicator: { opacity: 1, align: getRemoveIndicatorAligment },
            info: { translateX: calculateFileInfoOffset },
            status: { opacity: 0 }
          },
          DID_THROW_ITEM_REMOVE_ERROR: {
            processProgressIndicator: { opacity: 0, align: getRemoveIndicatorAligment },
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { opacity: 1, translateX: calculateFileInfoOffset }
          },
          DID_LOAD_ITEM: IdleStyle,
          DID_LOAD_LOCAL_ITEM: {
            buttonRemoveItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { translateX: calculateFileInfoOffset }
          },
          DID_START_ITEM_PROCESSING: ProcessingStyle,
          DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,
          DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,
          DID_COMPLETE_ITEM_PROCESSING: {
            buttonRevertItemProcessing: { opacity: 1 },
            info: { opacity: 1 },
            status: { opacity: 1 }
          },
          DID_THROW_ITEM_PROCESSING_ERROR: {
            buttonRemoveItem: { opacity: 1 },
            buttonRetryItemProcessing: { opacity: 1 },
            status: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset }
          },
          DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {
            buttonRevertItemProcessing: { opacity: 1 },
            status: { opacity: 1 },
            info: { opacity: 1 }
          },
          DID_ABORT_ITEM_PROCESSING: {
            buttonRemoveItem: { opacity: 1 },
            buttonProcessItem: { opacity: 1 },
            info: { translateX: calculateFileInfoOffset },
            status: { opacity: 1 }
          },
          DID_REVERT_ITEM_PROCESSING: IdleStyle
        };
        var processingCompleteIndicatorView = createView({
          create: function create2(_ref) {
            var root2 = _ref.root;
            root2.element.innerHTML = root2.query("GET_ICON_DONE");
          },
          name: "processing-complete-indicator",
          ignoreRect: true,
          mixins: {
            styles: ["scaleX", "scaleY", "opacity"],
            animations: {
              scaleX: "spring",
              scaleY: "spring",
              opacity: { type: "tween", duration: 250 }
            }
          }
        });
        var create$4 = function create2(_ref2) {
          var root2 = _ref2.root, props = _ref2.props;
          var LocalButtons = Object.keys(Buttons).reduce(function(prev2, curr) {
            prev2[curr] = Object.assign({}, Buttons[curr]);
            return prev2;
          }, {});
          var id2 = props.id;
          var allowRevert = root2.query("GET_ALLOW_REVERT");
          var allowRemove = root2.query("GET_ALLOW_REMOVE");
          var allowProcess = root2.query("GET_ALLOW_PROCESS");
          var instantUpload = root2.query("GET_INSTANT_UPLOAD");
          var isAsync2 = root2.query("IS_ASYNC");
          var alignRemoveItemButton = root2.query("GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN");
          var buttonFilter;
          if (isAsync2) {
            if (allowProcess && !allowRevert) {
              buttonFilter = function buttonFilter2(key) {
                return !/RevertItemProcessing/.test(key);
              };
            } else if (!allowProcess && allowRevert) {
              buttonFilter = function buttonFilter2(key) {
                return !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);
              };
            } else if (!allowProcess && !allowRevert) {
              buttonFilter = function buttonFilter2(key) {
                return !/Process/.test(key);
              };
            }
          } else {
            buttonFilter = function buttonFilter2(key) {
              return !/Process/.test(key);
            };
          }
          var enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();
          if (instantUpload && allowRevert) {
            LocalButtons["RevertItemProcessing"].label = "GET_LABEL_BUTTON_REMOVE_ITEM";
            LocalButtons["RevertItemProcessing"].icon = "GET_ICON_REMOVE";
          }
          if (isAsync2 && !allowRevert) {
            var map3 = StyleMap["DID_COMPLETE_ITEM_PROCESSING"];
            map3.info.translateX = calculateFileHorizontalCenterOffset;
            map3.info.translateY = calculateFileVerticalCenterOffset;
            map3.status.translateY = calculateFileVerticalCenterOffset;
            map3.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
          }
          if (isAsync2 && !allowProcess) {
            [
              "DID_START_ITEM_PROCESSING",
              "DID_REQUEST_ITEM_PROCESSING",
              "DID_UPDATE_ITEM_PROCESS_PROGRESS",
              "DID_THROW_ITEM_PROCESSING_ERROR"
            ].forEach(function(key) {
              StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;
            });
            StyleMap["DID_THROW_ITEM_PROCESSING_ERROR"].status.translateX = calculateButtonWidth;
          }
          if (alignRemoveItemButton && allowRevert) {
            LocalButtons["RevertItemProcessing"].align = "BUTTON_REMOVE_ITEM_POSITION";
            var _map = StyleMap["DID_COMPLETE_ITEM_PROCESSING"];
            _map.info.translateX = calculateFileInfoOffset;
            _map.status.translateY = calculateFileVerticalCenterOffset;
            _map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
          }
          if (!allowRemove) {
            LocalButtons["RemoveItem"].disabled = true;
          }
          forin(LocalButtons, function(key, definition) {
            var buttonView = root2.createChildView(fileActionButton, {
              label: root2.query(definition.label),
              icon: root2.query(definition.icon),
              opacity: 0
            });
            if (enabledButtons.includes(key)) {
              root2.appendChildView(buttonView);
            }
            if (definition.disabled) {
              buttonView.element.setAttribute("disabled", "disabled");
              buttonView.element.setAttribute("hidden", "hidden");
            }
            buttonView.element.dataset.align = root2.query("GET_STYLE_" + definition.align);
            buttonView.element.classList.add(definition.className);
            buttonView.on("click", function(e4) {
              e4.stopPropagation();
              if (definition.disabled) return;
              root2.dispatch(definition.action, { query: id2 });
            });
            root2.ref["button" + key] = buttonView;
          });
          root2.ref.processingCompleteIndicator = root2.appendChildView(
            root2.createChildView(processingCompleteIndicatorView)
          );
          root2.ref.processingCompleteIndicator.element.dataset.align = root2.query(
            "GET_STYLE_BUTTON_PROCESS_ITEM_POSITION"
          );
          root2.ref.info = root2.appendChildView(root2.createChildView(fileInfo, { id: id2 }));
          root2.ref.status = root2.appendChildView(root2.createChildView(fileStatus, { id: id2 }));
          var loadIndicatorView = root2.appendChildView(
            root2.createChildView(progressIndicator, {
              opacity: 0,
              align: root2.query("GET_STYLE_LOAD_INDICATOR_POSITION")
            })
          );
          loadIndicatorView.element.classList.add("filepond--load-indicator");
          root2.ref.loadProgressIndicator = loadIndicatorView;
          var progressIndicatorView = root2.appendChildView(
            root2.createChildView(progressIndicator, {
              opacity: 0,
              align: root2.query("GET_STYLE_PROGRESS_INDICATOR_POSITION")
            })
          );
          progressIndicatorView.element.classList.add("filepond--process-indicator");
          root2.ref.processProgressIndicator = progressIndicatorView;
          root2.ref.activeStyles = [];
        };
        var write$2 = function write2(_ref3) {
          var root2 = _ref3.root, actions2 = _ref3.actions, props = _ref3.props;
          route({ root: root2, actions: actions2, props });
          var action = actions2.concat().filter(function(action2) {
            return /^DID_/.test(action2.type);
          }).reverse().find(function(action2) {
            return StyleMap[action2.type];
          });
          if (action) {
            root2.ref.activeStyles = [];
            var stylesToApply = StyleMap[action.type];
            forin(DefaultStyle, function(name2, defaultStyles) {
              var control = root2.ref[name2];
              forin(defaultStyles, function(key, defaultValue) {
                var value = stylesToApply[name2] && typeof stylesToApply[name2][key] !== "undefined" ? stylesToApply[name2][key] : defaultValue;
                root2.ref.activeStyles.push({ control, key, value });
              });
            });
          }
          root2.ref.activeStyles.forEach(function(_ref4) {
            var control = _ref4.control, key = _ref4.key, value = _ref4.value;
            control[key] = typeof value === "function" ? value(root2) : value;
          });
        };
        var route = createRoute({
          DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: function DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING(_ref5) {
            var root2 = _ref5.root, action = _ref5.action;
            root2.ref.buttonAbortItemProcessing.label = action.value;
          },
          DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: function DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD(_ref6) {
            var root2 = _ref6.root, action = _ref6.action;
            root2.ref.buttonAbortItemLoad.label = action.value;
          },
          DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: function DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL(_ref7) {
            var root2 = _ref7.root, action = _ref7.action;
            root2.ref.buttonAbortItemRemoval.label = action.value;
          },
          DID_REQUEST_ITEM_PROCESSING: function DID_REQUEST_ITEM_PROCESSING(_ref8) {
            var root2 = _ref8.root;
            root2.ref.processProgressIndicator.spin = true;
            root2.ref.processProgressIndicator.progress = 0;
          },
          DID_START_ITEM_LOAD: function DID_START_ITEM_LOAD(_ref9) {
            var root2 = _ref9.root;
            root2.ref.loadProgressIndicator.spin = true;
            root2.ref.loadProgressIndicator.progress = 0;
          },
          DID_START_ITEM_REMOVE: function DID_START_ITEM_REMOVE(_ref10) {
            var root2 = _ref10.root;
            root2.ref.processProgressIndicator.spin = true;
            root2.ref.processProgressIndicator.progress = 0;
          },
          DID_UPDATE_ITEM_LOAD_PROGRESS: function DID_UPDATE_ITEM_LOAD_PROGRESS(_ref11) {
            var root2 = _ref11.root, action = _ref11.action;
            root2.ref.loadProgressIndicator.spin = false;
            root2.ref.loadProgressIndicator.progress = action.progress;
          },
          DID_UPDATE_ITEM_PROCESS_PROGRESS: function DID_UPDATE_ITEM_PROCESS_PROGRESS(_ref12) {
            var root2 = _ref12.root, action = _ref12.action;
            root2.ref.processProgressIndicator.spin = false;
            root2.ref.processProgressIndicator.progress = action.progress;
          }
        });
        var file = createView({
          create: create$4,
          write: write$2,
          didCreateView: function didCreateView(root2) {
            applyFilters("CREATE_VIEW", Object.assign({}, root2, { view: root2 }));
          },
          name: "file"
        });
        var create$5 = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          root2.ref.fileName = createElement$1("legend");
          root2.appendChild(root2.ref.fileName);
          root2.ref.file = root2.appendChildView(root2.createChildView(file, { id: props.id }));
          root2.ref.data = false;
        };
        var didLoadItem = function didLoadItem2(_ref2) {
          var root2 = _ref2.root, props = _ref2.props;
          text2(root2.ref.fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
        };
        var fileWrapper = createView({
          create: create$5,
          ignoreRect: true,
          write: createRoute({
            DID_LOAD_ITEM: didLoadItem
          }),
          didCreateView: function didCreateView(root2) {
            applyFilters("CREATE_VIEW", Object.assign({}, root2, { view: root2 }));
          },
          tag: "fieldset",
          name: "file-wrapper"
        });
        var PANEL_SPRING_PROPS = { type: "spring", damping: 0.6, mass: 7 };
        var create$6 = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          [
            {
              name: "top"
            },
            {
              name: "center",
              props: {
                translateY: null,
                scaleY: null
              },
              mixins: {
                animations: {
                  scaleY: PANEL_SPRING_PROPS
                },
                styles: ["translateY", "scaleY"]
              }
            },
            {
              name: "bottom",
              props: {
                translateY: null
              },
              mixins: {
                animations: {
                  translateY: PANEL_SPRING_PROPS
                },
                styles: ["translateY"]
              }
            }
          ].forEach(function(section) {
            createSection(root2, section, props.name);
          });
          root2.element.classList.add("filepond--" + props.name);
          root2.ref.scalable = null;
        };
        var createSection = function createSection2(root2, section, className) {
          var viewConstructor = createView({
            name: "panel-" + section.name + " filepond--" + className,
            mixins: section.mixins,
            ignoreRectUpdate: true
          });
          var view = root2.createChildView(viewConstructor, section.props);
          root2.ref[section.name] = root2.appendChildView(view);
        };
        var write$3 = function write2(_ref2) {
          var root2 = _ref2.root, props = _ref2.props;
          if (root2.ref.scalable === null || props.scalable !== root2.ref.scalable) {
            root2.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;
            root2.element.dataset.scalable = root2.ref.scalable;
          }
          if (!props.height) return;
          var topRect = root2.ref.top.rect.element;
          var bottomRect = root2.ref.bottom.rect.element;
          var height = Math.max(topRect.height + bottomRect.height, props.height);
          root2.ref.center.translateY = topRect.height;
          root2.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;
          root2.ref.bottom.translateY = height - bottomRect.height;
        };
        var panel = createView({
          name: "panel",
          read: function read(_ref3) {
            var root2 = _ref3.root, props = _ref3.props;
            return props.heightCurrent = root2.ref.bottom.translateY;
          },
          write: write$3,
          create: create$6,
          ignoreRect: true,
          mixins: {
            apis: ["height", "heightCurrent", "scalable"]
          }
        });
        var createDragHelper = function createDragHelper2(items) {
          var itemIds = items.map(function(item2) {
            return item2.id;
          });
          var prevIndex = void 0;
          return {
            setIndex: function setIndex(index2) {
              prevIndex = index2;
            },
            getIndex: function getIndex() {
              return prevIndex;
            },
            getItemIndex: function getItemIndex(item2) {
              return itemIds.indexOf(item2.id);
            }
          };
        };
        var ITEM_TRANSLATE_SPRING = {
          type: "spring",
          stiffness: 0.75,
          damping: 0.45,
          mass: 10
        };
        var ITEM_SCALE_SPRING = "spring";
        var StateMap = {
          DID_START_ITEM_LOAD: "busy",
          DID_UPDATE_ITEM_LOAD_PROGRESS: "loading",
          DID_THROW_ITEM_INVALID: "load-invalid",
          DID_THROW_ITEM_LOAD_ERROR: "load-error",
          DID_LOAD_ITEM: "idle",
          DID_THROW_ITEM_REMOVE_ERROR: "remove-error",
          DID_START_ITEM_REMOVE: "busy",
          DID_START_ITEM_PROCESSING: "busy processing",
          DID_REQUEST_ITEM_PROCESSING: "busy processing",
          DID_UPDATE_ITEM_PROCESS_PROGRESS: "processing",
          DID_COMPLETE_ITEM_PROCESSING: "processing-complete",
          DID_THROW_ITEM_PROCESSING_ERROR: "processing-error",
          DID_THROW_ITEM_PROCESSING_REVERT_ERROR: "processing-revert-error",
          DID_ABORT_ITEM_PROCESSING: "cancelled",
          DID_REVERT_ITEM_PROCESSING: "idle"
        };
        var create$7 = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          root2.ref.handleClick = function(e4) {
            return root2.dispatch("DID_ACTIVATE_ITEM", { id: props.id });
          };
          root2.element.id = "filepond--item-" + props.id;
          root2.element.addEventListener("click", root2.ref.handleClick);
          root2.ref.container = root2.appendChildView(
            root2.createChildView(fileWrapper, { id: props.id })
          );
          root2.ref.panel = root2.appendChildView(root2.createChildView(panel, { name: "item-panel" }));
          root2.ref.panel.height = null;
          props.markedForRemoval = false;
          if (!root2.query("GET_ALLOW_REORDER")) return;
          root2.element.dataset.dragState = "idle";
          var grab = function grab2(e4) {
            if (!e4.isPrimary) return;
            var removedActivateListener = false;
            var origin = {
              x: e4.pageX,
              y: e4.pageY
            };
            props.dragOrigin = {
              x: root2.translateX,
              y: root2.translateY
            };
            props.dragCenter = {
              x: e4.offsetX,
              y: e4.offsetY
            };
            var dragState = createDragHelper(root2.query("GET_ACTIVE_ITEMS"));
            root2.dispatch("DID_GRAB_ITEM", { id: props.id, dragState });
            var drag = function drag2(e5) {
              if (!e5.isPrimary) return;
              e5.stopPropagation();
              e5.preventDefault();
              props.dragOffset = {
                x: e5.pageX - origin.x,
                y: e5.pageY - origin.y
              };
              var dist = props.dragOffset.x * props.dragOffset.x + props.dragOffset.y * props.dragOffset.y;
              if (dist > 16 && !removedActivateListener) {
                removedActivateListener = true;
                root2.element.removeEventListener("click", root2.ref.handleClick);
              }
              root2.dispatch("DID_DRAG_ITEM", { id: props.id, dragState });
            };
            var drop2 = function drop3(e5) {
              if (!e5.isPrimary) return;
              document.removeEventListener("pointermove", drag);
              document.removeEventListener("pointerup", drop3);
              props.dragOffset = {
                x: e5.pageX - origin.x,
                y: e5.pageY - origin.y
              };
              root2.dispatch("DID_DROP_ITEM", { id: props.id, dragState });
              if (removedActivateListener) {
                setTimeout(function() {
                  return root2.element.addEventListener("click", root2.ref.handleClick);
                }, 0);
              }
            };
            document.addEventListener("pointermove", drag);
            document.addEventListener("pointerup", drop2);
          };
          root2.element.addEventListener("pointerdown", grab);
        };
        var route$1 = createRoute({
          DID_UPDATE_PANEL_HEIGHT: function DID_UPDATE_PANEL_HEIGHT(_ref2) {
            var root2 = _ref2.root, action = _ref2.action;
            root2.height = action.height;
          }
        });
        var write$4 = createRoute(
          {
            DID_GRAB_ITEM: function DID_GRAB_ITEM(_ref3) {
              var root2 = _ref3.root, props = _ref3.props;
              props.dragOrigin = {
                x: root2.translateX,
                y: root2.translateY
              };
            },
            DID_DRAG_ITEM: function DID_DRAG_ITEM(_ref4) {
              var root2 = _ref4.root;
              root2.element.dataset.dragState = "drag";
            },
            DID_DROP_ITEM: function DID_DROP_ITEM(_ref5) {
              var root2 = _ref5.root, props = _ref5.props;
              props.dragOffset = null;
              props.dragOrigin = null;
              root2.element.dataset.dragState = "drop";
            }
          },
          function(_ref6) {
            var root2 = _ref6.root, actions2 = _ref6.actions, props = _ref6.props, shouldOptimize = _ref6.shouldOptimize;
            if (root2.element.dataset.dragState === "drop") {
              if (root2.scaleX <= 1) {
                root2.element.dataset.dragState = "idle";
              }
            }
            var action = actions2.concat().filter(function(action2) {
              return /^DID_/.test(action2.type);
            }).reverse().find(function(action2) {
              return StateMap[action2.type];
            });
            if (action && action.type !== props.currentState) {
              props.currentState = action.type;
              root2.element.dataset.filepondItemState = StateMap[props.currentState] || "";
            }
            var aspectRatio = root2.query("GET_ITEM_PANEL_ASPECT_RATIO") || root2.query("GET_PANEL_ASPECT_RATIO");
            if (!aspectRatio) {
              route$1({ root: root2, actions: actions2, props });
              if (!root2.height && root2.ref.container.rect.element.height > 0) {
                root2.height = root2.ref.container.rect.element.height;
              }
            } else if (!shouldOptimize) {
              root2.height = root2.rect.element.width * aspectRatio;
            }
            if (shouldOptimize) {
              root2.ref.panel.height = null;
            }
            root2.ref.panel.height = root2.height;
          }
        );
        var item = createView({
          create: create$7,
          write: write$4,
          destroy: function destroy(_ref7) {
            var root2 = _ref7.root, props = _ref7.props;
            root2.element.removeEventListener("click", root2.ref.handleClick);
            root2.dispatch("RELEASE_ITEM", { query: props.id });
          },
          tag: "li",
          name: "item",
          mixins: {
            apis: [
              "id",
              "interactionMethod",
              "markedForRemoval",
              "spawnDate",
              "dragCenter",
              "dragOrigin",
              "dragOffset"
            ],
            styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity", "height"],
            animations: {
              scaleX: ITEM_SCALE_SPRING,
              scaleY: ITEM_SCALE_SPRING,
              translateX: ITEM_TRANSLATE_SPRING,
              translateY: ITEM_TRANSLATE_SPRING,
              opacity: { type: "tween", duration: 150 }
            }
          }
        });
        var getItemsPerRow = function(horizontalSpace, itemWidth) {
          return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));
        };
        var getItemIndexByPosition = function getItemIndexByPosition2(view, children2, positionInView) {
          if (!positionInView) return;
          var horizontalSpace = view.rect.element.width;
          var l4 = children2.length;
          var last = null;
          if (l4 === 0 || positionInView.top < children2[0].rect.element.top) return -1;
          var item2 = children2[0];
          var itemRect = item2.rect.element;
          var itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;
          var itemWidth = itemRect.width + itemHorizontalMargin;
          var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
          if (itemsPerRow === 1) {
            for (var index2 = 0; index2 < l4; index2++) {
              var child = children2[index2];
              var childMid = child.rect.outer.top + child.rect.element.height * 0.5;
              if (positionInView.top < childMid) {
                return index2;
              }
            }
            return l4;
          }
          var itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;
          var itemHeight = itemRect.height + itemVerticalMargin;
          for (var _index = 0; _index < l4; _index++) {
            var indexX = _index % itemsPerRow;
            var indexY = Math.floor(_index / itemsPerRow);
            var offsetX = indexX * itemWidth;
            var offsetY = indexY * itemHeight;
            var itemTop = offsetY - itemRect.marginTop;
            var itemRight = offsetX + itemWidth;
            var itemBottom = offsetY + itemHeight + itemRect.marginBottom;
            if (positionInView.top < itemBottom && positionInView.top > itemTop) {
              if (positionInView.left < itemRight) {
                return _index;
              } else if (_index !== l4 - 1) {
                last = _index;
              } else {
                last = null;
              }
            }
          }
          if (last !== null) {
            return last;
          }
          return l4;
        };
        var dropAreaDimensions = {
          height: 0,
          width: 0,
          get getHeight() {
            return this.height;
          },
          set setHeight(val) {
            if (this.height === 0 || val === 0) this.height = val;
          },
          get getWidth() {
            return this.width;
          },
          set setWidth(val) {
            if (this.width === 0 || val === 0) this.width = val;
          },
          setDimensions: function setDimensions(height, width) {
            if (this.height === 0 || height === 0) this.height = height;
            if (this.width === 0 || width === 0) this.width = width;
          }
        };
        var create$8 = function create2(_ref) {
          var root2 = _ref.root;
          attr2(root2.element, "role", "list");
          root2.ref.lastItemSpanwDate = Date.now();
        };
        var addItemView = function addItemView2(_ref2) {
          var root2 = _ref2.root, action = _ref2.action;
          var id2 = action.id, index2 = action.index, interactionMethod = action.interactionMethod;
          root2.ref.addIndex = index2;
          var now3 = Date.now();
          var spawnDate = now3;
          var opacity = 1;
          if (interactionMethod !== InteractionMethod.NONE) {
            opacity = 0;
            var cooldown = root2.query("GET_ITEM_INSERT_INTERVAL");
            var dist = now3 - root2.ref.lastItemSpanwDate;
            spawnDate = dist < cooldown ? now3 + (cooldown - dist) : now3;
          }
          root2.ref.lastItemSpanwDate = spawnDate;
          root2.appendChildView(
            root2.createChildView(
              // view type
              item,
              // props
              {
                spawnDate,
                id: id2,
                opacity,
                interactionMethod
              }
            ),
            index2
          );
        };
        var moveItem = function moveItem2(item2, x2, y2) {
          var vx = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var vy = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
          if (item2.dragOffset) {
            item2.translateX = null;
            item2.translateY = null;
            item2.translateX = item2.dragOrigin.x + item2.dragOffset.x;
            item2.translateY = item2.dragOrigin.y + item2.dragOffset.y;
            item2.scaleX = 1.025;
            item2.scaleY = 1.025;
          } else {
            item2.translateX = x2;
            item2.translateY = y2;
            if (Date.now() > item2.spawnDate) {
              if (item2.opacity === 0) {
                introItemView(item2, x2, y2, vx, vy);
              }
              item2.scaleX = 1;
              item2.scaleY = 1;
              item2.opacity = 1;
            }
          }
        };
        var introItemView = function introItemView2(item2, x2, y2, vx, vy) {
          if (item2.interactionMethod === InteractionMethod.NONE) {
            item2.translateX = null;
            item2.translateX = x2;
            item2.translateY = null;
            item2.translateY = y2;
          } else if (item2.interactionMethod === InteractionMethod.DROP) {
            item2.translateX = null;
            item2.translateX = x2 - vx * 20;
            item2.translateY = null;
            item2.translateY = y2 - vy * 10;
            item2.scaleX = 0.8;
            item2.scaleY = 0.8;
          } else if (item2.interactionMethod === InteractionMethod.BROWSE) {
            item2.translateY = null;
            item2.translateY = y2 - 30;
          } else if (item2.interactionMethod === InteractionMethod.API) {
            item2.translateX = null;
            item2.translateX = x2 - 30;
            item2.translateY = null;
          }
        };
        var removeItemView = function removeItemView2(_ref3) {
          var root2 = _ref3.root, action = _ref3.action;
          var id2 = action.id;
          var view = root2.childViews.find(function(child) {
            return child.id === id2;
          });
          if (!view) {
            return;
          }
          view.scaleX = 0.9;
          view.scaleY = 0.9;
          view.opacity = 0;
          view.markedForRemoval = true;
        };
        var getItemHeight = function getItemHeight2(child) {
          return child.rect.element.height + child.rect.element.marginBottom * 0.5 + child.rect.element.marginTop * 0.5;
        };
        var getItemWidth = function getItemWidth2(child) {
          return child.rect.element.width + child.rect.element.marginLeft * 0.5 + child.rect.element.marginRight * 0.5;
        };
        var dragItem = function dragItem2(_ref4) {
          var root2 = _ref4.root, action = _ref4.action;
          var id2 = action.id, dragState = action.dragState;
          var item2 = root2.query("GET_ITEM", { id: id2 });
          var view = root2.childViews.find(function(child) {
            return child.id === id2;
          });
          var numItems = root2.childViews.length;
          var oldIndex = dragState.getItemIndex(item2);
          if (!view) return;
          var dragPosition = {
            x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,
            y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y
          };
          var dragHeight = getItemHeight(view);
          var dragWidth = getItemWidth(view);
          var cols = Math.floor(root2.rect.outer.width / dragWidth);
          if (cols > numItems) cols = numItems;
          var rows = Math.floor(numItems / cols + 1);
          dropAreaDimensions.setHeight = dragHeight * rows;
          dropAreaDimensions.setWidth = dragWidth * cols;
          var location2 = {
            y: Math.floor(dragPosition.y / dragHeight),
            x: Math.floor(dragPosition.x / dragWidth),
            getGridIndex: function getGridIndex() {
              if (dragPosition.y > dropAreaDimensions.getHeight || dragPosition.y < 0 || dragPosition.x > dropAreaDimensions.getWidth || dragPosition.x < 0)
                return oldIndex;
              return this.y * cols + this.x;
            },
            getColIndex: function getColIndex() {
              var items = root2.query("GET_ACTIVE_ITEMS");
              var visibleChildren = root2.childViews.filter(function(child) {
                return child.rect.element.height;
              });
              var children2 = items.map(function(item3) {
                return visibleChildren.find(function(childView) {
                  return childView.id === item3.id;
                });
              });
              var currentIndex2 = children2.findIndex(function(child) {
                return child === view;
              });
              var dragHeight2 = getItemHeight(view);
              var l4 = children2.length;
              var idx = l4;
              var childHeight = 0;
              var childBottom = 0;
              var childTop = 0;
              for (var i4 = 0; i4 < l4; i4++) {
                childHeight = getItemHeight(children2[i4]);
                childTop = childBottom;
                childBottom = childTop + childHeight;
                if (dragPosition.y < childBottom) {
                  if (currentIndex2 > i4) {
                    if (dragPosition.y < childTop + dragHeight2) {
                      idx = i4;
                      break;
                    }
                    continue;
                  }
                  idx = i4;
                  break;
                }
              }
              return idx;
            }
          };
          var index2 = cols > 1 ? location2.getGridIndex() : location2.getColIndex();
          root2.dispatch("MOVE_ITEM", { query: view, index: index2 });
          var currentIndex = dragState.getIndex();
          if (currentIndex === void 0 || currentIndex !== index2) {
            dragState.setIndex(index2);
            if (currentIndex === void 0) return;
            root2.dispatch("DID_REORDER_ITEMS", {
              items: root2.query("GET_ACTIVE_ITEMS"),
              origin: oldIndex,
              target: index2
            });
          }
        };
        var route$2 = createRoute({
          DID_ADD_ITEM: addItemView,
          DID_REMOVE_ITEM: removeItemView,
          DID_DRAG_ITEM: dragItem
        });
        var write$5 = function write2(_ref5) {
          var root2 = _ref5.root, props = _ref5.props, actions2 = _ref5.actions, shouldOptimize = _ref5.shouldOptimize;
          route$2({ root: root2, props, actions: actions2 });
          var dragCoordinates = props.dragCoordinates;
          var horizontalSpace = root2.rect.element.width;
          var visibleChildren = root2.childViews.filter(function(child) {
            return child.rect.element.height;
          });
          var children2 = root2.query("GET_ACTIVE_ITEMS").map(function(item2) {
            return visibleChildren.find(function(child) {
              return child.id === item2.id;
            });
          }).filter(function(item2) {
            return item2;
          });
          var dragIndex = dragCoordinates ? getItemIndexByPosition(root2, children2, dragCoordinates) : null;
          var addIndex = root2.ref.addIndex || null;
          root2.ref.addIndex = null;
          var dragIndexOffset = 0;
          var removeIndexOffset = 0;
          var addIndexOffset = 0;
          if (children2.length === 0) return;
          var childRect = children2[0].rect.element;
          var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
          var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
          var itemWidth = childRect.width + itemHorizontalMargin;
          var itemHeight = childRect.height + itemVerticalMargin;
          var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
          if (itemsPerRow === 1) {
            var offsetY = 0;
            var dragOffset = 0;
            children2.forEach(function(child, index2) {
              if (dragIndex) {
                var dist = index2 - dragIndex;
                if (dist === -2) {
                  dragOffset = -itemVerticalMargin * 0.25;
                } else if (dist === -1) {
                  dragOffset = -itemVerticalMargin * 0.75;
                } else if (dist === 0) {
                  dragOffset = itemVerticalMargin * 0.75;
                } else if (dist === 1) {
                  dragOffset = itemVerticalMargin * 0.25;
                } else {
                  dragOffset = 0;
                }
              }
              if (shouldOptimize) {
                child.translateX = null;
                child.translateY = null;
              }
              if (!child.markedForRemoval) {
                moveItem(child, 0, offsetY + dragOffset);
              }
              var itemHeight2 = child.rect.element.height + itemVerticalMargin;
              var visualHeight = itemHeight2 * (child.markedForRemoval ? child.opacity : 1);
              offsetY += visualHeight;
            });
          } else {
            var prevX = 0;
            var prevY = 0;
            children2.forEach(function(child, index2) {
              if (index2 === dragIndex) {
                dragIndexOffset = 1;
              }
              if (index2 === addIndex) {
                addIndexOffset += 1;
              }
              if (child.markedForRemoval && child.opacity < 0.5) {
                removeIndexOffset -= 1;
              }
              var visualIndex = index2 + addIndexOffset + dragIndexOffset + removeIndexOffset;
              var indexX = visualIndex % itemsPerRow;
              var indexY = Math.floor(visualIndex / itemsPerRow);
              var offsetX = indexX * itemWidth;
              var offsetY2 = indexY * itemHeight;
              var vectorX = Math.sign(offsetX - prevX);
              var vectorY = Math.sign(offsetY2 - prevY);
              prevX = offsetX;
              prevY = offsetY2;
              if (child.markedForRemoval) return;
              if (shouldOptimize) {
                child.translateX = null;
                child.translateY = null;
              }
              moveItem(child, offsetX, offsetY2, vectorX, vectorY);
            });
          }
        };
        var filterSetItemActions = function filterSetItemActions2(child, actions2) {
          return actions2.filter(function(action) {
            if (action.data && action.data.id) {
              return child.id === action.data.id;
            }
            return true;
          });
        };
        var list = createView({
          create: create$8,
          write: write$5,
          tag: "ul",
          name: "list",
          didWriteView: function didWriteView(_ref6) {
            var root2 = _ref6.root;
            root2.childViews.filter(function(view) {
              return view.markedForRemoval && view.opacity === 0 && view.resting;
            }).forEach(function(view) {
              view._destroy();
              root2.removeChildView(view);
            });
          },
          filterFrameActionsForChild: filterSetItemActions,
          mixins: {
            apis: ["dragCoordinates"]
          }
        });
        var create$9 = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          root2.ref.list = root2.appendChildView(root2.createChildView(list));
          props.dragCoordinates = null;
          props.overflowing = false;
        };
        var storeDragCoordinates = function storeDragCoordinates2(_ref2) {
          var root2 = _ref2.root, props = _ref2.props, action = _ref2.action;
          if (!root2.query("GET_ITEM_INSERT_LOCATION_FREEDOM")) return;
          props.dragCoordinates = {
            left: action.position.scopeLeft - root2.ref.list.rect.element.left,
            top: action.position.scopeTop - (root2.rect.outer.top + root2.rect.element.marginTop + root2.rect.element.scrollTop)
          };
        };
        var clearDragCoordinates = function clearDragCoordinates2(_ref3) {
          var props = _ref3.props;
          props.dragCoordinates = null;
        };
        var route$3 = createRoute({
          DID_DRAG: storeDragCoordinates,
          DID_END_DRAG: clearDragCoordinates
        });
        var write$6 = function write2(_ref4) {
          var root2 = _ref4.root, props = _ref4.props, actions2 = _ref4.actions;
          route$3({ root: root2, props, actions: actions2 });
          root2.ref.list.dragCoordinates = props.dragCoordinates;
          if (props.overflowing && !props.overflow) {
            props.overflowing = false;
            root2.element.dataset.state = "";
            root2.height = null;
          }
          if (props.overflow) {
            var newHeight = Math.round(props.overflow);
            if (newHeight !== root2.height) {
              props.overflowing = true;
              root2.element.dataset.state = "overflow";
              root2.height = newHeight;
            }
          }
        };
        var listScroller = createView({
          create: create$9,
          write: write$6,
          name: "list-scroller",
          mixins: {
            apis: ["overflow", "dragCoordinates"],
            styles: ["height", "translateY"],
            animations: {
              translateY: "spring"
            }
          }
        });
        var attrToggle = function attrToggle2(element, name2, state2) {
          var enabledValue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
          if (state2) {
            attr2(element, name2, enabledValue);
          } else {
            element.removeAttribute(name2);
          }
        };
        var resetFileInput = function resetFileInput2(input) {
          if (!input || input.value === "") {
            return;
          }
          try {
            input.value = "";
          } catch (err) {
          }
          if (input.value) {
            var form = createElement$1("form");
            var parentNode = input.parentNode;
            var ref2 = input.nextSibling;
            form.appendChild(input);
            form.reset();
            if (ref2) {
              parentNode.insertBefore(input, ref2);
            } else {
              parentNode.appendChild(input);
            }
          }
        };
        var create$a = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          root2.element.id = "filepond--browser-" + props.id;
          attr2(root2.element, "name", root2.query("GET_NAME"));
          attr2(root2.element, "aria-controls", "filepond--assistant-" + props.id);
          attr2(root2.element, "aria-labelledby", "filepond--drop-label-" + props.id);
          setAcceptedFileTypes({
            root: root2,
            action: { value: root2.query("GET_ACCEPTED_FILE_TYPES") }
          });
          toggleAllowMultiple({ root: root2, action: { value: root2.query("GET_ALLOW_MULTIPLE") } });
          toggleDirectoryFilter({
            root: root2,
            action: { value: root2.query("GET_ALLOW_DIRECTORIES_ONLY") }
          });
          toggleDisabled({ root: root2 });
          toggleRequired({ root: root2, action: { value: root2.query("GET_REQUIRED") } });
          setCaptureMethod({ root: root2, action: { value: root2.query("GET_CAPTURE_METHOD") } });
          root2.ref.handleChange = function(e4) {
            if (!root2.element.value) {
              return;
            }
            var files = Array.from(root2.element.files).map(function(file2) {
              file2._relativePath = file2.webkitRelativePath;
              return file2;
            });
            setTimeout(function() {
              props.onload(files);
              resetFileInput(root2.element);
            }, 250);
          };
          root2.element.addEventListener("change", root2.ref.handleChange);
        };
        var setAcceptedFileTypes = function setAcceptedFileTypes2(_ref2) {
          var root2 = _ref2.root, action = _ref2.action;
          if (!root2.query("GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE")) return;
          attrToggle(
            root2.element,
            "accept",
            !!action.value,
            action.value ? action.value.join(",") : ""
          );
        };
        var toggleAllowMultiple = function toggleAllowMultiple2(_ref3) {
          var root2 = _ref3.root, action = _ref3.action;
          attrToggle(root2.element, "multiple", action.value);
        };
        var toggleDirectoryFilter = function toggleDirectoryFilter2(_ref4) {
          var root2 = _ref4.root, action = _ref4.action;
          attrToggle(root2.element, "webkitdirectory", action.value);
        };
        var toggleDisabled = function toggleDisabled2(_ref5) {
          var root2 = _ref5.root;
          var isDisabled = root2.query("GET_DISABLED");
          var doesAllowBrowse = root2.query("GET_ALLOW_BROWSE");
          var disableField = isDisabled || !doesAllowBrowse;
          attrToggle(root2.element, "disabled", disableField);
        };
        var toggleRequired = function toggleRequired2(_ref6) {
          var root2 = _ref6.root, action = _ref6.action;
          if (!action.value) {
            attrToggle(root2.element, "required", false);
          } else if (root2.query("GET_TOTAL_ITEMS") === 0) {
            attrToggle(root2.element, "required", true);
          }
        };
        var setCaptureMethod = function setCaptureMethod2(_ref7) {
          var root2 = _ref7.root, action = _ref7.action;
          attrToggle(
            root2.element,
            "capture",
            !!action.value,
            action.value === true ? "" : action.value
          );
        };
        var updateRequiredStatus = function updateRequiredStatus2(_ref8) {
          var root2 = _ref8.root;
          var element = root2.element;
          if (root2.query("GET_TOTAL_ITEMS") > 0) {
            attrToggle(element, "required", false);
            attrToggle(element, "name", false);
          } else {
            attrToggle(element, "name", true, root2.query("GET_NAME"));
            var shouldCheckValidity = root2.query("GET_CHECK_VALIDITY");
            if (shouldCheckValidity) {
              element.setCustomValidity("");
            }
            if (root2.query("GET_REQUIRED")) {
              attrToggle(element, "required", true);
            }
          }
        };
        var updateFieldValidityStatus = function updateFieldValidityStatus2(_ref9) {
          var root2 = _ref9.root;
          var shouldCheckValidity = root2.query("GET_CHECK_VALIDITY");
          if (!shouldCheckValidity) return;
          root2.element.setCustomValidity(root2.query("GET_LABEL_INVALID_FIELD"));
        };
        var browser2 = createView({
          tag: "input",
          name: "browser",
          ignoreRect: true,
          ignoreRectUpdate: true,
          attributes: {
            type: "file"
          },
          create: create$a,
          destroy: function destroy(_ref10) {
            var root2 = _ref10.root;
            root2.element.removeEventListener("change", root2.ref.handleChange);
          },
          write: createRoute({
            DID_LOAD_ITEM: updateRequiredStatus,
            DID_REMOVE_ITEM: updateRequiredStatus,
            DID_THROW_ITEM_INVALID: updateFieldValidityStatus,
            DID_SET_DISABLED: toggleDisabled,
            DID_SET_ALLOW_BROWSE: toggleDisabled,
            DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,
            DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,
            DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,
            DID_SET_CAPTURE_METHOD: setCaptureMethod,
            DID_SET_REQUIRED: toggleRequired
          })
        });
        var Key = {
          ENTER: 13,
          SPACE: 32
        };
        var create$b = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          var label = createElement$1("label");
          attr2(label, "for", "filepond--browser-" + props.id);
          attr2(label, "id", "filepond--drop-label-" + props.id);
          attr2(label, "aria-hidden", "true");
          root2.ref.handleKeyDown = function(e4) {
            var isActivationKey = e4.keyCode === Key.ENTER || e4.keyCode === Key.SPACE;
            if (!isActivationKey) return;
            e4.preventDefault();
            root2.ref.label.click();
          };
          root2.ref.handleClick = function(e4) {
            var isLabelClick = e4.target === label || label.contains(e4.target);
            if (isLabelClick) return;
            root2.ref.label.click();
          };
          label.addEventListener("keydown", root2.ref.handleKeyDown);
          root2.element.addEventListener("click", root2.ref.handleClick);
          updateLabelValue(label, props.caption);
          root2.appendChild(label);
          root2.ref.label = label;
        };
        var updateLabelValue = function updateLabelValue2(label, value) {
          label.innerHTML = value;
          var clickable = label.querySelector(".filepond--label-action");
          if (clickable) {
            attr2(clickable, "tabindex", "0");
          }
          return value;
        };
        var dropLabel = createView({
          name: "drop-label",
          ignoreRect: true,
          create: create$b,
          destroy: function destroy(_ref2) {
            var root2 = _ref2.root;
            root2.ref.label.addEventListener("keydown", root2.ref.handleKeyDown);
            root2.element.removeEventListener("click", root2.ref.handleClick);
          },
          write: createRoute({
            DID_SET_LABEL_IDLE: function DID_SET_LABEL_IDLE(_ref3) {
              var root2 = _ref3.root, action = _ref3.action;
              updateLabelValue(root2.ref.label, action.value);
            }
          }),
          mixins: {
            styles: ["opacity", "translateX", "translateY"],
            animations: {
              opacity: { type: "tween", duration: 150 },
              translateX: "spring",
              translateY: "spring"
            }
          }
        });
        var blob = createView({
          name: "drip-blob",
          ignoreRect: true,
          mixins: {
            styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
            animations: {
              scaleX: "spring",
              scaleY: "spring",
              translateX: "spring",
              translateY: "spring",
              opacity: { type: "tween", duration: 250 }
            }
          }
        });
        var addBlob = function addBlob2(_ref) {
          var root2 = _ref.root;
          var centerX = root2.rect.element.width * 0.5;
          var centerY = root2.rect.element.height * 0.5;
          root2.ref.blob = root2.appendChildView(
            root2.createChildView(blob, {
              opacity: 0,
              scaleX: 2.5,
              scaleY: 2.5,
              translateX: centerX,
              translateY: centerY
            })
          );
        };
        var moveBlob = function moveBlob2(_ref2) {
          var root2 = _ref2.root, action = _ref2.action;
          if (!root2.ref.blob) {
            addBlob({ root: root2 });
            return;
          }
          root2.ref.blob.translateX = action.position.scopeLeft;
          root2.ref.blob.translateY = action.position.scopeTop;
          root2.ref.blob.scaleX = 1;
          root2.ref.blob.scaleY = 1;
          root2.ref.blob.opacity = 1;
        };
        var hideBlob = function hideBlob2(_ref3) {
          var root2 = _ref3.root;
          if (!root2.ref.blob) {
            return;
          }
          root2.ref.blob.opacity = 0;
        };
        var explodeBlob = function explodeBlob2(_ref4) {
          var root2 = _ref4.root;
          if (!root2.ref.blob) {
            return;
          }
          root2.ref.blob.scaleX = 2.5;
          root2.ref.blob.scaleY = 2.5;
          root2.ref.blob.opacity = 0;
        };
        var write$7 = function write2(_ref5) {
          var root2 = _ref5.root, props = _ref5.props, actions2 = _ref5.actions;
          route$4({ root: root2, props, actions: actions2 });
          var blob2 = root2.ref.blob;
          if (actions2.length === 0 && blob2 && blob2.opacity === 0) {
            root2.removeChildView(blob2);
            root2.ref.blob = null;
          }
        };
        var route$4 = createRoute({
          DID_DRAG: moveBlob,
          DID_DROP: explodeBlob,
          DID_END_DRAG: hideBlob
        });
        var drip = createView({
          ignoreRect: true,
          ignoreRectUpdate: true,
          name: "drip",
          write: write$7
        });
        var setInputFiles = function setInputFiles2(element, files) {
          try {
            var dataTransfer = new DataTransfer();
            files.forEach(function(file2) {
              if (file2 instanceof File) {
                dataTransfer.items.add(file2);
              } else {
                dataTransfer.items.add(
                  new File([file2], file2.name, {
                    type: file2.type
                  })
                );
              }
            });
            element.files = dataTransfer.files;
          } catch (err) {
            return false;
          }
          return true;
        };
        var create$c = function create2(_ref) {
          var root2 = _ref.root;
          return root2.ref.fields = {};
        };
        var getField = function getField2(root2, id2) {
          return root2.ref.fields[id2];
        };
        var syncFieldPositionsWithItems = function syncFieldPositionsWithItems2(root2) {
          root2.query("GET_ACTIVE_ITEMS").forEach(function(item2) {
            if (!root2.ref.fields[item2.id]) return;
            root2.element.appendChild(root2.ref.fields[item2.id]);
          });
        };
        var didReorderItems = function didReorderItems2(_ref2) {
          var root2 = _ref2.root;
          return syncFieldPositionsWithItems(root2);
        };
        var didAddItem = function didAddItem2(_ref3) {
          var root2 = _ref3.root, action = _ref3.action;
          var fileItem = root2.query("GET_ITEM", action.id);
          var isLocalFile = fileItem.origin === FileOrigin.LOCAL;
          var shouldUseFileInput = !isLocalFile && root2.query("SHOULD_UPDATE_FILE_INPUT");
          var dataContainer = createElement$1("input");
          dataContainer.type = shouldUseFileInput ? "file" : "hidden";
          dataContainer.name = root2.query("GET_NAME");
          dataContainer.disabled = root2.query("GET_DISABLED");
          root2.ref.fields[action.id] = dataContainer;
          syncFieldPositionsWithItems(root2);
        };
        var didLoadItem$1 = function didLoadItem2(_ref4) {
          var root2 = _ref4.root, action = _ref4.action;
          var field = getField(root2, action.id);
          if (!field) return;
          if (action.serverFileReference !== null) field.value = action.serverFileReference;
          if (!root2.query("SHOULD_UPDATE_FILE_INPUT")) return;
          var fileItem = root2.query("GET_ITEM", action.id);
          setInputFiles(field, [fileItem.file]);
        };
        var didPrepareOutput = function didPrepareOutput2(_ref5) {
          var root2 = _ref5.root, action = _ref5.action;
          if (!root2.query("SHOULD_UPDATE_FILE_INPUT")) return;
          setTimeout(function() {
            var field = getField(root2, action.id);
            if (!field) return;
            setInputFiles(field, [action.file]);
          }, 0);
        };
        var didSetDisabled = function didSetDisabled2(_ref6) {
          var root2 = _ref6.root;
          root2.element.disabled = root2.query("GET_DISABLED");
        };
        var didRemoveItem = function didRemoveItem2(_ref7) {
          var root2 = _ref7.root, action = _ref7.action;
          var field = getField(root2, action.id);
          if (!field) return;
          if (field.parentNode) field.parentNode.removeChild(field);
          delete root2.ref.fields[action.id];
        };
        var didDefineValue = function didDefineValue2(_ref8) {
          var root2 = _ref8.root, action = _ref8.action;
          var field = getField(root2, action.id);
          if (!field) return;
          if (action.value === null) {
            field.removeAttribute("value");
          } else {
            field.value = action.value;
          }
          syncFieldPositionsWithItems(root2);
        };
        var write$8 = createRoute({
          DID_SET_DISABLED: didSetDisabled,
          DID_ADD_ITEM: didAddItem,
          DID_LOAD_ITEM: didLoadItem$1,
          DID_REMOVE_ITEM: didRemoveItem,
          DID_DEFINE_VALUE: didDefineValue,
          DID_PREPARE_OUTPUT: didPrepareOutput,
          DID_REORDER_ITEMS: didReorderItems,
          DID_SORT_ITEMS: didReorderItems
        });
        var data = createView({
          tag: "fieldset",
          name: "data",
          create: create$c,
          write: write$8,
          ignoreRect: true
        });
        var getRootNode2 = function getRootNode3(element) {
          return "getRootNode" in element ? element.getRootNode() : document;
        };
        var images = ["jpg", "jpeg", "png", "gif", "bmp", "webp", "svg", "tiff"];
        var text$1 = ["css", "csv", "html", "txt"];
        var map2 = {
          zip: "zip|compressed",
          epub: "application/epub+zip"
        };
        var guesstimateMimeType = function guesstimateMimeType2() {
          var extension = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          extension = extension.toLowerCase();
          if (images.includes(extension)) {
            return "image/" + (extension === "jpg" ? "jpeg" : extension === "svg" ? "svg+xml" : extension);
          }
          if (text$1.includes(extension)) {
            return "text/" + extension;
          }
          return map2[extension] || "";
        };
        var requestDataTransferItems = function requestDataTransferItems2(dataTransfer) {
          return new Promise(function(resolve, reject) {
            var links = getLinks(dataTransfer);
            if (links.length && !hasFiles(dataTransfer)) {
              return resolve(links);
            }
            getFiles(dataTransfer).then(resolve);
          });
        };
        var hasFiles = function hasFiles2(dataTransfer) {
          if (dataTransfer.files) return dataTransfer.files.length > 0;
          return false;
        };
        var getFiles = function getFiles2(dataTransfer) {
          return new Promise(function(resolve, reject) {
            var promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : []).filter(function(item2) {
              return isFileSystemItem(item2);
            }).map(function(item2) {
              return getFilesFromItem(item2);
            });
            if (!promisedFiles.length) {
              resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);
              return;
            }
            Promise.all(promisedFiles).then(function(returnedFileGroups) {
              var files = [];
              returnedFileGroups.forEach(function(group) {
                files.push.apply(files, group);
              });
              resolve(
                files.filter(function(file2) {
                  return file2;
                }).map(function(file2) {
                  if (!file2._relativePath)
                    file2._relativePath = file2.webkitRelativePath;
                  return file2;
                })
              );
            }).catch(console.error);
          });
        };
        var isFileSystemItem = function isFileSystemItem2(item2) {
          if (isEntry(item2)) {
            var entry = getAsEntry(item2);
            if (entry) {
              return entry.isFile || entry.isDirectory;
            }
          }
          return item2.kind === "file";
        };
        var getFilesFromItem = function getFilesFromItem2(item2) {
          return new Promise(function(resolve, reject) {
            if (isDirectoryEntry(item2)) {
              getFilesInDirectory(getAsEntry(item2)).then(resolve).catch(reject);
              return;
            }
            resolve([item2.getAsFile()]);
          });
        };
        var getFilesInDirectory = function getFilesInDirectory2(entry) {
          return new Promise(function(resolve, reject) {
            var files = [];
            var dirCounter = 0;
            var fileCounter = 0;
            var resolveIfDone = function resolveIfDone2() {
              if (fileCounter === 0 && dirCounter === 0) {
                resolve(files);
              }
            };
            var readEntries = function readEntries2(dirEntry) {
              dirCounter++;
              var directoryReader = dirEntry.createReader();
              var readBatch = function readBatch2() {
                directoryReader.readEntries(function(entries) {
                  if (entries.length === 0) {
                    dirCounter--;
                    resolveIfDone();
                    return;
                  }
                  entries.forEach(function(entry2) {
                    if (entry2.isDirectory) {
                      readEntries2(entry2);
                    } else {
                      fileCounter++;
                      entry2.file(function(file2) {
                        var correctedFile = correctMissingFileType(file2);
                        if (entry2.fullPath)
                          correctedFile._relativePath = entry2.fullPath;
                        files.push(correctedFile);
                        fileCounter--;
                        resolveIfDone();
                      });
                    }
                  });
                  readBatch2();
                }, reject);
              };
              readBatch();
            };
            readEntries(entry);
          });
        };
        var correctMissingFileType = function correctMissingFileType2(file2) {
          if (file2.type.length) return file2;
          var date = file2.lastModifiedDate;
          var name2 = file2.name;
          var type = guesstimateMimeType(getExtensionFromFilename(file2.name));
          if (!type.length) return file2;
          file2 = file2.slice(0, file2.size, type);
          file2.name = name2;
          file2.lastModifiedDate = date;
          return file2;
        };
        var isDirectoryEntry = function isDirectoryEntry2(item2) {
          return isEntry(item2) && (getAsEntry(item2) || {}).isDirectory;
        };
        var isEntry = function isEntry2(item2) {
          return "webkitGetAsEntry" in item2;
        };
        var getAsEntry = function getAsEntry2(item2) {
          return item2.webkitGetAsEntry();
        };
        var getLinks = function getLinks2(dataTransfer) {
          var links = [];
          try {
            links = getLinksFromTransferMetaData(dataTransfer);
            if (links.length) {
              return links;
            }
            links = getLinksFromTransferURLData(dataTransfer);
          } catch (e4) {
          }
          return links;
        };
        var getLinksFromTransferURLData = function getLinksFromTransferURLData2(dataTransfer) {
          var data2 = dataTransfer.getData("url");
          if (typeof data2 === "string" && data2.length) {
            return [data2];
          }
          return [];
        };
        var getLinksFromTransferMetaData = function getLinksFromTransferMetaData2(dataTransfer) {
          var data2 = dataTransfer.getData("text/html");
          if (typeof data2 === "string" && data2.length) {
            var matches2 = data2.match(/src\s*=\s*"(.+?)"/);
            if (matches2) {
              return [matches2[1]];
            }
          }
          return [];
        };
        var dragNDropObservers = [];
        var eventPosition = function eventPosition2(e4) {
          return {
            pageLeft: e4.pageX,
            pageTop: e4.pageY,
            scopeLeft: e4.offsetX || e4.layerX,
            scopeTop: e4.offsetY || e4.layerY
          };
        };
        var createDragNDropClient = function createDragNDropClient2(element, scopeToObserve, filterElement) {
          var observer = getDragNDropObserver(scopeToObserve);
          var client = {
            element,
            filterElement,
            state: null,
            ondrop: function ondrop() {
            },
            onenter: function onenter() {
            },
            ondrag: function ondrag() {
            },
            onexit: function onexit() {
            },
            onload: function onload() {
            },
            allowdrop: function allowdrop() {
            }
          };
          client.destroy = observer.addListener(client);
          return client;
        };
        var getDragNDropObserver = function getDragNDropObserver2(element) {
          var observer = dragNDropObservers.find(function(item2) {
            return item2.element === element;
          });
          if (observer) {
            return observer;
          }
          var newObserver = createDragNDropObserver(element);
          dragNDropObservers.push(newObserver);
          return newObserver;
        };
        var createDragNDropObserver = function createDragNDropObserver2(element) {
          var clients = [];
          var routes = {
            dragenter,
            dragover,
            dragleave,
            drop
          };
          var handlers = {};
          forin(routes, function(event2, createHandler) {
            handlers[event2] = createHandler(element, clients);
            element.addEventListener(event2, handlers[event2], false);
          });
          var observer = {
            element,
            addListener: function addListener(client) {
              clients.push(client);
              return function() {
                clients.splice(clients.indexOf(client), 1);
                if (clients.length === 0) {
                  dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);
                  forin(routes, function(event2) {
                    element.removeEventListener(event2, handlers[event2], false);
                  });
                }
              };
            }
          };
          return observer;
        };
        var elementFromPoint = function elementFromPoint2(root2, point) {
          if (!("elementFromPoint" in root2)) {
            root2 = document;
          }
          return root2.elementFromPoint(point.x, point.y);
        };
        var isEventTarget = function isEventTarget2(e4, target) {
          var root2 = getRootNode2(target);
          var elementAtPosition = elementFromPoint(root2, {
            x: e4.pageX - window.pageXOffset,
            y: e4.pageY - window.pageYOffset
          });
          return elementAtPosition === target || target.contains(elementAtPosition);
        };
        var initialTarget = null;
        var setDropEffect = function setDropEffect2(dataTransfer, effect) {
          try {
            dataTransfer.dropEffect = effect;
          } catch (e4) {
          }
        };
        var dragenter = function dragenter2(root2, clients) {
          return function(e4) {
            e4.preventDefault();
            initialTarget = e4.target;
            clients.forEach(function(client) {
              var element = client.element, onenter = client.onenter;
              if (isEventTarget(e4, element)) {
                client.state = "enter";
                onenter(eventPosition(e4));
              }
            });
          };
        };
        var dragover = function dragover2(root2, clients) {
          return function(e4) {
            e4.preventDefault();
            var dataTransfer = e4.dataTransfer;
            requestDataTransferItems(dataTransfer).then(function(items) {
              var overDropTarget = false;
              clients.some(function(client) {
                var filterElement = client.filterElement, element = client.element, onenter = client.onenter, onexit = client.onexit, ondrag = client.ondrag, allowdrop = client.allowdrop;
                setDropEffect(dataTransfer, "copy");
                var allowsTransfer = allowdrop(items);
                if (!allowsTransfer) {
                  setDropEffect(dataTransfer, "none");
                  return;
                }
                if (isEventTarget(e4, element)) {
                  overDropTarget = true;
                  if (client.state === null) {
                    client.state = "enter";
                    onenter(eventPosition(e4));
                    return;
                  }
                  client.state = "over";
                  if (filterElement && !allowsTransfer) {
                    setDropEffect(dataTransfer, "none");
                    return;
                  }
                  ondrag(eventPosition(e4));
                } else {
                  if (filterElement && !overDropTarget) {
                    setDropEffect(dataTransfer, "none");
                  }
                  if (client.state) {
                    client.state = null;
                    onexit(eventPosition(e4));
                  }
                }
              });
            });
          };
        };
        var drop = function drop2(root2, clients) {
          return function(e4) {
            e4.preventDefault();
            var dataTransfer = e4.dataTransfer;
            requestDataTransferItems(dataTransfer).then(function(items) {
              clients.forEach(function(client) {
                var filterElement = client.filterElement, element = client.element, ondrop = client.ondrop, onexit = client.onexit, allowdrop = client.allowdrop;
                client.state = null;
                if (filterElement && !isEventTarget(e4, element)) return;
                if (!allowdrop(items)) return onexit(eventPosition(e4));
                ondrop(eventPosition(e4), items);
              });
            });
          };
        };
        var dragleave = function dragleave2(root2, clients) {
          return function(e4) {
            if (initialTarget !== e4.target) {
              return;
            }
            clients.forEach(function(client) {
              var onexit = client.onexit;
              client.state = null;
              onexit(eventPosition(e4));
            });
          };
        };
        var createHopper = function createHopper2(scope, validateItems, options) {
          scope.classList.add("filepond--hopper");
          var catchesDropsOnPage = options.catchesDropsOnPage, requiresDropOnElement = options.requiresDropOnElement, _options$filterItems = options.filterItems, filterItems = _options$filterItems === void 0 ? function(items) {
            return items;
          } : _options$filterItems;
          var client = createDragNDropClient(
            scope,
            catchesDropsOnPage ? document.documentElement : scope,
            requiresDropOnElement
          );
          var lastState = "";
          var currentState = "";
          client.allowdrop = function(items) {
            return validateItems(filterItems(items));
          };
          client.ondrop = function(position, items) {
            var filteredItems = filterItems(items);
            if (!validateItems(filteredItems)) {
              api.ondragend(position);
              return;
            }
            currentState = "drag-drop";
            api.onload(filteredItems, position);
          };
          client.ondrag = function(position) {
            api.ondrag(position);
          };
          client.onenter = function(position) {
            currentState = "drag-over";
            api.ondragstart(position);
          };
          client.onexit = function(position) {
            currentState = "drag-exit";
            api.ondragend(position);
          };
          var api = {
            updateHopperState: function updateHopperState() {
              if (lastState !== currentState) {
                scope.dataset.hopperState = currentState;
                lastState = currentState;
              }
            },
            onload: function onload() {
            },
            ondragstart: function ondragstart() {
            },
            ondrag: function ondrag() {
            },
            ondragend: function ondragend() {
            },
            destroy: function destroy() {
              client.destroy();
            }
          };
          return api;
        };
        var listening = false;
        var listeners$1 = [];
        var handlePaste = function handlePaste2(e4) {
          var activeEl = document.activeElement;
          if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {
            var inScope = false;
            var element = activeEl;
            while (element !== document.body) {
              if (element.classList.contains("filepond--root")) {
                inScope = true;
                break;
              }
              element = element.parentNode;
            }
            if (!inScope) return;
          }
          requestDataTransferItems(e4.clipboardData).then(function(files) {
            if (!files.length) {
              return;
            }
            listeners$1.forEach(function(listener) {
              return listener(files);
            });
          });
        };
        var listen = function listen2(cb) {
          if (listeners$1.includes(cb)) {
            return;
          }
          listeners$1.push(cb);
          if (listening) {
            return;
          }
          listening = true;
          document.addEventListener("paste", handlePaste);
        };
        var unlisten = function unlisten2(listener) {
          arrayRemove(listeners$1, listeners$1.indexOf(listener));
          if (listeners$1.length === 0) {
            document.removeEventListener("paste", handlePaste);
            listening = false;
          }
        };
        var createPaster = function createPaster2() {
          var cb = function cb2(files) {
            api.onload(files);
          };
          var api = {
            destroy: function destroy() {
              unlisten(cb);
            },
            onload: function onload() {
            }
          };
          listen(cb);
          return api;
        };
        var create$d = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          root2.element.id = "filepond--assistant-" + props.id;
          attr2(root2.element, "role", "status");
          attr2(root2.element, "aria-live", "polite");
          attr2(root2.element, "aria-relevant", "additions");
        };
        var addFilesNotificationTimeout = null;
        var notificationClearTimeout = null;
        var filenames = [];
        var assist = function assist2(root2, message) {
          root2.element.textContent = message;
        };
        var clear$1 = function clear2(root2) {
          root2.element.textContent = "";
        };
        var listModified = function listModified2(root2, filename, label) {
          var total = root2.query("GET_TOTAL_ITEMS");
          assist(
            root2,
            label + " " + filename + ", " + total + " " + (total === 1 ? root2.query("GET_LABEL_FILE_COUNT_SINGULAR") : root2.query("GET_LABEL_FILE_COUNT_PLURAL"))
          );
          clearTimeout(notificationClearTimeout);
          notificationClearTimeout = setTimeout(function() {
            clear$1(root2);
          }, 1500);
        };
        var isUsingFilePond = function isUsingFilePond2(root2) {
          return root2.element.parentNode.contains(document.activeElement);
        };
        var itemAdded = function itemAdded2(_ref2) {
          var root2 = _ref2.root, action = _ref2.action;
          if (!isUsingFilePond(root2)) {
            return;
          }
          root2.element.textContent = "";
          var item2 = root2.query("GET_ITEM", action.id);
          filenames.push(item2.filename);
          clearTimeout(addFilesNotificationTimeout);
          addFilesNotificationTimeout = setTimeout(function() {
            listModified(root2, filenames.join(", "), root2.query("GET_LABEL_FILE_ADDED"));
            filenames.length = 0;
          }, 750);
        };
        var itemRemoved = function itemRemoved2(_ref3) {
          var root2 = _ref3.root, action = _ref3.action;
          if (!isUsingFilePond(root2)) {
            return;
          }
          var item2 = action.item;
          listModified(root2, item2.filename, root2.query("GET_LABEL_FILE_REMOVED"));
        };
        var itemProcessed = function itemProcessed2(_ref4) {
          var root2 = _ref4.root, action = _ref4.action;
          var item2 = root2.query("GET_ITEM", action.id);
          var filename = item2.filename;
          var label = root2.query("GET_LABEL_FILE_PROCESSING_COMPLETE");
          assist(root2, filename + " " + label);
        };
        var itemProcessedUndo = function itemProcessedUndo2(_ref5) {
          var root2 = _ref5.root, action = _ref5.action;
          var item2 = root2.query("GET_ITEM", action.id);
          var filename = item2.filename;
          var label = root2.query("GET_LABEL_FILE_PROCESSING_ABORTED");
          assist(root2, filename + " " + label);
        };
        var itemError = function itemError2(_ref6) {
          var root2 = _ref6.root, action = _ref6.action;
          var item2 = root2.query("GET_ITEM", action.id);
          var filename = item2.filename;
          assist(root2, action.status.main + " " + filename + " " + action.status.sub);
        };
        var assistant = createView({
          create: create$d,
          ignoreRect: true,
          ignoreRectUpdate: true,
          write: createRoute({
            DID_LOAD_ITEM: itemAdded,
            DID_REMOVE_ITEM: itemRemoved,
            DID_COMPLETE_ITEM_PROCESSING: itemProcessed,
            DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,
            DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,
            DID_THROW_ITEM_REMOVE_ERROR: itemError,
            DID_THROW_ITEM_LOAD_ERROR: itemError,
            DID_THROW_ITEM_INVALID: itemError,
            DID_THROW_ITEM_PROCESSING_ERROR: itemError
          }),
          tag: "span",
          name: "assistant"
        });
        var toCamels = function toCamels2(string) {
          var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "-";
          return string.replace(new RegExp(separator + ".", "g"), function(sub) {
            return sub.charAt(1).toUpperCase();
          });
        };
        var debounce = function debounce2(func) {
          var interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;
          var immidiateOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
          var last = Date.now();
          var timeout = null;
          return function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            clearTimeout(timeout);
            var dist = Date.now() - last;
            var fn2 = function fn3() {
              last = Date.now();
              func.apply(void 0, args);
            };
            if (dist < interval) {
              if (!immidiateOnly) {
                timeout = setTimeout(fn2, interval - dist);
              }
            } else {
              fn2();
            }
          };
        };
        var MAX_FILES_LIMIT = 1e6;
        var prevent = function prevent2(e4) {
          return e4.preventDefault();
        };
        var create$e = function create2(_ref) {
          var root2 = _ref.root, props = _ref.props;
          var id2 = root2.query("GET_ID");
          if (id2) {
            root2.element.id = id2;
          }
          var className = root2.query("GET_CLASS_NAME");
          if (className) {
            className.split(" ").filter(function(name2) {
              return name2.length;
            }).forEach(function(name2) {
              root2.element.classList.add(name2);
            });
          }
          root2.ref.label = root2.appendChildView(
            root2.createChildView(
              dropLabel,
              Object.assign({}, props, {
                translateY: null,
                caption: root2.query("GET_LABEL_IDLE")
              })
            )
          );
          root2.ref.list = root2.appendChildView(
            root2.createChildView(listScroller, { translateY: null })
          );
          root2.ref.panel = root2.appendChildView(root2.createChildView(panel, { name: "panel-root" }));
          root2.ref.assistant = root2.appendChildView(
            root2.createChildView(assistant, Object.assign({}, props))
          );
          root2.ref.data = root2.appendChildView(root2.createChildView(data, Object.assign({}, props)));
          root2.ref.measure = createElement$1("div");
          root2.ref.measure.style.height = "100%";
          root2.element.appendChild(root2.ref.measure);
          root2.ref.bounds = null;
          root2.query("GET_STYLES").filter(function(style) {
            return !isEmpty(style.value);
          }).map(function(_ref2) {
            var name2 = _ref2.name, value = _ref2.value;
            root2.element.dataset[name2] = value;
          });
          root2.ref.widthPrevious = null;
          root2.ref.widthUpdated = debounce(function() {
            root2.ref.updateHistory = [];
            root2.dispatch("DID_RESIZE_ROOT");
          }, 250);
          root2.ref.previousAspectRatio = null;
          root2.ref.updateHistory = [];
          var canHover = window.matchMedia("(pointer: fine) and (hover: hover)").matches;
          var hasPointerEvents = "PointerEvent" in window;
          if (root2.query("GET_ALLOW_REORDER") && hasPointerEvents && !canHover) {
            root2.element.addEventListener("touchmove", prevent, { passive: false });
            root2.element.addEventListener("gesturestart", prevent);
          }
          var credits = root2.query("GET_CREDITS");
          var hasCredits = credits.length === 2;
          if (hasCredits) {
            var frag = document.createElement("a");
            frag.className = "filepond--credits";
            frag.setAttribute("aria-hidden", "true");
            frag.href = credits[0];
            frag.tabindex = -1;
            frag.target = "_blank";
            frag.rel = "noopener noreferrer";
            frag.textContent = credits[1];
            root2.element.appendChild(frag);
            root2.ref.credits = frag;
          }
        };
        var write$9 = function write2(_ref3) {
          var root2 = _ref3.root, props = _ref3.props, actions2 = _ref3.actions;
          route$5({ root: root2, props, actions: actions2 });
          actions2.filter(function(action) {
            return /^DID_SET_STYLE_/.test(action.type);
          }).filter(function(action) {
            return !isEmpty(action.data.value);
          }).map(function(_ref4) {
            var type = _ref4.type, data2 = _ref4.data;
            var name2 = toCamels(type.substring(8).toLowerCase(), "_");
            root2.element.dataset[name2] = data2.value;
            root2.invalidateLayout();
          });
          if (root2.rect.element.hidden) return;
          if (root2.rect.element.width !== root2.ref.widthPrevious) {
            root2.ref.widthPrevious = root2.rect.element.width;
            root2.ref.widthUpdated();
          }
          var bounds = root2.ref.bounds;
          if (!bounds) {
            bounds = root2.ref.bounds = calculateRootBoundingBoxHeight(root2);
            root2.element.removeChild(root2.ref.measure);
            root2.ref.measure = null;
          }
          var _root$ref = root2.ref, hopper = _root$ref.hopper, label = _root$ref.label, list2 = _root$ref.list, panel2 = _root$ref.panel;
          if (hopper) {
            hopper.updateHopperState();
          }
          var aspectRatio = root2.query("GET_PANEL_ASPECT_RATIO");
          var isMultiItem = root2.query("GET_ALLOW_MULTIPLE");
          var totalItems = root2.query("GET_TOTAL_ITEMS");
          var maxItems = isMultiItem ? root2.query("GET_MAX_FILES") || MAX_FILES_LIMIT : 1;
          var atMaxCapacity = totalItems === maxItems;
          var addAction = actions2.find(function(action) {
            return action.type === "DID_ADD_ITEM";
          });
          if (atMaxCapacity && addAction) {
            var interactionMethod = addAction.data.interactionMethod;
            label.opacity = 0;
            if (isMultiItem) {
              label.translateY = -40;
            } else {
              if (interactionMethod === InteractionMethod.API) {
                label.translateX = 40;
              } else if (interactionMethod === InteractionMethod.BROWSE) {
                label.translateY = 40;
              } else {
                label.translateY = 30;
              }
            }
          } else if (!atMaxCapacity) {
            label.opacity = 1;
            label.translateX = 0;
            label.translateY = 0;
          }
          var listItemMargin = calculateListItemMargin(root2);
          var listHeight = calculateListHeight(root2);
          var labelHeight = label.rect.element.height;
          var currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;
          var listMarginTop = atMaxCapacity ? list2.rect.element.marginTop : 0;
          var listMarginBottom = totalItems === 0 ? 0 : list2.rect.element.marginBottom;
          var visualHeight = currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;
          var boundsHeight = currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;
          list2.translateY = Math.max(0, currentLabelHeight - list2.rect.element.marginTop) - listItemMargin.top;
          if (aspectRatio) {
            var width = root2.rect.element.width;
            var height = width * aspectRatio;
            if (aspectRatio !== root2.ref.previousAspectRatio) {
              root2.ref.previousAspectRatio = aspectRatio;
              root2.ref.updateHistory = [];
            }
            var history2 = root2.ref.updateHistory;
            history2.push(width);
            var MAX_BOUNCES = 2;
            if (history2.length > MAX_BOUNCES * 2) {
              var l4 = history2.length;
              var bottom = l4 - 10;
              var bounces = 0;
              for (var i4 = l4; i4 >= bottom; i4--) {
                if (history2[i4] === history2[i4 - 2]) {
                  bounces++;
                }
                if (bounces >= MAX_BOUNCES) {
                  return;
                }
              }
            }
            panel2.scalable = false;
            panel2.height = height;
            var listAvailableHeight = (
              // the height of the panel minus the label height
              height - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
              (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
              (atMaxCapacity ? listMarginTop : 0)
            );
            if (listHeight.visual > listAvailableHeight) {
              list2.overflow = listAvailableHeight;
            } else {
              list2.overflow = null;
            }
            root2.height = height;
          } else if (bounds.fixedHeight) {
            panel2.scalable = false;
            var _listAvailableHeight = (
              // the height of the panel minus the label height
              bounds.fixedHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
              (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
              (atMaxCapacity ? listMarginTop : 0)
            );
            if (listHeight.visual > _listAvailableHeight) {
              list2.overflow = _listAvailableHeight;
            } else {
              list2.overflow = null;
            }
          } else if (bounds.cappedHeight) {
            var isCappedHeight = visualHeight >= bounds.cappedHeight;
            var panelHeight = Math.min(bounds.cappedHeight, visualHeight);
            panel2.scalable = true;
            panel2.height = isCappedHeight ? panelHeight : panelHeight - listItemMargin.top - listItemMargin.bottom;
            var _listAvailableHeight2 = (
              // the height of the panel minus the label height
              panelHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
              (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
              (atMaxCapacity ? listMarginTop : 0)
            );
            if (visualHeight > bounds.cappedHeight && listHeight.visual > _listAvailableHeight2) {
              list2.overflow = _listAvailableHeight2;
            } else {
              list2.overflow = null;
            }
            root2.height = Math.min(
              bounds.cappedHeight,
              boundsHeight - listItemMargin.top - listItemMargin.bottom
            );
          } else {
            var itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;
            panel2.scalable = true;
            panel2.height = Math.max(labelHeight, visualHeight - itemMargin);
            root2.height = Math.max(labelHeight, boundsHeight - itemMargin);
          }
          if (root2.ref.credits && panel2.heightCurrent)
            root2.ref.credits.style.transform = "translateY(" + panel2.heightCurrent + "px)";
        };
        var calculateListItemMargin = function calculateListItemMargin2(root2) {
          var item2 = root2.ref.list.childViews[0].childViews[0];
          return item2 ? {
            top: item2.rect.element.marginTop,
            bottom: item2.rect.element.marginBottom
          } : {
            top: 0,
            bottom: 0
          };
        };
        var calculateListHeight = function calculateListHeight2(root2) {
          var visual = 0;
          var bounds = 0;
          var scrollList = root2.ref.list;
          var itemList = scrollList.childViews[0];
          var visibleChildren = itemList.childViews.filter(function(child) {
            return child.rect.element.height;
          });
          var children2 = root2.query("GET_ACTIVE_ITEMS").map(function(item2) {
            return visibleChildren.find(function(child) {
              return child.id === item2.id;
            });
          }).filter(function(item2) {
            return item2;
          });
          if (children2.length === 0) return { visual, bounds };
          var horizontalSpace = itemList.rect.element.width;
          var dragIndex = getItemIndexByPosition(itemList, children2, scrollList.dragCoordinates);
          var childRect = children2[0].rect.element;
          var itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
          var itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
          var itemWidth = childRect.width + itemHorizontalMargin;
          var itemHeight = childRect.height + itemVerticalMargin;
          var newItem = typeof dragIndex !== "undefined" && dragIndex >= 0 ? 1 : 0;
          var removedItem = children2.find(function(child) {
            return child.markedForRemoval && child.opacity < 0.45;
          }) ? -1 : 0;
          var verticalItemCount = children2.length + newItem + removedItem;
          var itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
          if (itemsPerRow === 1) {
            children2.forEach(function(item2) {
              var height = item2.rect.element.height + itemVerticalMargin;
              bounds += height;
              visual += height * item2.opacity;
            });
          } else {
            bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;
            visual = bounds;
          }
          return { visual, bounds };
        };
        var calculateRootBoundingBoxHeight = function calculateRootBoundingBoxHeight2(root2) {
          var height = root2.ref.measureHeight || null;
          var cappedHeight = parseInt(root2.style.maxHeight, 10) || null;
          var fixedHeight = height === 0 ? null : height;
          return {
            cappedHeight,
            fixedHeight
          };
        };
        var exceedsMaxFiles = function exceedsMaxFiles2(root2, items) {
          var allowReplace = root2.query("GET_ALLOW_REPLACE");
          var allowMultiple = root2.query("GET_ALLOW_MULTIPLE");
          var totalItems = root2.query("GET_TOTAL_ITEMS");
          var maxItems = root2.query("GET_MAX_FILES");
          var totalBrowseItems = items.length;
          if (!allowMultiple && totalBrowseItems > 1) {
            root2.dispatch("DID_THROW_MAX_FILES", {
              source: items,
              error: createResponse("warning", 0, "Max files")
            });
            return true;
          }
          maxItems = allowMultiple ? maxItems : 1;
          if (!allowMultiple && allowReplace) {
            return false;
          }
          var hasMaxItems = isInt(maxItems);
          if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {
            root2.dispatch("DID_THROW_MAX_FILES", {
              source: items,
              error: createResponse("warning", 0, "Max files")
            });
            return true;
          }
          return false;
        };
        var getDragIndex = function getDragIndex2(list2, children2, position) {
          var itemList = list2.childViews[0];
          return getItemIndexByPosition(itemList, children2, {
            left: position.scopeLeft - itemList.rect.element.left,
            top: position.scopeTop - (list2.rect.outer.top + list2.rect.element.marginTop + list2.rect.element.scrollTop)
          });
        };
        var toggleDrop = function toggleDrop2(root2) {
          var isAllowed = root2.query("GET_ALLOW_DROP");
          var isDisabled = root2.query("GET_DISABLED");
          var enabled = isAllowed && !isDisabled;
          if (enabled && !root2.ref.hopper) {
            var hopper = createHopper(
              root2.element,
              function(items) {
                var beforeDropFile = root2.query("GET_BEFORE_DROP_FILE") || function() {
                  return true;
                };
                var dropValidation = root2.query("GET_DROP_VALIDATION");
                return dropValidation ? items.every(function(item2) {
                  return applyFilters("ALLOW_HOPPER_ITEM", item2, {
                    query: root2.query
                  }).every(function(result) {
                    return result === true;
                  }) && beforeDropFile(item2);
                }) : true;
              },
              {
                filterItems: function filterItems(items) {
                  var ignoredFiles = root2.query("GET_IGNORED_FILES");
                  return items.filter(function(item2) {
                    if (isFile(item2)) {
                      return !ignoredFiles.includes(item2.name.toLowerCase());
                    }
                    return true;
                  });
                },
                catchesDropsOnPage: root2.query("GET_DROP_ON_PAGE"),
                requiresDropOnElement: root2.query("GET_DROP_ON_ELEMENT")
              }
            );
            hopper.onload = function(items, position) {
              var list2 = root2.ref.list.childViews[0];
              var visibleChildren = list2.childViews.filter(function(child) {
                return child.rect.element.height;
              });
              var children2 = root2.query("GET_ACTIVE_ITEMS").map(function(item2) {
                return visibleChildren.find(function(child) {
                  return child.id === item2.id;
                });
              }).filter(function(item2) {
                return item2;
              });
              applyFilterChain("ADD_ITEMS", items, { dispatch: root2.dispatch }).then(function(queue) {
                if (exceedsMaxFiles(root2, queue)) return false;
                root2.dispatch("ADD_ITEMS", {
                  items: queue,
                  index: getDragIndex(root2.ref.list, children2, position),
                  interactionMethod: InteractionMethod.DROP
                });
              });
              root2.dispatch("DID_DROP", { position });
              root2.dispatch("DID_END_DRAG", { position });
            };
            hopper.ondragstart = function(position) {
              root2.dispatch("DID_START_DRAG", { position });
            };
            hopper.ondrag = debounce(function(position) {
              root2.dispatch("DID_DRAG", { position });
            });
            hopper.ondragend = function(position) {
              root2.dispatch("DID_END_DRAG", { position });
            };
            root2.ref.hopper = hopper;
            root2.ref.drip = root2.appendChildView(root2.createChildView(drip));
          } else if (!enabled && root2.ref.hopper) {
            root2.ref.hopper.destroy();
            root2.ref.hopper = null;
            root2.removeChildView(root2.ref.drip);
          }
        };
        var toggleBrowse = function toggleBrowse2(root2, props) {
          var isAllowed = root2.query("GET_ALLOW_BROWSE");
          var isDisabled = root2.query("GET_DISABLED");
          var enabled = isAllowed && !isDisabled;
          if (enabled && !root2.ref.browser) {
            root2.ref.browser = root2.appendChildView(
              root2.createChildView(
                browser2,
                Object.assign({}, props, {
                  onload: function onload(items) {
                    applyFilterChain("ADD_ITEMS", items, {
                      dispatch: root2.dispatch
                    }).then(function(queue) {
                      if (exceedsMaxFiles(root2, queue)) return false;
                      root2.dispatch("ADD_ITEMS", {
                        items: queue,
                        index: -1,
                        interactionMethod: InteractionMethod.BROWSE
                      });
                    });
                  }
                })
              ),
              0
            );
          } else if (!enabled && root2.ref.browser) {
            root2.removeChildView(root2.ref.browser);
            root2.ref.browser = null;
          }
        };
        var togglePaste = function togglePaste2(root2) {
          var isAllowed = root2.query("GET_ALLOW_PASTE");
          var isDisabled = root2.query("GET_DISABLED");
          var enabled = isAllowed && !isDisabled;
          if (enabled && !root2.ref.paster) {
            root2.ref.paster = createPaster();
            root2.ref.paster.onload = function(items) {
              applyFilterChain("ADD_ITEMS", items, { dispatch: root2.dispatch }).then(function(queue) {
                if (exceedsMaxFiles(root2, queue)) return false;
                root2.dispatch("ADD_ITEMS", {
                  items: queue,
                  index: -1,
                  interactionMethod: InteractionMethod.PASTE
                });
              });
            };
          } else if (!enabled && root2.ref.paster) {
            root2.ref.paster.destroy();
            root2.ref.paster = null;
          }
        };
        var route$5 = createRoute({
          DID_SET_ALLOW_BROWSE: function DID_SET_ALLOW_BROWSE(_ref5) {
            var root2 = _ref5.root, props = _ref5.props;
            toggleBrowse(root2, props);
          },
          DID_SET_ALLOW_DROP: function DID_SET_ALLOW_DROP(_ref6) {
            var root2 = _ref6.root;
            toggleDrop(root2);
          },
          DID_SET_ALLOW_PASTE: function DID_SET_ALLOW_PASTE(_ref7) {
            var root2 = _ref7.root;
            togglePaste(root2);
          },
          DID_SET_DISABLED: function DID_SET_DISABLED(_ref8) {
            var root2 = _ref8.root, props = _ref8.props;
            toggleDrop(root2);
            togglePaste(root2);
            toggleBrowse(root2, props);
            var isDisabled = root2.query("GET_DISABLED");
            if (isDisabled) {
              root2.element.dataset.disabled = "disabled";
            } else {
              root2.element.removeAttribute("data-disabled");
            }
          }
        });
        var root = createView({
          name: "root",
          read: function read(_ref9) {
            var root2 = _ref9.root;
            if (root2.ref.measure) {
              root2.ref.measureHeight = root2.ref.measure.offsetHeight;
            }
          },
          create: create$e,
          write: write$9,
          destroy: function destroy(_ref10) {
            var root2 = _ref10.root;
            if (root2.ref.paster) {
              root2.ref.paster.destroy();
            }
            if (root2.ref.hopper) {
              root2.ref.hopper.destroy();
            }
            root2.element.removeEventListener("touchmove", prevent);
            root2.element.removeEventListener("gesturestart", prevent);
          },
          mixins: {
            styles: ["height"]
          }
        });
        var createApp2 = function createApp3() {
          var initialOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var originalElement = null;
          var defaultOptions2 = getOptions();
          var store = createStore(
            // initial state (should be serializable)
            createInitialState(defaultOptions2),
            // queries
            [queries, createOptionQueries(defaultOptions2)],
            // action handlers
            [actions, createOptionActions(defaultOptions2)]
          );
          store.dispatch("SET_OPTIONS", { options: initialOptions });
          var visibilityHandler = function visibilityHandler2() {
            if (document.hidden) return;
            store.dispatch("KICK");
          };
          document.addEventListener("visibilitychange", visibilityHandler);
          var resizeDoneTimer = null;
          var isResizing = false;
          var isResizingHorizontally = false;
          var initialWindowWidth = null;
          var currentWindowWidth = null;
          var resizeHandler = function resizeHandler2() {
            if (!isResizing) {
              isResizing = true;
            }
            clearTimeout(resizeDoneTimer);
            resizeDoneTimer = setTimeout(function() {
              isResizing = false;
              initialWindowWidth = null;
              currentWindowWidth = null;
              if (isResizingHorizontally) {
                isResizingHorizontally = false;
                store.dispatch("DID_STOP_RESIZE");
              }
            }, 500);
          };
          window.addEventListener("resize", resizeHandler);
          var view = root(store, { id: getUniqueId() });
          var isResting = false;
          var isHidden3 = false;
          var readWriteApi = {
            // necessary for update loop
            /**
             * Reads from dom (never call manually)
             * @private
             */
            _read: function _read() {
              if (isResizing) {
                currentWindowWidth = window.innerWidth;
                if (!initialWindowWidth) {
                  initialWindowWidth = currentWindowWidth;
                }
                if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {
                  store.dispatch("DID_START_RESIZE");
                  isResizingHorizontally = true;
                }
              }
              if (isHidden3 && isResting) {
                isResting = view.element.offsetParent === null;
              }
              if (isResting) return;
              view._read();
              isHidden3 = view.rect.element.hidden;
            },
            /**
             * Writes to dom (never call manually)
             * @private
             */
            _write: function _write(ts) {
              var actions2 = store.processActionQueue().filter(function(action) {
                return !/^SET_/.test(action.type);
              });
              if (isResting && !actions2.length) return;
              routeActionsToEvents(actions2);
              isResting = view._write(ts, actions2, isResizingHorizontally);
              removeReleasedItems(store.query("GET_ITEMS"));
              if (isResting) {
                store.processDispatchQueue();
              }
            }
          };
          var createEvent = function createEvent2(name2) {
            return function(data2) {
              var event2 = {
                type: name2
              };
              if (!data2) {
                return event2;
              }
              if (data2.hasOwnProperty("error")) {
                event2.error = data2.error ? Object.assign({}, data2.error) : null;
              }
              if (data2.status) {
                event2.status = Object.assign({}, data2.status);
              }
              if (data2.file) {
                event2.output = data2.file;
              }
              if (data2.source) {
                event2.file = data2.source;
              } else if (data2.item || data2.id) {
                var item2 = data2.item ? data2.item : store.query("GET_ITEM", data2.id);
                event2.file = item2 ? createItemAPI(item2) : null;
              }
              if (data2.items) {
                event2.items = data2.items.map(createItemAPI);
              }
              if (/progress/.test(name2)) {
                event2.progress = data2.progress;
              }
              if (data2.hasOwnProperty("origin") && data2.hasOwnProperty("target")) {
                event2.origin = data2.origin;
                event2.target = data2.target;
              }
              return event2;
            };
          };
          var eventRoutes = {
            DID_DESTROY: createEvent("destroy"),
            DID_INIT: createEvent("init"),
            DID_THROW_MAX_FILES: createEvent("warning"),
            DID_INIT_ITEM: createEvent("initfile"),
            DID_START_ITEM_LOAD: createEvent("addfilestart"),
            DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent("addfileprogress"),
            DID_LOAD_ITEM: createEvent("addfile"),
            DID_THROW_ITEM_INVALID: [createEvent("error"), createEvent("addfile")],
            DID_THROW_ITEM_LOAD_ERROR: [createEvent("error"), createEvent("addfile")],
            DID_THROW_ITEM_REMOVE_ERROR: [createEvent("error"), createEvent("removefile")],
            DID_PREPARE_OUTPUT: createEvent("preparefile"),
            DID_START_ITEM_PROCESSING: createEvent("processfilestart"),
            DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent("processfileprogress"),
            DID_ABORT_ITEM_PROCESSING: createEvent("processfileabort"),
            DID_COMPLETE_ITEM_PROCESSING: createEvent("processfile"),
            DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent("processfiles"),
            DID_REVERT_ITEM_PROCESSING: createEvent("processfilerevert"),
            DID_THROW_ITEM_PROCESSING_ERROR: [createEvent("error"), createEvent("processfile")],
            DID_REMOVE_ITEM: createEvent("removefile"),
            DID_UPDATE_ITEMS: createEvent("updatefiles"),
            DID_ACTIVATE_ITEM: createEvent("activatefile"),
            DID_REORDER_ITEMS: createEvent("reorderfiles")
          };
          var exposeEvent = function exposeEvent2(event2) {
            var detail = Object.assign({ pond: exports3 }, event2);
            delete detail.type;
            view.element.dispatchEvent(
              new CustomEvent("FilePond:" + event2.type, {
                // event info
                detail,
                // event behaviour
                bubbles: true,
                cancelable: true,
                composed: true
                // triggers listeners outside of shadow root
              })
            );
            var params = [];
            if (event2.hasOwnProperty("error")) {
              params.push(event2.error);
            }
            if (event2.hasOwnProperty("file")) {
              params.push(event2.file);
            }
            var filtered = ["type", "error", "file"];
            Object.keys(event2).filter(function(key) {
              return !filtered.includes(key);
            }).forEach(function(key) {
              return params.push(event2[key]);
            });
            exports3.fire.apply(exports3, [event2.type].concat(params));
            var handler = store.query("GET_ON" + event2.type.toUpperCase());
            if (handler) {
              handler.apply(void 0, params);
            }
          };
          var routeActionsToEvents = function routeActionsToEvents2(actions2) {
            if (!actions2.length) return;
            actions2.filter(function(action) {
              return eventRoutes[action.type];
            }).forEach(function(action) {
              var routes = eventRoutes[action.type];
              (Array.isArray(routes) ? routes : [routes]).forEach(function(route2) {
                if (action.type === "DID_INIT_ITEM") {
                  exposeEvent(route2(action.data));
                } else {
                  setTimeout(function() {
                    exposeEvent(route2(action.data));
                  }, 0);
                }
              });
            });
          };
          var setOptions2 = function setOptions3(options) {
            return store.dispatch("SET_OPTIONS", { options });
          };
          var getFile = function getFile2(query) {
            return store.query("GET_ACTIVE_ITEM", query);
          };
          var prepareFile = function prepareFile2(query) {
            return new Promise(function(resolve, reject) {
              store.dispatch("REQUEST_ITEM_PREPARE", {
                query,
                success: function success(item2) {
                  resolve(item2);
                },
                failure: function failure(error2) {
                  reject(error2);
                }
              });
            });
          };
          var addFile = function addFile2(source) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return new Promise(function(resolve, reject) {
              addFiles([{ source, options }], { index: options.index }).then(function(items) {
                return resolve(items && items[0]);
              }).catch(reject);
            });
          };
          var isFilePondFile = function isFilePondFile2(obj) {
            return obj.file && obj.id;
          };
          var removeFile = function removeFile2(query, options) {
            if (typeof query === "object" && !isFilePondFile(query) && !options) {
              options = query;
              query = void 0;
            }
            store.dispatch("REMOVE_ITEM", Object.assign({}, options, { query }));
            return store.query("GET_ACTIVE_ITEM", query) === null;
          };
          var addFiles = function addFiles2() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return new Promise(function(resolve, reject) {
              var sources = [];
              var options = {};
              if (isArray3(args[0])) {
                sources.push.apply(sources, args[0]);
                Object.assign(options, args[1] || {});
              } else {
                var lastArgument = args[args.length - 1];
                if (typeof lastArgument === "object" && !(lastArgument instanceof Blob)) {
                  Object.assign(options, args.pop());
                }
                sources.push.apply(sources, args);
              }
              store.dispatch("ADD_ITEMS", {
                items: sources,
                index: options.index,
                interactionMethod: InteractionMethod.API,
                success: resolve,
                failure: reject
              });
            });
          };
          var getFiles2 = function getFiles3() {
            return store.query("GET_ACTIVE_ITEMS");
          };
          var processFile = function processFile2(query) {
            return new Promise(function(resolve, reject) {
              store.dispatch("REQUEST_ITEM_PROCESSING", {
                query,
                success: function success(item2) {
                  resolve(item2);
                },
                failure: function failure(error2) {
                  reject(error2);
                }
              });
            });
          };
          var prepareFiles = function prepareFiles2() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            var queries2 = Array.isArray(args[0]) ? args[0] : args;
            var items = queries2.length ? queries2 : getFiles2();
            return Promise.all(items.map(prepareFile));
          };
          var processFiles = function processFiles2() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            var queries2 = Array.isArray(args[0]) ? args[0] : args;
            if (!queries2.length) {
              var files = getFiles2().filter(function(item2) {
                return !(item2.status === ItemStatus.IDLE && item2.origin === FileOrigin.LOCAL) && item2.status !== ItemStatus.PROCESSING && item2.status !== ItemStatus.PROCESSING_COMPLETE && item2.status !== ItemStatus.PROCESSING_REVERT_ERROR;
              });
              return Promise.all(files.map(processFile));
            }
            return Promise.all(queries2.map(processFile));
          };
          var removeFiles = function removeFiles2() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            var queries2 = Array.isArray(args[0]) ? args[0] : args;
            var options;
            if (typeof queries2[queries2.length - 1] === "object") {
              options = queries2.pop();
            } else if (Array.isArray(args[0])) {
              options = args[1];
            }
            var files = getFiles2();
            if (!queries2.length)
              return Promise.all(
                files.map(function(file2) {
                  return removeFile(file2, options);
                })
              );
            var mappedQueries = queries2.map(function(query) {
              return isNumber(query) ? files[query] ? files[query].id : null : query;
            }).filter(function(query) {
              return query;
            });
            return mappedQueries.map(function(q2) {
              return removeFile(q2, options);
            });
          };
          var exports3 = Object.assign(
            {},
            on2(),
            {},
            readWriteApi,
            {},
            createOptionAPI(store, defaultOptions2),
            {
              /**
               * Override options defined in options object
               * @param options
               */
              setOptions: setOptions2,
              /**
               * Load the given file
               * @param source - the source of the file (either a File, base64 data uri or url)
               * @param options - object, { index: 0 }
               */
              addFile,
              /**
               * Load the given files
               * @param sources - the sources of the files to load
               * @param options - object, { index: 0 }
               */
              addFiles,
              /**
               * Returns the file objects matching the given query
               * @param query { string, number, null }
               */
              getFile,
              /**
               * Upload file with given name
               * @param query { string, number, null  }
               */
              processFile,
              /**
               * Request prepare output for file with given name
               * @param query { string, number, null  }
               */
              prepareFile,
              /**
               * Removes a file by its name
               * @param query { string, number, null  }
               */
              removeFile,
              /**
               * Moves a file to a new location in the files list
               */
              moveFile: function moveFile(query, index2) {
                return store.dispatch("MOVE_ITEM", { query, index: index2 });
              },
              /**
               * Returns all files (wrapped in public api)
               */
              getFiles: getFiles2,
              /**
               * Starts uploading all files
               */
              processFiles,
              /**
               * Clears all files from the files list
               */
              removeFiles,
              /**
               * Starts preparing output of all files
               */
              prepareFiles,
              /**
               * Sort list of files
               */
              sort: function sort(compare) {
                return store.dispatch("SORT", { compare });
              },
              /**
               * Browse the file system for a file
               */
              browse: function browse() {
                var input = view.element.querySelector("input[type=file]");
                if (input) {
                  input.click();
                }
              },
              /**
               * Destroys the app
               */
              destroy: function destroy() {
                exports3.fire("destroy", view.element);
                store.dispatch("ABORT_ALL");
                view._destroy();
                window.removeEventListener("resize", resizeHandler);
                document.removeEventListener("visibilitychange", visibilityHandler);
                store.dispatch("DID_DESTROY");
              },
              /**
               * Inserts the plugin before the target element
               */
              insertBefore: function insertBefore$1(element) {
                return insertBefore(view.element, element);
              },
              /**
               * Inserts the plugin after the target element
               */
              insertAfter: function insertAfter$1(element) {
                return insertAfter(view.element, element);
              },
              /**
               * Appends the plugin to the target element
               */
              appendTo: function appendTo(element) {
                return element.appendChild(view.element);
              },
              /**
               * Replaces an element with the app
               */
              replaceElement: function replaceElement(element) {
                insertBefore(view.element, element);
                element.parentNode.removeChild(element);
                originalElement = element;
              },
              /**
               * Restores the original element
               */
              restoreElement: function restoreElement() {
                if (!originalElement) {
                  return;
                }
                insertAfter(originalElement, view.element);
                view.element.parentNode.removeChild(view.element);
                originalElement = null;
              },
              /**
               * Returns true if the app root is attached to given element
               * @param element
               */
              isAttachedTo: function isAttachedTo(element) {
                return view.element === element || originalElement === element;
              },
              /**
               * Returns the root element
               */
              element: {
                get: function get() {
                  return view.element;
                }
              },
              /**
               * Returns the current pond status
               */
              status: {
                get: function get() {
                  return store.query("GET_STATUS");
                }
              }
            }
          );
          store.dispatch("DID_INIT");
          return createObject(exports3);
        };
        var createAppObject = function createAppObject2() {
          var customOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var defaultOptions2 = {};
          forin(getOptions(), function(key, value) {
            defaultOptions2[key] = value[0];
          });
          var app2 = createApp2(
            Object.assign(
              {},
              defaultOptions2,
              {},
              customOptions
            )
          );
          return app2;
        };
        var lowerCaseFirstLetter = function lowerCaseFirstLetter2(string) {
          return string.charAt(0).toLowerCase() + string.slice(1);
        };
        var attributeNameToPropertyName = function attributeNameToPropertyName2(attributeName) {
          return toCamels(attributeName.replace(/^data-/, ""));
        };
        var mapObject = function mapObject2(object, propertyMap) {
          forin(propertyMap, function(selector3, mapping) {
            forin(object, function(property, value) {
              var selectorRegExp = new RegExp(selector3);
              var matches2 = selectorRegExp.test(property);
              if (!matches2) {
                return;
              }
              delete object[property];
              if (mapping === false) {
                return;
              }
              if (isString2(mapping)) {
                object[mapping] = value;
                return;
              }
              var group = mapping.group;
              if (isObject3(mapping) && !object[group]) {
                object[group] = {};
              }
              object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ""))] = value;
            });
            if (mapping.mapping) {
              mapObject2(object[mapping.group], mapping.mapping);
            }
          });
        };
        var getAttributesAsObject = function getAttributesAsObject2(node) {
          var attributeMapping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var attributes = [];
          forin(node.attributes, function(index2) {
            attributes.push(node.attributes[index2]);
          });
          var output = attributes.filter(function(attribute) {
            return attribute.name;
          }).reduce(function(obj, attribute) {
            var value = attr2(node, attribute.name);
            obj[attributeNameToPropertyName(attribute.name)] = value === attribute.name ? true : value;
            return obj;
          }, {});
          mapObject(output, attributeMapping);
          return output;
        };
        var createAppAtElement = function createAppAtElement2(element) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var attributeMapping = {
            // translate to other name
            "^class$": "className",
            "^multiple$": "allowMultiple",
            "^capture$": "captureMethod",
            "^webkitdirectory$": "allowDirectoriesOnly",
            // group under single property
            "^server": {
              group: "server",
              mapping: {
                "^process": {
                  group: "process"
                },
                "^revert": {
                  group: "revert"
                },
                "^fetch": {
                  group: "fetch"
                },
                "^restore": {
                  group: "restore"
                },
                "^load": {
                  group: "load"
                }
              }
            },
            // don't include in object
            "^type$": false,
            "^files$": false
          };
          applyFilters("SET_ATTRIBUTE_TO_OPTION_MAP", attributeMapping);
          var mergedOptions = Object.assign({}, options);
          var attributeOptions = getAttributesAsObject(
            element.nodeName === "FIELDSET" ? element.querySelector("input[type=file]") : element,
            attributeMapping
          );
          Object.keys(attributeOptions).forEach(function(key) {
            if (isObject3(attributeOptions[key])) {
              if (!isObject3(mergedOptions[key])) {
                mergedOptions[key] = {};
              }
              Object.assign(mergedOptions[key], attributeOptions[key]);
            } else {
              mergedOptions[key] = attributeOptions[key];
            }
          });
          mergedOptions.files = (options.files || []).concat(
            Array.from(element.querySelectorAll("input:not([type=file])")).map(function(input) {
              return {
                source: input.value,
                options: {
                  type: input.dataset.type
                }
              };
            })
          );
          var app2 = createAppObject(mergedOptions);
          if (element.files) {
            Array.from(element.files).forEach(function(file2) {
              app2.addFile(file2);
            });
          }
          app2.replaceElement(element);
          return app2;
        };
        var createApp$1 = function createApp3() {
          return isNode2(arguments.length <= 0 ? void 0 : arguments[0]) ? createAppAtElement.apply(void 0, arguments) : createAppObject.apply(void 0, arguments);
        };
        var PRIVATE_METHODS = ["fire", "_read", "_write"];
        var createAppAPI = function createAppAPI2(app2) {
          var api = {};
          copyObjectPropertiesToObject(app2, api, PRIVATE_METHODS);
          return api;
        };
        var replaceInString = function replaceInString2(string, replacements) {
          return string.replace(/(?:{([a-zA-Z]+)})/g, function(match, group) {
            return replacements[group];
          });
        };
        var createWorker = function createWorker2(fn2) {
          var workerBlob = new Blob(["(", fn2.toString(), ")()"], {
            type: "application/javascript"
          });
          var workerURL = URL.createObjectURL(workerBlob);
          var worker = new Worker(workerURL);
          return {
            transfer: function transfer(message, cb) {
            },
            post: function post(message, cb, transferList) {
              var id2 = getUniqueId();
              worker.onmessage = function(e4) {
                if (e4.data.id === id2) {
                  cb(e4.data.message);
                }
              };
              worker.postMessage(
                {
                  id: id2,
                  message
                },
                transferList
              );
            },
            terminate: function terminate() {
              worker.terminate();
              URL.revokeObjectURL(workerURL);
            }
          };
        };
        var loadImage3 = function loadImage4(url) {
          return new Promise(function(resolve, reject) {
            var img = new Image();
            img.onload = function() {
              resolve(img);
            };
            img.onerror = function(e4) {
              reject(e4);
            };
            img.src = url;
          });
        };
        var renameFile = function renameFile2(file2, name2) {
          var renamedFile = file2.slice(0, file2.size, file2.type);
          renamedFile.lastModifiedDate = file2.lastModifiedDate;
          renamedFile.name = name2;
          return renamedFile;
        };
        var copyFile = function copyFile2(file2) {
          return renameFile(file2, file2.name);
        };
        var registeredPlugins = [];
        var createAppPlugin = function createAppPlugin2(plugin) {
          if (registeredPlugins.includes(plugin)) {
            return;
          }
          registeredPlugins.push(plugin);
          var pluginOutline = plugin({
            addFilter,
            utils: {
              Type,
              forin,
              isString: isString2,
              isFile,
              toNaturalFileSize,
              replaceInString,
              getExtensionFromFilename,
              getFilenameWithoutExtension,
              guesstimateMimeType,
              getFileFromBlob,
              getFilenameFromURL,
              createRoute,
              createWorker,
              createView,
              createItemAPI,
              loadImage: loadImage3,
              copyFile,
              renameFile,
              createBlob,
              applyFilterChain,
              text: text2,
              getNumericAspectRatioFromString
            },
            views: {
              fileActionButton
            }
          });
          extendDefaultOptions(pluginOutline.options);
        };
        var isOperaMini = function isOperaMini2() {
          return Object.prototype.toString.call(window.operamini) === "[object OperaMini]";
        };
        var hasPromises = function hasPromises2() {
          return "Promise" in window;
        };
        var hasBlobSlice = function hasBlobSlice2() {
          return "slice" in Blob.prototype;
        };
        var hasCreateObjectURL = function hasCreateObjectURL2() {
          return "URL" in window && "createObjectURL" in window.URL;
        };
        var hasVisibility = function hasVisibility2() {
          return "visibilityState" in document;
        };
        var hasTiming = function hasTiming2() {
          return "performance" in window;
        };
        var hasCSSSupports = function hasCSSSupports2() {
          return "supports" in (window.CSS || {});
        };
        var isIE11 = function isIE112() {
          return /MSIE|Trident/.test(window.navigator.userAgent);
        };
        var supported = function() {
          var isSupported = (
            // Has to be a browser
            isBrowser() && // Can't run on Opera Mini due to lack of everything
            !isOperaMini() && // Require these APIs to feature detect a modern browser
            hasVisibility() && hasPromises() && hasBlobSlice() && hasCreateObjectURL() && hasTiming() && // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)
            (hasCSSSupports() || isIE11())
          );
          return function() {
            return isSupported;
          };
        }();
        var state = {
          // active app instances, used to redraw the apps and to find the later
          apps: []
        };
        var name = "filepond";
        var fn = function fn2() {
        };
        exports2.Status = {};
        exports2.FileStatus = {};
        exports2.FileOrigin = {};
        exports2.OptionTypes = {};
        exports2.create = fn;
        exports2.destroy = fn;
        exports2.parse = fn;
        exports2.find = fn;
        exports2.registerPlugin = fn;
        exports2.getOptions = fn;
        exports2.setOptions = fn;
        if (supported()) {
          createPainter(
            function() {
              state.apps.forEach(function(app2) {
                return app2._read();
              });
            },
            function(ts) {
              state.apps.forEach(function(app2) {
                return app2._write(ts);
              });
            }
          );
          var dispatch = function dispatch2() {
            document.dispatchEvent(
              new CustomEvent("FilePond:loaded", {
                detail: {
                  supported,
                  create: exports2.create,
                  destroy: exports2.destroy,
                  parse: exports2.parse,
                  find: exports2.find,
                  registerPlugin: exports2.registerPlugin,
                  setOptions: exports2.setOptions
                }
              })
            );
            document.removeEventListener("DOMContentLoaded", dispatch2);
          };
          if (document.readyState !== "loading") {
            setTimeout(function() {
              return dispatch();
            }, 0);
          } else {
            document.addEventListener("DOMContentLoaded", dispatch);
          }
          var updateOptionTypes = function updateOptionTypes2() {
            return forin(getOptions(), function(key, value) {
              exports2.OptionTypes[key] = value[1];
            });
          };
          exports2.Status = Object.assign({}, Status);
          exports2.FileOrigin = Object.assign({}, FileOrigin);
          exports2.FileStatus = Object.assign({}, ItemStatus);
          exports2.OptionTypes = {};
          updateOptionTypes();
          exports2.create = function create2() {
            var app2 = createApp$1.apply(void 0, arguments);
            app2.on("destroy", exports2.destroy);
            state.apps.push(app2);
            return createAppAPI(app2);
          };
          exports2.destroy = function destroy(hook) {
            var indexToRemove = state.apps.findIndex(function(app3) {
              return app3.isAttachedTo(hook);
            });
            if (indexToRemove >= 0) {
              var app2 = state.apps.splice(indexToRemove, 1)[0];
              app2.restoreElement();
              return true;
            }
            return false;
          };
          exports2.parse = function parse3(context3) {
            var matchedHooks = Array.from(context3.querySelectorAll("." + name));
            var newHooks = matchedHooks.filter(function(newHook) {
              return !state.apps.find(function(app2) {
                return app2.isAttachedTo(newHook);
              });
            });
            return newHooks.map(function(hook) {
              return exports2.create(hook);
            });
          };
          exports2.find = function find2(hook) {
            var app2 = state.apps.find(function(app3) {
              return app3.isAttachedTo(hook);
            });
            if (!app2) {
              return null;
            }
            return createAppAPI(app2);
          };
          exports2.registerPlugin = function registerPlugin2() {
            for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
              plugins[_key] = arguments[_key];
            }
            plugins.forEach(createAppPlugin);
            updateOptionTypes();
          };
          exports2.getOptions = function getOptions$1() {
            var opts = {};
            forin(getOptions(), function(key, value) {
              opts[key] = value[0];
            });
            return opts;
          };
          exports2.setOptions = function setOptions$1(opts) {
            if (isObject3(opts)) {
              state.apps.forEach(function(app2) {
                app2.setOptions(opts);
              });
              setOptions(opts);
            }
            return exports2.getOptions();
          };
        }
        exports2.supported = supported;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/vue-filepond/dist/vue-filepond.js
  var require_vue_filepond = __commonJS({
    "node_modules/vue-filepond/dist/vue-filepond.js"(exports) {
      (function(global2, factory) {
        if (typeof define === "function" && define.amd) {
          define("vueFilePond", ["exports", "vue", "filepond"], factory);
        } else if (typeof exports !== "undefined") {
          factory(exports, require_vue(), require_filepond());
        } else {
          var mod = {
            exports: {}
          };
          factory(mod.exports, global2.Vue, global2.FilePond);
          global2.vueFilePond = mod.exports;
        }
      })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports, function(_exports, _vue, _filepond) {
        "use strict";
        Object.defineProperty(_exports, "__esModule", {
          value: true
        });
        _exports.default = _exports.setOptions = void 0;
        function _slicedToArray2(arr, i4) {
          return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i4) || _nonIterableRest2();
        }
        function _nonIterableRest2() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
        function _iterableToArrayLimit2(arr, i4) {
          if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
            return;
          }
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e2 = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i4 && _arr.length === i4) break;
            }
          } catch (err) {
            _d = true;
            _e2 = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e2;
            }
          }
          return _arr;
        }
        function _arrayWithHoles2(arr) {
          if (Array.isArray(arr)) return arr;
        }
        var filteredComponentMethods = ["setOptions", "on", "off", "onOnce", "appendTo", "insertAfter", "insertBefore", "isAttachedTo", "replaceElement", "restoreElement", "destroy"];
        var isSupported = (0, _filepond.supported)();
        var getNativeConstructorFromType = function getNativeConstructorFromType2(type) {
          return {
            string: String,
            boolean: Boolean,
            array: Array,
            function: Function,
            int: Number,
            serverapi: Object,
            object: Object
          }[type];
        };
        var props = {};
        var events2 = [];
        var instances = [];
        var globalOptions = {};
        var setOptions = function setOptions2(options) {
          globalOptions = Object.assign(globalOptions, options);
          instances.forEach(function(instance) {
            instance.setOptions(globalOptions);
          });
        };
        _exports.setOptions = setOptions;
        var _default2 = function _default3() {
          _filepond.registerPlugin.apply(void 0, arguments);
          events2.length = 0;
          for (var prop in _filepond.OptionTypes) {
            if (/^on/.test(prop)) {
              events2.push(prop);
              continue;
            }
            var valid_types = [String, getNativeConstructorFromType(_filepond.OptionTypes[prop])];
            if (prop == "labelFileProcessingError") {
              valid_types.push(Function);
            }
            props[prop] = {
              type: valid_types,
              // set this default value so we know which props have been explicitely set by user on component
              default: void 0
            };
          }
          return {
            name: "FilePond",
            props,
            render: function render6() {
              var attributes = Object.entries({
                id: this.id,
                name: this.name,
                type: "file",
                class: this.className,
                required: this.required,
                multiple: this.allowMultiple,
                accept: this.acceptedFileTypes,
                capture: this.captureMethod
              }).reduce(function(attributes2, _ref) {
                var _ref2 = _slicedToArray2(_ref, 2), key = _ref2[0], value = _ref2[1];
                if (value !== void 0) attributes2[key] = value;
                return attributes2;
              }, {});
              return (0, _vue.h)("div", {
                class: {
                  "filepond--wrapper": true
                }
              }, [(0, _vue.h)("input", attributes)]);
            },
            created: function created() {
              var _this = this;
              this.watchers = Object.keys(props).map(function(key) {
                return _this.$watch(key, function(next2) {
                  _this._pond[key] = next2;
                });
              });
            },
            // Will setup FilePond instance when mounted
            mounted: function mounted() {
              var _this2 = this;
              if (!isSupported) return;
              this._element = this.$el.querySelector("input");
              var options = events2.reduce(function(obj, value) {
                obj[value] = function() {
                  _this2.$emit("input", _this2._pond ? _this2._pond.getFiles() : []);
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  _this2.$emit.apply(_this2, [value.substr(2)].concat(args));
                };
                return obj;
              }, {});
              var passedProps = {};
              Object.keys(props).forEach(function(key) {
                if (_this2[key] === void 0) return;
                passedProps[key] = _this2[key];
              });
              this._pond = (0, _filepond.create)(this._element, Object.assign({}, globalOptions, options, passedProps));
              Object.keys(this._pond).filter(function(key) {
                return !filteredComponentMethods.includes(key);
              }).forEach(function(key) {
                _this2[key] = _this2._pond[key];
              });
              instances.push(this._pond);
            },
            // Will clean up FilePond instance when unmounted
            beforeUnmount: function beforeUnmount() {
              var _this3 = this;
              var detached = this.$options.detached;
              if (!this.$el.offsetParent) {
                detached.call(this);
                return;
              }
              var mutationHandler = function mutationHandler2(mutations, observer2) {
                var removedNodes = (mutations[0] || {}).removedNodes || [];
                var removedNode = removedNodes[0];
                if (!removedNode || !removedNode.contains(_this3.$el)) return;
                observer2.disconnect();
                detached.call(_this3);
              };
              var observer = new MutationObserver(mutationHandler);
              observer.observe(document.documentElement, {
                childList: true,
                subtree: true
              });
            },
            // called when the component root node has been detached
            detached: function detached() {
              this.watchers.forEach(function(unwatch) {
                return unwatch();
              });
              if (!this._pond) return;
              this._pond.destroy();
              var index2 = instances.indexOf(this._pond);
              if (index2 >= 0) {
                instances.splice(index2, 1);
              }
              this._pond = null;
            }
          };
        };
        _exports.default = _default2;
      });
    }
  });

  // node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js
  var require_filepond_plugin_file_validate_type = __commonJS({
    "node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.FilePondPluginFileValidateType = factory());
      })(exports, function() {
        "use strict";
        var plugin = function plugin2(_ref) {
          var addFilter = _ref.addFilter, utils = _ref.utils;
          var Type = utils.Type, isString2 = utils.isString, replaceInString = utils.replaceInString, guesstimateMimeType = utils.guesstimateMimeType, getExtensionFromFilename = utils.getExtensionFromFilename, getFilenameFromURL = utils.getFilenameFromURL;
          var mimeTypeMatchesWildCard = function mimeTypeMatchesWildCard2(mimeType, wildcard) {
            var mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop();
            var wildcardGroup = wildcard.slice(0, -2);
            return mimeTypeGroup === wildcardGroup;
          };
          var isValidMimeType = function isValidMimeType2(acceptedTypes, userInputType) {
            return acceptedTypes.some(function(acceptedType) {
              if (/\*$/.test(acceptedType)) {
                return mimeTypeMatchesWildCard(userInputType, acceptedType);
              }
              return acceptedType === userInputType;
            });
          };
          var getItemType = function getItemType2(item) {
            var type = "";
            if (isString2(item)) {
              var filename = getFilenameFromURL(item);
              var extension = getExtensionFromFilename(filename);
              if (extension) {
                type = guesstimateMimeType(extension);
              }
            } else {
              type = item.type;
            }
            return type;
          };
          var validateFile = function validateFile2(item, acceptedFileTypes, typeDetector) {
            if (acceptedFileTypes.length === 0) {
              return true;
            }
            var type = getItemType(item);
            if (!typeDetector) {
              return isValidMimeType(acceptedFileTypes, type);
            }
            return new Promise(function(resolve, reject) {
              typeDetector(item, type).then(function(detectedType) {
                if (isValidMimeType(acceptedFileTypes, detectedType)) {
                  resolve();
                } else {
                  reject();
                }
              }).catch(reject);
            });
          };
          var applyMimeTypeMap = function applyMimeTypeMap2(map2) {
            return function(acceptedFileType) {
              return map2[acceptedFileType] === null ? false : map2[acceptedFileType] || acceptedFileType;
            };
          };
          addFilter("SET_ATTRIBUTE_TO_OPTION_MAP", function(map2) {
            return Object.assign(map2, {
              accept: "acceptedFileTypes"
            });
          });
          addFilter("ALLOW_HOPPER_ITEM", function(file, _ref2) {
            var query = _ref2.query;
            if (!query("GET_ALLOW_FILE_TYPE_VALIDATION")) {
              return true;
            }
            return validateFile(file, query("GET_ACCEPTED_FILE_TYPES"));
          });
          addFilter("LOAD_FILE", function(file, _ref3) {
            var query = _ref3.query;
            return new Promise(function(resolve, reject) {
              if (!query("GET_ALLOW_FILE_TYPE_VALIDATION")) {
                resolve(file);
                return;
              }
              var acceptedFileTypes = query("GET_ACCEPTED_FILE_TYPES");
              var typeDetector = query("GET_FILE_VALIDATE_TYPE_DETECT_TYPE");
              var validationResult = validateFile(
                file,
                acceptedFileTypes,
                typeDetector
              );
              var handleRejection = function handleRejection2() {
                var acceptedFileTypesMapped = acceptedFileTypes.map(
                  applyMimeTypeMap(
                    query("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP")
                  )
                ).filter(function(label) {
                  return label !== false;
                });
                var acceptedFileTypesMapped_unique = acceptedFileTypesMapped.filter(
                  function(item, index2) {
                    return acceptedFileTypesMapped.indexOf(item) === index2;
                  }
                );
                reject({
                  status: {
                    main: query("GET_LABEL_FILE_TYPE_NOT_ALLOWED"),
                    sub: replaceInString(
                      query("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES"),
                      {
                        allTypes: acceptedFileTypesMapped_unique.join(", "),
                        allButLastType: acceptedFileTypesMapped_unique.slice(0, -1).join(", "),
                        lastType: acceptedFileTypesMapped_unique[acceptedFileTypesMapped.length - 1]
                      }
                    )
                  }
                });
              };
              if (typeof validationResult === "boolean") {
                if (!validationResult) {
                  return handleRejection();
                }
                return resolve(file);
              }
              validationResult.then(function() {
                resolve(file);
              }).catch(handleRejection);
            });
          });
          return {
            // default options
            options: {
              // Enable or disable file type validation
              allowFileTypeValidation: [true, Type.BOOLEAN],
              // What file types to accept
              acceptedFileTypes: [[], Type.ARRAY],
              // - must be comma separated
              // - mime types: image/png, image/jpeg, image/gif
              // - extensions: .png, .jpg, .jpeg ( not enabled yet )
              // - wildcards: image/*
              // label to show when a type is not allowed
              labelFileTypeNotAllowed: ["File is of invalid type", Type.STRING],
              // nicer label
              fileValidateTypeLabelExpectedTypes: [
                "Expects {allButLastType} or {lastType}",
                Type.STRING
              ],
              // map mime types to extensions
              fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],
              // Custom function to detect type of file
              fileValidateTypeDetectType: [null, Type.FUNCTION]
            }
          };
        };
        var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
        if (isBrowser) {
          document.dispatchEvent(
            new CustomEvent("FilePond:pluginloaded", { detail: plugin })
          );
        }
        return plugin;
      });
    }
  });

  // node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js
  var require_filepond_plugin_file_validate_size = __commonJS({
    "node_modules/filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.FilePondPluginFileValidateSize = factory());
      })(exports, function() {
        "use strict";
        var plugin = function plugin2(_ref) {
          var addFilter = _ref.addFilter, utils = _ref.utils;
          var Type = utils.Type, replaceInString = utils.replaceInString, toNaturalFileSize = utils.toNaturalFileSize;
          addFilter("ALLOW_HOPPER_ITEM", function(file, _ref2) {
            var query = _ref2.query;
            if (!query("GET_ALLOW_FILE_SIZE_VALIDATION")) {
              return true;
            }
            var sizeMax = query("GET_MAX_FILE_SIZE");
            if (sizeMax !== null && file.size > sizeMax) {
              return false;
            }
            var sizeMin = query("GET_MIN_FILE_SIZE");
            if (sizeMin !== null && file.size < sizeMin) {
              return false;
            }
            return true;
          });
          addFilter("LOAD_FILE", function(file, _ref3) {
            var query = _ref3.query;
            return new Promise(function(resolve, reject) {
              if (!query("GET_ALLOW_FILE_SIZE_VALIDATION")) {
                return resolve(file);
              }
              var fileFilter = query("GET_FILE_VALIDATE_SIZE_FILTER");
              if (fileFilter && !fileFilter(file)) {
                return resolve(file);
              }
              var sizeMax = query("GET_MAX_FILE_SIZE");
              if (sizeMax !== null && file.size > sizeMax) {
                reject({
                  status: {
                    main: query("GET_LABEL_MAX_FILE_SIZE_EXCEEDED"),
                    sub: replaceInString(query("GET_LABEL_MAX_FILE_SIZE"), {
                      filesize: toNaturalFileSize(
                        sizeMax,
                        ".",
                        query("GET_FILE_SIZE_BASE"),
                        query("GET_FILE_SIZE_LABELS", query)
                      )
                    })
                  }
                });
                return;
              }
              var sizeMin = query("GET_MIN_FILE_SIZE");
              if (sizeMin !== null && file.size < sizeMin) {
                reject({
                  status: {
                    main: query("GET_LABEL_MIN_FILE_SIZE_EXCEEDED"),
                    sub: replaceInString(query("GET_LABEL_MIN_FILE_SIZE"), {
                      filesize: toNaturalFileSize(
                        sizeMin,
                        ".",
                        query("GET_FILE_SIZE_BASE"),
                        query("GET_FILE_SIZE_LABELS", query)
                      )
                    })
                  }
                });
                return;
              }
              var totalSizeMax = query("GET_MAX_TOTAL_FILE_SIZE");
              if (totalSizeMax !== null) {
                var currentTotalSize = query("GET_ACTIVE_ITEMS").reduce(function(total, item) {
                  return total + item.fileSize;
                }, 0);
                if (currentTotalSize > totalSizeMax) {
                  reject({
                    status: {
                      main: query("GET_LABEL_MAX_TOTAL_FILE_SIZE_EXCEEDED"),
                      sub: replaceInString(query("GET_LABEL_MAX_TOTAL_FILE_SIZE"), {
                        filesize: toNaturalFileSize(
                          totalSizeMax,
                          ".",
                          query("GET_FILE_SIZE_BASE"),
                          query("GET_FILE_SIZE_LABELS", query)
                        )
                      })
                    }
                  });
                  return;
                }
              }
              resolve(file);
            });
          });
          return {
            options: {
              // Enable or disable file type validation
              allowFileSizeValidation: [true, Type.BOOLEAN],
              // Max individual file size in bytes
              maxFileSize: [null, Type.INT],
              // Min individual file size in bytes
              minFileSize: [null, Type.INT],
              // Max total file size in bytes
              maxTotalFileSize: [null, Type.INT],
              // Filter the files that need to be validated for size
              fileValidateSizeFilter: [null, Type.FUNCTION],
              // error labels
              labelMinFileSizeExceeded: ["File is too small", Type.STRING],
              labelMinFileSize: ["Minimum file size is {filesize}", Type.STRING],
              labelMaxFileSizeExceeded: ["File is too large", Type.STRING],
              labelMaxFileSize: ["Maximum file size is {filesize}", Type.STRING],
              labelMaxTotalFileSizeExceeded: ["Maximum total size exceeded", Type.STRING],
              labelMaxTotalFileSize: ["Maximum total file size is {filesize}", Type.STRING]
            }
          };
        };
        var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
        if (isBrowser) {
          document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", { detail: plugin }));
        }
        return plugin;
      });
    }
  });

  // node_modules/colormap/colorScale.js
  var require_colorScale = __commonJS({
    "node_modules/colormap/colorScale.js"(exports, module) {
      module.exports = {
        "jet": [{ "index": 0, "rgb": [0, 0, 131] }, { "index": 0.125, "rgb": [0, 60, 170] }, { "index": 0.375, "rgb": [5, 255, 255] }, { "index": 0.625, "rgb": [255, 255, 0] }, { "index": 0.875, "rgb": [250, 0, 0] }, { "index": 1, "rgb": [128, 0, 0] }],
        "hsv": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 0.169, "rgb": [253, 255, 2] }, { "index": 0.173, "rgb": [247, 255, 2] }, { "index": 0.337, "rgb": [0, 252, 4] }, { "index": 0.341, "rgb": [0, 252, 10] }, { "index": 0.506, "rgb": [1, 249, 255] }, { "index": 0.671, "rgb": [2, 0, 253] }, { "index": 0.675, "rgb": [8, 0, 253] }, { "index": 0.839, "rgb": [255, 0, 251] }, { "index": 0.843, "rgb": [255, 0, 245] }, { "index": 1, "rgb": [255, 0, 6] }],
        "hot": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.3, "rgb": [230, 0, 0] }, { "index": 0.6, "rgb": [255, 210, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
        "spring": [{ "index": 0, "rgb": [255, 0, 255] }, { "index": 1, "rgb": [255, 255, 0] }],
        "summer": [{ "index": 0, "rgb": [0, 128, 102] }, { "index": 1, "rgb": [255, 255, 102] }],
        "autumn": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 1, "rgb": [255, 255, 0] }],
        "winter": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [0, 255, 128] }],
        "bone": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.376, "rgb": [84, 84, 116] }, { "index": 0.753, "rgb": [169, 200, 200] }, { "index": 1, "rgb": [255, 255, 255] }],
        "copper": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.804, "rgb": [255, 160, 102] }, { "index": 1, "rgb": [255, 199, 127] }],
        "greys": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
        "yignbu": [{ "index": 0, "rgb": [8, 29, 88] }, { "index": 0.125, "rgb": [37, 52, 148] }, { "index": 0.25, "rgb": [34, 94, 168] }, { "index": 0.375, "rgb": [29, 145, 192] }, { "index": 0.5, "rgb": [65, 182, 196] }, { "index": 0.625, "rgb": [127, 205, 187] }, { "index": 0.75, "rgb": [199, 233, 180] }, { "index": 0.875, "rgb": [237, 248, 217] }, { "index": 1, "rgb": [255, 255, 217] }],
        "greens": [{ "index": 0, "rgb": [0, 68, 27] }, { "index": 0.125, "rgb": [0, 109, 44] }, { "index": 0.25, "rgb": [35, 139, 69] }, { "index": 0.375, "rgb": [65, 171, 93] }, { "index": 0.5, "rgb": [116, 196, 118] }, { "index": 0.625, "rgb": [161, 217, 155] }, { "index": 0.75, "rgb": [199, 233, 192] }, { "index": 0.875, "rgb": [229, 245, 224] }, { "index": 1, "rgb": [247, 252, 245] }],
        "yiorrd": [{ "index": 0, "rgb": [128, 0, 38] }, { "index": 0.125, "rgb": [189, 0, 38] }, { "index": 0.25, "rgb": [227, 26, 28] }, { "index": 0.375, "rgb": [252, 78, 42] }, { "index": 0.5, "rgb": [253, 141, 60] }, { "index": 0.625, "rgb": [254, 178, 76] }, { "index": 0.75, "rgb": [254, 217, 118] }, { "index": 0.875, "rgb": [255, 237, 160] }, { "index": 1, "rgb": [255, 255, 204] }],
        "bluered": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [255, 0, 0] }],
        "rdbu": [{ "index": 0, "rgb": [5, 10, 172] }, { "index": 0.35, "rgb": [106, 137, 247] }, { "index": 0.5, "rgb": [190, 190, 190] }, { "index": 0.6, "rgb": [220, 170, 132] }, { "index": 0.7, "rgb": [230, 145, 90] }, { "index": 1, "rgb": [178, 10, 28] }],
        "picnic": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 0.1, "rgb": [51, 153, 255] }, { "index": 0.2, "rgb": [102, 204, 255] }, { "index": 0.3, "rgb": [153, 204, 255] }, { "index": 0.4, "rgb": [204, 204, 255] }, { "index": 0.5, "rgb": [255, 255, 255] }, { "index": 0.6, "rgb": [255, 204, 255] }, { "index": 0.7, "rgb": [255, 153, 255] }, { "index": 0.8, "rgb": [255, 102, 204] }, { "index": 0.9, "rgb": [255, 102, 102] }, { "index": 1, "rgb": [255, 0, 0] }],
        "rainbow": [{ "index": 0, "rgb": [150, 0, 90] }, { "index": 0.125, "rgb": [0, 0, 200] }, { "index": 0.25, "rgb": [0, 25, 255] }, { "index": 0.375, "rgb": [0, 152, 255] }, { "index": 0.5, "rgb": [44, 255, 150] }, { "index": 0.625, "rgb": [151, 255, 0] }, { "index": 0.75, "rgb": [255, 234, 0] }, { "index": 0.875, "rgb": [255, 111, 0] }, { "index": 1, "rgb": [255, 0, 0] }],
        "portland": [{ "index": 0, "rgb": [12, 51, 131] }, { "index": 0.25, "rgb": [10, 136, 186] }, { "index": 0.5, "rgb": [242, 211, 56] }, { "index": 0.75, "rgb": [242, 143, 56] }, { "index": 1, "rgb": [217, 30, 30] }],
        "blackbody": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.2, "rgb": [230, 0, 0] }, { "index": 0.4, "rgb": [230, 210, 0] }, { "index": 0.7, "rgb": [255, 255, 255] }, { "index": 1, "rgb": [160, 200, 255] }],
        "earth": [{ "index": 0, "rgb": [0, 0, 130] }, { "index": 0.1, "rgb": [0, 180, 180] }, { "index": 0.2, "rgb": [40, 210, 40] }, { "index": 0.4, "rgb": [230, 230, 50] }, { "index": 0.6, "rgb": [120, 70, 20] }, { "index": 1, "rgb": [255, 255, 255] }],
        "electric": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.15, "rgb": [30, 0, 100] }, { "index": 0.4, "rgb": [120, 0, 100] }, { "index": 0.6, "rgb": [160, 90, 0] }, { "index": 0.8, "rgb": [230, 200, 0] }, { "index": 1, "rgb": [255, 250, 220] }],
        "alpha": [{ "index": 0, "rgb": [255, 255, 255, 0] }, { "index": 1, "rgb": [255, 255, 255, 1] }],
        "viridis": [{ "index": 0, "rgb": [68, 1, 84] }, { "index": 0.13, "rgb": [71, 44, 122] }, { "index": 0.25, "rgb": [59, 81, 139] }, { "index": 0.38, "rgb": [44, 113, 142] }, { "index": 0.5, "rgb": [33, 144, 141] }, { "index": 0.63, "rgb": [39, 173, 129] }, { "index": 0.75, "rgb": [92, 200, 99] }, { "index": 0.88, "rgb": [170, 220, 50] }, { "index": 1, "rgb": [253, 231, 37] }],
        "inferno": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [31, 12, 72] }, { "index": 0.25, "rgb": [85, 15, 109] }, { "index": 0.38, "rgb": [136, 34, 106] }, { "index": 0.5, "rgb": [186, 54, 85] }, { "index": 0.63, "rgb": [227, 89, 51] }, { "index": 0.75, "rgb": [249, 140, 10] }, { "index": 0.88, "rgb": [249, 201, 50] }, { "index": 1, "rgb": [252, 255, 164] }],
        "magma": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [28, 16, 68] }, { "index": 0.25, "rgb": [79, 18, 123] }, { "index": 0.38, "rgb": [129, 37, 129] }, { "index": 0.5, "rgb": [181, 54, 122] }, { "index": 0.63, "rgb": [229, 80, 100] }, { "index": 0.75, "rgb": [251, 135, 97] }, { "index": 0.88, "rgb": [254, 194, 135] }, { "index": 1, "rgb": [252, 253, 191] }],
        "plasma": [{ "index": 0, "rgb": [13, 8, 135] }, { "index": 0.13, "rgb": [75, 3, 161] }, { "index": 0.25, "rgb": [125, 3, 168] }, { "index": 0.38, "rgb": [168, 34, 150] }, { "index": 0.5, "rgb": [203, 70, 121] }, { "index": 0.63, "rgb": [229, 107, 93] }, { "index": 0.75, "rgb": [248, 148, 65] }, { "index": 0.88, "rgb": [253, 195, 40] }, { "index": 1, "rgb": [240, 249, 33] }],
        "warm": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [172, 0, 187] }, { "index": 0.25, "rgb": [219, 0, 170] }, { "index": 0.38, "rgb": [255, 0, 130] }, { "index": 0.5, "rgb": [255, 63, 74] }, { "index": 0.63, "rgb": [255, 123, 0] }, { "index": 0.75, "rgb": [234, 176, 0] }, { "index": 0.88, "rgb": [190, 228, 0] }, { "index": 1, "rgb": [147, 255, 0] }],
        "cool": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [116, 0, 218] }, { "index": 0.25, "rgb": [98, 74, 237] }, { "index": 0.38, "rgb": [68, 146, 231] }, { "index": 0.5, "rgb": [0, 204, 197] }, { "index": 0.63, "rgb": [0, 247, 146] }, { "index": 0.75, "rgb": [0, 255, 88] }, { "index": 0.88, "rgb": [40, 255, 8] }, { "index": 1, "rgb": [147, 255, 0] }],
        "rainbow-soft": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.1, "rgb": [199, 0, 180] }, { "index": 0.2, "rgb": [255, 0, 121] }, { "index": 0.3, "rgb": [255, 108, 0] }, { "index": 0.4, "rgb": [222, 194, 0] }, { "index": 0.5, "rgb": [150, 255, 0] }, { "index": 0.6, "rgb": [0, 255, 55] }, { "index": 0.7, "rgb": [0, 246, 150] }, { "index": 0.8, "rgb": [50, 167, 222] }, { "index": 0.9, "rgb": [103, 51, 235] }, { "index": 1, "rgb": [124, 0, 186] }],
        "bathymetry": [{ "index": 0, "rgb": [40, 26, 44] }, { "index": 0.13, "rgb": [59, 49, 90] }, { "index": 0.25, "rgb": [64, 76, 139] }, { "index": 0.38, "rgb": [63, 110, 151] }, { "index": 0.5, "rgb": [72, 142, 158] }, { "index": 0.63, "rgb": [85, 174, 163] }, { "index": 0.75, "rgb": [120, 206, 163] }, { "index": 0.88, "rgb": [187, 230, 172] }, { "index": 1, "rgb": [253, 254, 204] }],
        "cdom": [{ "index": 0, "rgb": [47, 15, 62] }, { "index": 0.13, "rgb": [87, 23, 86] }, { "index": 0.25, "rgb": [130, 28, 99] }, { "index": 0.38, "rgb": [171, 41, 96] }, { "index": 0.5, "rgb": [206, 67, 86] }, { "index": 0.63, "rgb": [230, 106, 84] }, { "index": 0.75, "rgb": [242, 149, 103] }, { "index": 0.88, "rgb": [249, 193, 135] }, { "index": 1, "rgb": [254, 237, 176] }],
        "chlorophyll": [{ "index": 0, "rgb": [18, 36, 20] }, { "index": 0.13, "rgb": [25, 63, 41] }, { "index": 0.25, "rgb": [24, 91, 59] }, { "index": 0.38, "rgb": [13, 119, 72] }, { "index": 0.5, "rgb": [18, 148, 80] }, { "index": 0.63, "rgb": [80, 173, 89] }, { "index": 0.75, "rgb": [132, 196, 122] }, { "index": 0.88, "rgb": [175, 221, 162] }, { "index": 1, "rgb": [215, 249, 208] }],
        "density": [{ "index": 0, "rgb": [54, 14, 36] }, { "index": 0.13, "rgb": [89, 23, 80] }, { "index": 0.25, "rgb": [110, 45, 132] }, { "index": 0.38, "rgb": [120, 77, 178] }, { "index": 0.5, "rgb": [120, 113, 213] }, { "index": 0.63, "rgb": [115, 151, 228] }, { "index": 0.75, "rgb": [134, 185, 227] }, { "index": 0.88, "rgb": [177, 214, 227] }, { "index": 1, "rgb": [230, 241, 241] }],
        "freesurface-blue": [{ "index": 0, "rgb": [30, 4, 110] }, { "index": 0.13, "rgb": [47, 14, 176] }, { "index": 0.25, "rgb": [41, 45, 236] }, { "index": 0.38, "rgb": [25, 99, 212] }, { "index": 0.5, "rgb": [68, 131, 200] }, { "index": 0.63, "rgb": [114, 156, 197] }, { "index": 0.75, "rgb": [157, 181, 203] }, { "index": 0.88, "rgb": [200, 208, 216] }, { "index": 1, "rgb": [241, 237, 236] }],
        "freesurface-red": [{ "index": 0, "rgb": [60, 9, 18] }, { "index": 0.13, "rgb": [100, 17, 27] }, { "index": 0.25, "rgb": [142, 20, 29] }, { "index": 0.38, "rgb": [177, 43, 27] }, { "index": 0.5, "rgb": [192, 87, 63] }, { "index": 0.63, "rgb": [205, 125, 105] }, { "index": 0.75, "rgb": [216, 162, 148] }, { "index": 0.88, "rgb": [227, 199, 193] }, { "index": 1, "rgb": [241, 237, 236] }],
        "oxygen": [{ "index": 0, "rgb": [64, 5, 5] }, { "index": 0.13, "rgb": [106, 6, 15] }, { "index": 0.25, "rgb": [144, 26, 7] }, { "index": 0.38, "rgb": [168, 64, 3] }, { "index": 0.5, "rgb": [188, 100, 4] }, { "index": 0.63, "rgb": [206, 136, 11] }, { "index": 0.75, "rgb": [220, 174, 25] }, { "index": 0.88, "rgb": [231, 215, 44] }, { "index": 1, "rgb": [248, 254, 105] }],
        "par": [{ "index": 0, "rgb": [51, 20, 24] }, { "index": 0.13, "rgb": [90, 32, 35] }, { "index": 0.25, "rgb": [129, 44, 34] }, { "index": 0.38, "rgb": [159, 68, 25] }, { "index": 0.5, "rgb": [182, 99, 19] }, { "index": 0.63, "rgb": [199, 134, 22] }, { "index": 0.75, "rgb": [212, 171, 35] }, { "index": 0.88, "rgb": [221, 210, 54] }, { "index": 1, "rgb": [225, 253, 75] }],
        "phase": [{ "index": 0, "rgb": [145, 105, 18] }, { "index": 0.13, "rgb": [184, 71, 38] }, { "index": 0.25, "rgb": [186, 58, 115] }, { "index": 0.38, "rgb": [160, 71, 185] }, { "index": 0.5, "rgb": [110, 97, 218] }, { "index": 0.63, "rgb": [50, 123, 164] }, { "index": 0.75, "rgb": [31, 131, 110] }, { "index": 0.88, "rgb": [77, 129, 34] }, { "index": 1, "rgb": [145, 105, 18] }],
        "salinity": [{ "index": 0, "rgb": [42, 24, 108] }, { "index": 0.13, "rgb": [33, 50, 162] }, { "index": 0.25, "rgb": [15, 90, 145] }, { "index": 0.38, "rgb": [40, 118, 137] }, { "index": 0.5, "rgb": [59, 146, 135] }, { "index": 0.63, "rgb": [79, 175, 126] }, { "index": 0.75, "rgb": [120, 203, 104] }, { "index": 0.88, "rgb": [193, 221, 100] }, { "index": 1, "rgb": [253, 239, 154] }],
        "temperature": [{ "index": 0, "rgb": [4, 35, 51] }, { "index": 0.13, "rgb": [23, 51, 122] }, { "index": 0.25, "rgb": [85, 59, 157] }, { "index": 0.38, "rgb": [129, 79, 143] }, { "index": 0.5, "rgb": [175, 95, 130] }, { "index": 0.63, "rgb": [222, 112, 101] }, { "index": 0.75, "rgb": [249, 146, 66] }, { "index": 0.88, "rgb": [249, 196, 65] }, { "index": 1, "rgb": [232, 250, 91] }],
        "turbidity": [{ "index": 0, "rgb": [34, 31, 27] }, { "index": 0.13, "rgb": [65, 50, 41] }, { "index": 0.25, "rgb": [98, 69, 52] }, { "index": 0.38, "rgb": [131, 89, 57] }, { "index": 0.5, "rgb": [161, 112, 59] }, { "index": 0.63, "rgb": [185, 140, 66] }, { "index": 0.75, "rgb": [202, 174, 88] }, { "index": 0.88, "rgb": [216, 209, 126] }, { "index": 1, "rgb": [233, 246, 171] }],
        "velocity-blue": [{ "index": 0, "rgb": [17, 32, 64] }, { "index": 0.13, "rgb": [35, 52, 116] }, { "index": 0.25, "rgb": [29, 81, 156] }, { "index": 0.38, "rgb": [31, 113, 162] }, { "index": 0.5, "rgb": [50, 144, 169] }, { "index": 0.63, "rgb": [87, 173, 176] }, { "index": 0.75, "rgb": [149, 196, 189] }, { "index": 0.88, "rgb": [203, 221, 211] }, { "index": 1, "rgb": [254, 251, 230] }],
        "velocity-green": [{ "index": 0, "rgb": [23, 35, 19] }, { "index": 0.13, "rgb": [24, 64, 38] }, { "index": 0.25, "rgb": [11, 95, 45] }, { "index": 0.38, "rgb": [39, 123, 35] }, { "index": 0.5, "rgb": [95, 146, 12] }, { "index": 0.63, "rgb": [152, 165, 18] }, { "index": 0.75, "rgb": [201, 186, 69] }, { "index": 0.88, "rgb": [233, 216, 137] }, { "index": 1, "rgb": [255, 253, 205] }],
        "cubehelix": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.07, "rgb": [22, 5, 59] }, { "index": 0.13, "rgb": [60, 4, 105] }, { "index": 0.2, "rgb": [109, 1, 135] }, { "index": 0.27, "rgb": [161, 0, 147] }, { "index": 0.33, "rgb": [210, 2, 142] }, { "index": 0.4, "rgb": [251, 11, 123] }, { "index": 0.47, "rgb": [255, 29, 97] }, { "index": 0.53, "rgb": [255, 54, 69] }, { "index": 0.6, "rgb": [255, 85, 46] }, { "index": 0.67, "rgb": [255, 120, 34] }, { "index": 0.73, "rgb": [255, 157, 37] }, { "index": 0.8, "rgb": [241, 191, 57] }, { "index": 0.87, "rgb": [224, 220, 93] }, { "index": 0.93, "rgb": [218, 241, 142] }, { "index": 1, "rgb": [227, 253, 198] }]
      };
    }
  });

  // node_modules/lerp/index.js
  var require_lerp = __commonJS({
    "node_modules/lerp/index.js"(exports, module) {
      function lerp3(v0, v1, t3) {
        return v0 * (1 - t3) + v1 * t3;
      }
      module.exports = lerp3;
    }
  });

  // node_modules/colormap/index.js
  var require_colormap = __commonJS({
    "node_modules/colormap/index.js"(exports, module) {
      "use strict";
      var colorScale = require_colorScale();
      var lerp3 = require_lerp();
      module.exports = createColormap;
      function createColormap(spec) {
        var indicies, fromrgba, torgba, nsteps, cmap, colormap2, format, nshades, colors2, alpha, i4;
        if (!spec) spec = {};
        nshades = (spec.nshades || 72) - 1;
        format = spec.format || "hex";
        colormap2 = spec.colormap;
        if (!colormap2) colormap2 = "jet";
        if (typeof colormap2 === "string") {
          colormap2 = colormap2.toLowerCase();
          if (!colorScale[colormap2]) {
            throw Error(colormap2 + " not a supported colorscale");
          }
          cmap = colorScale[colormap2];
        } else if (Array.isArray(colormap2)) {
          cmap = colormap2.slice();
        } else {
          throw Error("unsupported colormap option", colormap2);
        }
        if (cmap.length > nshades + 1) {
          throw new Error(
            colormap2 + " map requires nshades to be at least size " + cmap.length
          );
        }
        if (!Array.isArray(spec.alpha)) {
          if (typeof spec.alpha === "number") {
            alpha = [spec.alpha, spec.alpha];
          } else {
            alpha = [1, 1];
          }
        } else if (spec.alpha.length !== 2) {
          alpha = [1, 1];
        } else {
          alpha = spec.alpha.slice();
        }
        indicies = cmap.map(function(c3) {
          return Math.round(c3.index * nshades);
        });
        alpha[0] = Math.min(Math.max(alpha[0], 0), 1);
        alpha[1] = Math.min(Math.max(alpha[1], 0), 1);
        var steps = cmap.map(function(c3, i5) {
          var index2 = cmap[i5].index;
          var rgba = cmap[i5].rgb.slice();
          if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) {
            return rgba;
          }
          rgba[3] = alpha[0] + (alpha[1] - alpha[0]) * index2;
          return rgba;
        });
        var colors2 = [];
        for (i4 = 0; i4 < indicies.length - 1; ++i4) {
          nsteps = indicies[i4 + 1] - indicies[i4];
          fromrgba = steps[i4];
          torgba = steps[i4 + 1];
          for (var j2 = 0; j2 < nsteps; j2++) {
            var amt = j2 / nsteps;
            colors2.push([
              Math.round(lerp3(fromrgba[0], torgba[0], amt)),
              Math.round(lerp3(fromrgba[1], torgba[1], amt)),
              Math.round(lerp3(fromrgba[2], torgba[2], amt)),
              lerp3(fromrgba[3], torgba[3], amt)
            ]);
          }
        }
        colors2.push(cmap[cmap.length - 1].rgb.concat(alpha[1]));
        if (format === "hex") colors2 = colors2.map(rgb2hex);
        else if (format === "rgbaString") colors2 = colors2.map(rgbaStr);
        else if (format === "float") colors2 = colors2.map(rgb2float);
        return colors2;
      }
      function rgb2float(rgba) {
        return [
          rgba[0] / 255,
          rgba[1] / 255,
          rgba[2] / 255,
          rgba[3]
        ];
      }
      function rgb2hex(rgba) {
        var dig, hex = "#";
        for (var i4 = 0; i4 < 3; ++i4) {
          dig = rgba[i4];
          dig = dig.toString(16);
          hex += ("00" + dig).substr(dig.length);
        }
        return hex;
      }
      function rgbaStr(rgba) {
        return "rgba(" + rgba.join(",") + ")";
      }
    }
  });

  // node_modules/bezier-easing/src/index.js
  var require_src = __commonJS({
    "node_modules/bezier-easing/src/index.js"(exports, module) {
      var NEWTON_ITERATIONS = 4;
      var NEWTON_MIN_SLOPE = 1e-3;
      var SUBDIVISION_PRECISION = 1e-7;
      var SUBDIVISION_MAX_ITERATIONS = 10;
      var kSplineTableSize = 11;
      var kSampleStepSize = 1 / (kSplineTableSize - 1);
      var float32ArraySupported = typeof Float32Array === "function";
      function A2(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      }
      function B2(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      }
      function C2(aA1) {
        return 3 * aA1;
      }
      function calcBezier(aT, aA1, aA2) {
        return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
      }
      function getSlope(aT, aA1, aA2) {
        return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
      }
      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i4 = 0;
        do {
          currentT = aA + (aB - aA) / 2;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i4 < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i4 = 0; i4 < NEWTON_ITERATIONS; ++i4) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0) {
            return aGuessT;
          }
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      function LinearEasing(x2) {
        return x2;
      }
      module.exports = function bezier2(mX1, mY1, mX2, mY2) {
        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
          throw new Error("bezier x values must be in [0, 1] range");
        }
        if (mX1 === mY1 && mX2 === mY2) {
          return LinearEasing;
        }
        var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
        for (var i4 = 0; i4 < kSplineTableSize; ++i4) {
          sampleValues[i4] = calcBezier(i4 * kSampleStepSize, mX1, mX2);
        }
        function getTForX(aX) {
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } else if (initialSlope === 0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        }
        return function BezierEasing(x2) {
          if (x2 === 0) {
            return 0;
          }
          if (x2 === 1) {
            return 1;
          }
          return calcBezier(getTForX(x2), mY1, mY2);
        };
      };
    }
  });

  // node_modules/svg4everybody/dist/svg4everybody.js
  var require_svg4everybody = __commonJS({
    "node_modules/svg4everybody/dist/svg4everybody.js"(exports, module) {
      !function(root, factory) {
        "function" == typeof define && define.amd ? (
          // AMD. Register as an anonymous module unless amdModuleId is set
          define([], function() {
            return root.svg4everybody = factory();
          })
        ) : "object" == typeof module && module.exports ? (
          // Node. Does not work with strict CommonJS, but
          // only CommonJS-like environments that support module.exports,
          // like Node.
          module.exports = factory()
        ) : root.svg4everybody = factory();
      }(exports, function() {
        function embed(parent2, svg, target) {
          if (target) {
            var fragment2 = document.createDocumentFragment(), viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
            viewBox && svg.setAttribute("viewBox", viewBox);
            for (var clone2 = target.cloneNode(true); clone2.childNodes.length; ) {
              fragment2.appendChild(clone2.firstChild);
            }
            parent2.appendChild(fragment2);
          }
        }
        function loadreadystatechange(xhr) {
          xhr.onreadystatechange = function() {
            if (4 === xhr.readyState) {
              var cachedDocument = xhr._cachedDocument;
              cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), // clear the xhr embeds list and embed each item
              xhr._embeds.splice(0).map(function(item) {
                var target = xhr._cachedTarget[item.id];
                target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), // embed the target into the svg
                embed(item.parent, item.svg, target);
              });
            }
          }, // test the ready state change immediately
          xhr.onreadystatechange();
        }
        function svg4everybody2(rawopts) {
          function oninterval() {
            for (var index2 = 0; index2 < uses.length; ) {
              var use = uses[index2], parent2 = use.parentNode, svg = getSVGAncestor(parent2), src = use.getAttribute("xlink:href") || use.getAttribute("href");
              if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), svg && src) {
                if (polyfill) {
                  if (!opts.validate || opts.validate(src, svg, use)) {
                    parent2.removeChild(use);
                    var srcSplit = src.split("#"), url = srcSplit.shift(), id = srcSplit.join("#");
                    if (url.length) {
                      var xhr = requests[url];
                      xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), xhr._embeds = []), // add the svg and id as an item to the xhr embeds list
                      xhr._embeds.push({
                        parent: parent2,
                        svg,
                        id
                      }), // prepare the xhr ready state change event
                      loadreadystatechange(xhr);
                    } else {
                      embed(parent2, svg, document.getElementById(id));
                    }
                  } else {
                    ++index2, ++numberOfSvgUseElementsToBypass;
                  }
                }
              } else {
                ++index2;
              }
            }
            (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame2(oninterval, 67);
          }
          var polyfill, opts = Object(rawopts), newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/, webkitUA = /\bAppleWebKit\/(\d+)\b/, olderEdgeUA = /\bEdge\/12\.(\d+)\b/, edgeUA = /\bEdge\/.(\d+)\b/, inIframe = window.top !== window.self;
          polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe;
          var requests = {}, requestAnimationFrame2 = window.requestAnimationFrame || setTimeout, uses = document.getElementsByTagName("use"), numberOfSvgUseElementsToBypass = 0;
          polyfill && oninterval();
        }
        function getSVGAncestor(node) {
          for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode); ) {
          }
          return svg;
        }
        return svg4everybody2;
      });
    }
  });

  // node_modules/modujs/dist/main.esm.js
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i4 = 0; i4 < props.length; i4++) {
      var descriptor = props[i4];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _slicedToArray(arr, i4) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i4) || _unsupportedIterableToArray(arr, i4) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }
  function _iterableToArrayLimit(arr, i4) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e2 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i4 && _arr.length === i4) break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e2;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o4, minLen) {
    if (!o4) return;
    if (typeof o4 === "string") return _arrayLikeToArray(o4, minLen);
    var n4 = Object.prototype.toString.call(o4).slice(8, -1);
    if (n4 === "Object" && o4.constructor) n4 = o4.constructor.name;
    if (n4 === "Map" || n4 === "Set") return Array.from(o4);
    if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return _arrayLikeToArray(o4, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++) arr2[i4] = arr[i4];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var _default = /* @__PURE__ */ function() {
    function _default2(options) {
      _classCallCheck(this, _default2);
      this.mAttr = "data-" + options.dataName;
      this.mCaptureEvents = ["mouseenter", "mouseleave"];
      this.el = options.el;
    }
    _createClass(_default2, [{
      key: "mInit",
      value: function mInit(modules) {
        var _this = this;
        this.modules = modules;
        this.mCheckEventTarget = this.mCheckEventTarget.bind(this);
        if (this.events) {
          Object.keys(this.events).forEach(function(event2) {
            return _this.mAddEvent(event2);
          });
        }
      }
    }, {
      key: "mUpdate",
      value: function mUpdate(modules) {
        this.modules = modules;
      }
    }, {
      key: "mDestroy",
      value: function mDestroy() {
        var _this2 = this;
        if (this.events) {
          Object.keys(this.events).forEach(function(event2) {
            return _this2.mRemoveEvent(event2);
          });
        }
      }
    }, {
      key: "mAddEvent",
      value: function mAddEvent(event2) {
        var capture = this.mCaptureEvents.includes(event2) ? true : false;
        this.el.addEventListener(event2, this.mCheckEventTarget, capture);
      }
    }, {
      key: "mRemoveEvent",
      value: function mRemoveEvent(event2) {
        var capture = this.mCaptureEvents.includes(event2) ? true : false;
        this.el.removeEventListener(event2, this.mCheckEventTarget, capture);
      }
    }, {
      key: "mCheckEventTarget",
      value: function mCheckEventTarget(e4) {
        var event2 = this.events[e4.type];
        if (typeof event2 === "string") {
          this[event2](e4);
        } else {
          var data = "[" + this.mAttr + "]";
          var target = e4.target;
          if (this.mCaptureEvents.includes(e4.type)) {
            if (target.matches(data)) {
              this.mCallEventMethod(e4, event2, target);
            }
          } else {
            while (target && target !== document) {
              if (target.matches(data)) {
                if (this.mCallEventMethod(e4, event2, target) != "undefined") {
                  break;
                }
              }
              target = target.parentNode;
            }
          }
        }
      }
    }, {
      key: "mCallEventMethod",
      value: function mCallEventMethod(e4, event2, target) {
        var name = target.getAttribute(this.mAttr);
        if (event2.hasOwnProperty(name)) {
          var method = event2[name];
          if (!e4.hasOwnProperty("currentTarget")) {
            Object.defineProperty(e4, "currentTarget", {
              value: target
            });
          }
          if (!e4.hasOwnProperty("curTarget")) {
            Object.defineProperty(e4, "curTarget", {
              value: target
            });
          }
          this[method](e4);
        }
      }
    }, {
      key: "$",
      value: function $3(query, context3) {
        var classIndex = query.indexOf(".");
        var idIndex = query.indexOf("#");
        var attrIndex = query.indexOf("[");
        var indexes = [classIndex, idIndex, attrIndex].filter(function(index3) {
          return index3 != -1;
        });
        var index2 = false;
        var name = query;
        var more = "";
        var parent2 = this.el;
        if (indexes.length) {
          index2 = Math.min.apply(Math, _toConsumableArray(indexes));
          name = query.slice(0, index2);
          more = query.slice(index2);
        }
        if (_typeof(context3) == "object") {
          parent2 = context3;
        }
        return parent2.querySelectorAll("[" + this.mAttr + "=" + name + "]" + more);
      }
    }, {
      key: "parent",
      value: function parent2(query, context3) {
        var data = "[" + this.mAttr + "=" + query + "]";
        var parent3 = context3.parentNode;
        while (parent3 && parent3 !== document) {
          if (parent3.matches(data)) {
            return parent3;
          }
          parent3 = parent3.parentNode;
        }
      }
    }, {
      key: "getData",
      value: function getData(name, context3) {
        var target = context3 || this.el;
        return target.getAttribute(this.mAttr + "-" + name);
      }
    }, {
      key: "setData",
      value: function setData(name, value, context3) {
        var target = context3 || this.el;
        return target.setAttribute(this.mAttr + "-" + name, value);
      }
    }, {
      key: "call",
      value: function call(func, args, mod, id) {
        var _this3 = this;
        if (args && !mod) {
          mod = args;
          args = false;
        }
        if (this.modules[mod]) {
          if (id) {
            if (this.modules[mod][id]) {
              this.modules[mod][id][func](args);
            }
          } else {
            Object.keys(this.modules[mod]).forEach(function(id2) {
              _this3.modules[mod][id2][func](args);
            });
          }
        }
      }
    }, {
      key: "on",
      value: function on2(e4, mod, func, id) {
        var _this4 = this;
        if (this.modules[mod]) {
          if (id) {
            this.modules[mod][id].el.addEventListener(e4, function(o4) {
              return func(o4);
            });
          } else {
            Object.keys(this.modules[mod]).forEach(function(i4) {
              _this4.modules[mod][i4].el.addEventListener(e4, function(o4) {
                return func(o4);
              });
            });
          }
        }
      }
    }, {
      key: "init",
      value: function init5() {
      }
    }, {
      key: "destroy",
      value: function destroy() {
      }
    }]);
    return _default2;
  }();
  var _default$1 = /* @__PURE__ */ function() {
    function _default2(options) {
      _classCallCheck(this, _default2);
      this.app;
      this.modules = options.modules;
      this.currentModules = {};
      this.activeModules = {};
      this.newModules = {};
      this.moduleId = 0;
    }
    _createClass(_default2, [{
      key: "init",
      value: function init5(app2, scope) {
        var _this = this;
        var container = scope || document;
        var elements = container.querySelectorAll("*");
        if (app2 && !this.app) {
          this.app = app2;
        }
        this.activeModules["app"] = {
          "app": this.app
        };
        elements.forEach(function(el) {
          Array.from(el.attributes).forEach(function(i4) {
            if (i4.name.startsWith("data-module")) {
              var moduleExists = false;
              var dataName = i4.name.split("-").splice(2);
              var moduleName = _this.toCamel(dataName);
              if (_this.modules[moduleName]) {
                moduleExists = true;
              } else if (_this.modules[_this.toUpper(moduleName)]) {
                moduleName = _this.toUpper(moduleName);
                moduleExists = true;
              }
              if (moduleExists) {
                var options = {
                  el,
                  name: moduleName,
                  dataName: dataName.join("-")
                };
                var module = new _this.modules[moduleName](options);
                var id = i4.value;
                if (!id) {
                  _this.moduleId++;
                  id = "m" + _this.moduleId;
                  el.setAttribute(i4.name, id);
                }
                _this.addActiveModule(moduleName, id, module);
                var moduleId = moduleName + "-" + id;
                if (scope) {
                  _this.newModules[moduleId] = module;
                } else {
                  _this.currentModules[moduleId] = module;
                }
              }
            }
          });
        });
        Object.entries(this.currentModules).forEach(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), id = _ref2[0], module = _ref2[1];
          if (scope) {
            var split = id.split("-");
            var moduleName = split.shift();
            var moduleId = split.pop();
            _this.addActiveModule(moduleName, moduleId, module);
          } else {
            _this.initModule(module);
          }
        });
      }
    }, {
      key: "initModule",
      value: function initModule(module) {
        module.mInit(this.activeModules);
        module.init();
      }
    }, {
      key: "addActiveModule",
      value: function addActiveModule(name, id, module) {
        if (this.activeModules[name]) {
          Object.assign(this.activeModules[name], _defineProperty({}, id, module));
        } else {
          this.activeModules[name] = _defineProperty({}, id, module);
        }
      }
    }, {
      key: "update",
      value: function update(scope) {
        var _this2 = this;
        this.init(this.app, scope);
        Object.entries(this.currentModules).forEach(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), id = _ref4[0], module = _ref4[1];
          module.mUpdate(_this2.activeModules);
        });
        Object.entries(this.newModules).forEach(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 2), id = _ref6[0], module = _ref6[1];
          _this2.initModule(module);
        });
        Object.assign(this.currentModules, this.newModules);
      }
    }, {
      key: "destroy",
      value: function destroy(scope) {
        if (scope) {
          this.destroyScope(scope);
        } else {
          this.destroyModules();
        }
      }
    }, {
      key: "destroyScope",
      value: function destroyScope(scope) {
        var _this3 = this;
        var elements = scope.querySelectorAll("*");
        elements.forEach(function(el) {
          Array.from(el.attributes).forEach(function(i4) {
            if (i4.name.startsWith("data-module")) {
              var id = i4.value;
              var dataName = i4.name.split("-").splice(2);
              var moduleName = _this3.toCamel(dataName) + "-" + id;
              var moduleExists = false;
              if (_this3.currentModules[moduleName]) {
                moduleExists = true;
              } else if (_this3.currentModules[_this3.toUpper(moduleName)]) {
                moduleName = _this3.toUpper(moduleName);
                moduleExists = true;
              }
              if (moduleExists) {
                _this3.destroyModule(_this3.currentModules[moduleName]);
                delete _this3.currentModules[moduleName];
              }
            }
          });
        });
        this.activeModules = {};
        this.newModules = {};
      }
    }, {
      key: "destroyModules",
      value: function destroyModules() {
        var _this4 = this;
        Object.entries(this.currentModules).forEach(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), id = _ref8[0], module = _ref8[1];
          _this4.destroyModule(module);
        });
        this.currentModules = [];
      }
    }, {
      key: "destroyModule",
      value: function destroyModule(module) {
        module.mDestroy();
        module.destroy();
      }
    }, {
      key: "toCamel",
      value: function toCamel(arr) {
        var _this5 = this;
        return arr.reduce(function(a3, b2) {
          return a3 + _this5.toUpper(b2);
        });
      }
    }, {
      key: "toUpper",
      value: function toUpper(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
    }]);
    return _default2;
  }();
  var main_esm_default = _default$1;

  // assets/scripts/modules.js
  var modules_exports = {};
  __export(modules_exports, {
    CookieConsent: () => CookieConsent_default,
    CopyToClipboard: () => CopyToClipboard_default,
    FancyGallery: () => FancyGallery_default,
    FancyTexts: () => FancyTexts_default,
    FeaturedLinks: () => FeaturedLinks_default,
    Gallery: () => Gallery_default,
    GridHelper: () => GridHelper,
    Header: () => Header_default,
    HomeHero: () => HomeHero_default,
    Hovers: () => Hovers_default,
    ImagesSequence: () => ImagesSequence_default,
    Lisa: () => Lisa_default,
    Load: () => Load_default,
    LostScene: () => LostScene_default,
    ModelViewer: () => ModelViewer_default,
    NewsletterModal: () => NewsletterModal_default,
    NewsletterToggler: () => NewsletterToggler_default,
    Rail: () => Rail_default,
    Ring: () => Ring_default,
    Scroll: () => Scroll_default,
    TeamCanvas: () => TeamCanvas_default,
    TeamList: () => TeamList_default,
    TeamListCanvas: () => TeamListCanvas_default,
    TeamModal: () => TeamModal_default,
    TeamModalCanvas: () => TeamModalCanvas_default,
    VideoInview: () => VideoInview_default,
    VideoModal: () => VideoModal_default,
    VideoModalToggler: () => VideoModalToggler_default,
    WorkFilters: () => WorkFilters_default,
    WorkGallery: () => WorkGallery_default,
    WorkListItem: () => WorkListItem_default,
    WorkNext: () => WorkNext_default,
    WorkSingleHero: () => WorkSingleHero_default
  });

  // node_modules/vanilla-cookieconsent/dist/cookieconsent.esm.js
  var cookieconsent_esm_exports = {};
  __export(cookieconsent_esm_exports, {
    acceptCategory: () => Ne,
    acceptService: () => Ve,
    acceptedCategory: () => He,
    acceptedService: () => Ie,
    eraseCookies: () => Fe,
    getConfig: () => qe,
    getCookie: () => ze,
    getUserPreferences: () => Je,
    hide: () => Le,
    hidePreferences: () => Re,
    loadScript: () => Ue,
    reset: () => We,
    run: () => Qe,
    setCookieData: () => $e,
    setLanguage: () => Ge,
    show: () => Pe,
    showPreferences: () => Oe,
    validConsent: () => Ke,
    validCookie: () => je
  });
  var e = "opt-in";
  var t = "opt-out";
  var n = "show--consent";
  var o = "show--preferences";
  var s = "disable--interaction";
  var a = "data-category";
  var c = "div";
  var r = "button";
  var i = "aria-hidden";
  var l = "btn-group";
  var d = "click";
  var f = "data-role";
  var _ = "consentModal";
  var u = "preferencesModal";
  var p = class {
    constructor() {
      this.t = { mode: e, revision: 0, autoShow: true, lazyHtmlGeneration: true, autoClearCookies: true, manageScriptTags: true, hideFromBots: true, cookie: { name: "cc_cookie", expiresAfterDays: 182, domain: "", path: "/", sameSite: "Lax" } }, this.o = { i: {}, l: "", _: {}, u: {}, p: {}, m: [], v: false, h: null, C: null, S: null, M: "", D: true, T: false, k: false, A: false, N: false, H: [], V: false, I: true, j: [], F: false, P: "", L: false, O: [], R: [], B: [], G: [], J: false, U: false, $: false, q: [], K: [], W: [], X: {}, Y: {}, Z: {}, ee: {}, te: {}, ne: [] }, this.oe = { se: {}, ae: {} }, this.ce = {}, this.re = { ie: "cc:onFirstConsent", le: "cc:onConsent", de: "cc:onChange", fe: "cc:onModalShow", _e: "cc:onModalHide", ue: "cc:onModalReady" };
    }
  };
  var m = new p();
  var g = (e4, t3) => e4.indexOf(t3);
  var b = (e4, t3) => -1 !== g(e4, t3);
  var v = (e4) => Array.isArray(e4);
  var y = (e4) => "string" == typeof e4;
  var h = (e4) => !!e4 && "object" == typeof e4 && !v(e4);
  var C = (e4) => "function" == typeof e4;
  var w = (e4) => Object.keys(e4);
  var S = (e4) => Array.from(new Set(e4));
  var x = () => document.activeElement;
  var M = (e4) => e4.preventDefault();
  var D = (e4, t3) => e4.querySelectorAll(t3);
  var T = (e4) => e4.dispatchEvent(new Event("change"));
  var k = (e4) => {
    const t3 = document.createElement(e4);
    return e4 === r && (t3.type = e4), t3;
  };
  var A = (e4, t3, n4) => e4.setAttribute(t3, n4);
  var E = (e4, t3, n4) => {
    e4.removeAttribute(n4 ? "data-" + t3 : t3);
  };
  var N = (e4, t3, n4) => e4.getAttribute(n4 ? "data-" + t3 : t3);
  var H = (e4, t3) => e4.appendChild(t3);
  var V = (e4, t3) => e4.classList.add(t3);
  var I = (e4, t3) => V(e4, "cm__" + t3);
  var j = (e4, t3) => V(e4, "pm__" + t3);
  var F = (e4, t3) => e4.classList.remove(t3);
  var P = (e4) => {
    if ("object" != typeof e4) return e4;
    if (e4 instanceof Date) return new Date(e4.getTime());
    let t3 = Array.isArray(e4) ? [] : {};
    for (let n4 in e4) {
      let o4 = e4[n4];
      t3[n4] = P(o4);
    }
    return t3;
  };
  var L = () => {
    const e4 = {}, { O: t3, X: n4, Y: o4 } = m.o;
    for (const s4 of t3) e4[s4] = G(o4[s4], w(n4[s4]));
    return e4;
  };
  var O = (e4, t3) => dispatchEvent(new CustomEvent(e4, { detail: t3 }));
  var R = (e4, t3, n4, o4) => {
    e4.addEventListener(t3, n4), o4 && m.o.m.push({ pe: e4, me: t3, ge: n4 });
  };
  var B = () => {
    const e4 = m.t.cookie.expiresAfterDays;
    return C(e4) ? e4(m.o.P) : e4;
  };
  var G = (e4, t3) => {
    const n4 = e4 || [], o4 = t3 || [];
    return n4.filter((e5) => !b(o4, e5)).concat(o4.filter((e5) => !b(n4, e5)));
  };
  var J = (e4) => {
    m.o.R = S(e4), m.o.P = (() => {
      let e5 = "custom";
      const { R: t3, O: n4, B: o4 } = m.o, s4 = t3.length;
      return s4 === n4.length ? e5 = "all" : s4 === o4.length && (e5 = "necessary"), e5;
    })();
  };
  var U = (e4, t3, n4, o4) => {
    const s4 = "accept-", { show: a3, showPreferences: c3, hide: r3, hidePreferences: i4, acceptCategory: l4 } = t3, f2 = e4 || document, _2 = (e5) => D(f2, `[data-cc="${e5}"]`), u2 = (e5, t4) => {
      M(e5), l4(t4), i4(), r3();
    }, p2 = _2("show-preferencesModal"), g2 = _2("show-consentModal"), b2 = _2(s4 + "all"), v2 = _2(s4 + "necessary"), y2 = _2(s4 + "custom"), h4 = m.t.lazyHtmlGeneration;
    for (const e5 of p2) A(e5, "aria-haspopup", "dialog"), R(e5, d, (e6) => {
      M(e6), c3();
    }), h4 && (R(e5, "mouseenter", (e6) => {
      M(e6), m.o.N || n4(t3, o4);
    }, true), R(e5, "focus", () => {
      m.o.N || n4(t3, o4);
    }));
    for (let e5 of g2) A(e5, "aria-haspopup", "dialog"), R(e5, d, (e6) => {
      M(e6), a3(true);
    }, true);
    for (let e5 of b2) R(e5, d, (e6) => {
      u2(e6, "all");
    }, true);
    for (let e5 of y2) R(e5, d, (e6) => {
      u2(e6);
    }, true);
    for (let e5 of v2) R(e5, d, (e6) => {
      u2(e6, []);
    }, true);
  };
  var $ = (e4, t3) => {
    e4 && (t3 && (e4.tabIndex = -1), e4.focus(), t3 && e4.removeAttribute("tabindex"));
  };
  var z = (e4, t3) => {
    const n4 = (o4) => {
      o4.target.removeEventListener("transitionend", n4), "opacity" === o4.propertyName && "1" === getComputedStyle(e4).opacity && $(((e5) => 1 === e5 ? m.oe.be : m.oe.ve)(t3));
    };
    R(e4, "transitionend", n4);
  };
  var q;
  var K = (e4) => {
    clearTimeout(q), e4 ? V(m.oe.ye, s) : q = setTimeout(() => {
      F(m.oe.ye, s);
    }, 500);
  };
  var Q = ["M 19.5 4.5 L 4.5 19.5 M 4.5 4.501 L 19.5 19.5", "M 3.572 13.406 L 8.281 18.115 L 20.428 5.885", "M 21.999 6.94 L 11.639 17.18 L 2.001 6.82 "];
  var W = (e4 = 0, t3 = 1.5) => `<svg viewBox="0 0 24 24" stroke-width="${t3}"><path d="${Q[e4]}"/></svg>`;
  var X = (e4) => {
    const t3 = m.oe, n4 = m.o;
    ((e5) => {
      const o4 = e5 === t3.he, s4 = n4.i.disablePageInteraction ? t3.ye : o4 ? t3.Ce : t3.ye;
      R(s4, "keydown", (t4) => {
        if ("Tab" !== t4.key || !(o4 ? n4.k && !n4.A : n4.A)) return;
        const s5 = x(), a3 = o4 ? n4.q : n4.K;
        0 !== a3.length && (t4.shiftKey ? s5 !== a3[0] && e5.contains(s5) || (M(t4), $(a3[1])) : s5 !== a3[1] && e5.contains(s5) || (M(t4), $(a3[0])));
      }, true);
    })(e4);
  };
  var Y = ["[href]", r, "input", "details", "[tabindex]"].map((e4) => e4 + ':not([tabindex="-1"])').join(",");
  var Z = (e4) => {
    const { o: t3, oe: n4 } = m, o4 = (e5, t4) => {
      const n5 = D(e5, Y);
      t4[0] = n5[0], t4[1] = n5[n5.length - 1];
    };
    1 === e4 && t3.T && o4(n4.he, t3.q), 2 === e4 && t3.N && o4(n4.we, t3.K);
  };
  var ee = (e4, t3, n4) => {
    const { de: o4, le: s4, ie: a3, _e: c3, ue: r3, fe: i4 } = m.ce, l4 = m.re;
    if (t3) {
      const o5 = { modalName: t3 };
      return e4 === l4.fe ? C(i4) && i4(o5) : e4 === l4._e ? C(c3) && c3(o5) : (o5.modal = n4, C(r3) && r3(o5)), O(e4, o5);
    }
    const d2 = { cookie: m.o.p };
    e4 === l4.ie ? C(a3) && a3(P(d2)) : e4 === l4.le ? C(s4) && s4(P(d2)) : (d2.changedCategories = m.o.j, d2.changedServices = m.o.ee, C(o4) && o4(P(d2))), O(e4, P(d2));
  };
  var te = (e4) => {
    const { Y: t3, ee: n4, O: o4, X: s4, ne: c3, p: r3, j: i4 } = m.o;
    for (const e5 of o4) {
      const o5 = n4[e5] || t3[e5] || [];
      for (const n5 of o5) {
        const o6 = s4[e5][n5];
        if (!o6) continue;
        const { onAccept: a3, onReject: c4 } = o6;
        !o6.Se && b(t3[e5], n5) && C(a3) ? (o6.Se = true, a3()) : o6.Se && !b(t3[e5], n5) && C(c4) && (o6.Se = false, c4());
      }
    }
    if (!m.t.manageScriptTags) return;
    const l4 = c3, d2 = e4 || r3.categories || [], f2 = (e5, o5) => {
      if (o5 >= e5.length) return;
      const s5 = c3[o5];
      if (s5.xe) return f2(e5, o5 + 1);
      const r4 = s5.Me, l5 = s5.De, _2 = s5.Te, u2 = b(d2, l5), p2 = !!_2 && b(t3[l5], _2);
      if (!_2 && !s5.ke && u2 || !_2 && s5.ke && !u2 && b(i4, l5) || _2 && !s5.ke && p2 || _2 && s5.ke && !p2 && b(n4[l5] || [], _2)) {
        s5.xe = true;
        const t4 = N(r4, "type", true);
        E(r4, "type", !!t4), E(r4, a);
        let n5 = N(r4, "src", true);
        n5 && E(r4, "src", true);
        const c4 = k("script");
        c4.textContent = r4.innerHTML;
        for (const { nodeName: e6 } of r4.attributes) A(c4, e6, r4[e6] || N(r4, e6));
        t4 && (c4.type = t4), n5 ? c4.src = n5 : n5 = r4.src;
        const i5 = !!n5 && (!t4 || ["text/javascript", "module"].includes(t4));
        if (i5 && (c4.onload = c4.onerror = () => {
          f2(e5, ++o5);
        }), r4.replaceWith(c4), i5) return;
      }
      f2(e5, ++o5);
    };
    f2(l4, 0);
  };
  var ne = "bottom";
  var oe = "left";
  var se = "center";
  var ae = "right";
  var ce = "inline";
  var re = "wide";
  var ie = "pm--";
  var le = ["middle", "top", ne];
  var de = [oe, se, ae];
  var fe = { box: { Ae: [re, ce], Ee: le, Ne: de, He: ne, Ve: ae }, cloud: { Ae: [ce], Ee: le, Ne: de, He: ne, Ve: se }, bar: { Ae: [ce], Ee: le.slice(1), Ne: [], He: ne, Ve: "" } };
  var _e = { box: { Ae: [], Ee: [], Ne: [], He: "", Ve: "" }, bar: { Ae: [re], Ee: [], Ne: [oe, ae], He: "", Ve: oe } };
  var ue = (e4) => {
    const t3 = m.o.i.guiOptions, n4 = t3 && t3.consentModal, o4 = t3 && t3.preferencesModal;
    0 === e4 && pe(m.oe.he, fe, n4, "cm--", "box", "cm"), 1 === e4 && pe(m.oe.we, _e, o4, ie, "box", "pm");
  };
  var pe = (e4, t3, n4, o4, s4, a3) => {
    e4.className = a3;
    const c3 = n4 && n4.layout, r3 = n4 && n4.position, i4 = n4 && n4.flipButtons, l4 = !n4 || false !== n4.equalWeightButtons, d2 = c3 && c3.split(" ") || [], f2 = d2[0], _2 = d2[1], u2 = f2 in t3 ? f2 : s4, p2 = t3[u2], g2 = b(p2.Ae, _2) && _2, v2 = r3 && r3.split(" ") || [], y2 = v2[0], h4 = o4 === ie ? v2[0] : v2[1], C2 = b(p2.Ee, y2) ? y2 : p2.He, w2 = b(p2.Ne, h4) ? h4 : p2.Ve, S2 = (t4) => {
      t4 && V(e4, o4 + t4);
    };
    S2(u2), S2(g2), S2(C2), S2(w2), i4 && S2("flip");
    const x2 = a3 + "__btn--secondary";
    if ("cm" === a3) {
      const { Ie: e5, je: t4 } = m.oe;
      e5 && (l4 ? F(e5, x2) : V(e5, x2)), t4 && (l4 ? F(t4, x2) : V(t4, x2));
    } else {
      const { Fe: e5 } = m.oe;
      e5 && (l4 ? F(e5, x2) : V(e5, x2));
    }
  };
  var me = (e4, t3) => {
    const n4 = m.o, o4 = m.oe, { hide: s4, hidePreferences: a3, acceptCategory: _2 } = e4, p2 = (e5) => {
      _2(e5), a3(), s4();
    }, g2 = n4.u && n4.u.preferencesModal;
    if (!g2) return;
    const b2 = g2.title, v2 = g2.closeIconLabel, C2 = g2.acceptAllBtn, S2 = g2.acceptNecessaryBtn, x2 = g2.savePreferencesBtn, M2 = g2.sections || [], D2 = C2 || S2 || x2;
    if (o4.Pe) o4.Le = k(c), j(o4.Le, "body");
    else {
      o4.Pe = k(c), V(o4.Pe, "pm-wrapper");
      const e5 = k("div");
      V(e5, "pm-overlay"), H(o4.Pe, e5), R(e5, d, a3), o4.we = k(c), V(o4.we, "pm"), A(o4.we, "role", "dialog"), A(o4.we, i, true), A(o4.we, "aria-modal", true), A(o4.we, "aria-labelledby", "pm__title"), R(o4.ye, "keydown", (e6) => {
        27 === e6.keyCode && a3();
      }, true), o4.Oe = k(c), j(o4.Oe, "header"), o4.Re = k("h2"), j(o4.Re, "title"), o4.Re.id = "pm__title", o4.Be = k(r), j(o4.Be, "close-btn"), A(o4.Be, "aria-label", g2.closeIconLabel || ""), R(o4.Be, d, a3), o4.Ge = k("span"), o4.Ge.innerHTML = W(), H(o4.Be, o4.Ge), o4.Je = k(c), j(o4.Je, "body"), o4.Ue = k(c), j(o4.Ue, "footer");
      var T2 = k(c);
      V(T2, "btns");
      var E2 = k(c), N2 = k(c);
      j(E2, l), j(N2, l), H(o4.Ue, E2), H(o4.Ue, N2), H(o4.Oe, o4.Re), H(o4.Oe, o4.Be), o4.ve = k(c), A(o4.ve, "tabIndex", -1), H(o4.we, o4.ve), H(o4.we, o4.Oe), H(o4.we, o4.Je), D2 && H(o4.we, o4.Ue), H(o4.Pe, o4.we);
    }
    let I2;
    b2 && (o4.Re.innerHTML = b2, v2 && A(o4.Be, "aria-label", v2)), M2.forEach((e5, t4) => {
      const s5 = e5.title, a4 = e5.description, l4 = e5.linkedCategory, f2 = l4 && n4.L[l4], _3 = e5.cookieTable, u2 = _3 && _3.body, p3 = _3 && _3.caption, m2 = u2 && u2.length > 0, b3 = !!f2, v3 = b3 && n4.X[l4], C3 = h(v3) && w(v3) || [], S3 = b3 && (!!a4 || !!m2 || w(v3).length > 0);
      var x3 = k(c);
      if (j(x3, "section"), S3 || a4) {
        var M3 = k(c);
        j(M3, "section-desc-wrapper");
      }
      let D3 = C3.length;
      if (S3 && D3 > 0) {
        const e6 = k(c);
        j(e6, "section-services");
        for (const t5 of C3) {
          const n5 = v3[t5], o5 = n5 && n5.label || t5, s6 = k(c), a5 = k(c), r3 = k(c), i4 = k(c);
          j(s6, "service"), j(i4, "service-title"), j(a5, "service-header"), j(r3, "service-icon");
          const d2 = ge(o5, t5, f2, true, l4);
          i4.innerHTML = o5, H(a5, r3), H(a5, i4), H(s6, a5), H(s6, d2), H(e6, s6);
        }
        H(M3, e6);
      }
      if (s5) {
        var T3 = k(c), E3 = k(b3 ? r : c);
        if (j(T3, "section-title-wrapper"), j(E3, "section-title"), E3.innerHTML = s5, H(T3, E3), b3) {
          const e6 = k("span");
          e6.innerHTML = W(2, 3.5), j(e6, "section-arrow"), H(T3, e6), x3.className += "--toggle";
          const t5 = ge(s5, l4, f2);
          let n5 = g2.serviceCounterLabel;
          if (D3 > 0 && y(n5)) {
            let e7 = k("span");
            j(e7, "badge"), j(e7, "service-counter"), A(e7, i, true), A(e7, "data-servicecounter", D3), n5 && (n5 = n5.split("|"), n5 = n5.length > 1 && D3 > 1 ? n5[1] : n5[0], A(e7, "data-counterlabel", n5)), e7.innerHTML = D3 + (n5 ? " " + n5 : ""), H(E3, e7);
          }
          if (S3) {
            j(x3, "section--expandable");
            var N3 = l4 + "-desc";
            A(E3, "aria-expanded", false), A(E3, "aria-controls", N3);
          }
          H(T3, t5);
        } else A(E3, "role", "heading"), A(E3, "aria-level", "3");
        H(x3, T3);
      }
      if (a4) {
        var P2 = k("p");
        j(P2, "section-desc"), P2.innerHTML = a4, H(M3, P2);
      }
      if (S3 && (A(M3, i, "true"), M3.id = N3, ((e6, t5, n5) => {
        R(E3, d, () => {
          t5.classList.contains("is-expanded") ? (F(t5, "is-expanded"), A(n5, "aria-expanded", "false"), A(e6, i, "true")) : (V(t5, "is-expanded"), A(n5, "aria-expanded", "true"), A(e6, i, "false"));
        });
      })(M3, x3, E3), m2)) {
        const e6 = k("table"), n5 = k("thead"), s6 = k("tbody");
        if (p3) {
          const t5 = k("caption");
          j(t5, "table-caption"), t5.innerHTML = p3, e6.appendChild(t5);
        }
        j(e6, "section-table"), j(n5, "table-head"), j(s6, "table-body");
        const a5 = _3.headers, r3 = w(a5), i4 = o4.$e.createDocumentFragment(), l5 = k("tr");
        for (const e7 of r3) {
          const n6 = a5[e7], o5 = k("th");
          o5.id = "cc__row-" + n6 + t4, A(o5, "scope", "col"), j(o5, "table-th"), o5.innerHTML = n6, H(i4, o5);
        }
        H(l5, i4), H(n5, l5);
        const d2 = o4.$e.createDocumentFragment();
        for (const e7 of u2) {
          const n6 = k("tr");
          j(n6, "table-tr");
          for (const o5 of r3) {
            const s7 = a5[o5], r4 = e7[o5], i5 = k("td"), l6 = k(c);
            j(i5, "table-td"), A(i5, "data-column", s7), A(i5, "headers", "cc__row-" + s7 + t4), l6.insertAdjacentHTML("beforeend", r4), H(i5, l6), H(n6, i5);
          }
          H(d2, n6);
        }
        H(s6, d2), H(e6, n5), H(e6, s6), H(M3, e6);
      }
      (S3 || a4) && H(x3, M3);
      const L2 = o4.Le || o4.Je;
      b3 ? (I2 || (I2 = k(c), j(I2, "section-toggles")), I2.appendChild(x3)) : I2 = null, H(L2, I2 || x3);
    }), C2 && (o4.ze || (o4.ze = k(r), j(o4.ze, "btn"), A(o4.ze, f, "all"), H(E2, o4.ze), R(o4.ze, d, () => p2("all"))), o4.ze.innerHTML = C2), S2 && (o4.Fe || (o4.Fe = k(r), j(o4.Fe, "btn"), A(o4.Fe, f, "necessary"), H(E2, o4.Fe), R(o4.Fe, d, () => p2([]))), o4.Fe.innerHTML = S2), x2 && (o4.qe || (o4.qe = k(r), j(o4.qe, "btn"), j(o4.qe, "btn--secondary"), A(o4.qe, f, "save"), H(N2, o4.qe), R(o4.qe, d, () => p2())), o4.qe.innerHTML = x2), o4.Le && (o4.we.replaceChild(o4.Le, o4.Je), o4.Je = o4.Le), ue(1), n4.N || (n4.N = true, ee(m.re.ue, u, o4.we), t3(e4), H(o4.Ce, o4.Pe), X(o4.we), setTimeout(() => V(o4.Pe, "cc--anim"), 100)), Z(2);
  };
  function ge(e4, t3, n4, o4, s4) {
    const c3 = m.o, r3 = m.oe, l4 = k("label"), f2 = k("input"), _2 = k("span"), u2 = k("span"), p2 = k("span"), g2 = k("span"), v2 = k("span");
    if (g2.innerHTML = W(1, 3), v2.innerHTML = W(0, 3), f2.type = "checkbox", V(l4, "section__toggle-wrapper"), V(f2, "section__toggle"), V(g2, "toggle__icon-on"), V(v2, "toggle__icon-off"), V(_2, "toggle__icon"), V(u2, "toggle__icon-circle"), V(p2, "toggle__label"), A(_2, i, "true"), o4 ? (V(l4, "toggle-service"), A(f2, a, s4), r3.ae[s4][t3] = f2) : r3.se[t3] = f2, o4 ? ((e5) => {
      R(f2, "change", () => {
        const t4 = r3.ae[e5], n5 = r3.se[e5];
        c3.Z[e5] = [];
        for (let n6 in t4) {
          const o5 = t4[n6];
          o5.checked && c3.Z[e5].push(o5.value);
        }
        n5.checked = c3.Z[e5].length > 0;
      });
    })(s4) : ((e5) => {
      R(f2, d, () => {
        const t4 = r3.ae[e5], n5 = f2.checked;
        c3.Z[e5] = [];
        for (let o5 in t4) t4[o5].checked = n5, n5 && c3.Z[e5].push(o5);
      });
    })(t3), f2.value = t3, p2.textContent = e4.replace(/<.*>.*<\/.*>/gm, ""), H(u2, v2), H(u2, g2), H(_2, u2), c3.D) (n4.readOnly || n4.enabled) && (f2.checked = true);
    else if (o4) {
      const e5 = c3.Y[s4];
      f2.checked = n4.readOnly || b(e5, t3);
    } else b(c3.R, t3) && (f2.checked = true);
    return n4.readOnly && (f2.disabled = true), H(l4, f2), H(l4, _2), H(l4, p2), l4;
  }
  var be = () => {
    const e4 = k("span");
    return m.oe.Ke || (m.oe.Ke = e4), e4;
  };
  var ve = (e4, t3) => {
    const n4 = m.o, o4 = m.oe, { hide: s4, showPreferences: a3, acceptCategory: u2 } = e4, p2 = n4.u && n4.u.consentModal;
    if (!p2) return;
    const g2 = p2.acceptAllBtn, b2 = p2.acceptNecessaryBtn, v2 = p2.showPreferencesBtn, y2 = p2.closeIconLabel, h4 = p2.footer, C2 = p2.label, w2 = p2.title, S2 = (e5) => {
      s4(), u2(e5);
    };
    if (!o4.Qe) {
      o4.Qe = k(c), o4.he = k(c), o4.We = k(c), o4.Xe = k(c), o4.Ye = k(c), V(o4.Qe, "cm-wrapper"), V(o4.he, "cm"), I(o4.We, "body"), I(o4.Xe, "texts"), I(o4.Ye, "btns"), A(o4.he, "role", "dialog"), A(o4.he, "aria-modal", "true"), A(o4.he, i, "false"), A(o4.he, "aria-describedby", "cm__desc"), C2 ? A(o4.he, "aria-label", C2) : w2 && A(o4.he, "aria-labelledby", "cm__title");
      const e5 = "box", t4 = n4.i.guiOptions, s5 = t4 && t4.consentModal, a4 = (s5 && s5.layout || e5).split(" ")[0] === e5;
      w2 && y2 && a4 && (o4.je || (o4.je = k(r), o4.je.innerHTML = W(), I(o4.je, "btn"), I(o4.je, "btn--close"), R(o4.je, d, () => {
        S2([]);
      }), H(o4.We, o4.je)), A(o4.je, "aria-label", y2)), H(o4.We, o4.Xe), (g2 || b2 || v2) && H(o4.We, o4.Ye), o4.be = k(c), A(o4.be, "tabIndex", -1), H(o4.he, o4.be), H(o4.he, o4.We), H(o4.Qe, o4.he);
    }
    w2 && (o4.Ze || (o4.Ze = k("h2"), o4.Ze.className = o4.Ze.id = "cm__title", H(o4.Xe, o4.Ze)), o4.Ze.innerHTML = w2);
    let x2 = p2.description;
    if (x2 && (n4.V && (x2 = x2.replace("{{revisionMessage}}", n4.I ? "" : p2.revisionMessage || "")), o4.et || (o4.et = k("p"), o4.et.className = o4.et.id = "cm__desc", H(o4.Xe, o4.et)), o4.et.innerHTML = x2), g2 && (o4.tt || (o4.tt = k(r), H(o4.tt, be()), I(o4.tt, "btn"), A(o4.tt, f, "all"), R(o4.tt, d, () => {
      S2("all");
    })), o4.tt.firstElementChild.innerHTML = g2), b2 && (o4.Ie || (o4.Ie = k(r), H(o4.Ie, be()), I(o4.Ie, "btn"), A(o4.Ie, f, "necessary"), R(o4.Ie, d, () => {
      S2([]);
    })), o4.Ie.firstElementChild.innerHTML = b2), v2 && (o4.nt || (o4.nt = k(r), H(o4.nt, be()), I(o4.nt, "btn"), I(o4.nt, "btn--secondary"), A(o4.nt, f, "show"), R(o4.nt, "mouseenter", () => {
      n4.N || me(e4, t3);
    }), R(o4.nt, d, a3)), o4.nt.firstElementChild.innerHTML = v2), o4.ot || (o4.ot = k(c), I(o4.ot, l), g2 && H(o4.ot, o4.tt), b2 && H(o4.ot, o4.Ie), (g2 || b2) && H(o4.We, o4.ot), H(o4.Ye, o4.ot)), o4.nt && !o4.st && (o4.st = k(c), o4.Ie && o4.tt ? (I(o4.st, l), H(o4.st, o4.nt), H(o4.Ye, o4.st)) : (H(o4.ot, o4.nt), I(o4.ot, l + "--uneven"))), h4) {
      if (!o4.ct) {
        let e5 = k(c), t4 = k(c);
        o4.ct = k(c), I(e5, "footer"), I(t4, "links"), I(o4.ct, "link-group"), H(t4, o4.ct), H(e5, t4), H(o4.he, e5);
      }
      o4.ct.innerHTML = h4;
    }
    ue(0), n4.T || (n4.T = true, ee(m.re.ue, _, o4.he), t3(e4), H(o4.Ce, o4.Qe), X(o4.he), setTimeout(() => V(o4.Qe, "cc--anim"), 100)), Z(1), U(o4.We, e4, me, t3);
  };
  var ye = (e4) => {
    if (!y(e4)) return null;
    if (e4 in m.o._) return e4;
    let t3 = e4.slice(0, 2);
    return t3 in m.o._ ? t3 : null;
  };
  var he = () => m.o.l || m.o.i.language.default;
  var Ce = (e4) => {
    e4 && (m.o.l = e4);
  };
  var we = (e4) => __async(void 0, null, function* () {
    const t3 = m.o;
    let n4 = ye(e4) ? e4 : he(), o4 = t3._[n4];
    if (!o4) return false;
    if (y(o4)) {
      const e5 = yield ((e6) => __async(void 0, null, function* () {
        try {
          const t4 = yield fetch(e6);
          return !(!t4 || !t4.ok) && (yield t4.json());
        } catch (e7) {
          return false;
        }
      }))(o4);
      if (!e5) return false;
      o4 = e5;
    }
    return t3.u = o4, Ce(n4), true;
  });
  var Se = () => {
    let e4 = m.o.i.language.rtl, t3 = m.oe.Ce;
    e4 && t3 && (v(e4) || (e4 = [e4]), b(e4, m.o.l) ? V(t3, "cc--rtl") : F(t3, "cc--rtl"));
  };
  var xe = () => {
    const e4 = m.oe;
    if (e4.Ce) return;
    e4.Ce = k(c), e4.Ce.id = "cc-main", Se();
    let t3 = m.o.i.root;
    t3 && y(t3) && (t3 = document.querySelector(t3)), (t3 || e4.$e.body).appendChild(e4.Ce);
  };
  var Me = (e4, t3) => {
    if (t3 instanceof RegExp) return e4.filter((e5) => t3.test(e5));
    {
      const n4 = g(e4, t3);
      return n4 > -1 ? [e4[n4]] : [];
    }
  };
  var De = (e4) => {
    const { hostname: t3, protocol: n4 } = location, { name: o4, path: s4, domain: a3, sameSite: c3 } = m.t.cookie, r3 = encodeURIComponent(JSON.stringify(m.o.p)), i4 = e4 ? (() => {
      const e5 = m.o.S, t4 = e5 ? /* @__PURE__ */ new Date() - e5 : 0;
      return 864e5 * B() - t4;
    })() : 864e5 * B(), l4 = /* @__PURE__ */ new Date();
    l4.setTime(l4.getTime() + i4);
    let d2 = o4 + "=" + r3 + (0 !== i4 ? "; expires=" + l4.toUTCString() : "") + "; Path=" + s4 + "; SameSite=" + c3;
    b(t3, ".") && (d2 += "; Domain=" + a3), "https:" === n4 && (d2 += "; Secure"), document.cookie = d2, m.o.p;
  };
  var Te = (e4, t3, n4) => {
    if (0 === e4.length) return;
    const o4 = n4 || m.t.cookie.domain, s4 = t3 || m.t.cookie.path, a3 = "www." === o4.slice(0, 4), c3 = a3 && o4.substring(4), r3 = (e5, t4) => {
      document.cookie = e5 + "=; path=" + s4 + (t4 ? "; domain=." + t4 : "") + "; expires=Thu, 01 Jan 1970 00:00:01 GMT;";
    };
    for (const t4 of e4) r3(t4), r3(t4, o4), a3 && r3(t4, c3);
  };
  var ke = (e4) => ((e5) => {
    let t3;
    try {
      t3 = JSON.parse(decodeURIComponent(e5));
    } catch (e6) {
      t3 = {};
    }
    return t3;
  })(Ae(e4 || m.t.cookie.name, true));
  var Ae = (e4, t3) => {
    const n4 = document.cookie.match("(^|;)\\s*" + e4 + "\\s*=\\s*([^;]+)");
    return n4 ? t3 ? n4.pop() : e4 : "";
  };
  var Ee = (e4) => {
    const t3 = document.cookie.split(/;\s*/), n4 = [];
    for (const o4 of t3) {
      let t4 = o4.split("=")[0];
      if (e4) try {
        e4.test(t4) && n4.push(t4);
      } catch (e5) {
      }
      else n4.push(t4);
    }
    return n4;
  };
  var Ne = (n4, o4 = []) => {
    ((e4, t3) => {
      const { O: n5, R: o5, B: s4, N: a3, Z: c3, X: r3 } = m.o;
      let i4 = [];
      if (e4) {
        v(e4) ? i4.push(...e4) : y(e4) && (i4 = "all" === e4 ? n5 : [e4]);
        for (const e5 of n5) c3[e5] = b(i4, e5) ? w(r3[e5]) : [];
      } else i4 = o5, i4 = a3 && (() => {
        const e5 = m.oe.se;
        if (!e5) return [];
        let t4 = [];
        for (let n6 in e5) e5[n6].checked && t4.push(n6);
        return t4;
      })();
      i4 = i4.filter((e5) => !b(n5, e5) || !b(t3, e5)), i4.push(...s4), J(i4);
    })(n4, o4), ((e4) => {
      const t3 = m.o, { Z: n5, B: o5, Y: s4, X: a3, O: c3 } = t3, r3 = c3;
      t3.te = P(s4);
      for (const e5 of r3) {
        const t4 = a3[e5], c4 = w(t4), r4 = n5[e5] && n5[e5].length > 0, i4 = b(o5, e5);
        if (0 !== c4.length) {
          if (s4[e5] = [], i4) s4[e5].push(...c4);
          else if (r4) {
            const t5 = n5[e5];
            s4[e5].push(...t5);
          } else s4[e5] = [];
          s4[e5] = S(s4[e5]);
        }
      }
    })(), (() => {
      const n5 = m.o;
      n5.j = m.t.mode === t && n5.D ? G(n5.G, n5.R) : G(n5.R, n5.p.categories);
      let o5 = n5.j.length > 0, s4 = false;
      for (const e4 of n5.O) n5.ee[e4] = G(n5.Y[e4], n5.te[e4]), n5.ee[e4].length > 0 && (s4 = true);
      const a3 = m.oe.se;
      for (const e4 in a3) a3[e4].checked = b(n5.R, e4);
      for (const e4 of n5.O) {
        const t3 = m.oe.ae[e4], o6 = n5.Y[e4];
        for (const e5 in t3) t3[e5].checked = b(o6, e5);
      }
      n5.C || (n5.C = /* @__PURE__ */ new Date()), n5.M || (n5.M = ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (e4) => (e4 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> e4 / 4).toString(16))), n5.p = { categories: P(n5.R), revision: m.t.revision, data: n5.h, consentTimestamp: n5.C.toISOString(), consentId: n5.M, services: P(n5.Y) };
      let c3 = false;
      const r3 = o5 || s4;
      (n5.D || r3) && (n5.D && (n5.D = false, c3 = true), n5.S = n5.S ? /* @__PURE__ */ new Date() : n5.C, n5.p.lastConsentTimestamp = n5.S.toISOString(), De(), m.t.autoClearCookies && (c3 || r3) && ((e4) => {
        const t3 = m.o, n6 = Ee(), o6 = ((e5) => {
          const t4 = m.o;
          return (e5 ? t4.O : t4.j).filter((e6) => {
            const n7 = t4.L[e6];
            return !!n7 && !n7.readOnly && !!n7.autoClear;
          });
        })(e4);
        for (const e5 in t3.ee) for (const o7 of t3.ee[e5]) {
          const s5 = t3.X[e5][o7].cookies;
          if (!b(t3.Y[e5], o7) && s5) for (const e6 of s5) {
            const t4 = Me(n6, e6.name);
            Te(t4, e6.path, e6.domain);
          }
        }
        for (const s5 of o6) {
          const o7 = t3.L[s5].autoClear, a4 = o7 && o7.cookies || [], c4 = b(t3.j, s5), r4 = !b(t3.R, s5), i4 = c4 && r4;
          if (e4 ? r4 : i4) {
            o7.reloadPage && i4 && (t3.F = true);
            for (const e5 of a4) {
              const t4 = Me(n6, e5.name);
              Te(t4, e5.path, e5.domain);
            }
          }
        }
      })(c3), te()), c3 && (ee(m.re.ie), ee(m.re.le), m.t.mode === e) || (r3 && ee(m.re.de), n5.F && (n5.F = false, location.reload()));
    })();
  };
  var He = (e4) => {
    const t3 = m.o.D ? [] : m.o.R;
    return b(t3, e4);
  };
  var Ve = (e4, t3) => {
    const { O: n4, X: o4 } = m.o;
    if (!(e4 && t3 && y(t3) && b(n4, t3) && 0 !== w(o4[t3]).length)) return false;
    ((e5, t4) => {
      const n5 = m.o, { X: o5, Z: s4, N: a3 } = n5, c3 = m.oe.ae[t4] || {}, r3 = m.oe.se[t4] || {}, i4 = w(o5[t4]);
      if (s4[t4] = [], y(e5)) {
        if ("all" === e5) {
          if (s4[t4].push(...i4), a3) for (let e6 in c3) c3[e6].checked = true, T(c3[e6]);
        } else if (b(i4, e5) && s4[t4].push(e5), a3) for (let t5 in c3) c3[t5].checked = e5 === t5, T(c3[t5]);
      } else if (v(e5)) for (let n6 of i4) {
        const o6 = b(e5, n6);
        o6 && s4[t4].push(n6), a3 && (c3[n6].checked = o6, T(c3[n6]));
      }
      const l4 = 0 === s4[t4].length;
      n5.R = l4 ? n5.R.filter((e6) => e6 !== t4) : S([...n5.R, t4]), a3 && (r3.checked = !l4, T(r3));
    })(e4, t3), Ne();
  };
  var Ie = (e4, t3) => {
    const n4 = m.o.D ? [] : m.o.Y[t3];
    return b(n4, e4);
  };
  var je = (e4) => "" !== Ae(e4, true);
  var Fe = (e4, t3, n4) => {
    let o4 = [];
    const s4 = (e5) => {
      if (y(e5)) {
        let t4 = Ae(e5);
        "" !== t4 && o4.push(t4);
      } else o4.push(...Ee(e5));
    };
    if (v(e4)) for (let t4 of e4) s4(t4);
    else s4(e4);
    Te(o4, t3, n4);
  };
  var Pe = (e4) => {
    const { oe: t3, o: o4 } = m;
    if (!o4.k) {
      if (!o4.T) {
        if (!e4) return;
        ve(Be, xe);
      }
      o4.k = true, o4.U = x(), o4.v && K(true), z(t3.he, 1), V(t3.ye, n), A(t3.he, i, "false"), setTimeout(() => {
        $(m.oe.be);
      }, 100), ee(m.re.fe, _);
    }
  };
  var Le = () => {
    const { oe: e4, o: t3, re: o4 } = m;
    t3.k && (t3.k = false, t3.v && K(), $(e4.Ke, true), F(e4.ye, n), A(e4.he, i, "true"), $(t3.U), t3.U = null, ee(o4._e, _));
  };
  var Oe = () => {
    const e4 = m.o;
    e4.A || (e4.N || me(Be, xe), e4.A = true, e4.k ? e4.$ = x() : e4.U = x(), z(m.oe.we, 2), V(m.oe.ye, o), A(m.oe.we, i, "false"), setTimeout(() => {
      $(m.oe.ve);
    }, 100), ee(m.re.fe, u));
  };
  var Re = () => {
    const e4 = m.o;
    e4.A && (e4.A = false, (() => {
      const e5 = Ke(), t3 = m.o.L, n4 = m.oe.se, o4 = m.oe.ae, s4 = (e6) => b(m.o.G, e6);
      for (const a3 in n4) {
        const c3 = !!t3[a3].readOnly;
        n4[a3].checked = c3 || (e5 ? He(a3) : s4(a3));
        for (const t4 in o4[a3]) o4[a3][t4].checked = c3 || (e5 ? Ie(t4, a3) : s4(a3));
      }
    })(), $(m.oe.Ge, true), F(m.oe.ye, o), A(m.oe.we, i, "true"), e4.k ? ($(e4.$), e4.$ = null) : ($(e4.U), e4.U = null), ee(m.re._e, u));
  };
  var Be = { show: Pe, hide: Le, showPreferences: Oe, hidePreferences: Re, acceptCategory: Ne };
  var Ge = (e4, t3) => __async(void 0, null, function* () {
    if (!ye(e4)) return false;
    const n4 = m.o;
    return !(e4 === he() && true !== t3 || !(yield we(e4)) || (Ce(e4), n4.T && ve(Be, xe), n4.N && me(Be, xe), Se(), 0));
  });
  var Je = () => {
    const { P: e4, Y: t3 } = m.o, { accepted: n4, rejected: o4 } = (() => {
      const { D: e5, R: t4, O: n5 } = m.o;
      return { accepted: t4, rejected: e5 ? [] : n5.filter((e6) => !b(t4, e6)) };
    })();
    return P({ acceptType: e4, acceptedCategories: n4, rejectedCategories: o4, acceptedServices: t3, rejectedServices: L() });
  };
  var Ue = (e4, t3) => {
    let n4 = document.querySelector('script[src="' + e4 + '"]');
    return new Promise((o4) => {
      if (n4) return o4(true);
      if (n4 = k("script"), h(t3)) for (const e5 in t3) A(n4, e5, t3[e5]);
      n4.onload = () => o4(true), n4.onerror = () => {
        n4.remove(), o4(false);
      }, n4.src = e4, H(document.head, n4);
    });
  };
  var $e = (e4) => {
    let t3, n4 = e4.value, o4 = e4.mode, s4 = false;
    const a3 = m.o;
    if ("update" === o4) {
      a3.h = t3 = ze("data");
      const e5 = typeof t3 == typeof n4;
      if (e5 && "object" == typeof t3) {
        !t3 && (t3 = {});
        for (let e6 in n4) t3[e6] !== n4[e6] && (t3[e6] = n4[e6], s4 = true);
      } else !e5 && t3 || t3 === n4 || (t3 = n4, s4 = true);
    } else t3 = n4, s4 = true;
    return s4 && (a3.h = t3, a3.p.data = t3, De(true)), s4;
  };
  var ze = (e4, t3) => {
    const n4 = ke(t3);
    return e4 ? n4[e4] : n4;
  };
  var qe = (e4) => {
    const t3 = m.t, n4 = m.o.i;
    return e4 ? t3[e4] || n4[e4] : __spreadProps(__spreadValues(__spreadValues({}, t3), n4), { cookie: __spreadValues({}, t3.cookie) });
  };
  var Ke = () => !m.o.D;
  var Qe = (e4) => __async(void 0, null, function* () {
    const { o: n4, t: o4, re: s4 } = m, c3 = window;
    if (!c3._ccRun) {
      if (c3._ccRun = true, ((e5) => {
        const { oe: n5, t: o5, o: s5 } = m, c4 = o5, r4 = s5, { cookie: i5 } = c4, l4 = m.ce, d2 = e5.cookie, f2 = e5.categories, _2 = w(f2) || [], u2 = navigator, p2 = document;
        n5.$e = p2, n5.ye = p2.documentElement, i5.domain = location.hostname, r4.i = e5, r4.L = f2, r4.O = _2, r4._ = e5.language.translations, r4.v = !!e5.disablePageInteraction, l4.ie = e5.onFirstConsent, l4.le = e5.onConsent, l4.de = e5.onChange, l4._e = e5.onModalHide, l4.fe = e5.onModalShow, l4.ue = e5.onModalReady;
        const { mode: g2, autoShow: v2, lazyHtmlGeneration: y2, autoClearCookies: C2, revision: S2, manageScriptTags: x2, hideFromBots: M2 } = e5;
        g2 === t && (c4.mode = g2), "boolean" == typeof C2 && (c4.autoClearCookies = C2), "boolean" == typeof x2 && (c4.manageScriptTags = x2), "number" == typeof S2 && S2 >= 0 && (c4.revision = S2, r4.V = true), "boolean" == typeof v2 && (c4.autoShow = v2), "boolean" == typeof y2 && (c4.lazyHtmlGeneration = y2), false === M2 && (c4.hideFromBots = false), true === c4.hideFromBots && u2 && (r4.J = u2.userAgent && /bot|crawl|spider|slurp|teoma/i.test(u2.userAgent) || u2.webdriver), h(d2) && (c4.cookie = __spreadValues(__spreadValues({}, i5), d2)), c4.autoClearCookies, r4.V, c4.manageScriptTags, ((e6) => {
          const { L: t3, X: n6, Y: o6, Z: s6, B: a3 } = m.o;
          for (let c5 of e6) {
            const e7 = t3[c5], r5 = e7.services || {}, i6 = h(r5) && w(r5) || [];
            n6[c5] = {}, o6[c5] = [], s6[c5] = [], e7.readOnly && (a3.push(c5), o6[c5] = i6), m.oe.ae[c5] = {};
            for (let e8 of i6) {
              const t4 = r5[e8];
              t4.Se = false, n6[c5][e8] = t4;
            }
          }
        })(_2), (() => {
          if (!m.t.manageScriptTags) return;
          const e6 = m.o, t3 = D(document, "script[" + a + "]");
          for (const n6 of t3) {
            let t4 = N(n6, a), o6 = n6.dataset.service || "", s6 = false;
            if (t4 && "!" === t4.charAt(0) && (t4 = t4.slice(1), s6 = true), "!" === o6.charAt(0) && (o6 = o6.slice(1), s6 = true), b(e6.O, t4) && (e6.ne.push({ Me: n6, xe: false, ke: s6, De: t4, Te: o6 }), o6)) {
              const n7 = e6.X[t4];
              n7[o6] || (n7[o6] = { Se: false });
            }
          }
        })(), Ce((() => {
          const e6 = m.o.i.language.autoDetect;
          if (e6) {
            const t3 = { browser: navigator.language, document: document.documentElement.lang }, n6 = ye(t3[e6]);
            if (n6) return n6;
          }
          return he();
        })());
      })(e4), n4.J) return;
      (() => {
        const e5 = m.o, n5 = m.t, o5 = ke(), { categories: s5, services: a3, consentId: c4, consentTimestamp: r4, lastConsentTimestamp: i5, data: l4, revision: d2 } = o5, f2 = v(s5);
        e5.p = o5, e5.M = c4;
        const _2 = !!c4 && y(c4);
        e5.C = r4, e5.C && (e5.C = new Date(r4)), e5.S = i5, e5.S && (e5.S = new Date(i5)), e5.h = void 0 !== l4 ? l4 : null, e5.V && _2 && d2 !== n5.revision && (e5.I = false), e5.D = !(_2 && e5.I && e5.C && e5.S && f2), e5.D, (() => {
          const e6 = m.o;
          for (const n6 of e6.O) {
            const o6 = e6.L[n6];
            if (o6.readOnly || o6.enabled && e6.i.mode === t) {
              e6.G.push(n6);
              const t3 = e6.X[n6] || {};
              for (let o7 in t3) e6.Y[n6].push(o7);
            }
          }
        })(), e5.D ? n5.mode === t && (e5.R = [...e5.G]) : (e5.Y = __spreadValues(__spreadValues({}, e5.Y), a3), J([...e5.B, ...s5])), e5.Z = __spreadValues({}, e5.Y);
      })();
      const i4 = Ke();
      if (!(yield we())) return false;
      if (U(null, r3 = Be, me, xe), m.o.D && ve(r3, xe), m.t.lazyHtmlGeneration || me(r3, xe), o4.autoShow && !i4 && Pe(true), i4) return te(), ee(s4.le);
      o4.mode === t && te(n4.G);
    }
    var r3;
  });
  var We = (e4) => {
    const { Ce: t3, ye: a3 } = m.oe, { name: c3, path: r3, domain: i4 } = m.t.cookie;
    e4 && Fe(c3, r3, i4);
    for (const { pe: e5, me: t4, ge: n4 } of m.o.m) e5.removeEventListener(t4, n4);
    t3 && t3.remove(), a3 && a3.classList.remove(s, o, n);
    const l4 = new p();
    for (const e5 in m) m[e5] = l4[e5];
    window._ccRun = false;
  };

  // assets/scripts/modules/CookieConsent.js
  var CookieConsent_default = class extends _default {
    constructor(m2) {
      super(m2);
      try {
        this.config = JSON.parse(this.getData("config"));
      } catch (err) {
        console.warn(err.message);
      }
      this.events = {
        click: {
          hide: "hideModal",
          "show-preferences": "showPreferences"
        }
      };
    }
    init() {
      if (!this.config.categories || Object.keys(this.config.categories).length === 0) {
        console.warn("[CookieConsent]", "No categories configured.");
        return;
      }
      this.config.categories = this.prepareCategories(this.config.categories);
      this.config.cookie = {
        name: "cc_cookie_locomotive"
      };
      Qe(Object.assign({
        autoShow: false,
        onConsent: () => {
          this.toggleCategoryAnalytics();
        },
        onChange: ({ changedCategories }) => {
          if (changedCategories.includes("analytics")) {
            this.toggleCategoryAnalytics();
          }
        }
      }, this.config));
      setTimeout(Pe, 1e3);
    }
    showPreferences() {
      Oe();
    }
    hideModal() {
      Re();
      Le();
    }
    prepareCategories(categories) {
      var _a;
      for (const [categoryName, categoryData] of Object.entries(categories)) {
        if (((_a = categoryData == null ? void 0 : categoryData.autoClear) == null ? void 0 : _a.cookies) && Array.isArray(categoryData.autoClear.cookies) && categoryData.autoClear.cookies.length > 0) {
          categoryData.autoClear.cookies.map((cookie) => {
            if ((cookie == null ? void 0 : cookie.name) && typeof cookie.name === "string") {
              const found = cookie.name.match(/^\/(.+)\/([a-z]+)?$/);
              if (found) {
                cookie.name = new RegExp(found[1], found[2]);
              }
            }
            return cookie;
          });
          categories[categoryName].autoClear.cookies = categoryData.autoClear.cookies;
        }
      }
      return categories;
    }
    toggleCategoryAnalytics() {
      var _a;
      const isAccepted = cookieconsent_esm_exports == null ? void 0 : cookieconsent_esm_exports.acceptedCategory("analytics");
      (_a = window.dataLayer) == null ? void 0 : _a.push(["consent", "update", {
        "analytics_storage": isAccepted ? "granted" : "denied"
      }]);
    }
  };

  // assets/scripts/utils/html.js
  var SHUFFLE_PATTERN = new RegExp("\\p{Extended_Pictographic}|\\r|\\n|.", "gu");
  function shuffleElementTexts(item, shuffleFn) {
    if ((!item.children.length || item.dataset.allowShuffle != void 0) && item.innerText) {
      item.querySelectorAll(".u-screen-reader-text").forEach((item2) => item2.remove());
      const words = item.innerText.replace("\n", " \n ").split(" ");
      for (let i4 = 0; i4 < words.length; i4++) {
        const chars = [...words[i4].matchAll(SHUFFLE_PATTERN)].map((item2) => item2[0]);
        words[i4] = shuffleFn(chars);
      }
      item.innerText = words.join(" ");
    }
  }
  function shuffleContainerTexts(container, shuffleFn) {
    container.querySelectorAll("*").forEach((item) => {
      shuffleElementTexts(item, shuffleFn);
    });
  }
  function copyToClipboard(el) {
    window.copyToClipboard(el.dataset.toCopy);
    alert(el.dataset.confirmation);
  }

  // assets/scripts/modules/CopyToClipboard.js
  var CopyToClipboard_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.events = {
        click: "onClick"
      };
    }
    onClick(e4) {
      e4.preventDefault();
      e4.stopPropagation();
      copyToClipboard(e4.target);
    }
  };

  // node_modules/gsap/gsap-core.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value) {
    return typeof value === "string";
  };
  var _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  };
  var _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  };
  var _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  };
  var _isObject = function _isObject2(value) {
    return typeof value === "object";
  };
  var _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i4;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i4 = _harnessPlugins.length;
      while (i4-- && !_harnessPlugins[i4].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i4];
    }
    i4 = targets.length;
    while (i4--) {
      targets[i4] && (targets[i4]._gsap || (targets[i4]._gsap = new GSCache(targets[i4], harnessPlugin))) || targets.splice(i4, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property, v2) {
    return (v2 = target[property]) && _isFunction(v2) ? target[property]() : _isUndefined(v2) && target.getAttribute && target.getAttribute(property) || v2;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l4 = toFind.length, i4 = 0;
    for (; toSearch.indexOf(toFind[i4]) < 0 && ++i4 < l4; ) {
    }
    return i4 < l4;
  };
  var _lazyRender = function _lazyRender2() {
    var l4 = _lazyTweens.length, a3 = _lazyTweens.slice(0), i4, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i4 = 0; i4 < l4; i4++) {
      tween = a3[i4];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
    _lazyTweens.length && _lazyRender();
    animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
    _lazyTweens.length && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value) {
    var n4 = parseFloat(value);
    return (n4 || n4 === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n4 : _isString(value) ? value.trim() : value;
  };
  var _passThrough = function _passThrough2(p2) {
    return p2;
  };
  var _setDefaults = function _setDefaults2(obj, defaults2) {
    for (var p2 in defaults2) {
      p2 in obj || (obj[p2] = defaults2[p2]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults2) {
      for (var p2 in defaults2) {
        p2 in obj || p2 === "duration" && excludeDuration || p2 === "ease" || (obj[p2] = defaults2[p2]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p2 in toMerge) {
      base[p2] = toMerge[p2];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p2 in toMerge) {
      p2 !== "__proto__" && p2 !== "constructor" && p2 !== "prototype" && (base[p2] = _isObject(toMerge[p2]) ? _mergeDeep2(base[p2] || (base[p2] = {}), toMerge[p2]) : toMerge[p2]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p2;
    for (p2 in obj) {
      p2 in excluding || (copy[p2] = obj[p2]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent2 = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent2) {
        func(vars, parent2.vars.defaults);
        parent2 = parent2.parent || parent2._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a22) {
    var i4 = a1.length, match = i4 === a22.length;
    while (match && i4-- && a1[i4] === a22[i4]) {
    }
    return i4 < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent2, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev2 = parent2[lastProp], t3;
    if (sortBy) {
      t3 = child[sortBy];
      while (prev2 && prev2[sortBy] > t3) {
        prev2 = prev2._prev;
      }
    }
    if (prev2) {
      child._next = prev2._next;
      prev2._next = child;
    } else {
      child._next = parent2[firstProp];
      parent2[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent2[lastProp] = child;
    }
    child._prev = prev2;
    child.parent = child._dp = parent2;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent2, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev2 = child._prev, next2 = child._next;
    if (prev2) {
      prev2._next = next2;
    } else if (parent2[firstProp] === child) {
      parent2[firstProp] = next2;
    }
    if (next2) {
      next2._prev = prev2;
    } else if (parent2[lastProp] === child) {
      parent2[lastProp] = prev2;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a3 = animation;
      while (a3) {
        a3._dirty = 1;
        a3 = a3.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent2 = animation.parent;
    while (parent2 && parent2.parent) {
      parent2._dirty = 1;
      parent2.totalDuration();
      parent2 = parent2.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime /= cycleDuration);
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent2 = animation._dp;
    if (parent2 && parent2.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent2._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent2._dirty || _uncache(parent2, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline3, child) {
    var t3;
    if (child._time || child._initted && !child._dur) {
      t3 = _parentToChildTotalTime(timeline3.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t3) - child._tTime > _tinyNum) {
        child.render(t3, true);
      }
    }
    if (_uncache(timeline3, child)._dp && timeline3._initted && timeline3._time >= timeline3._dur && timeline3._ts) {
      if (timeline3._dur < timeline3.duration()) {
        t3 = timeline3;
        while (t3._dp) {
          t3.rawTime() >= 0 && t3.totalTime(t3._tTime);
          t3 = t3._dp;
        }
      }
      timeline3._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline3, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline3 !== _globalTimeline ? _parsePosition(timeline3, position, child) : timeline3._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline3, child, "_first", "_last", timeline3._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline3._recent = child);
    skipChecks || _postAddChecks(timeline3, child);
    timeline3._ts < 0 && _alignPlayhead(timeline3, timeline3._tTime);
    return timeline3;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger2) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger2)) && _globals.ScrollTrigger.create(trigger2, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent2 = _ref.parent;
    return parent2 && parent2._ts && parent2._initted && !parent2._lock && (parent2.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent2));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i4, offset2, isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      offset2 = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i4 = position.indexOf("=");
      if (offset2 === "<" || offset2 === ">") {
        i4 >= 0 && (position = position.replace(/=/, ""));
        return (offset2 === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i4 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i4 < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset2 = parseFloat(position.charAt(i4 - 1) + position.substr(i4 + 1));
      if (isPercent && percentAnimation) {
        offset2 = offset2 / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i4 > 1 ? _parsePosition2(animation, position.substr(0, i4 - 1), percentAnimation) + offset2 : clippedDuration + offset2;
    }
    return position == null ? clippedDuration : +position;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline3) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent2;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline3;
    if (type) {
      irVars = vars;
      parent2 = timeline3;
      while (parent2 && !("immediateRender" in irVars)) {
        irVars = parent2.vars.defaults || {};
        parent2 = _isNotFalse(parent2.vars.inherit) && parent2.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  };
  var _clamp = function _clamp2(min, max, value) {
    return value < min ? min : value > max ? max : value;
  };
  var getUnit = function getUnit2(value, v2) {
    return !_isString(value) || !(v2 = _unitExp.exec(value)) ? "" : v2[1];
  };
  var clamp = function clamp2(min, max, value) {
    return _conditionalReturn(value, function(v2) {
      return _clamp(min, max, v2);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  };
  var toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  };
  var selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v2) {
      var el = value.current || value.nativeElement || value;
      return toArray(v2, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  };
  var shuffle = function shuffle2(a3) {
    return a3.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v2) {
    if (_isFunction(v2)) {
      return v2;
    }
    var vars = _isObject(v2) ? v2 : {
      each: v2
    }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function(i4, target, a3) {
      var l4 = (a3 || vars).length, distances = cache[l4], originX, originY, x2, y2, d2, j2, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a3[wrapAt++].getBoundingClientRect().left) && wrapAt < l4) {
          }
          wrapAt--;
        }
        distances = cache[l4] = [];
        originX = ratios ? Math.min(wrapAt, l4) * ratioX - 0.5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l4 * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j2 = 0; j2 < l4; j2++) {
          x2 = j2 % wrapAt - originX;
          y2 = originY - (j2 / wrapAt | 0);
          distances[j2] = d2 = !axis ? _sqrt(x2 * x2 + y2 * y2) : Math.abs(axis === "y" ? y2 : x2);
          d2 > max && (max = d2);
          d2 < min && (min = d2);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l4 = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l4 ? l4 - 1 : !axis ? Math.max(wrapAt, l4 / wrapAt) : axis === "y" ? l4 / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l4 < 0 ? base - l4 : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease = ease && l4 < 0 ? _invertEase(ease) : ease;
      }
      l4 = (distances[i4] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l4) : l4) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v2) {
    var p2 = Math.pow(10, ((v2 + "").split(".")[1] || "").length);
    return function(raw) {
      var n4 = _roundPrecise(Math.round(parseFloat(raw) / v2) * v2 * p2);
      return (n4 - n4 % 1) / p2 + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value) {
    var isArray3 = _isArray(snapTo), radius, is2D;
    if (!isArray3 && _isObject(snapTo)) {
      radius = isArray3 = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray3 ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x2 = parseFloat(is2D ? raw.x : raw), y2 = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest2 = 0, i4 = snapTo.length, dx, dy;
      while (i4--) {
        if (is2D) {
          dx = snapTo[i4].x - x2;
          dy = snapTo[i4].y - y2;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i4] - x2);
        }
        if (dx < min) {
          min = dx;
          closest2 = i4;
        }
      }
      closest2 = !radius || min <= radius ? snapTo[closest2] : raw;
      return is2D || closest2 === raw || _isNumber(raw) ? closest2 : closest2 + getUnit(raw);
    });
  };
  var random = function random2(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v2, f2) {
        return f2(v2);
      }, value);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  };
  var normalize = function normalize2(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  };
  var _wrapArray = function _wrapArray2(a3, wrapper, value) {
    return _conditionalReturn(value, function(index2) {
      return a3[~~wrapper(index2)];
    });
  };
  var wrap = function wrap2(min, max, value) {
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
      return (range + (value2 - min) % range) % range + min;
    });
  };
  var wrapYoyo = function wrapYoyo2(min, max, value) {
    var range = max - min, total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min) % total) % total || 0;
      return min + (value2 > range ? total - value2 : value2);
    });
  };
  var _replaceRandom = function _replaceRandom2(value) {
    var prev2 = 0, s4 = "", i4, nums, end, isArray3;
    while (~(i4 = value.indexOf("random(", prev2))) {
      end = value.indexOf(")", i4);
      isArray3 = value.charAt(i4 + 7) === "[";
      nums = value.substr(i4 + 7, end - i4 - 7).match(isArray3 ? _delimitedValueExp : _strictNumExp);
      s4 += value.substr(prev2, i4 - prev2) + random(isArray3 ? nums : +nums[0], isArray3 ? 0 : +nums[1], +nums[2] || 1e-5);
      prev2 = end + 1;
    }
    return s4 + value.substr(prev2, value.length - prev2);
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p3) {
      return (1 - p3) * start + p3 * end;
    };
    if (!func) {
      var isString2 = _isString(start), master = {}, p2, i4, interpolators, l4, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString2) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l4 = start.length;
        il = l4 - 2;
        for (i4 = 1; i4 < l4; i4++) {
          interpolators.push(interpolate2(start[i4 - 1], start[i4]));
        }
        l4--;
        func = function func2(p3) {
          p3 *= l4;
          var i5 = Math.min(il, ~~p3);
          return interpolators[i5](p3 - i5);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p2 in end) {
          _addPropTween.call(master, start, p2, "get", end[p2]);
        }
        func = function func2(p3) {
          return _renderPropTweens(p3, master) || (isString2 ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline3, fromTime, backward) {
    var labels = timeline3.labels, min = _bigNum, p2, distance, label;
    for (p2 in labels) {
      distance = labels[p2] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p2;
        min = distance;
      }
    }
    return label;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v2 = animation.vars, callback = v2[type], prevContext = _context, context3 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v2[type + "Params"];
    scope = v2.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context3 && (_context = context3);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _createPlugin = function _createPlugin2(config3) {
    config3 = !config3.name && config3["default"] || config3;
    var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
      this._props = [];
    } : config3, instanceDefaults = {
      init: _emptyFunc,
      render: _renderPropTweens,
      add: _addPropTween,
      kill: _killPropTweensOf,
      modifier: _addPluginModifier,
      rawVars: 0
    }, statics = {
      targetTest: 0,
      get: 0,
      getSetter: _getSetter,
      aliases: {},
      register: 0
    };
    _wake();
    if (config3 !== Plugin) {
      if (_plugins[name]) {
        return;
      }
      _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
      _plugins[Plugin.prop = name] = Plugin;
      if (config3.targetTest) {
        _harnessPlugins.push(Plugin);
        _reservedProps[name] = 1;
      }
      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
    }
    _addGlobal(name, Plugin);
    config3.register && config3.register(gsap, Plugin, PropTween);
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h4, m1, m2) {
    h4 += h4 < 0 ? 1 : h4 > 1 ? -1 : 0;
    return (h4 * 6 < 1 ? m1 + (m2 - m1) * h4 * 6 : h4 < 0.5 ? m2 : h4 * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h4) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v2, toHSL, forceAlpha) {
    var a3 = !v2 ? _colorLookup.black : _isNumber(v2) ? [v2 >> 16, v2 >> 8 & _255, v2 & _255] : 0, r3, g2, b2, h4, s4, l4, max, min, d2, wasHSL;
    if (!a3) {
      if (v2.substr(-1) === ",") {
        v2 = v2.substr(0, v2.length - 1);
      }
      if (_colorLookup[v2]) {
        a3 = _colorLookup[v2];
      } else if (v2.charAt(0) === "#") {
        if (v2.length < 6) {
          r3 = v2.charAt(1);
          g2 = v2.charAt(2);
          b2 = v2.charAt(3);
          v2 = "#" + r3 + r3 + g2 + g2 + b2 + b2 + (v2.length === 5 ? v2.charAt(4) + v2.charAt(4) : "");
        }
        if (v2.length === 9) {
          a3 = parseInt(v2.substr(1, 6), 16);
          return [a3 >> 16, a3 >> 8 & _255, a3 & _255, parseInt(v2.substr(7), 16) / 255];
        }
        v2 = parseInt(v2.substr(1), 16);
        a3 = [v2 >> 16, v2 >> 8 & _255, v2 & _255];
      } else if (v2.substr(0, 3) === "hsl") {
        a3 = wasHSL = v2.match(_strictNumExp);
        if (!toHSL) {
          h4 = +a3[0] % 360 / 360;
          s4 = +a3[1] / 100;
          l4 = +a3[2] / 100;
          g2 = l4 <= 0.5 ? l4 * (s4 + 1) : l4 + s4 - l4 * s4;
          r3 = l4 * 2 - g2;
          a3.length > 3 && (a3[3] *= 1);
          a3[0] = _hue(h4 + 1 / 3, r3, g2);
          a3[1] = _hue(h4, r3, g2);
          a3[2] = _hue(h4 - 1 / 3, r3, g2);
        } else if (~v2.indexOf("=")) {
          a3 = v2.match(_numExp);
          forceAlpha && a3.length < 4 && (a3[3] = 1);
          return a3;
        }
      } else {
        a3 = v2.match(_strictNumExp) || _colorLookup.transparent;
      }
      a3 = a3.map(Number);
    }
    if (toHSL && !wasHSL) {
      r3 = a3[0] / _255;
      g2 = a3[1] / _255;
      b2 = a3[2] / _255;
      max = Math.max(r3, g2, b2);
      min = Math.min(r3, g2, b2);
      l4 = (max + min) / 2;
      if (max === min) {
        h4 = s4 = 0;
      } else {
        d2 = max - min;
        s4 = l4 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        h4 = max === r3 ? (g2 - b2) / d2 + (g2 < b2 ? 6 : 0) : max === g2 ? (b2 - r3) / d2 + 2 : (r3 - g2) / d2 + 4;
        h4 *= 60;
      }
      a3[0] = ~~(h4 + 0.5);
      a3[1] = ~~(s4 * 100 + 0.5);
      a3[2] = ~~(l4 * 100 + 0.5);
    }
    forceAlpha && a3.length < 4 && (a3[3] = 1);
    return a3;
  };
  var _colorOrderData = function _colorOrderData2(v2) {
    var values = [], c3 = [], i4 = -1;
    v2.split(_colorExp).forEach(function(v3) {
      var a3 = v3.match(_numWithUnitExp) || [];
      values.push.apply(values, a3);
      c3.push(i4 += a3.length + 1);
    });
    values.c = c3;
    return values;
  };
  var _formatColors = function _formatColors2(s4, toHSL, orderMatchData) {
    var result = "", colors2 = (s4 + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i4 = 0, c3, shell, d2, l4;
    if (!colors2) {
      return s4;
    }
    colors2 = colors2.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d2 = _colorOrderData(s4);
      c3 = orderMatchData.c;
      if (c3.join(result) !== d2.c.join(result)) {
        shell = s4.replace(_colorExp, "1").split(_numWithUnitExp);
        l4 = shell.length - 1;
        for (; i4 < l4; i4++) {
          result += shell[i4] + (~c3.indexOf(i4) ? colors2.shift() || type + "0,0,0,0)" : (d2.length ? d2 : colors2.length ? colors2 : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s4.split(_colorExp);
      l4 = shell.length - 1;
      for (; i4 < l4; i4++) {
        result += shell[i4] + colors2[i4];
      }
    }
    return result + shell[l4];
  };
  var _colorExp = function() {
    var s4 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p2;
    for (p2 in _colorLookup) {
      s4 += "|" + p2 + "\\b";
    }
    return new RegExp(s4 + ")", "gi");
  }();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a3) {
    var combined = a3.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a3[1] = _formatColors(a3[1], toHSL);
      a3[0] = _formatColors(a3[0], toHSL, _colorOrderData(a3[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = function() {
    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v2) {
      var elapsed = _getTime() - _lastUpdate, manual = v2 === true, overlap, dispatch, time, frame;
      elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1e3;
        _self.time = time = time / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i = 0; _i < _listeners2.length; _i++) {
          _listeners2[_i](time, _delta, frame, v2);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _raf = _win.requestAnimationFrame;
          }
          _id && _self.sleep();
          _req = _raf || function(f2) {
            return setTimeout(f2, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || 1 / _tinyNum;
        _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function(t3, d2, f2, v2) {
          callback(t3, d2, f2, v2);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners2[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove2(callback, i4) {
        ~(i4 = _listeners2.indexOf(callback)) && _listeners2.splice(i4, 1) && _i >= i4 && _i--;
      },
      _listeners: _listeners2
    };
    return _self;
  }();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i4 = 1, l4 = split.length, index2, val, parsedVal;
    for (; i4 < l4; i4++) {
      val = split[i4];
      index2 = i4 !== l4 - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index2);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index2 + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value) {
    var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name) {
    var split = (name + "").split("("), ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  };
  var _invertEase = function _invertEase2(ease) {
    return function(p2) {
      return 1 - ease(1 - p2);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline3, isYoyo) {
    var child = timeline3._first, ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut2(p2) {
        return 1 - easeIn(1 - p2);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p2) {
        return p2 < 0.5 ? easeIn(p2 * 2) / 2 : 1 - easeIn((1 - p2) * 2) / 2;
      };
    }
    var ease = {
      easeIn,
      easeOut,
      easeInOut
    }, lowercaseName;
    _forEachName(names, function(name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p2 in ease) {
        _easeMap[lowercaseName + (p2 === "easeIn" ? ".in" : p2 === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p2] = ease[p2];
      }
    });
    return ease;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
    return function(p2) {
      return p2 < 0.5 ? (1 - easeOut(1 - p2 * 2)) / 2 : 0.5 + easeOut((p2 - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p4) {
      return p4 === 1 ? 1 : p1 * Math.pow(2, -10 * p4) * _sin((p4 - p3) * p2) + 1;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p4) {
      return 1 - easeOut(1 - p4);
    } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2;
    ease.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut2(p2) {
      return p2 ? --p2 * p2 * ((overshoot + 1) * p2 + overshoot) + 1 : 0;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p2) {
      return 1 - easeOut(1 - p2);
    } : _easeInOutFromOut(easeOut);
    ease.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i4) {
    var power = i4 < 5 ? i4 + 1 : i4;
    _insertEase(name + ",Power" + (power - 1), i4 ? function(p2) {
      return Math.pow(p2, power);
    } : function(p2) {
      return p2;
    }, function(p2) {
      return 1 - Math.pow(1 - p2, power);
    }, function(p2) {
      return p2 < 0.5 ? Math.pow(p2 * 2, power) / 2 : 1 - Math.pow((1 - p2) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n4, c3) {
    var n1 = 1 / c3, n22 = 2 * n1, n32 = 2.5 * n1, easeOut = function easeOut2(p2) {
      return p2 < n1 ? n4 * p2 * p2 : p2 < n22 ? n4 * Math.pow(p2 - 1.5 / c3, 2) + 0.75 : p2 < n32 ? n4 * (p2 -= 2.25 / c3) * p2 + 0.9375 : n4 * Math.pow(p2 - 2.625 / c3, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p2) {
      return 1 - easeOut(1 - p2);
    }, easeOut);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p2) {
    return p2 ? Math.pow(2, 10 * (p2 - 1)) : 0;
  });
  _insertEase("Circ", function(p2) {
    return -(_sqrt(1 - p2 * p2) - 1);
  });
  _insertEase("Sine", function(p2) {
    return p2 === 1 ? 1 : -_cos(p2 * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p4) {
        return ((p2 * _clamp(0, max, p4) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay3(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent2 = this._dp;
      if (parent2 && parent2.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent2._dp || parent2.parent || _postAddChecks(parent2, this);
        while (parent2 && parent2.parent) {
          if (parent2.parent._time !== parent2._start + (parent2._ts >= 0 ? parent2._tTime / parent2._ts : (parent2.totalDuration() - parent2._tTime) / -parent2._ts)) {
            parent2.totalTime(parent2._tTime, true);
          }
          parent2 = parent2.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
    };
    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent2 = this.parent || this._dp;
        parent2 && (parent2._sort || !this.parent) && _addToTimeline(parent2, this, value - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent2 = this.parent || this._dp;
      return !parent2 ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent2.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config3;
      if (this._initted || this._startAt) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (animation._ts || 1);
        animation = animation._dp;
      }
      return !this.parent && this.vars.immediateRender ? -1 : time;
    };
    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time ? this.time(time) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
    };
    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent2 = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent2 || this._ts && this._initted && parent2.isActive() && (rawTime = parent2.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self2 = this;
      return new Promise(function(resolve) {
        var f2 = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self2.then;
          self2.then = null;
          _isFunction(f2) && (f2 = f2(self2)) && (f2.then || f2 === self2) && (self2.then = _then);
          resolve(f2);
          self2.then = _then;
        };
        if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
          _resolve();
        } else {
          self2._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill() {
      _interrupt(this);
    };
    return Animation2;
  }();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ function(_Animation) {
    _inheritsLoose(Timeline2, _Animation);
    function Timeline2(vars, position) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline2.prototype;
    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set2(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render6(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next2, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === tTime / cycleDuration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : dur;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && time && !suppressEvents) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next2 = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next2 && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next2;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time;
          while (child) {
            next2 = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next2 && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next2;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a3 = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a3.push(child);
          } else {
            timelines && a3.push(child);
            nested && a3.push.apply(a3, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a3;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i4 = animations.length;
      while (i4--) {
        if (animations[i4].vars.id === id) {
          return animations[i4];
        }
      }
    };
    _proto2.remove = function remove2(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition(this, position);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position, callback, params) {
      var t3 = Tween.delayedCall(0, callback || _emptyFunc, params);
      t3.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t3, _parsePosition(this, position));
    };
    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i4 = tweens.length;
      while (i4--) {
        _overwritingTween !== tweens[i4] && tweens[i4].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a3 = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children2;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a3.push(child);
          }
        } else if ((children2 = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a3.push.apply(a3, children2);
        }
        child = child._next;
      }
      return a3;
    };
    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p2;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p2 in labels) {
          if (labels[p2] >= ignoreBeforeTime) {
            labels[p2] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next2;
      while (child) {
        next2 = child._next;
        this.remove(child);
        child = next2;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev2, start, parent2;
      if (arguments.length) {
        return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
      }
      if (self2._dirty) {
        parent2 = self2.parent;
        while (child) {
          prev2 = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self2._sort && child._ts && !self2._lock) {
            self2._lock = 1;
            _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent2 && !self2._dp || parent2 && parent2.smoothChildTiming) {
              self2._start += start / self2._ts;
              self2._time -= start;
              self2._tTime -= start;
            }
            self2.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev2;
        }
        _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
        self2._dirty = 0;
      }
      return self2._tDur;
    };
    Timeline2.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline2;
  }(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index2 = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a3;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a3 = [start, end];
      stringFilter(a3, target, prop);
      start = a3[0];
      end = a3[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index2, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index2 = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop, start, end, index2, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index2 || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index2, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index2, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index2, target, targets) : vars;
    }
    var copy = {}, p2;
    for (p2 in vars) {
      copy[p2] = _parseFuncOrString(vars[p2], tween, index2, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property, vars, tween, index2, target, targets) {
    var plugin, pt, ptLookup, i4;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index2, target, targets, tween), tween, index2, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i4 = plugin._props.length;
        while (i4--) {
          ptLookup[plugin._props[i4]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time, tTime) {
    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, onUpdateParams = vars.onUpdateParams, callbackScope = vars.callbackScope, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent2 = tween.parent, fullTargets = parent2 && parent2.data === "nested" ? parent2.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i4, p2, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index2, harnessVars, overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent: parent2,
          immediateRender: true,
          lazy: _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate,
          onUpdateParams,
          callbackScope,
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            time && (tween._zTime = time);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time && (immediateRender = false);
          p2 = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent2
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})
          }, cleanVars);
          harnessVars && (p2[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p2));
          tween._startAt._dp = 0;
          time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i4 = 0; i4 < targets.length; i4++) {
        target = targets[i4];
        gsData = target._gsap || _harness(targets)[i4]._gsap;
        tween._ptLookup[i4] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index2 = fullTargets === targets ? i4 : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index2, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p2 in cleanVars) {
            if (_plugins[p2] && (plugin = _checkPlugin(p2, cleanVars, tween, index2, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p2] = pt = _addPropTween.call(tween, target, p2, "get", cleanVars[p2], index2, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i4] && tween.kill(target, tween._op[i4]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup2, i4;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup2 = tween._ptLookup;
      i4 = tween._targets.length;
      while (i4--) {
        pt = lookup2[i4][property];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return 1;
        }
        ptCache.push(pt);
      }
    }
    i4 = ptCache.length;
    while (i4--) {
      rootPT = ptCache[i4];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p2, i4, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p2 in propertyAliases) {
      if (p2 in copy) {
        aliases = propertyAliases[p2].split(",");
        i4 = aliases.length;
        while (i4--) {
          copy[aliases[i4]] = copy[p2];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut", p2, a3;
    if (_isArray(obj)) {
      a3 = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value, i4) {
        return a3.push({
          t: i4 / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p2 in obj) {
        a3 = allProps[p2] || (allProps[p2] = []);
        p2 === "ease" || a3.push({
          t: parseFloat(prop),
          v: obj[p2],
          e: ease
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value, tween, i4, target, targets) {
    return _isFunction(value) ? value.call(tween, i4, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
    return _staggerPropsToSkip[name] = 1;
  });
  var Tween = /* @__PURE__ */ function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay3 = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent2 = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i4, copy, l4, p2, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay3)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults2 || {},
          targets: parent2 && parent2.data === "nested" ? parent2.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay3)) {
          l4 = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p2 in stagger) {
              if (~_staggerTweenProps.indexOf(p2)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p2] = stagger[p2];
              }
            }
          }
          for (i4 = 0; i4 < l4; i4++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i4];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i4, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay3, _assertThisInitialized(_this3), i4, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l4 === 1 && copy.delay) {
              _this3._delay = delay3 = copy.delay;
              _this3._start += delay3;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i4, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay3 = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0, a3, kf, v2;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p2 in keyframes) {
              p2 === "ease" || p2 === "easeEach" || _parseKeyframe(p2, keyframes[p2], copy, keyframes.easeEach);
            }
            for (p2 in copy) {
              a3 = copy[p2].sort(function(a4, b2) {
                return a4.t - b2.t;
              });
              time = 0;
              for (i4 = 0; i4 < a3.length; i4++) {
                kf = a3[i4];
                v2 = {
                  ease: kf.e,
                  duration: (kf.t - (i4 ? a3[i4 - 1].t : 0)) / 100 * duration
                };
                v2[p2] = kf.v;
                tl.to(parsedTargets, v2, time);
                time += v2.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent2, _assertThisInitialized(_this3), position);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent2._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent2.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay3) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render6(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline3, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
        time = tTime;
        timeline3 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === tTime / cycleDuration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline3 && this._yEase && _propagateYoyoEase(timeline3, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (time && !prevTime && !suppressEvents) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline3 && timeline3.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline3._dur * timeline3._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur);
      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
        return this.resetTo(property, value, start, startIsRelative);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        return this.parent ? _interrupt(this) : this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p2, pt, i4;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p2 = {};
          _forEachName(vars, function(name) {
            return p2[name] = 1;
          });
          vars = p2;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i4 = parsedTargets.length;
      while (i4--) {
        if (~killingTargets.indexOf(parsedTargets[i4])) {
          curLookup = propTweenLookup[i4];
          if (vars === "all") {
            overwrittenProps[i4] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i4] = overwrittenProps[i4] || {};
            props = vars;
          }
          for (p2 in props) {
            pt = curLookup && curLookup[p2];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p2) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p2];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p2] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay3, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay3,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set2(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  }(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
    Tween[name] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property, value) {
    return target[property] = value;
  };
  var _setterFunc = function _setterFunc2(target, property, value) {
    return target[property](value);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
    return target[property](data.fp, value);
  };
  var _setterAttribute = function _setterAttribute2(target, property, value) {
    return target.setAttribute(property, value);
  };
  var _getSetter = function _getSetter2(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s4 = "";
    if (!ratio && data.b) {
      s4 = data.b;
    } else if (ratio === 1 && data.e) {
      s4 = data.e;
    } else {
      while (pt) {
        s4 = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s4;
        pt = pt._next;
      }
      s4 += data.c;
    }
    data.set(data.t, data.p, s4, data);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
    var pt = this._pt, next2;
    while (pt) {
      next2 = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next2;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property) {
    var pt = this._pt, hasNonDependentRemaining, next2;
    while (pt) {
      next2 = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next2;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent2) {
    var pt = parent2._pt, next2, pt2, first, last;
    while (pt) {
      next2 = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next2;
    }
    parent2._pt = first;
  };
  var PropTween = /* @__PURE__ */ function() {
    function PropTween2(next2, target, prop, start, change2, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change2;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next2;
      if (next2) {
        next2._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
    return _reservedProps[name] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f2) {
      return f2();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time = Date.now(), matches2 = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c3) {
        var queries = c3.queries, conditions = c3.conditions, match, p2, anyMatch, toggled;
        for (p2 in queries) {
          match = _win.matchMedia(queries[p2]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p2]) {
            conditions[p2] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c3.revert();
          anyMatch && matches2.push(c3);
        }
      });
      _dispatch("matchMediaRevert");
      matches2.forEach(function(c3) {
        return c3.onMatch(c3);
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ function() {
    function Context3(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      func && this.add(func);
    }
    var _proto5 = Context3.prototype;
    _proto5.add = function add(name, func, scope) {
      if (_isFunction(name)) {
        scope = func;
        func = name;
        name = _isFunction;
      }
      var self2 = this, f2 = function f3() {
        var prev2 = _context, prevSelector = self2.selector, result;
        prev2 && prev2 !== self2 && prev2.data.push(self2);
        scope && (self2.selector = selector(scope));
        _context = self2;
        result = func.apply(self2, arguments);
        _isFunction(result) && self2._r.push(result);
        _context = prev2;
        self2.selector = prevSelector;
        self2.isReverted = false;
        return result;
      };
      self2.last = f2;
      return name === _isFunction ? f2(self2) : name ? self2[name] = f2 : f2;
    };
    _proto5.ignore = function ignore(func) {
      var prev2 = _context;
      _context = null;
      func(this);
      _context = prev2;
    };
    _proto5.getTweens = function getTweens() {
      var a3 = [];
      this.data.forEach(function(e4) {
        return e4 instanceof Context3 ? a3.push.apply(a3, e4.getTweens()) : e4 instanceof Tween && !(e4.parent && e4.parent.data === "nested") && a3.push(e4);
      });
      return a3;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill(revert, matchMedia2) {
      var _this4 = this;
      if (revert) {
        var tweens = this.getTweens();
        this.data.forEach(function(t3) {
          if (t3.data === "isFlip") {
            t3.revert();
            t3.getChildren(true, true, false).forEach(function(tween) {
              return tweens.splice(tweens.indexOf(tween), 1);
            });
          }
        });
        tweens.map(function(t3) {
          return {
            g: t3.globalTime(0),
            t: t3
          };
        }).sort(function(a3, b2) {
          return b2.g - a3.g || -1;
        }).forEach(function(o4) {
          return o4.t.revert(revert);
        });
        this.data.forEach(function(e4) {
          return !(e4 instanceof Animation) && e4.revert && e4.revert(revert);
        });
        this._r.forEach(function(f2) {
          return f2(revert, _this4);
        });
        this.isReverted = true;
      } else {
        this.data.forEach(function(e4) {
          return e4.kill && e4.kill();
        });
      }
      this.clear();
      if (matchMedia2) {
        var i4 = _media.indexOf(this);
        !!~i4 && _media.splice(i4, 1);
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context3;
  }();
  var MatchMedia = /* @__PURE__ */ function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p2, active;
      this.contexts.push(context3);
      func = context3.add("onMatch", func);
      context3.queries = conditions;
      for (p2 in conditions) {
        if (p2 === "all") {
          active = 1;
        } else {
          mq = _win.matchMedia(conditions[p2]);
          if (mq) {
            _media.indexOf(context3) < 0 && _media.push(context3);
            (cond[p2] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context3);
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function(c3) {
        return c3.kill(revert, true);
      });
    };
    return MatchMedia2;
  }();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property ? function(property2, unit2, uncache2) {
        return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t3) {
          return gsap.quickSetter(t3, property, unit);
        }), l4 = setters.length;
        return function(value) {
          var i4 = l4;
          while (i4--) {
            setters[i4](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property], cache = _getCache(target), p2 = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
        var p3 = new Plugin();
        _quickTween._pt = 0;
        p3.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p3.render(1, p3);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p2);
      return Plugin ? setter : function(value) {
        return setter(target, p2, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _merge22;
      var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });
      _effects[name] = function(targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name] = function(targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next2;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next2 = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next2;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c3) {
        var cond = c3.conditions, found, p2;
        for (p2 in cond) {
          if (cond[p2]) {
            cond[p2] = false;
            found = 1;
          }
        }
        found && c3.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a3 = _listeners[type] || (_listeners[type] = []);
      ~a3.indexOf(callback) || a3.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a3 = _listeners[type], i4 = a3 && a3.indexOf(callback);
      i4 >= 0 && a3.splice(i4, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
    return _gsap[name] = Tween[name];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p2, i4, pt;
    for (p2 in modifiers) {
      i4 = targets.length;
      while (i4--) {
        pt = tween._ptLookup[i4][p2];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p2);
          }
          pt && pt.modifier && pt.modifier(modifiers[p2], tween, targets[i4], p2);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
    return {
      name,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init5(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p2;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name2) {
              return temp[name2] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p2 in vars) {
              temp[p2] = modifier(vars[p2]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index2, targets) {
      var p2, pt, v2;
      this.tween = tween;
      for (p2 in vars) {
        v2 = target.getAttribute(p2) || "";
        pt = this.add(target, "setAttribute", (v2 || 0) + "", vars[p2], index2, targets, 0, 0, p2);
        pt.op = p2;
        pt.b = v2;
        this._props.push(p2);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    init: function init2(target, value) {
      var i4 = value.length;
      while (i4--) {
        this.add(target, i4, target[i4] || 0, value[i4], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.11.3";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/gsap/CSSPlugin.js
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
    return target.style[property] = value;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property, value) {
    return target.style.setProperty(property, value);
  };
  var _setterTransform = function _setterTransform2(target, property, value) {
    return target._gsap[property] = value;
  };
  var _setterScale = function _setterScale2(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style;
    if (property in _transformProps) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function(a3) {
          return _this.tfm[a3] = _get(target, a3);
        }) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property);
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (target._gsap.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i4, p2;
    for (i4 = 0; i4 < props.length; i4 += 3) {
      props[i4 + 1] ? target[props[i4]] = props[i4 + 2] : props[i4 + 2] ? style[props[i4]] = props[i4 + 2] : style.removeProperty(props[i4].replace(_capsExp, "-$1").toLowerCase());
    }
    if (this.tfm) {
      for (p2 in this.tfm) {
        cache[p2] = this.tfm[p2];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i4 = _reverting2();
      if (i4 && !i4.isStart && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        cache.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    properties && properties.split(",").forEach(function(p2) {
      return saver.save(p2);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e4 = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e4.style ? e4 : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
    var e4 = element || _tempDiv, s4 = e4.style, i4 = 5;
    if (property in s4 && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i4-- && !(_prefixes[i4] + property in s4)) {
    }
    return i4 < 0 ? null : (i4 === 3 ? "ms" : i4 >= 0 ? _prefixes[i4] : "") + property;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
    _docElement.appendChild(svg);
    svg.appendChild(this);
    this.style.display = "block";
    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._gsapBBox = this.getBBox;
        this.getBBox = _getBBoxHack2;
      } catch (e4) {
      }
    } else if (this._gsapBBox) {
      bbox = this._gsapBBox();
    }
    if (oldParent) {
      if (oldSibling) {
        oldParent.insertBefore(this, oldSibling);
      } else {
        oldParent.appendChild(this);
      }
    }
    _docElement.removeChild(svg);
    this.style.cssText = oldCSS;
    return bbox;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i4 = attributesArray.length;
    while (i4--) {
      if (target.hasAttribute(attributesArray[i4])) {
        return target.getAttribute(attributesArray[i4]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getBBoxHack.call(target, true);
    }
    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e4) {
    return !!(e4.getCTM && (!e4.parentNode || e4.ownerSVGElement) && _getBBox(e4));
  };
  var _removeProperty = function _removeProperty2(target, property) {
    if (property) {
      var style = target.style;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
          property = "-" + property;
        }
        style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent2, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent2 = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent2 = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent2 || parent2 === _doc2 || !parent2.appendChild) {
      parent2 = _doc2.body;
    }
    cache = parent2._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent2, "display")] && (style.position = _getComputedProperty(target, "position"));
      parent2 === target && (style.position = "static");
      parent2.appendChild(_tempDiv);
      px = _tempDiv[measureProperty];
      parent2.removeChild(_tempDiv);
      style.position = "absolute";
      if (horizontal && toPercent) {
        cache = _getCache(parent2);
        cache.time = _ticker.time;
        cache.width = parent2[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  };
  var _get = function _get2(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p2 = _checkPropPrefix(prop, target, 1), s4 = p2 && _getComputedProperty(target, p2, 1);
      if (s4 && s4 !== start) {
        prop = p2;
        start = s4;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index2 = 0, matchIndex = 0, a3, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end === "auto") {
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      target.style[prop] = start;
    }
    a3 = [start, end];
    _colorStringFilter(a3);
    start = a3[0];
    end = a3[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index2, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index2 = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index2 === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split = value.split(" "), x2 = split[0], y2 = split[1] || "50%";
    if (x2 === "top" || x2 === "bottom" || y2 === "left" || y2 === "right") {
      value = x2;
      x2 = y2;
      y2 = value;
    }
    split[0] = _keywordToPercent[x2] || x2;
    split[1] = _keywordToPercent[y2] || y2;
    return split.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i4;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i4 = props.length;
        while (--i4 > -1) {
          prop = props[i4];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent2, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent2 = target.parentNode;
      if (!parent2 || !target.offsetParent) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent2.insertBefore(target, nextSibling) : parent2 ? parent2.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a3 = matrix[0], b2 = matrix[1], c3 = matrix[2], d2 = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x2, y2;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a3 * d2 - b2 * c3)) {
      x2 = xOrigin * (d2 / determinant) + yOrigin * (-c3 / determinant) + (c3 * ty - d2 * tx) / determinant;
      y2 = xOrigin * (-b2 / determinant) + yOrigin * (a3 / determinant) - (a3 * ty - b2 * tx) / determinant;
      xOrigin = x2;
      yOrigin = y2;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a3 + ty * c3) - tx;
      cache.yOffset = yOffsetOld + (tx * b2 + ty * d2) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x2, y2, z2, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a3, b2, c3, d2, a12, a22, t1, t22, t3, a13, a23, a33, a42, a43, a32;
    x2 = y2 = z2 = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t22 = target.getBBox();
        origin = cache.xOrigin - t22.x + "px " + (cache.yOrigin - t22.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a3 = matrix[0];
      b2 = matrix[1];
      c3 = matrix[2];
      d2 = matrix[3];
      x2 = a12 = matrix[4];
      y2 = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a3 * a3 + b2 * b2);
        scaleY = Math.sqrt(d2 * d2 + c3 * c3);
        rotation = a3 || b2 ? _atan2(b2, a3) * _RAD2DEG : 0;
        skewX = c3 || d2 ? _atan2(c3, d2) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x2 -= xOrigin - (xOrigin * a3 + yOrigin * c3);
          y2 -= yOrigin - (xOrigin * b2 + yOrigin * d2);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x2 = matrix[12];
        y2 = matrix[13];
        z2 = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t22 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t22;
          a32 = t3;
        }
        angle = _atan2(-c3, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a3 * cos - a13 * sin;
          t22 = b2 * cos - a23 * sin;
          t3 = c3 * cos - a33 * sin;
          a43 = d2 * sin + a43 * cos;
          a3 = t1;
          b2 = t22;
          c3 = t3;
        }
        angle = _atan2(b2, a3);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a3 * cos + b2 * sin;
          t22 = a12 * cos + a22 * sin;
          b2 = b2 * cos - a3 * sin;
          a22 = a22 * cos - a12 * sin;
          a3 = t1;
          a12 = t22;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a3 * a3 + b2 * b2 + c3 * c3));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x2 - ((cache.xPercent = x2 && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x2) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y2 - ((cache.yPercent = y2 && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y2) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z2 + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x2 = _ref.x, y2 = _ref.y, z2 = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x2 = _addPxTranslate(target, x2, a13 * cos * -zOrigin);
      y2 = _addPxTranslate(target, y2, -Math.sin(angle) * -zOrigin);
      z2 = _addPxTranslate(target, z2, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x2 !== _zeroPx || y2 !== _zeroPx || z2 !== _zeroPx) {
      transforms += z2 !== _zeroPx || use3D ? "translate3d(" + x2 + ", " + y2 + ", " + z2 + ") " : "translate(" + x2 + ", " + y2 + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x2 = _ref2.x, y2 = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x2), ty = parseFloat(y2), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x2 + "").indexOf("px") || ty && !~(y2 + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x2, "px");
      ty = _convertToUnit(target, "y", y2, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
    var cap = 360, isString2 = _isString(endValue), endNum = parseFloat(endValue) * (isString2 && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change2 = endNum - startNum, finalValue = startNum + change2 + "deg", direction, pt;
    if (isString2) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change2 %= cap;
        if (change2 !== change2 % (cap / 2)) {
          change2 += change2 < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change2 < 0) {
        change2 = (change2 + cap * _bigNum2) % cap - ~~(change2 / cap) * cap;
      } else if (direction === "ccw" && change2 > 0) {
        change2 = (change2 - cap * _bigNum2) % cap - ~~(change2 / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change2, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  };
  var _assign = function _assign2(target, source) {
    for (var p2 in source) {
      target[p2] = source[p2];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p2, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p2 in _transformProps) {
      startValue = startCache[p2];
      endValue = endCache[p2];
      if (startValue !== endValue && exclude.indexOf(p2) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p2, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p2, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p2);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name, index2) {
    var t3 = "Top", r3 = "Right", b2 = "Bottom", l4 = "Left", props = (index2 < 3 ? [t3, r3, b2, l4] : [t3 + l4, t3 + r3, b2 + r3, b2 + l4]).map(function(side) {
      return index2 < 2 ? name + side : "border" + side + name;
    });
    _specialProps[index2 > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
      var a3, vars;
      if (arguments.length < 4) {
        a3 = props.map(function(prop) {
          return _get(plugin, prop, property);
        });
        vars = a3.join(" ");
        return vars.split(a3[0]).length === 5 ? a3[0] : vars;
      }
      a3 = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i4) {
        return vars[prop] = a3[i4] = a3[i4] || a3[(i4 - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index2, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p2, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p2 in vars) {
        if (p2 === "autoRound") {
          continue;
        }
        endValue = vars[p2];
        if (_plugins[p2] && _checkPlugin(p2, vars, tween, index2, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p2];
        if (type === "function") {
          endValue = endValue.call(tween, index2, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p2, endValue, tween) && (hasPriority = 1);
        } else if (p2.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p2) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p2, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index2, targets, 0, 0, p2);
          props.push(p2);
          inlineProps.push(p2, 0, style[p2]);
        } else if (type !== "undefined") {
          if (startAt && p2 in startAt) {
            startValue = typeof startAt[p2] === "function" ? startAt[p2].call(tween, index2, target, targets) : startAt[p2];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || (startValue += _config.units[p2] || getUnit(_get(target, p2)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p2));
          } else {
            startValue = _get(target, p2);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p2 in _propertyAliases) {
            if (p2 === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p2 !== "scale" && p2 !== "transform") {
              p2 = _propertyAliases[p2];
              ~p2.indexOf(",") && (p2 = p2.split(",")[0]);
            }
          }
          isTransformRelated = p2 in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p2);
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p2 === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p2);
              p2 += "X";
            } else if (p2 === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p2, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p2 === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p2 in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p2, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p2 === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p2 === "force3D") {
              cache[p2] = endValue;
              continue;
            } else if (p2 === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p2 in style)) {
            p2 = _checkPropPrefix(p2) || p2;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p2 in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p2 in _config.units ? _config.units[p2] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p2, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p2, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p2 === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p2 in style)) {
            if (p2 in target) {
              this.add(target, p2, startValue || target[p2], relative ? relative + endValue : endValue, index2, targets);
            } else {
              _missingPlugin(p2, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p2, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p2 in style ? inlineProps.push(p2, 0, style[p2]) : inlineProps.push(p2, 1, startValue || target[p2]));
          props.push(p2);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data) {
      if (data.tween._time || !_reverting2()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      var p2 = _propertyAliases[property];
      p2 && p2.indexOf(",") < 0 && (property = p2);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
      _transformProps[name] = 1;
    });
    _forEachName(rotation, function(name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
    _config.units[name] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // assets/scripts/utils/maths.js
  function lerp(start, end, amt) {
    return (1 - amt) * start + amt * end;
  }
  function map(value, min0, max0, min1, max1) {
    return min1 + (value - min0) / (max0 - min0) * (max1 - min1);
  }

  // assets/scripts/utils/array.js
  function shuffle3(a3) {
    for (let i4 = a3.length - 1; i4 > 0; i4--) {
      const j2 = Math.floor(Math.random() * (i4 + 1));
      [a3[i4], a3[j2]] = [a3[j2], a3[i4]];
    }
    return a3;
  }

  // assets/scripts/utils/image.js
  var LAZY_LOADED_IMAGES = [];
  var LOADED_IMAGES = [];
  function loadImage(url, options = {}) {
    return new Promise((resolve, reject) => {
      let loadedImage = LOADED_IMAGES.find((image2) => image2.url === url);
      if (loadedImage) {
        resolve(__spreadValues(__spreadValues({}, loadedImage), options));
      } else {
        const $img = new Image();
        if (options.crossOrigin) {
          $img.crossOrigin = options.crossOrigin;
        }
        const loadCallback = () => {
          const result = __spreadValues(__spreadValues({
            element: $img
          }, getImageMetadata($img)), options);
          LOADED_IMAGES.push(result);
          resolve(result);
        };
        if ($img.decode) {
          $img.src = url;
          $img.decode().then(loadCallback).catch((e4) => {
            reject(e4);
          });
        } else {
          $img.onload = loadCallback;
          $img.onerror = (e4) => {
            reject(e4);
          };
          $img.src = url;
        }
      }
    });
  }
  function getImageMetadata($img) {
    return {
      url: $img.src,
      width: $img.naturalWidth,
      height: $img.naturalHeight,
      ratio: $img.naturalWidth / $img.naturalHeight
    };
  }
  function lazyLoadImage($el, url, callback) {
    return __async(this, null, function* () {
      let src = url ? url : $el.dataset.src;
      let loadedImage = LAZY_LOADED_IMAGES.find((image2) => image2.url === src);
      if (!loadedImage) {
        loadedImage = yield loadImage(src);
        if (!loadedImage.url) {
          return;
        }
        LAZY_LOADED_IMAGES.push(loadedImage);
      }
      if ($el.src === src) {
        return;
      }
      if ($el.tagName === "IMG") {
        $el.src = loadedImage.url;
      } else {
        $el.style.backgroundImage = `url(${loadedImage.url})`;
      }
      requestAnimationFrame(() => {
        let lazyParent = $el.closest(".c-image");
        if (lazyParent) {
          lazyParent.classList.add("-loaded");
          lazyParent.style.backgroundImage = "";
        }
        $el.classList.add("-loaded");
        callback == null ? void 0 : callback();
      });
    });
  }
  function animDepixelate($el) {
    return __async(this, null, function* () {
      const $parent = $el.parentNode;
      $parent.classList.add("-pixelated");
      const previousCanvas = $parent.querySelector("canvas");
      if (previousCanvas) previousCanvas.remove();
      const canvas2 = document.createElement("canvas");
      canvas2.style.zIndex = 10;
      $parent.appendChild(canvas2);
      const ctx = canvas2.getContext("2d", { willReadFrequently: true });
      const maxWidth = 128;
      let w2 = $el.naturalWidth;
      let h4 = $el.naturalHeight;
      if (w2 > maxWidth) {
        h4 = maxWidth * (h4 / w2);
        w2 = maxWidth;
      }
      const pixelate = (sample_amount) => __async(this, null, function* () {
        return new Promise((resolve) => {
          if (!canvas2.parentNode) {
            resolve();
            return;
          }
          const sample_size = Math.round(w2 / sample_amount);
          ctx.canvas.width = w2;
          ctx.canvas.height = h4;
          ctx.drawImage($el, 0, 0, w2, h4);
          const pixelArr = ctx.getImageData(0, 0, w2, h4).data;
          for (let y2 = 0; y2 < h4; y2 += sample_size) {
            for (let x2 = 0; x2 < w2; x2 += sample_size) {
              const p2 = (x2 + y2 * w2) * 4;
              ctx.fillStyle = "rgba(" + pixelArr[p2] + "," + pixelArr[p2 + 1] + "," + pixelArr[p2 + 2] + "," + pixelArr[p2 + 3] + ")";
              ctx.fillRect(x2, y2, sample_size, sample_size);
            }
          }
          resolve();
        });
      });
      const ITERATION_DELAY = 100;
      const delay3 = (ms) => new Promise((res) => setTimeout(res, ms));
      yield pixelate(8);
      yield delay3(ITERATION_DELAY);
      yield pixelate(16);
      yield delay3(ITERATION_DELAY);
      yield pixelate(32);
      yield delay3(ITERATION_DELAY);
      yield pixelate(48);
      yield delay3(ITERATION_DELAY);
      yield pixelate(96);
      yield delay3(ITERATION_DELAY);
      yield pixelate(128);
      canvas2.remove();
      $parent.classList.remove("-pixelated");
    });
  }

  // assets/scripts/modules/FancyGallery.js
  function getVec2Dist(vec1, vec2) {
    return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
  }
  var FancyGallery_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.rotationAmplitude = 16;
      this.distanceToSpawn = 80;
      this.delayToSpawn = 500;
      this.minImages = 60;
      this.$images = [];
      this.timelines = [];
      this.currentIndex = 0;
      this.lastSpawnTime = Date.now();
    }
    init() {
      if (!this.$("image").length) {
        console.error("[FancyGallery] no images given");
        return false;
      }
      this.compute();
      this.populateImages();
      this.bindEvents();
      this.render();
    }
    compute() {
      this.isMobile = window.innerWidth < 700;
      this.canHover = window.matchMedia("(hover: hover)").matches;
      const BCR = this.el.getBoundingClientRect();
      const center = {
        x: BCR.width / 2,
        y: BCR.height / 2
      };
      this.target = __spreadValues({}, center);
      this.lerp = __spreadValues({}, center);
      this.lastSpawn = __spreadValues({}, center);
    }
    checkResize() {
      if (!this.resizeTick) {
        this.resizeTick = true;
        requestAnimationFrame(() => {
          this.compute();
          this.resizeTick = false;
        });
      }
    }
    bindEvents() {
      this.onMouseEnter = (e4) => {
        const enterPos = {
          x: e4.layerX,
          y: e4.layerY
        };
        this.target = __spreadValues({}, enterPos);
        this.lerp = __spreadValues({}, enterPos);
        this.lastSpawn = __spreadValues({}, enterPos);
      };
      this.onMouseMove = (e4) => {
        this.target = {
          x: e4.layerX,
          y: e4.layerY
        };
      };
      if (this.canHover && !this.isMobile) {
        this.el.addEventListener("mouseenter", this.onMouseEnter);
        this.el.addEventListener("mousemove", this.onMouseMove);
      }
      this.checkResizeBind = this.checkResize.bind(this);
      window.addEventListener("resize", this.checkResizeBind);
    }
    unbindEvents() {
      this.el.removeEventListener("mouseenter", this.onMouseEnter);
      this.el.removeEventListener("mousemove", this.onMouseMove);
      window.removeEventListener("resize", this.checkResizeBind);
    }
    render() {
      this.lerp = {
        x: lerp(this.lerp.x, this.target.x, 0.1),
        y: lerp(this.lerp.y, this.target.y, 0.1)
      };
      this.checkSpawn();
      this.raf = requestAnimationFrame(this.render.bind(this));
    }
    checkSpawn() {
      if (this.canHover && !this.isMobile) {
        const dist = Math.abs(getVec2Dist(this.lastSpawn, this.lerp));
        if (dist > this.distanceToSpawn) {
          this.spawn();
        }
      } else {
        const delay3 = Date.now() - this.lastSpawnTime;
        if (delay3 > this.delayToSpawn) {
          this.spawn();
        }
      }
    }
    spawn() {
      this.lastSpawn = this.lerp;
      this.lastSpawnTime = Date.now();
      const target = this.$images[this.currentIndex % this.$images.length];
      const inner = target.querySelector(".c-image_inner");
      const img = target.querySelector("img");
      if (img) {
        if (!img.classList.contains("-loaded")) {
          lazyLoadImage(img, null);
        }
      }
      const tl = gsapWithCSS.timeline({
        onComplete: () => {
          this.timelines.splice(this.timelines.indexOf(tl), 1);
        }
      });
      tl.set(target, { force3D: true, x: this.lastSpawn.x, y: this.lastSpawn.y, zIndex: this.currentIndex });
      tl.set(inner, { opacity: 0, scale: 0.5, force3D: true });
      tl.to(inner, { opacity: 1, duration: 0.15 }, 0);
      tl.to(inner, { force3D: true, scale: 1, rotation: Math.random() * this.rotationAmplitude - this.rotationAmplitude / 2, duration: 0.25 }, 0);
      tl.to(inner, { force3D: true, scale: 1.2, duration: 1 });
      tl.to(inner, { force3D: true, scale: 0.5, rotation: Math.random() * this.rotationAmplitude - this.rotationAmplitude / 2, opacity: 0, duration: 0.3, ease: "power2.in" });
      this.timelines.push(tl);
      this.currentIndex++;
    }
    populateImages() {
      const images = shuffle3(Array.from(this.$("image")));
      for (let image2 of images) {
        image2.parentNode.appendChild(image2);
      }
      for (let i4 = 0; i4 < Math.ceil(this.minImages / images.length); i4++) {
        for (let image2 of Array.from(images)) {
          const clone2 = image2.cloneNode(true);
          image2.parentNode.appendChild(clone2);
        }
      }
      this.$images = Array.from(this.$("image"));
    }
    destroy() {
      super.destroy();
      for (let tl of this.timelines) {
        tl.kill();
        tl = null;
      }
      this.unbindEvents();
    }
  };

  // node_modules/gsap/utils/strings.js
  var emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
  function getText(e4) {
    var type = e4.nodeType, result = "";
    if (type === 1 || type === 9 || type === 11) {
      if (typeof e4.textContent === "string") {
        return e4.textContent;
      } else {
        for (e4 = e4.firstChild; e4; e4 = e4.nextSibling) {
          result += getText(e4);
        }
      }
    } else if (type === 3 || type === 4) {
      return e4.nodeValue;
    }
    return result;
  }

  // node_modules/gsap/SplitText.js
  var _doc3;
  var _win3;
  var _coreInitted2;
  var _stripExp = /(?:\r|\n|\t\t)/g;
  var _multipleSpacesExp = /(?:\s\s+)/g;
  var _initCore3 = function _initCore4() {
    _doc3 = document;
    _win3 = window;
    _coreInitted2 = 1;
  };
  var _bonusValidated = 1;
  var _getComputedStyle = function _getComputedStyle2(element) {
    return _win3.getComputedStyle(element);
  };
  var _isArray2 = Array.isArray;
  var _slice2 = [].slice;
  var _toArray = function _toArray2(value, leaveStrings) {
    var type;
    return _isArray2(value) ? value : (type = typeof value) === "string" && !leaveStrings && value ? _slice2.call(_doc3.querySelectorAll(value), 0) : value && type === "object" && "length" in value ? _slice2.call(value, 0) : value ? [value] : [];
  };
  var _isAbsolute = function _isAbsolute2(vars) {
    return vars.position === "absolute" || vars.absolute === true;
  };
  var _findSpecialChars = function _findSpecialChars2(text2, chars) {
    var i4 = chars.length, s4;
    while (--i4 > -1) {
      s4 = chars[i4];
      if (text2.substr(0, s4.length) === s4) {
        return s4.length;
      }
    }
  };
  var _divStart = " style='position:relative;display:inline-block;'";
  var _cssClassFunc = function _cssClassFunc2(cssClass, tag) {
    if (cssClass === void 0) {
      cssClass = "";
    }
    var iterate = ~cssClass.indexOf("++"), num = 1;
    if (iterate) {
      cssClass = cssClass.split("++").join("");
    }
    return function() {
      return "<" + tag + _divStart + (cssClass ? " class='" + cssClass + (iterate ? num++ : "") + "'>" : ">");
    };
  };
  var _swapText = function _swapText2(element, oldText, newText) {
    var type = element.nodeType;
    if (type === 1 || type === 9 || type === 11) {
      for (element = element.firstChild; element; element = element.nextSibling) {
        _swapText2(element, oldText, newText);
      }
    } else if (type === 3 || type === 4) {
      element.nodeValue = element.nodeValue.split(oldText).join(newText);
    }
  };
  var _pushReversed = function _pushReversed2(a3, merge) {
    var i4 = merge.length;
    while (--i4 > -1) {
      a3.push(merge[i4]);
    }
  };
  var _isBeforeWordDelimiter = function _isBeforeWordDelimiter2(e4, root, wordDelimiter) {
    var next2;
    while (e4 && e4 !== root) {
      next2 = e4._next || e4.nextSibling;
      if (next2) {
        return next2.textContent.charAt(0) === wordDelimiter;
      }
      e4 = e4.parentNode || e4._parent;
    }
  };
  var _deWordify = function _deWordify2(e4) {
    var children2 = _toArray(e4.childNodes), l4 = children2.length, i4, child;
    for (i4 = 0; i4 < l4; i4++) {
      child = children2[i4];
      if (child._isSplit) {
        _deWordify2(child);
      } else {
        if (i4 && child.previousSibling && child.previousSibling.nodeType === 3) {
          child.previousSibling.nodeValue += child.nodeType === 3 ? child.nodeValue : child.firstChild.nodeValue;
          e4.removeChild(child);
        } else if (child.nodeType !== 3) {
          e4.insertBefore(child.firstChild, child);
          e4.removeChild(child);
        }
      }
    }
  };
  var _getStyleAsNumber = function _getStyleAsNumber2(name, computedStyle) {
    return parseFloat(computedStyle[name]) || 0;
  };
  var _setPositionsAfterSplit = function _setPositionsAfterSplit2(element, vars, allChars, allWords, allLines, origWidth, origHeight) {
    var cs = _getComputedStyle(element), paddingLeft = _getStyleAsNumber("paddingLeft", cs), lineOffsetY = -999, borderTopAndBottom = _getStyleAsNumber("borderBottomWidth", cs) + _getStyleAsNumber("borderTopWidth", cs), borderLeftAndRight = _getStyleAsNumber("borderLeftWidth", cs) + _getStyleAsNumber("borderRightWidth", cs), padTopAndBottom = _getStyleAsNumber("paddingTop", cs) + _getStyleAsNumber("paddingBottom", cs), padLeftAndRight = _getStyleAsNumber("paddingLeft", cs) + _getStyleAsNumber("paddingRight", cs), lineThreshold = _getStyleAsNumber("fontSize", cs) * (vars.lineThreshold || 0.2), textAlign = cs.textAlign, charArray = [], wordArray = [], lineArray = [], wordDelimiter = vars.wordDelimiter || " ", tag = vars.tag ? vars.tag : vars.span ? "span" : "div", types = vars.type || vars.split || "chars,words,lines", lines = allLines && ~types.indexOf("lines") ? [] : null, words = ~types.indexOf("words"), chars = ~types.indexOf("chars"), absolute = _isAbsolute(vars), linesClass = vars.linesClass, iterateLine = ~(linesClass || "").indexOf("++"), spaceNodesToRemove = [], isFlex = cs.display === "flex", prevInlineDisplay = element.style.display, i4, j2, l4, node, nodes, isChild, curLine, addWordSpaces, style, lineNode, lineWidth, offset2;
    iterateLine && (linesClass = linesClass.split("++").join(""));
    isFlex && (element.style.display = "block");
    j2 = element.getElementsByTagName("*");
    l4 = j2.length;
    nodes = [];
    for (i4 = 0; i4 < l4; i4++) {
      nodes[i4] = j2[i4];
    }
    if (lines || absolute) {
      for (i4 = 0; i4 < l4; i4++) {
        node = nodes[i4];
        isChild = node.parentNode === element;
        if (isChild || absolute || chars && !words) {
          offset2 = node.offsetTop;
          if (lines && isChild && Math.abs(offset2 - lineOffsetY) > lineThreshold && (node.nodeName !== "BR" || i4 === 0)) {
            curLine = [];
            lines.push(curLine);
            lineOffsetY = offset2;
          }
          if (absolute) {
            node._x = node.offsetLeft;
            node._y = offset2;
            node._w = node.offsetWidth;
            node._h = node.offsetHeight;
          }
          if (lines) {
            if (node._isSplit && isChild || !chars && isChild || words && isChild || !words && node.parentNode.parentNode === element && !node.parentNode._isSplit) {
              curLine.push(node);
              node._x -= paddingLeft;
              if (_isBeforeWordDelimiter(node, element, wordDelimiter)) {
                node._wordEnd = true;
              }
            }
            if (node.nodeName === "BR" && (node.nextSibling && node.nextSibling.nodeName === "BR" || i4 === 0)) {
              lines.push([]);
            }
          }
        }
      }
    }
    for (i4 = 0; i4 < l4; i4++) {
      node = nodes[i4];
      isChild = node.parentNode === element;
      if (node.nodeName === "BR") {
        if (lines || absolute) {
          node.parentNode && node.parentNode.removeChild(node);
          nodes.splice(i4--, 1);
          l4--;
        } else if (!words) {
          element.appendChild(node);
        }
        continue;
      }
      if (absolute) {
        style = node.style;
        if (!words && !isChild) {
          node._x += node.parentNode._x;
          node._y += node.parentNode._y;
        }
        style.left = node._x + "px";
        style.top = node._y + "px";
        style.position = "absolute";
        style.display = "block";
        style.width = node._w + 1 + "px";
        style.height = node._h + "px";
      }
      if (!words && chars) {
        if (node._isSplit) {
          node._next = j2 = node.nextSibling;
          node.parentNode.appendChild(node);
          while (j2 && j2.nodeType === 3 && j2.textContent === " ") {
            node._next = j2.nextSibling;
            node.parentNode.appendChild(j2);
            j2 = j2.nextSibling;
          }
        } else if (node.parentNode._isSplit) {
          node._parent = node.parentNode;
          if (!node.previousSibling && node.firstChild) {
            node.firstChild._isFirst = true;
          }
          if (node.nextSibling && node.nextSibling.textContent === " " && !node.nextSibling.nextSibling) {
            spaceNodesToRemove.push(node.nextSibling);
          }
          node._next = node.nextSibling && node.nextSibling._isFirst ? null : node.nextSibling;
          node.parentNode.removeChild(node);
          nodes.splice(i4--, 1);
          l4--;
        } else if (!isChild) {
          offset2 = !node.nextSibling && _isBeforeWordDelimiter(node.parentNode, element, wordDelimiter);
          node.parentNode._parent && node.parentNode._parent.appendChild(node);
          offset2 && node.parentNode.appendChild(_doc3.createTextNode(" "));
          if (tag === "span") {
            node.style.display = "inline";
          }
          charArray.push(node);
        }
      } else if (node.parentNode._isSplit && !node._isSplit && node.innerHTML !== "") {
        wordArray.push(node);
      } else if (chars && !node._isSplit) {
        if (tag === "span") {
          node.style.display = "inline";
        }
        charArray.push(node);
      }
    }
    i4 = spaceNodesToRemove.length;
    while (--i4 > -1) {
      spaceNodesToRemove[i4].parentNode.removeChild(spaceNodesToRemove[i4]);
    }
    if (lines) {
      if (absolute) {
        lineNode = _doc3.createElement(tag);
        element.appendChild(lineNode);
        lineWidth = lineNode.offsetWidth + "px";
        offset2 = lineNode.offsetParent === element ? 0 : element.offsetLeft;
        element.removeChild(lineNode);
      }
      style = element.style.cssText;
      element.style.cssText = "display:none;";
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
      addWordSpaces = wordDelimiter === " " && (!absolute || !words && !chars);
      for (i4 = 0; i4 < lines.length; i4++) {
        curLine = lines[i4];
        lineNode = _doc3.createElement(tag);
        lineNode.style.cssText = "display:block;text-align:" + textAlign + ";position:" + (absolute ? "absolute;" : "relative;");
        if (linesClass) {
          lineNode.className = linesClass + (iterateLine ? i4 + 1 : "");
        }
        lineArray.push(lineNode);
        l4 = curLine.length;
        for (j2 = 0; j2 < l4; j2++) {
          if (curLine[j2].nodeName !== "BR") {
            node = curLine[j2];
            lineNode.appendChild(node);
            addWordSpaces && node._wordEnd && lineNode.appendChild(_doc3.createTextNode(" "));
            if (absolute) {
              if (j2 === 0) {
                lineNode.style.top = node._y + "px";
                lineNode.style.left = paddingLeft + offset2 + "px";
              }
              node.style.top = "0px";
              if (offset2) {
                node.style.left = node._x - offset2 + "px";
              }
            }
          }
        }
        if (l4 === 0) {
          lineNode.innerHTML = "&nbsp;";
        } else if (!words && !chars) {
          _deWordify(lineNode);
          _swapText(lineNode, String.fromCharCode(160), " ");
        }
        if (absolute) {
          lineNode.style.width = lineWidth;
          lineNode.style.height = node._h + "px";
        }
        element.appendChild(lineNode);
      }
      element.style.cssText = style;
    }
    if (absolute) {
      if (origHeight > element.clientHeight) {
        element.style.height = origHeight - padTopAndBottom + "px";
        if (element.clientHeight < origHeight) {
          element.style.height = origHeight + borderTopAndBottom + "px";
        }
      }
      if (origWidth > element.clientWidth) {
        element.style.width = origWidth - padLeftAndRight + "px";
        if (element.clientWidth < origWidth) {
          element.style.width = origWidth + borderLeftAndRight + "px";
        }
      }
    }
    isFlex && (prevInlineDisplay ? element.style.display = prevInlineDisplay : element.style.removeProperty("display"));
    _pushReversed(allChars, charArray);
    words && _pushReversed(allWords, wordArray);
    _pushReversed(allLines, lineArray);
  };
  var _splitRawText = function _splitRawText2(element, vars, wordStart, charStart) {
    var tag = vars.tag ? vars.tag : vars.span ? "span" : "div", types = vars.type || vars.split || "chars,words,lines", chars = ~types.indexOf("chars"), absolute = _isAbsolute(vars), wordDelimiter = vars.wordDelimiter || " ", space = wordDelimiter !== " " ? "" : absolute ? "&#173; " : " ", wordEnd = "</" + tag + ">", wordIsOpen = 1, specialChars = vars.specialChars ? typeof vars.specialChars === "function" ? vars.specialChars : _findSpecialChars : null, text2, splitText, i4, j2, l4, character, hasTagStart, testResult, container = _doc3.createElement("div"), parent2 = element.parentNode;
    parent2.insertBefore(container, element);
    container.textContent = element.nodeValue;
    parent2.removeChild(element);
    element = container;
    text2 = getText(element);
    hasTagStart = text2.indexOf("<") !== -1;
    if (vars.reduceWhiteSpace !== false) {
      text2 = text2.replace(_multipleSpacesExp, " ").replace(_stripExp, "");
    }
    if (hasTagStart) {
      text2 = text2.split("<").join("{{LT}}");
    }
    l4 = text2.length;
    splitText = (text2.charAt(0) === " " ? space : "") + wordStart();
    for (i4 = 0; i4 < l4; i4++) {
      character = text2.charAt(i4);
      if (specialChars && (testResult = specialChars(text2.substr(i4), vars.specialChars))) {
        character = text2.substr(i4, testResult || 1);
        splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;
        i4 += testResult - 1;
      } else if (character === wordDelimiter && text2.charAt(i4 - 1) !== wordDelimiter && i4) {
        splitText += wordIsOpen ? wordEnd : "";
        wordIsOpen = 0;
        while (text2.charAt(i4 + 1) === wordDelimiter) {
          splitText += space;
          i4++;
        }
        if (i4 === l4 - 1) {
          splitText += space;
        } else if (text2.charAt(i4 + 1) !== ")") {
          splitText += space + wordStart();
          wordIsOpen = 1;
        }
      } else if (character === "{" && text2.substr(i4, 6) === "{{LT}}") {
        splitText += chars ? charStart() + "{{LT}}</" + tag + ">" : "{{LT}}";
        i4 += 5;
      } else if (character.charCodeAt(0) >= 55296 && character.charCodeAt(0) <= 56319 || text2.charCodeAt(i4 + 1) >= 65024 && text2.charCodeAt(i4 + 1) <= 65039) {
        j2 = ((text2.substr(i4, 12).split(emojiExp) || [])[1] || "").length || 2;
        splitText += chars && character !== " " ? charStart() + text2.substr(i4, j2) + "</" + tag + ">" : text2.substr(i4, j2);
        i4 += j2 - 1;
      } else {
        splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;
      }
    }
    element.outerHTML = splitText + (wordIsOpen ? wordEnd : "");
    hasTagStart && _swapText(parent2, "{{LT}}", "<");
  };
  var _split = function _split2(element, vars, wordStart, charStart) {
    var children2 = _toArray(element.childNodes), l4 = children2.length, absolute = _isAbsolute(vars), i4, child;
    if (element.nodeType !== 3 || l4 > 1) {
      vars.absolute = false;
      for (i4 = 0; i4 < l4; i4++) {
        child = children2[i4];
        child._next = child._isFirst = child._parent = child._wordEnd = null;
        if (child.nodeType !== 3 || /\S+/.test(child.nodeValue)) {
          if (absolute && child.nodeType !== 3 && _getComputedStyle(child).display === "inline") {
            child.style.display = "inline-block";
            child.style.position = "relative";
          }
          child._isSplit = true;
          _split2(child, vars, wordStart, charStart);
        }
      }
      vars.absolute = absolute;
      element._isSplit = true;
      return;
    }
    _splitRawText(element, vars, wordStart, charStart);
  };
  var SplitText = /* @__PURE__ */ function() {
    function SplitText2(element, vars) {
      _coreInitted2 || _initCore3();
      this.elements = _toArray(element);
      this.chars = [];
      this.words = [];
      this.lines = [];
      this._originals = [];
      this.vars = vars || {};
      _bonusValidated && this.split(vars);
    }
    var _proto = SplitText2.prototype;
    _proto.split = function split(vars) {
      this.isSplit && this.revert();
      this.vars = vars = vars || this.vars;
      this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
      var i4 = this.elements.length, tag = vars.tag ? vars.tag : vars.span ? "span" : "div", wordStart = _cssClassFunc(vars.wordsClass, tag), charStart = _cssClassFunc(vars.charsClass, tag), origHeight, origWidth, e4;
      while (--i4 > -1) {
        e4 = this.elements[i4];
        this._originals[i4] = e4.innerHTML;
        origHeight = e4.clientHeight;
        origWidth = e4.clientWidth;
        _split(e4, vars, wordStart, charStart);
        _setPositionsAfterSplit(e4, vars, this.chars, this.words, this.lines, origWidth, origHeight);
      }
      this.chars.reverse();
      this.words.reverse();
      this.lines.reverse();
      this.isSplit = true;
      return this;
    };
    _proto.revert = function revert() {
      var originals = this._originals;
      if (!originals) {
        throw "revert() call wasn't scoped properly.";
      }
      this.elements.forEach(function(e4, i4) {
        return e4.innerHTML = originals[i4];
      });
      this.chars = [];
      this.words = [];
      this.lines = [];
      this.isSplit = false;
      return this;
    };
    SplitText2.create = function create(element, vars) {
      return new SplitText2(element, vars);
    };
    return SplitText2;
  }();
  SplitText.version = "3.11.3";

  // assets/scripts/modules/FancyTexts.js
  gsapWithCSS.registerPlugin(SplitText);
  var FancyTexts_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$cols = Array.from(this.$("col"));
      this.timelines = {};
    }
    init() {
      if (!this.$cols.length) {
        console.error("[FancyTexts] no cols given");
        return false;
      }
      for (let col of this.$cols) {
        const animations = this.getData("animations", col) ? this.getData("animations", col).split(",") : ["base", "stagger", "shuffle", "scramble", "fast"];
        let contentIndex = -1;
        let contents = this.getData("contents", col).split("|");
        let rows = this.getData("rows", col);
        if (rows != "manual") rows = parseInt(rows);
        let tl;
        let populate = (content) => {
          col.innerHTML = "";
          let row = document.createElement("div");
          row.innerText = content;
          if (rows == "manual") {
            let sentences = content.split(",");
            for (let sentence of sentences) {
              row.innerText = sentence;
              col.appendChild(row.cloneNode(true));
            }
          } else {
            for (let i4 = 0; i4 < rows; i4++)
              col.appendChild(row.cloneNode(true));
          }
        };
        let startNextContent = () => {
          var _a, _b;
          contentIndex++;
          const content = contents[contentIndex % contents.length];
          populate(content, 7);
          this.timelines[this.$cols.indexOf(col)] && ((_b = (_a = this.timelines[this.$cols.indexOf(col)]).kill) == null ? void 0 : _b.call(_a));
          tl = gsapWithCSS.timeline({
            onComplete: () => {
              gsapWithCSS.set(col, { opacity: 0 });
              split.revert();
              requestAnimationFrame(() => {
                startNextContent();
              });
            }
          });
          this.timelines[this.$cols.indexOf(col)] = tl;
          let split = new SplitText(col, { type: "chars" });
          tl.set(split.chars, { opacity: 0 });
          tl.set(col, { opacity: 1 });
          const animation = animations[Math.floor(animations.length * Math.random())];
          switch (animation) {
            case "base":
              for (let i4 = 0; i4 < col.children.length; i4++) {
                tl.set([...col.children[i4].children], { opacity: 1, stagger: 0.04 }, "row" + i4);
              }
              tl.set(shuffle3(Array.from(split.chars)), { opacity: 0, stagger: 0.04 });
              tl.add(() => {
              }, "+=1");
              break;
            case "stagger":
              for (let i4 = 0; i4 < col.children.length; i4++) {
                tl.set([...col.children[i4].children], { opacity: 1, stagger: 0.04 }, i4 * 0.1);
                tl.addLabel(i4 + "first");
                if (i4 > 0) {
                  tl.set([...col.children[i4 - 1].children], { opacity: 0, stagger: 0.04 }, i4 - 1 + "first");
                }
              }
              break;
            case "shuffle":
              for (let i4 = 0; i4 < col.children.length; i4++) {
                tl.set([...col.children[i4].children], { opacity: 1, stagger: 0.04 }, i4 * 0.1);
                tl.addLabel(i4 + "out");
                if (i4 > 0) {
                  tl.set(shuffle3([...col.children[i4 - 1].children]), { opacity: 0, stagger: 0.08 }, i4 - 1 + "out");
                }
              }
              break;
            case "scramble":
              for (let i4 = 0; i4 < col.children.length; i4++) {
                tl.set([...col.children[i4].children], { opacity: 1, stagger: 0.04 });
                tl.addLabel(i4 + "out");
                if (i4 > 0) {
                  tl.add(() => {
                    let alternateChars = "~!@#$%&*{}/?;;<>[]".split("");
                    let chars = shuffle3([...col.children[i4 - 1].children]);
                    for (let j2 = 0; j2 < chars.length; j2++) {
                      setTimeout(() => {
                        chars[j2].innerText = alternateChars[Math.floor(alternateChars.length * Math.random())];
                      }, 200 * j2);
                      setTimeout(() => {
                        gsapWithCSS.set(chars[j2], { opacity: 0 });
                      }, 400 * j2);
                    }
                  }, i4 - 1 + "out");
                }
              }
              tl.set(shuffle3(Array.from(split.chars)), { opacity: 0, stagger: 0.01 });
              break;
            case "fast":
              for (let i4 = 0; i4 < col.children.length; i4++) {
                tl.set([...col.children[i4].children], { opacity: 1, stagger: 0.02 }, "row" + i4);
                if (i4 > 0) tl.set([...col.children[i4 - 1].children], { opacity: 0, stagger: 0.02 }, "row" + i4);
              }
              break;
            case "slow":
              for (let i4 = 0; i4 < col.children.length; i4++) {
                tl.set([...col.children[i4].children], { opacity: 1, stagger: 0.1 }, "row" + i4);
                tl.add(() => {
                }, "row" + i4 + "+=.5");
                if (i4 > 0) tl.set(shuffle3([...col.children[i4 - 1].children]), { opacity: 0, stagger: 0.2 }, "row" + i4);
              }
              tl.add(() => {
              }, "+=1");
              break;
          }
        };
        startNextContent();
      }
    }
    destroy() {
      var _a, _b;
      for (let key of Object.keys(this.timelines)) {
        this.timelines[key] && ((_b = (_a = this.timelines[key]).kill) == null ? void 0 : _b.call(_a));
      }
    }
  };

  // assets/scripts/modules/FeaturedLinks.js
  var FeaturedLinks_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$items = Array.from(this.$("item"));
    }
    init() {
      this.touchStartBind = () => {
        this.isTouch = true;
      };
      this.el.addEventListener("touchstart", this.touchStartBind, { once: true });
      this.enter = (e4) => {
        if (this.isTouch) return;
        const img = e4.target.querySelector("img");
        if (img) {
          if (!img.classList.contains("-loaded")) {
            lazyLoadImage(img, null, () => {
              animDepixelate(img);
            });
          } else {
            animDepixelate(img);
          }
        }
      };
      for (let item of this.$items) {
        item.addEventListener("mouseenter", this.enter);
        item.addEventListener("focusin", this.enter);
      }
    }
    destroy() {
      for (let item of this.$items) {
        item.removeEventListener("mouseenter", this.enter);
        item.removeEventListener("focusin", this.enter);
      }
    }
  };

  // node_modules/ssr-window/ssr-window.esm.js
  function isObject(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
  }
  function extend(target = {}, src = {}) {
    Object.keys(src).forEach((key) => {
      if (typeof target[key] === "undefined")
        target[key] = src[key];
      else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
        extend(target[key], src[key]);
      }
    });
  }
  var ssrDocument = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function getDocument() {
    const doc = typeof document !== "undefined" ? document : {};
    extend(doc, ssrDocument);
    return doc;
  }
  var ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function CustomEvent2() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(callback) {
      if (typeof setTimeout === "undefined") {
        callback();
        return null;
      }
      return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
      if (typeof setTimeout === "undefined") {
        return;
      }
      clearTimeout(id);
    }
  };
  function getWindow() {
    const win = typeof window !== "undefined" ? window : {};
    extend(win, ssrWindow);
    return win;
  }

  // node_modules/dom7/dom7.esm.js
  function makeReactive(obj) {
    const proto = obj.__proto__;
    Object.defineProperty(obj, "__proto__", {
      get() {
        return proto;
      },
      set(value) {
        proto.__proto__ = value;
      }
    });
  }
  var Dom7 = class extends Array {
    constructor(items) {
      if (typeof items === "number") {
        super(items);
      } else {
        super(...items || []);
        makeReactive(this);
      }
    }
  };
  function arrayFlat(arr = []) {
    const res = [];
    arr.forEach((el) => {
      if (Array.isArray(el)) {
        res.push(...arrayFlat(el));
      } else {
        res.push(el);
      }
    });
    return res;
  }
  function arrayFilter(arr, callback) {
    return Array.prototype.filter.call(arr, callback);
  }
  function arrayUnique(arr) {
    const uniqueArray = [];
    for (let i4 = 0; i4 < arr.length; i4 += 1) {
      if (uniqueArray.indexOf(arr[i4]) === -1) uniqueArray.push(arr[i4]);
    }
    return uniqueArray;
  }
  function qsa(selector3, context3) {
    if (typeof selector3 !== "string") {
      return [selector3];
    }
    const a3 = [];
    const res = context3.querySelectorAll(selector3);
    for (let i4 = 0; i4 < res.length; i4 += 1) {
      a3.push(res[i4]);
    }
    return a3;
  }
  function $2(selector3, context3) {
    const window2 = getWindow();
    const document2 = getDocument();
    let arr = [];
    if (!context3 && selector3 instanceof Dom7) {
      return selector3;
    }
    if (!selector3) {
      return new Dom7(arr);
    }
    if (typeof selector3 === "string") {
      const html3 = selector3.trim();
      if (html3.indexOf("<") >= 0 && html3.indexOf(">") >= 0) {
        let toCreate = "div";
        if (html3.indexOf("<li") === 0) toCreate = "ul";
        if (html3.indexOf("<tr") === 0) toCreate = "tbody";
        if (html3.indexOf("<td") === 0 || html3.indexOf("<th") === 0) toCreate = "tr";
        if (html3.indexOf("<tbody") === 0) toCreate = "table";
        if (html3.indexOf("<option") === 0) toCreate = "select";
        const tempParent = document2.createElement(toCreate);
        tempParent.innerHTML = html3;
        for (let i4 = 0; i4 < tempParent.childNodes.length; i4 += 1) {
          arr.push(tempParent.childNodes[i4]);
        }
      } else {
        arr = qsa(selector3.trim(), context3 || document2);
      }
    } else if (selector3.nodeType || selector3 === window2 || selector3 === document2) {
      arr.push(selector3);
    } else if (Array.isArray(selector3)) {
      if (selector3 instanceof Dom7) return selector3;
      arr = selector3;
    }
    return new Dom7(arrayUnique(arr));
  }
  $2.fn = Dom7.prototype;
  function addClass(...classes) {
    const classNames = arrayFlat(classes.map((c3) => c3.split(" ")));
    this.forEach((el) => {
      el.classList.add(...classNames);
    });
    return this;
  }
  function removeClass(...classes) {
    const classNames = arrayFlat(classes.map((c3) => c3.split(" ")));
    this.forEach((el) => {
      el.classList.remove(...classNames);
    });
    return this;
  }
  function toggleClass(...classes) {
    const classNames = arrayFlat(classes.map((c3) => c3.split(" ")));
    this.forEach((el) => {
      classNames.forEach((className) => {
        el.classList.toggle(className);
      });
    });
  }
  function hasClass(...classes) {
    const classNames = arrayFlat(classes.map((c3) => c3.split(" ")));
    return arrayFilter(this, (el) => {
      return classNames.filter((className) => el.classList.contains(className)).length > 0;
    }).length > 0;
  }
  function attr(attrs, value) {
    if (arguments.length === 1 && typeof attrs === "string") {
      if (this[0]) return this[0].getAttribute(attrs);
      return void 0;
    }
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      if (arguments.length === 2) {
        this[i4].setAttribute(attrs, value);
      } else {
        for (const attrName in attrs) {
          this[i4][attrName] = attrs[attrName];
          this[i4].setAttribute(attrName, attrs[attrName]);
        }
      }
    }
    return this;
  }
  function removeAttr(attr2) {
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      this[i4].removeAttribute(attr2);
    }
    return this;
  }
  function transform(transform2) {
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      this[i4].style.transform = transform2;
    }
    return this;
  }
  function transition(duration) {
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      this[i4].style.transitionDuration = typeof duration !== "string" ? `${duration}ms` : duration;
    }
    return this;
  }
  function on(...args) {
    let [eventType, targetSelector, listener, capture] = args;
    if (typeof args[1] === "function") {
      [eventType, listener, capture] = args;
      targetSelector = void 0;
    }
    if (!capture) capture = false;
    function handleLiveEvent(e4) {
      const target = e4.target;
      if (!target) return;
      const eventData = e4.target.dom7EventData || [];
      if (eventData.indexOf(e4) < 0) {
        eventData.unshift(e4);
      }
      if ($2(target).is(targetSelector)) listener.apply(target, eventData);
      else {
        const parents2 = $2(target).parents();
        for (let k2 = 0; k2 < parents2.length; k2 += 1) {
          if ($2(parents2[k2]).is(targetSelector)) listener.apply(parents2[k2], eventData);
        }
      }
    }
    function handleEvent(e4) {
      const eventData = e4 && e4.target ? e4.target.dom7EventData || [] : [];
      if (eventData.indexOf(e4) < 0) {
        eventData.unshift(e4);
      }
      listener.apply(this, eventData);
    }
    const events2 = eventType.split(" ");
    let j2;
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      const el = this[i4];
      if (!targetSelector) {
        for (j2 = 0; j2 < events2.length; j2 += 1) {
          const event2 = events2[j2];
          if (!el.dom7Listeners) el.dom7Listeners = {};
          if (!el.dom7Listeners[event2]) el.dom7Listeners[event2] = [];
          el.dom7Listeners[event2].push({
            listener,
            proxyListener: handleEvent
          });
          el.addEventListener(event2, handleEvent, capture);
        }
      } else {
        for (j2 = 0; j2 < events2.length; j2 += 1) {
          const event2 = events2[j2];
          if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
          if (!el.dom7LiveListeners[event2]) el.dom7LiveListeners[event2] = [];
          el.dom7LiveListeners[event2].push({
            listener,
            proxyListener: handleLiveEvent
          });
          el.addEventListener(event2, handleLiveEvent, capture);
        }
      }
    }
    return this;
  }
  function off(...args) {
    let [eventType, targetSelector, listener, capture] = args;
    if (typeof args[1] === "function") {
      [eventType, listener, capture] = args;
      targetSelector = void 0;
    }
    if (!capture) capture = false;
    const events2 = eventType.split(" ");
    for (let i4 = 0; i4 < events2.length; i4 += 1) {
      const event2 = events2[i4];
      for (let j2 = 0; j2 < this.length; j2 += 1) {
        const el = this[j2];
        let handlers;
        if (!targetSelector && el.dom7Listeners) {
          handlers = el.dom7Listeners[event2];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers = el.dom7LiveListeners[event2];
        }
        if (handlers && handlers.length) {
          for (let k2 = handlers.length - 1; k2 >= 0; k2 -= 1) {
            const handler = handlers[k2];
            if (listener && handler.listener === listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers.splice(k2, 1);
            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers.splice(k2, 1);
            } else if (!listener) {
              el.removeEventListener(event2, handler.proxyListener, capture);
              handlers.splice(k2, 1);
            }
          }
        }
      }
    }
    return this;
  }
  function trigger(...args) {
    const window2 = getWindow();
    const events2 = args[0].split(" ");
    const eventData = args[1];
    for (let i4 = 0; i4 < events2.length; i4 += 1) {
      const event2 = events2[i4];
      for (let j2 = 0; j2 < this.length; j2 += 1) {
        const el = this[j2];
        if (window2.CustomEvent) {
          const evt = new window2.CustomEvent(event2, {
            detail: eventData,
            bubbles: true,
            cancelable: true
          });
          el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
          el.dispatchEvent(evt);
          el.dom7EventData = [];
          delete el.dom7EventData;
        }
      }
    }
    return this;
  }
  function transitionEnd(callback) {
    const dom = this;
    function fireCallBack(e4) {
      if (e4.target !== this) return;
      callback.call(this, e4);
      dom.off("transitionend", fireCallBack);
    }
    if (callback) {
      dom.on("transitionend", fireCallBack);
    }
    return this;
  }
  function outerWidth(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles2 = this.styles();
        return this[0].offsetWidth + parseFloat(styles2.getPropertyValue("margin-right")) + parseFloat(styles2.getPropertyValue("margin-left"));
      }
      return this[0].offsetWidth;
    }
    return null;
  }
  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        const styles2 = this.styles();
        return this[0].offsetHeight + parseFloat(styles2.getPropertyValue("margin-top")) + parseFloat(styles2.getPropertyValue("margin-bottom"));
      }
      return this[0].offsetHeight;
    }
    return null;
  }
  function offset() {
    if (this.length > 0) {
      const window2 = getWindow();
      const document2 = getDocument();
      const el = this[0];
      const box = el.getBoundingClientRect();
      const body2 = document2.body;
      const clientTop = el.clientTop || body2.clientTop || 0;
      const clientLeft = el.clientLeft || body2.clientLeft || 0;
      const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
      const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
      return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }
    return null;
  }
  function styles() {
    const window2 = getWindow();
    if (this[0]) return window2.getComputedStyle(this[0], null);
    return {};
  }
  function css(props, value) {
    const window2 = getWindow();
    let i4;
    if (arguments.length === 1) {
      if (typeof props === "string") {
        if (this[0]) return window2.getComputedStyle(this[0], null).getPropertyValue(props);
      } else {
        for (i4 = 0; i4 < this.length; i4 += 1) {
          for (const prop in props) {
            this[i4].style[prop] = props[prop];
          }
        }
        return this;
      }
    }
    if (arguments.length === 2 && typeof props === "string") {
      for (i4 = 0; i4 < this.length; i4 += 1) {
        this[i4].style[props] = value;
      }
      return this;
    }
    return this;
  }
  function each(callback) {
    if (!callback) return this;
    this.forEach((el, index2) => {
      callback.apply(el, [el, index2]);
    });
    return this;
  }
  function filter(callback) {
    const result = arrayFilter(this, callback);
    return $2(result);
  }
  function html(html3) {
    if (typeof html3 === "undefined") {
      return this[0] ? this[0].innerHTML : null;
    }
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      this[i4].innerHTML = html3;
    }
    return this;
  }
  function text(text2) {
    if (typeof text2 === "undefined") {
      return this[0] ? this[0].textContent.trim() : null;
    }
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      this[i4].textContent = text2;
    }
    return this;
  }
  function is(selector3) {
    const window2 = getWindow();
    const document2 = getDocument();
    const el = this[0];
    let compareWith;
    let i4;
    if (!el || typeof selector3 === "undefined") return false;
    if (typeof selector3 === "string") {
      if (el.matches) return el.matches(selector3);
      if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector3);
      if (el.msMatchesSelector) return el.msMatchesSelector(selector3);
      compareWith = $2(selector3);
      for (i4 = 0; i4 < compareWith.length; i4 += 1) {
        if (compareWith[i4] === el) return true;
      }
      return false;
    }
    if (selector3 === document2) {
      return el === document2;
    }
    if (selector3 === window2) {
      return el === window2;
    }
    if (selector3.nodeType || selector3 instanceof Dom7) {
      compareWith = selector3.nodeType ? [selector3] : selector3;
      for (i4 = 0; i4 < compareWith.length; i4 += 1) {
        if (compareWith[i4] === el) return true;
      }
      return false;
    }
    return false;
  }
  function index() {
    let child = this[0];
    let i4;
    if (child) {
      i4 = 0;
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) i4 += 1;
      }
      return i4;
    }
    return void 0;
  }
  function eq(index2) {
    if (typeof index2 === "undefined") return this;
    const length = this.length;
    if (index2 > length - 1) {
      return $2([]);
    }
    if (index2 < 0) {
      const returnIndex = length + index2;
      if (returnIndex < 0) return $2([]);
      return $2([this[returnIndex]]);
    }
    return $2([this[index2]]);
  }
  function append(...els) {
    let newChild;
    const document2 = getDocument();
    for (let k2 = 0; k2 < els.length; k2 += 1) {
      newChild = els[k2];
      for (let i4 = 0; i4 < this.length; i4 += 1) {
        if (typeof newChild === "string") {
          const tempDiv = document2.createElement("div");
          tempDiv.innerHTML = newChild;
          while (tempDiv.firstChild) {
            this[i4].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (let j2 = 0; j2 < newChild.length; j2 += 1) {
            this[i4].appendChild(newChild[j2]);
          }
        } else {
          this[i4].appendChild(newChild);
        }
      }
    }
    return this;
  }
  function prepend(newChild) {
    const document2 = getDocument();
    let i4;
    let j2;
    for (i4 = 0; i4 < this.length; i4 += 1) {
      if (typeof newChild === "string") {
        const tempDiv = document2.createElement("div");
        tempDiv.innerHTML = newChild;
        for (j2 = tempDiv.childNodes.length - 1; j2 >= 0; j2 -= 1) {
          this[i4].insertBefore(tempDiv.childNodes[j2], this[i4].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j2 = 0; j2 < newChild.length; j2 += 1) {
          this[i4].insertBefore(newChild[j2], this[i4].childNodes[0]);
        }
      } else {
        this[i4].insertBefore(newChild, this[i4].childNodes[0]);
      }
    }
    return this;
  }
  function next(selector3) {
    if (this.length > 0) {
      if (selector3) {
        if (this[0].nextElementSibling && $2(this[0].nextElementSibling).is(selector3)) {
          return $2([this[0].nextElementSibling]);
        }
        return $2([]);
      }
      if (this[0].nextElementSibling) return $2([this[0].nextElementSibling]);
      return $2([]);
    }
    return $2([]);
  }
  function nextAll(selector3) {
    const nextEls = [];
    let el = this[0];
    if (!el) return $2([]);
    while (el.nextElementSibling) {
      const next2 = el.nextElementSibling;
      if (selector3) {
        if ($2(next2).is(selector3)) nextEls.push(next2);
      } else nextEls.push(next2);
      el = next2;
    }
    return $2(nextEls);
  }
  function prev(selector3) {
    if (this.length > 0) {
      const el = this[0];
      if (selector3) {
        if (el.previousElementSibling && $2(el.previousElementSibling).is(selector3)) {
          return $2([el.previousElementSibling]);
        }
        return $2([]);
      }
      if (el.previousElementSibling) return $2([el.previousElementSibling]);
      return $2([]);
    }
    return $2([]);
  }
  function prevAll(selector3) {
    const prevEls = [];
    let el = this[0];
    if (!el) return $2([]);
    while (el.previousElementSibling) {
      const prev2 = el.previousElementSibling;
      if (selector3) {
        if ($2(prev2).is(selector3)) prevEls.push(prev2);
      } else prevEls.push(prev2);
      el = prev2;
    }
    return $2(prevEls);
  }
  function parent(selector3) {
    const parents2 = [];
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      if (this[i4].parentNode !== null) {
        if (selector3) {
          if ($2(this[i4].parentNode).is(selector3)) parents2.push(this[i4].parentNode);
        } else {
          parents2.push(this[i4].parentNode);
        }
      }
    }
    return $2(parents2);
  }
  function parents(selector3) {
    const parents2 = [];
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      let parent2 = this[i4].parentNode;
      while (parent2) {
        if (selector3) {
          if ($2(parent2).is(selector3)) parents2.push(parent2);
        } else {
          parents2.push(parent2);
        }
        parent2 = parent2.parentNode;
      }
    }
    return $2(parents2);
  }
  function closest(selector3) {
    let closest2 = this;
    if (typeof selector3 === "undefined") {
      return $2([]);
    }
    if (!closest2.is(selector3)) {
      closest2 = closest2.parents(selector3).eq(0);
    }
    return closest2;
  }
  function find(selector3) {
    const foundElements = [];
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      const found = this[i4].querySelectorAll(selector3);
      for (let j2 = 0; j2 < found.length; j2 += 1) {
        foundElements.push(found[j2]);
      }
    }
    return $2(foundElements);
  }
  function children(selector3) {
    const children2 = [];
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      const childNodes = this[i4].children;
      for (let j2 = 0; j2 < childNodes.length; j2 += 1) {
        if (!selector3 || $2(childNodes[j2]).is(selector3)) {
          children2.push(childNodes[j2]);
        }
      }
    }
    return $2(children2);
  }
  function remove() {
    for (let i4 = 0; i4 < this.length; i4 += 1) {
      if (this[i4].parentNode) this[i4].parentNode.removeChild(this[i4]);
    }
    return this;
  }
  var noTrigger = "resize scroll".split(" ");
  function shortcut(name) {
    function eventHandler(...args) {
      if (typeof args[0] === "undefined") {
        for (let i4 = 0; i4 < this.length; i4 += 1) {
          if (noTrigger.indexOf(name) < 0) {
            if (name in this[i4]) this[i4][name]();
            else {
              $2(this[i4]).trigger(name);
            }
          }
        }
        return this;
      }
      return this.on(name, ...args);
    }
    return eventHandler;
  }
  var click = shortcut("click");
  var blur = shortcut("blur");
  var focus = shortcut("focus");
  var focusin = shortcut("focusin");
  var focusout = shortcut("focusout");
  var keyup = shortcut("keyup");
  var keydown = shortcut("keydown");
  var keypress = shortcut("keypress");
  var submit = shortcut("submit");
  var change = shortcut("change");
  var mousedown = shortcut("mousedown");
  var mousemove = shortcut("mousemove");
  var mouseup = shortcut("mouseup");
  var mouseenter = shortcut("mouseenter");
  var mouseleave = shortcut("mouseleave");
  var mouseout = shortcut("mouseout");
  var mouseover = shortcut("mouseover");
  var touchstart = shortcut("touchstart");
  var touchend = shortcut("touchend");
  var touchmove = shortcut("touchmove");
  var resize = shortcut("resize");
  var scroll = shortcut("scroll");

  // node_modules/swiper/shared/dom.js
  var Methods = {
    addClass,
    removeClass,
    hasClass,
    toggleClass,
    attr,
    removeAttr,
    transform,
    transition,
    on,
    off,
    trigger,
    transitionEnd,
    outerWidth,
    outerHeight,
    styles,
    offset,
    css,
    each,
    html,
    text,
    is,
    index,
    eq,
    append,
    prepend,
    next,
    nextAll,
    prev,
    prevAll,
    parent,
    parents,
    closest,
    find,
    children,
    filter,
    remove
  };
  Object.keys(Methods).forEach((methodName) => {
    Object.defineProperty($2.fn, methodName, {
      value: Methods[methodName],
      writable: true
    });
  });
  var dom_default = $2;

  // node_modules/swiper/shared/utils.js
  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e4) {
      }
      try {
        delete object[key];
      } catch (e4) {
      }
    });
  }
  function nextTick(callback, delay3 = 0) {
    return setTimeout(callback, delay3);
  }
  function now() {
    return Date.now();
  }
  function getComputedStyle2(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) {
      style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }
    if (!style) {
      style = el.style;
    }
    return style;
  }
  function getTranslate(el, axis = "x") {
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle2(el, null);
    if (window2.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(",").length > 6) {
        curTransform = curTransform.split(", ").map((a3) => a3.replace(",", ".")).join(", ");
      }
      transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
      matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
      if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
      if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  }
  function isObject2(o4) {
    return typeof o4 === "object" && o4 !== null && o4.constructor && Object.prototype.toString.call(o4).slice(8, -1) === "Object";
  }
  function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
      return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
  }
  function extend2(...args) {
    const to = Object(args[0]);
    const noExtend = ["__proto__", "constructor", "prototype"];
    for (let i4 = 1; i4 < args.length; i4 += 1) {
      const nextSource = args[i4];
      if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              to[nextKey] = {};
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  }
  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }
  function animateCSSModeScroll({
    swiper,
    targetPosition,
    side
  }) {
    const window2 = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target) => {
      return dir === "next" && current >= target || dir === "prev" && current <= target;
    };
    const animate = () => {
      time = (/* @__PURE__ */ new Date()).getTime();
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }
      swiper.wrapperEl.scrollTo({
        [side]: currentPosition
      });
      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper.wrapperEl.style.overflow = "hidden";
        swiper.wrapperEl.style.scrollSnapType = "";
        setTimeout(() => {
          swiper.wrapperEl.style.overflow = "";
          swiper.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window2.cancelAnimationFrame(swiper.cssModeFrameID);
        return;
      }
      swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
  }

  // node_modules/swiper/shared/get-support.js
  var support;
  function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
      smoothScroll: document2.documentElement && "scrollBehavior" in document2.documentElement.style,
      touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
      passiveListener: function checkPassiveListener() {
        let supportsPassive = false;
        try {
          const opts = Object.defineProperty({}, "passive", {
            // eslint-disable-next-line
            get() {
              supportsPassive = true;
            }
          });
          window2.addEventListener("testPassiveListener", null, opts);
        } catch (e4) {
        }
        return supportsPassive;
      }(),
      gestures: function checkGestures() {
        return "ongesturestart" in window2;
      }()
    };
  }
  function getSupport() {
    if (!support) {
      support = calcSupport();
    }
    return support;
  }

  // node_modules/swiper/shared/get-device.js
  var deviceCached;
  function calcDevice({
    userAgent
  } = {}) {
    const support2 = getSupport();
    const window2 = getWindow();
    const platform = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === "Win32";
    let macos = platform === "MacIntel";
    const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad) ipad = [0, 1, "13_0_0"];
      macos = false;
    }
    if (android && !windows) {
      device.os = "android";
      device.android = true;
    }
    if (ipad || iphone || ipod) {
      device.os = "ios";
      device.ios = true;
    }
    return device;
  }
  function getDevice(overrides = {}) {
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }
    return deviceCached;
  }

  // node_modules/swiper/shared/get-browser.js
  var browser;
  function calcBrowser() {
    const window2 = getWindow();
    function isSafari() {
      const ua = window2.navigator.userAgent.toLowerCase();
      return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    return {
      isSafari: isSafari(),
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
    };
  }
  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }
    return browser;
  }

  // node_modules/swiper/core/modules/resize/resize.js
  function Resize({
    swiper,
    on: on2,
    emit
  }) {
    const window2 = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit("beforeResize");
      emit("resize");
    };
    const createObserver = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      observer = new ResizeObserver((entries) => {
        animationFrame = window2.requestAnimationFrame(() => {
          const {
            width,
            height
          } = swiper;
          let newWidth = width;
          let newHeight = height;
          entries.forEach(({
            contentBoxSize,
            contentRect,
            target
          }) => {
            if (target && target !== swiper.el) return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
      });
      observer.observe(swiper.el);
    };
    const removeObserver = () => {
      if (animationFrame) {
        window2.cancelAnimationFrame(animationFrame);
      }
      if (observer && observer.unobserve && swiper.el) {
        observer.unobserve(swiper.el);
        observer = null;
      }
    };
    const orientationChangeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized) return;
      emit("orientationchange");
    };
    on2("init", () => {
      if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
        createObserver();
        return;
      }
      window2.addEventListener("resize", resizeHandler);
      window2.addEventListener("orientationchange", orientationChangeHandler);
    });
    on2("destroy", () => {
      removeObserver();
      window2.removeEventListener("resize", resizeHandler);
      window2.removeEventListener("orientationchange", orientationChangeHandler);
    });
  }

  // node_modules/swiper/core/modules/observer/observer.js
  function Observer({
    swiper,
    extendParams,
    on: on2,
    emit
  }) {
    const observers = [];
    const window2 = getWindow();
    const attach = (target, options = {}) => {
      const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
      const observer = new ObserverFunc((mutations) => {
        if (mutations.length === 1) {
          emit("observerUpdate", mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate2() {
          emit("observerUpdate", mutations[0]);
        };
        if (window2.requestAnimationFrame) {
          window2.requestAnimationFrame(observerUpdate);
        } else {
          window2.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === "undefined" ? true : options.attributes,
        childList: typeof options.childList === "undefined" ? true : options.childList,
        characterData: typeof options.characterData === "undefined" ? true : options.characterData
      });
      observers.push(observer);
    };
    const init5 = () => {
      if (!swiper.params.observer) return;
      if (swiper.params.observeParents) {
        const containerParents = swiper.$el.parents();
        for (let i4 = 0; i4 < containerParents.length; i4 += 1) {
          attach(containerParents[i4]);
        }
      }
      attach(swiper.$el[0], {
        childList: swiper.params.observeSlideChildren
      });
      attach(swiper.$wrapperEl[0], {
        attributes: false
      });
    };
    const destroy = () => {
      observers.forEach((observer) => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };
    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on2("init", init5);
    on2("destroy", destroy);
  }

  // node_modules/swiper/core/events-emitter.js
  var events_emitter_default = {
    on(events2, handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (typeof handler !== "function") return self2;
      const method = priority ? "unshift" : "push";
      events2.split(" ").forEach((event2) => {
        if (!self2.eventsListeners[event2]) self2.eventsListeners[event2] = [];
        self2.eventsListeners[event2][method](handler);
      });
      return self2;
    },
    once(events2, handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (typeof handler !== "function") return self2;
      function onceHandler(...args) {
        self2.off(events2, onceHandler);
        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }
        handler.apply(self2, args);
      }
      onceHandler.__emitterProxy = handler;
      return self2.on(events2, onceHandler, priority);
    },
    onAny(handler, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (typeof handler !== "function") return self2;
      const method = priority ? "unshift" : "push";
      if (self2.eventsAnyListeners.indexOf(handler) < 0) {
        self2.eventsAnyListeners[method](handler);
      }
      return self2;
    },
    offAny(handler) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (!self2.eventsAnyListeners) return self2;
      const index2 = self2.eventsAnyListeners.indexOf(handler);
      if (index2 >= 0) {
        self2.eventsAnyListeners.splice(index2, 1);
      }
      return self2;
    },
    off(events2, handler) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (!self2.eventsListeners) return self2;
      events2.split(" ").forEach((event2) => {
        if (typeof handler === "undefined") {
          self2.eventsListeners[event2] = [];
        } else if (self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler, index2) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self2.eventsListeners[event2].splice(index2, 1);
            }
          });
        }
      });
      return self2;
    },
    emit(...args) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed) return self2;
      if (!self2.eventsListeners) return self2;
      let events2;
      let data;
      let context3;
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        events2 = args[0];
        data = args.slice(1, args.length);
        context3 = self2;
      } else {
        events2 = args[0].events;
        data = args[0].data;
        context3 = args[0].context || self2;
      }
      data.unshift(context3);
      const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
      eventsArray.forEach((event2) => {
        if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
          self2.eventsAnyListeners.forEach((eventHandler) => {
            eventHandler.apply(context3, [event2, ...data]);
          });
        }
        if (self2.eventsListeners && self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler) => {
            eventHandler.apply(context3, data);
          });
        }
      });
      return self2;
    }
  };

  // node_modules/swiper/core/update/updateSize.js
  function updateSize() {
    const swiper = this;
    let width;
    let height;
    const $el = swiper.$el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
      width = swiper.params.width;
    } else {
      width = $el[0].clientWidth;
    }
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
      height = swiper.params.height;
    } else {
      height = $el[0].clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    }
    width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
    height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    Object.assign(swiper, {
      width,
      height,
      size: swiper.isHorizontal() ? width : height
    });
  }

  // node_modules/swiper/core/update/updateSlides.js
  function updateSlides() {
    const swiper = this;
    function getDirectionLabel(property) {
      if (swiper.isHorizontal()) {
        return property;
      }
      return {
        "width": "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        "marginRight": "marginBottom"
      }[property];
    }
    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const {
      $wrapperEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index2 = 0;
    if (typeof swiperSize === "undefined") {
      return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    }
    swiper.virtualSize = -spaceBetween;
    if (rtl) slides.css({
      marginLeft: "",
      marginBottom: "",
      marginTop: ""
    });
    else slides.css({
      marginRight: "",
      marginBottom: "",
      marginTop: ""
    });
    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", "");
      setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) {
      swiper.grid.initSlides(slidesLength);
    }
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
      return typeof params.breakpoints[key].slidesPerView !== "undefined";
    }).length > 0;
    for (let i4 = 0; i4 < slidesLength; i4 += 1) {
      slideSize = 0;
      const slide = slides.eq(i4);
      if (gridEnabled) {
        swiper.grid.updateSlide(i4, slide, slidesLength, getDirectionLabel);
      }
      if (slide.css("display") === "none") continue;
      if (params.slidesPerView === "auto") {
        if (shouldResetSlideSize) {
          slides[i4].style[getDirectionLabel("width")] = ``;
        }
        const slideStyles = getComputedStyle(slide[0]);
        const currentTransform = slide[0].style.transform;
        const currentWebKitTransform = slide[0].style.webkitTransform;
        if (currentTransform) {
          slide[0].style.transform = "none";
        }
        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = "none";
        }
        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
        } else {
          const width = getDirectionPropertyValue(slideStyles, "width");
          const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
          const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
          const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
          const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
          const boxSizing = slideStyles.getPropertyValue("box-sizing");
          if (boxSizing && boxSizing === "border-box") {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide[0];
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths) slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths) slideSize = Math.floor(slideSize);
        if (slides[i4]) {
          slides[i4].style[getDirectionLabel("width")] = `${slideSize}px`;
        }
      }
      if (slides[i4]) {
        slides[i4].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);
      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i4 !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i4 === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if (index2 % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }
      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index2 += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
      $wrapperEl.css({
        width: `${swiper.virtualSize + params.spaceBetween}px`
      });
    }
    if (params.setWrapperSize) {
      $wrapperEl.css({
        [getDirectionLabel("width")]: `${swiper.virtualSize + params.spaceBetween}px`
      });
    }
    if (gridEnabled) {
      swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
    }
    if (!params.centeredSlides) {
      const newSlidesGrid = [];
      for (let i4 = 0; i4 < snapGrid.length; i4 += 1) {
        let slidesGridItem = snapGrid[i4];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i4] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }
    if (snapGrid.length === 0) snapGrid = [0];
    if (params.spaceBetween !== 0) {
      const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
      slides.filter((_2, slideIndex) => {
        if (!params.cssMode) return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }).css({
        [key]: `${spaceBetween}px`
      });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map((snap3) => {
        if (snap3 < 0) return -offsetBefore;
        if (snap3 > maxSnap) return maxSnap + offsetAfter;
        return snap3;
      });
    }
    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      if (allSlidesSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach((snap3, snapIndex) => {
          snapGrid[snapIndex] = snap3 - allSlidesOffset;
        });
        slidesGrid.forEach((snap3, snapIndex) => {
          slidesGrid[snapIndex] = snap3 + allSlidesOffset;
        });
      }
    }
    Object.assign(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
      setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper.snapGrid[0];
      const addToSlidesGrid = -swiper.slidesGrid[0];
      swiper.snapGrid = swiper.snapGrid.map((v2) => v2 + addToSnapGrid);
      swiper.slidesGrid = swiper.slidesGrid.map((v2) => v2 + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
      swiper.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) swiper.checkOverflow();
      swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper.$el.removeClass(backFaceHiddenClass);
      }
    }
  }

  // node_modules/swiper/core/update/updateAutoHeight.js
  function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i4;
    if (typeof speed === "number") {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }
    const getSlideByIndex = (index2) => {
      if (isVirtual) {
        return swiper.slides.filter((el) => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index2)[0];
      }
      return swiper.slides.eq(index2)[0];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        (swiper.visibleSlides || dom_default([])).each((slide) => {
          activeSlides.push(slide);
        });
      } else {
        for (i4 = 0; i4 < Math.ceil(swiper.params.slidesPerView); i4 += 1) {
          const index2 = swiper.activeIndex + i4;
          if (index2 > swiper.slides.length && !isVirtual) break;
          activeSlides.push(getSlideByIndex(index2));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    for (i4 = 0; i4 < activeSlides.length; i4 += 1) {
      if (typeof activeSlides[i4] !== "undefined") {
        const height = activeSlides[i4].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    }
    if (newHeight || newHeight === 0) swiper.$wrapperEl.css("height", `${newHeight}px`);
  }

  // node_modules/swiper/core/update/updateSlidesOffset.js
  function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    for (let i4 = 0; i4 < slides.length; i4 += 1) {
      slides[i4].swiperSlideOffset = swiper.isHorizontal() ? slides[i4].offsetLeft : slides[i4].offsetTop;
    }
  }

  // node_modules/swiper/core/update/updateSlidesProgress.js
  function updateSlidesProgress(translate = this && this.translate || 0) {
    const swiper = this;
    const params = swiper.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
    let offsetCenter = -translate;
    if (rtl) offsetCenter = translate;
    slides.removeClass(params.slideVisibleClass);
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    for (let i4 = 0; i4 < slides.length; i4 += 1) {
      const slide = slides[i4];
      let slideOffset = slide.swiperSlideOffset;
      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }
      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i4];
      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i4);
        slides.eq(i4).addClass(params.slideVisibleClass);
      }
      slide.progress = rtl ? -slideProgress : slideProgress;
      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
    swiper.visibleSlides = dom_default(swiper.visibleSlides);
  }

  // node_modules/swiper/core/update/updateProgress.js
  function updateProgress(translate) {
    const swiper = this;
    if (typeof translate === "undefined") {
      const multiplier = swiper.rtlTranslate ? -1 : 1;
      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd
    } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper.minTranslate()) / translatesDiff;
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }
    Object.assign(swiper, {
      progress,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
    if (isBeginning && !wasBeginning) {
      swiper.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
      swiper.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit("fromEdge");
    }
    swiper.emit("progress", progress);
  }

  // node_modules/swiper/core/update/updateSlidesClasses.js
  function updateSlidesClasses() {
    const swiper = this;
    const {
      slides,
      params,
      $wrapperEl,
      activeIndex,
      realIndex
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
    let activeSlide;
    if (isVirtual) {
      activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
    } else {
      activeSlide = slides.eq(activeIndex);
    }
    activeSlide.addClass(params.slideActiveClass);
    if (params.loop) {
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
      }
    }
    let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    }
    let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }
    if (params.loop) {
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
      }
      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
      }
    }
    swiper.emitSlidesClasses();
  }

  // node_modules/swiper/core/update/updateActiveIndex.js
  function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      slidesGrid,
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    if (typeof activeIndex === "undefined") {
      for (let i4 = 0; i4 < slidesGrid.length; i4 += 1) {
        if (typeof slidesGrid[i4 + 1] !== "undefined") {
          if (translate >= slidesGrid[i4] && translate < slidesGrid[i4 + 1] - (slidesGrid[i4 + 1] - slidesGrid[i4]) / 2) {
            activeIndex = i4;
          } else if (translate >= slidesGrid[i4] && translate < slidesGrid[i4 + 1]) {
            activeIndex = i4 + 1;
          }
        } else if (translate >= slidesGrid[i4]) {
          activeIndex = i4;
        }
      }
      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
      }
    }
    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit("snapIndexChange");
      }
      return;
    }
    const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
    Object.assign(swiper, {
      snapIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (previousRealIndex !== realIndex) {
      swiper.emit("realIndexChange");
    }
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      swiper.emit("slideChange");
    }
  }

  // node_modules/swiper/core/update/updateClickedSlide.js
  function updateClickedSlide(e4) {
    const swiper = this;
    const params = swiper.params;
    const slide = dom_default(e4).closest(`.${params.slideClass}`)[0];
    let slideFound = false;
    let slideIndex;
    if (slide) {
      for (let i4 = 0; i4 < swiper.slides.length; i4 += 1) {
        if (swiper.slides[i4] === slide) {
          slideFound = true;
          slideIndex = i4;
          break;
        }
      }
    }
    if (slide && slideFound) {
      swiper.clickedSlide = slide;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt(dom_default(slide).attr("data-swiper-slide-index"), 10);
      } else {
        swiper.clickedIndex = slideIndex;
      }
    } else {
      swiper.clickedSlide = void 0;
      swiper.clickedIndex = void 0;
      return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }

  // node_modules/swiper/core/update/index.js
  var update_default = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };

  // node_modules/swiper/core/translate/getTranslate.js
  function getSwiperTranslate(axis = this.isHorizontal() ? "x" : "y") {
    const swiper = this;
    const {
      params,
      rtlTranslate: rtl,
      translate,
      $wrapperEl
    } = swiper;
    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }
    if (params.cssMode) {
      return translate;
    }
    let currentTranslate = getTranslate($wrapperEl[0], axis);
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }

  // node_modules/swiper/core/translate/setTranslate.js
  function setTranslate(translate, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl,
      params,
      $wrapperEl,
      wrapperEl,
      progress
    } = swiper;
    let x2 = 0;
    let y2 = 0;
    const z2 = 0;
    if (swiper.isHorizontal()) {
      x2 = rtl ? -translate : translate;
    } else {
      y2 = translate;
    }
    if (params.roundLengths) {
      x2 = Math.floor(x2);
      y2 = Math.floor(y2);
    }
    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x2 : -y2;
    } else if (!params.virtualTranslate) {
      $wrapperEl.transform(`translate3d(${x2}px, ${y2}px, ${z2}px)`);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x2 : y2;
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
      swiper.updateProgress(translate);
    }
    swiper.emit("setTranslate", swiper.translate, byController);
  }

  // node_modules/swiper/core/translate/minTranslate.js
  function minTranslate() {
    return -this.snapGrid[0];
  }

  // node_modules/swiper/core/translate/maxTranslate.js
  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  // node_modules/swiper/core/translate/translateTo.js
  function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
    const swiper = this;
    const {
      params,
      wrapperEl
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    const minTranslate2 = swiper.minTranslate();
    const maxTranslate2 = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate > minTranslate2) newTranslate = minTranslate2;
    else if (translateBounds && translate < maxTranslate2) newTranslate = maxTranslate2;
    else newTranslate = translate;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: -newTranslate,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: -newTranslate,
          behavior: "smooth"
        });
      }
      return true;
    }
    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionEnd");
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionStart");
      }
      if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd3(e4) {
            if (!swiper || swiper.destroyed) return;
            if (e4.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;
            if (runCallbacks) {
              swiper.emit("transitionEnd");
            }
          };
        }
        swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
      }
    }
    return true;
  }

  // node_modules/swiper/core/translate/index.js
  var translate_default = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };

  // node_modules/swiper/core/transition/setTransition.js
  function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
      swiper.$wrapperEl.transition(duration);
    }
    swiper.emit("setTransition", duration, byController);
  }

  // node_modules/swiper/core/transition/transitionEmit.js
  function transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step
  }) {
    const {
      activeIndex,
      previousIndex
    } = swiper;
    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex) dir = "next";
      else if (activeIndex < previousIndex) dir = "prev";
      else dir = "reset";
    }
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === "reset") {
        swiper.emit(`slideResetTransition${step}`);
        return;
      }
      swiper.emit(`slideChangeTransition${step}`);
      if (dir === "next") {
        swiper.emit(`slideNextTransition${step}`);
      } else {
        swiper.emit(`slidePrevTransition${step}`);
      }
    }
  }

  // node_modules/swiper/core/transition/transitionStart.js
  function transitionStart(runCallbacks = true, direction) {
    const swiper = this;
    const {
      params
    } = swiper;
    if (params.cssMode) return;
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "Start"
    });
  }

  // node_modules/swiper/core/transition/transitionEnd.js
  function transitionEnd2(runCallbacks = true, direction) {
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "End"
    });
  }

  // node_modules/swiper/core/transition/index.js
  var transition_default = {
    setTransition,
    transitionStart,
    transitionEnd: transitionEnd2
  };

  // node_modules/swiper/core/slide/slideTo.js
  function slideTo(index2 = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
    if (typeof index2 !== "number" && typeof index2 !== "string") {
      throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index2}] given.`);
    }
    if (typeof index2 === "string") {
      const indexAsNumber = parseInt(index2, 10);
      const isValidNumber = isFinite(indexAsNumber);
      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
      }
      index2 = indexAsNumber;
    }
    const swiper = this;
    let slideIndex = index2;
    if (slideIndex < 0) slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
      return false;
    }
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    const translate = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) {
      for (let i4 = 0; i4 < slidesGrid.length; i4 += 1) {
        const normalizedTranslate = -Math.floor(translate * 100);
        const normalizedGrid = Math.floor(slidesGrid[i4] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i4 + 1] * 100);
        if (typeof slidesGrid[i4 + 1] !== "undefined") {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i4;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i4 + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i4;
        }
      }
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
        return false;
      }
      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) return false;
      }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper.emit("beforeSlideChangeStart");
    }
    swiper.updateProgress(translate);
    let direction;
    if (slideIndex > activeIndex) direction = "next";
    else if (slideIndex < activeIndex) direction = "prev";
    else direction = "reset";
    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
      swiper.updateActiveIndex(slideIndex);
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      swiper.updateSlidesClasses();
      if (params.effect !== "slide") {
        swiper.setTranslate(translate);
      }
      if (direction !== "reset") {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      const t3 = rtl ? translate : -translate;
      if (speed === 0) {
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        if (isVirtual) {
          swiper.wrapperEl.style.scrollSnapType = "none";
          swiper._immediateVirtual = true;
        }
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t3;
        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper.wrapperEl.style.scrollSnapType = "";
            swiper._swiperImmediateVirtual = false;
          });
        }
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: t3,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: t3,
          behavior: "smooth"
        });
      }
      return true;
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) {
      swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd3(e4) {
          if (!swiper || swiper.destroyed) return;
          if (e4.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
  }

  // node_modules/swiper/core/slide/slideToLoop.js
  function slideToLoop(index2 = 0, speed = this.params.speed, runCallbacks = true, internal) {
    if (typeof index2 === "string") {
      const indexAsNumber = parseInt(index2, 10);
      const isValidNumber = isFinite(indexAsNumber);
      if (!isValidNumber) {
        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
      }
      index2 = indexAsNumber;
    }
    const swiper = this;
    let newIndex = index2;
    if (swiper.params.loop) {
      newIndex += swiper.loopedSlides;
    }
    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideNext.js
  function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      animating,
      enabled,
      params
    } = swiper;
    if (!enabled) return swiper;
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
    }
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper.loopFix();
      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }
    if (params.rewind && swiper.isEnd) {
      return swiper.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slidePrev.js
  function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      params,
      animating,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled) return swiper;
    if (params.loop) {
      if (animating && params.loopPreventsSlide) return false;
      swiper.loopFix();
      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }
    const translate = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize4(val) {
      if (val < 0) return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }
    const normalizedTranslate = normalize4(translate);
    const normalizedSnapGrid = snapGrid.map((val) => normalize4(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap3, snapIndex) => {
        if (normalizedTranslate >= snap3) {
          prevSnapIndex = snapIndex;
        }
      });
      if (typeof prevSnapIndex !== "undefined") {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }
    if (params.rewind && swiper.isBeginning) {
      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideReset.js
  function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideToClosest.js
  function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
    const swiper = this;
    let index2 = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
    const snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate >= swiper.snapGrid[snapIndex]) {
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];
      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
        index2 += swiper.params.slidesPerGroup;
      }
    } else {
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];
      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index2 -= swiper.params.slidesPerGroup;
      }
    }
    index2 = Math.max(index2, 0);
    index2 = Math.min(index2, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index2, speed, runCallbacks, internal);
  }

  // node_modules/swiper/core/slide/slideToClickedSlide.js
  function slideToClickedSlide() {
    const swiper = this;
    const {
      params,
      $wrapperEl
    } = swiper;
    const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    if (params.loop) {
      if (swiper.animating) return;
      realIndex = parseInt(dom_default(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }

  // node_modules/swiper/core/slide/index.js
  var slide_default = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };

  // node_modules/swiper/core/loop/loopCreate.js
  function loopCreate() {
    const swiper = this;
    const document2 = getDocument();
    const {
      params,
      $wrapperEl
    } = swiper;
    const $selector = $wrapperEl.children().length > 0 ? dom_default($wrapperEl.children()[0].parentNode) : $wrapperEl;
    $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
    let slides = $selector.children(`.${params.slideClass}`);
    if (params.loopFillGroupWithBlank) {
      const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
      if (blankSlidesNum !== params.slidesPerGroup) {
        for (let i4 = 0; i4 < blankSlidesNum; i4 += 1) {
          const blankNode = dom_default(document2.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
          $selector.append(blankNode);
        }
        slides = $selector.children(`.${params.slideClass}`);
      }
    }
    if (params.slidesPerView === "auto" && !params.loopedSlides) params.loopedSlides = slides.length;
    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper.loopedSlides += params.loopAdditionalSlides;
    if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) {
      swiper.loopedSlides = slides.length;
    }
    const prependSlides = [];
    const appendSlides = [];
    slides.each((el, index2) => {
      const slide = dom_default(el);
      slide.attr("data-swiper-slide-index", index2);
    });
    for (let i4 = 0; i4 < swiper.loopedSlides; i4 += 1) {
      const index2 = i4 - Math.floor(i4 / slides.length) * slides.length;
      appendSlides.push(slides.eq(index2)[0]);
      prependSlides.unshift(slides.eq(slides.length - index2 - 1)[0]);
    }
    for (let i4 = 0; i4 < appendSlides.length; i4 += 1) {
      $selector.append(dom_default(appendSlides[i4].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
    for (let i4 = prependSlides.length - 1; i4 >= 0; i4 -= 1) {
      $selector.prepend(dom_default(prependSlides[i4].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  // node_modules/swiper/core/loop/loopFix.js
  function loopFix() {
    const swiper = this;
    swiper.emit("beforeLoopFix");
    const {
      activeIndex,
      slides,
      loopedSlides,
      allowSlidePrev,
      allowSlideNext,
      snapGrid,
      rtlTranslate: rtl
    } = swiper;
    let newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    const snapTranslate = -snapGrid[activeIndex];
    const diff = snapTranslate - swiper.getTranslate();
    if (activeIndex < loopedSlides) {
      newIndex = slides.length - loopedSlides * 3 + activeIndex;
      newIndex += loopedSlides;
      const slideChanged = swiper.slideTo(newIndex, 0, false, true);
      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    } else if (activeIndex >= slides.length - loopedSlides) {
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;
      const slideChanged = swiper.slideTo(newIndex, 0, false, true);
      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit("loopFix");
  }

  // node_modules/swiper/core/loop/loopDestroy.js
  function loopDestroy() {
    const swiper = this;
    const {
      $wrapperEl,
      params,
      slides
    } = swiper;
    $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
    slides.removeAttr("data-swiper-slide-index");
  }

  // node_modules/swiper/core/loop/index.js
  var loop_default = {
    loopCreate,
    loopFix,
    loopDestroy
  };

  // node_modules/swiper/core/grab-cursor/setGrabCursor.js
  function setGrabCursor(moving) {
    const swiper = this;
    if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
  }

  // node_modules/swiper/core/grab-cursor/unsetGrabCursor.js
  function unsetGrabCursor() {
    const swiper = this;
    if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }
    swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
  }

  // node_modules/swiper/core/grab-cursor/index.js
  var grab_cursor_default = {
    setGrabCursor,
    unsetGrabCursor
  };

  // node_modules/swiper/core/events/onTouchStart.js
  function closestElement(selector3, base = this) {
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow()) return null;
      if (el.assignedSlot) el = el.assignedSlot;
      const found = el.closest(selector3);
      if (!found && !el.getRootNode) {
        return null;
      }
      return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
  }
  function onTouchStart(event2) {
    const swiper = this;
    const document2 = getDocument();
    const window2 = getWindow();
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      enabled
    } = swiper;
    if (!enabled) return;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }
    if (!swiper.animating && params.cssMode && params.loop) {
      swiper.loopFix();
    }
    let e4 = event2;
    if (e4.originalEvent) e4 = e4.originalEvent;
    let $targetEl = dom_default(e4.target);
    if (params.touchEventsTarget === "wrapper") {
      if (!$targetEl.closest(swiper.wrapperEl).length) return;
    }
    data.isTouchEvent = e4.type === "touchstart";
    if (!data.isTouchEvent && "which" in e4 && e4.which === 3) return;
    if (!data.isTouchEvent && "button" in e4 && e4.button > 0) return;
    if (data.isTouched && data.isMoved) return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = event2.composedPath ? event2.composedPath() : event2.path;
    if (swipingClassHasValue && e4.target && e4.target.shadowRoot && eventPath) {
      $targetEl = dom_default(eventPath[0]);
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e4.target && e4.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
      swiper.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!$targetEl.closest(params.swipeHandler)[0]) return;
    }
    touches.currentX = e4.type === "touchstart" ? e4.targetTouches[0].pageX : e4.pageX;
    touches.currentY = e4.type === "touchstart" ? e4.targetTouches[0].pageY : e4.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === "prevent") {
        event2.preventDefault();
      } else {
        return;
      }
    }
    Object.assign(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: void 0,
      startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0) data.allowThresholdMove = false;
    if (e4.type !== "touchstart") {
      let preventDefault = true;
      if ($targetEl.is(data.focusableElements)) {
        preventDefault = false;
        if ($targetEl[0].nodeName === "SELECT") {
          data.isTouched = false;
        }
      }
      if (document2.activeElement && dom_default(document2.activeElement).is(data.focusableElements) && document2.activeElement !== $targetEl[0]) {
        document2.activeElement.blur();
      }
      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
        e4.preventDefault();
      }
    }
    if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
      swiper.freeMode.onTouchStart();
    }
    swiper.emit("touchStart", e4);
  }

  // node_modules/swiper/core/events/onTouchMove.js
  function onTouchMove(event2) {
    const document2 = getDocument();
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper;
    if (!enabled) return;
    let e4 = event2;
    if (e4.originalEvent) e4 = e4.originalEvent;
    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit("touchMoveOpposite", e4);
      }
      return;
    }
    if (data.isTouchEvent && e4.type !== "touchmove") return;
    const targetTouch = e4.type === "touchmove" && e4.targetTouches && (e4.targetTouches[0] || e4.changedTouches[0]);
    const pageX = e4.type === "touchmove" ? targetTouch.pageX : e4.pageX;
    const pageY = e4.type === "touchmove" ? targetTouch.pageY : e4.pageY;
    if (e4.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper.allowTouchMove) {
      if (!dom_default(e4.target).is(data.focusableElements)) {
        swiper.allowClick = false;
      }
      if (data.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = now();
      }
      return;
    }
    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }
    if (data.isTouchEvent && document2.activeElement) {
      if (e4.target === document2.activeElement && dom_default(e4.target).is(data.focusableElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }
    if (data.allowTouchCallbacks) {
      swiper.emit("touchMove", e4);
    }
    if (e4.targetTouches && e4.targetTouches.length > 1) return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(__pow(diffX, 2) + __pow(diffY, 2)) < swiper.params.threshold) return;
    if (typeof data.isScrolling === "undefined") {
      let touchAngle;
      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }
    if (data.isScrolling) {
      swiper.emit("touchMoveOpposite", e4);
    }
    if (typeof data.startMoving === "undefined") {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }
    if (data.isScrolling) {
      data.isTouched = false;
      return;
    }
    if (!data.startMoving) {
      return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e4.cancelable) {
      e4.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e4.stopPropagation();
    }
    if (!data.isMoved) {
      if (params.loop && !params.cssMode) {
        swiper.loopFix();
      }
      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);
      if (swiper.animating) {
        swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
      }
      data.allowMomentumBounce = false;
      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }
      swiper.emit("sliderFirstMove", e4);
    }
    swiper.emit("sliderMove", e4);
    data.isMoved = true;
    let diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) diff = -diff;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + __pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - __pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
    }
    if (disableParentSwiper) {
      e4.preventedByNestedSwiper = true;
    }
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
      data.currentTranslate = data.startTranslate;
    }
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }
    if (!params.followFinger || params.cssMode) return;
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
      swiper.freeMode.onTouchMove();
    }
    swiper.updateProgress(data.currentTranslate);
    swiper.setTranslate(data.currentTranslate);
  }

  // node_modules/swiper/core/events/onTouchEnd.js
  function onTouchEnd(event2) {
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper;
    if (!enabled) return;
    let e4 = event2;
    if (e4.originalEvent) e4 = e4.originalEvent;
    if (data.allowTouchCallbacks) {
      swiper.emit("touchEnd", e4);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    }
    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (swiper.allowClick) {
      const pathTree = e4.path || e4.composedPath && e4.composedPath();
      swiper.updateClickedSlide(pathTree && pathTree[0] || e4.target);
      swiper.emit("tap click", e4);
      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper.emit("doubleTap doubleClick", e4);
      }
    }
    data.lastClickTime = now();
    nextTick(() => {
      if (!swiper.destroyed) swiper.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
      return;
    }
    if (swiper.params.freeMode && params.freeMode.enabled) {
      swiper.freeMode.onTouchEnd({
        currentPos
      });
      return;
    }
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for (let i4 = 0; i4 < slidesGrid.length; i4 += i4 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment2 = i4 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (typeof slidesGrid[i4 + increment2] !== "undefined") {
        if (currentPos >= slidesGrid[i4] && currentPos < slidesGrid[i4 + increment2]) {
          stopIndex = i4;
          groupSize = slidesGrid[i4 + increment2] - slidesGrid[i4];
        }
      } else if (currentPos >= slidesGrid[i4]) {
        stopIndex = i4;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
      if (swiper.isBeginning) {
        rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      } else if (swiper.isEnd) {
        rewindFirstIndex = 0;
      }
    }
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (swiper.swipeDirection === "next") {
        if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
        else swiper.slideTo(stopIndex);
      }
      if (swiper.swipeDirection === "prev") {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper.slideTo(rewindLastIndex);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper.navigation && (e4.target === swiper.navigation.nextEl || e4.target === swiper.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === "next") {
          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }
        if (swiper.swipeDirection === "prev") {
          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e4.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }

  // node_modules/swiper/core/events/onResize.js
  function onResize() {
    const swiper = this;
    const {
      params,
      el
    } = swiper;
    if (el && el.offsetWidth === 0) return;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      swiper.autoplay.run();
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }

  // node_modules/swiper/core/events/onClick.js
  function onClick(e4) {
    const swiper = this;
    if (!swiper.enabled) return;
    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) e4.preventDefault();
      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e4.stopPropagation();
        e4.stopImmediatePropagation();
      }
    }
  }

  // node_modules/swiper/core/events/onScroll.js
  function onScroll() {
    const swiper = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
      swiper.translate = -wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    }
    if (swiper.translate === 0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit("setTranslate", swiper.translate, false);
  }

  // node_modules/swiper/core/events/index.js
  var dummyEventAttached = false;
  function dummyEventListener() {
  }
  var events = (swiper, method) => {
    const document2 = getDocument();
    const {
      params,
      touchEvents,
      el,
      wrapperEl,
      device,
      support: support2
    } = swiper;
    const capture = !!params.nested;
    const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method;
    if (!support2.touch) {
      el[domMethod](touchEvents.start, swiper.onTouchStart, false);
      document2[domMethod](touchEvents.move, swiper.onTouchMove, capture);
      document2[domMethod](touchEvents.end, swiper.onTouchEnd, false);
    } else {
      const passiveListener = touchEvents.start === "touchstart" && support2.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
      el[domMethod](touchEvents.move, swiper.onTouchMove, support2.passiveListener ? {
        passive: false,
        capture
      } : capture);
      el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }
    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]("click", swiper.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl[domMethod]("scroll", swiper.onScroll);
    }
    if (params.updateOnWindowResize) {
      swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
      swiper[swiperMethod]("observerUpdate", onResize, true);
    }
  };
  function attachEvents() {
    const swiper = this;
    const document2 = getDocument();
    const {
      params,
      support: support2
    } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    if (support2.touch && !dummyEventAttached) {
      document2.addEventListener("touchstart", dummyEventListener);
      dummyEventAttached = true;
    }
    events(swiper, "on");
  }
  function detachEvents() {
    const swiper = this;
    events(swiper, "off");
  }
  var events_default = {
    attachEvents,
    detachEvents
  };

  // node_modules/swiper/core/breakpoints/setBreakpoint.js
  var isGridEnabled = (swiper, params) => {
    return swiper.grid && params.grid && params.grid.rows > 1;
  };
  function setBreakpoint() {
    const swiper = this;
    const {
      activeIndex,
      initialized,
      loopedSlides = 0,
      params,
      $el
    } = swiper;
    const breakpoints = params.breakpoints;
    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(`${params.containerModifierClass}grid`);
      if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
        $el.addClass(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }
    ["navigation", "pagination", "scrollbar"].forEach((prop) => {
      const wasModuleEnabled = params[prop] && params[prop].enabled;
      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
      if (wasModuleEnabled && !isModuleEnabled) {
        swiper[prop].disable();
      }
      if (!wasModuleEnabled && isModuleEnabled) {
        swiper[prop].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    if (directionChanged && initialized) {
      swiper.changeDirection();
    }
    extend2(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    Object.assign(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
      swiper.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
    }
    swiper.emit("breakpoint", breakpointParams);
  }

  // node_modules/swiper/core/breakpoints/getBreakpoint.js
  function getBreakpoint(breakpoints, base = "window", containerEl) {
    if (!breakpoints || base === "container" && !containerEl) return void 0;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints).map((point) => {
      if (typeof point === "string" && point.indexOf("@") === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = currentHeight * minRatio;
        return {
          value,
          point
        };
      }
      return {
        value: point,
        point
      };
    });
    points.sort((a3, b2) => parseInt(a3.value, 10) - parseInt(b2.value, 10));
    for (let i4 = 0; i4 < points.length; i4 += 1) {
      const {
        point,
        value
      } = points[i4];
      if (base === "window") {
        if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
          breakpoint = point;
        }
      } else if (value <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || "max";
  }

  // node_modules/swiper/core/breakpoints/index.js
  var breakpoints_default = {
    setBreakpoint,
    getBreakpoint
  };

  // node_modules/swiper/core/classes/addClasses.js
  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item) => {
      if (typeof item === "object") {
        Object.keys(item).forEach((classNames) => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === "string") {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }
  function addClasses() {
    const swiper = this;
    const {
      classNames,
      params,
      rtl,
      $el,
      device,
      support: support2
    } = swiper;
    const suffixes = prepareClasses(["initialized", params.direction, {
      "pointer-events": !support2.touch
    }, {
      "free-mode": swiper.params.freeMode && params.freeMode.enabled
    }, {
      "autoheight": params.autoHeight
    }, {
      "rtl": rtl
    }, {
      "grid": params.grid && params.grid.rows > 1
    }, {
      "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
    }, {
      "android": device.android
    }, {
      "ios": device.ios
    }, {
      "css-mode": params.cssMode
    }, {
      "centered": params.cssMode && params.centeredSlides
    }, {
      "watch-progress": params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    $el.addClass([...classNames].join(" "));
    swiper.emitContainerClasses();
  }

  // node_modules/swiper/core/classes/removeClasses.js
  function removeClasses() {
    const swiper = this;
    const {
      $el,
      classNames
    } = swiper;
    $el.removeClass(classNames.join(" "));
    swiper.emitContainerClasses();
  }

  // node_modules/swiper/core/classes/index.js
  var classes_default = {
    addClasses,
    removeClasses
  };

  // node_modules/swiper/core/images/loadImage.js
  function loadImage2(imageEl, src, srcset, sizes, checkForComplete, callback) {
    const window2 = getWindow();
    let image2;
    function onReady() {
      if (callback) callback();
    }
    const isPicture = dom_default(imageEl).parent("picture")[0];
    if (!isPicture && (!imageEl.complete || !checkForComplete)) {
      if (src) {
        image2 = new window2.Image();
        image2.onload = onReady;
        image2.onerror = onReady;
        if (sizes) {
          image2.sizes = sizes;
        }
        if (srcset) {
          image2.srcset = srcset;
        }
        if (src) {
          image2.src = src;
        }
      } else {
        onReady();
      }
    } else {
      onReady();
    }
  }

  // node_modules/swiper/core/images/preloadImages.js
  function preloadImages() {
    const swiper = this;
    swiper.imagesToLoad = swiper.$el.find("img");
    function onReady() {
      if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed) return;
      if (swiper.imagesLoaded !== void 0) swiper.imagesLoaded += 1;
      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
        if (swiper.params.updateOnImagesReady) swiper.update();
        swiper.emit("imagesReady");
      }
    }
    for (let i4 = 0; i4 < swiper.imagesToLoad.length; i4 += 1) {
      const imageEl = swiper.imagesToLoad[i4];
      swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
    }
  }

  // node_modules/swiper/core/images/index.js
  var images_default = {
    loadImage: loadImage2,
    preloadImages
  };

  // node_modules/swiper/core/check-overflow/index.js
  function checkOverflow() {
    const swiper = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper;
    const {
      slidesOffsetBefore
    } = params;
    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper.slides.length - 1;
      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
      swiper.allowSlideNext = !swiper.isLocked;
    }
    if (params.allowSlidePrev === true) {
      swiper.allowSlidePrev = !swiper.isLocked;
    }
    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
    }
    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? "lock" : "unlock");
    }
  }
  var check_overflow_default = {
    checkOverflow
  };

  // node_modules/swiper/core/defaults.js
  var defaults_default = {
    init: true,
    direction: "horizontal",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // Images
    preloadImages: true,
    updateOnImagesReady: true,
    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopedSlidesLimit: true,
    loopFillGroupWithBlank: false,
    loopPreventsSlide: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };

  // node_modules/swiper/core/moduleExtendParams.js
  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj = {}) {
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];
      if (typeof moduleParams !== "object" || moduleParams === null) {
        extend2(allModulesParams, obj);
        return;
      }
      if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
        params[moduleParamName] = {
          auto: true
        };
      }
      if (!(moduleParamName in params && "enabled" in moduleParams)) {
        extend2(allModulesParams, obj);
        return;
      }
      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }
      if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }
      if (!params[moduleParamName]) params[moduleParamName] = {
        enabled: false
      };
      extend2(allModulesParams, obj);
    };
  }

  // node_modules/swiper/core/core.js
  var prototypes = {
    eventsEmitter: events_emitter_default,
    update: update_default,
    translate: translate_default,
    transition: transition_default,
    slide: slide_default,
    loop: loop_default,
    grabCursor: grab_cursor_default,
    events: events_default,
    breakpoints: breakpoints_default,
    checkOverflow: check_overflow_default,
    classes: classes_default,
    images: images_default
  };
  var extendedDefaults = {};
  var Swiper = class _Swiper {
    constructor(...args) {
      let el;
      let params;
      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params) params = {};
      params = extend2({}, params);
      if (el && !params.el) params.el = el;
      if (params.el && dom_default(params.el).length > 1) {
        const swipers = [];
        dom_default(params.el).each((containerEl) => {
          const newParams = extend2({}, params, {
            el: containerEl
          });
          swipers.push(new _Swiper(newParams));
        });
        return swipers;
      }
      const swiper = this;
      swiper.__swiper__ = true;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      swiper.modules = [...swiper.__modules__];
      if (params.modules && Array.isArray(params.modules)) {
        swiper.modules.push(...params.modules);
      }
      const allModulesParams = {};
      swiper.modules.forEach((mod) => {
        mod({
          swiper,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper.on.bind(swiper),
          once: swiper.once.bind(swiper),
          off: swiper.off.bind(swiper),
          emit: swiper.emit.bind(swiper)
        });
      });
      const swiperParams = extend2({}, defaults_default, allModulesParams);
      swiper.params = extend2({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend2({}, swiper.params);
      swiper.passedParams = extend2({}, params);
      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach((eventName) => {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      }
      if (swiper.params && swiper.params.onAny) {
        swiper.onAny(swiper.params.onAny);
      }
      swiper.$ = dom_default;
      Object.assign(swiper, {
        enabled: swiper.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: dom_default(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return swiper.params.direction === "horizontal";
        },
        isVertical() {
          return swiper.params.direction === "vertical";
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEvents: function touchEvents() {
          const touch = ["touchstart", "touchmove", "touchend", "touchcancel"];
          const desktop = ["pointerdown", "pointermove", "pointerup"];
          swiper.touchEventsTouch = {
            start: touch[0],
            move: touch[1],
            end: touch[2],
            cancel: touch[3]
          };
          swiper.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2]
          };
          return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
        }(),
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          // Form elements to match
          focusableElements: swiper.params.focusableElements,
          // Last click time
          lastClickTime: now(),
          clickTimeout: void 0,
          // Velocities
          velocities: [],
          allowMomentumBounce: void 0,
          isTouchEvent: void 0,
          startMoving: void 0
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper.emit("_swiper");
      if (swiper.params.init) {
        swiper.init();
      }
      return swiper;
    }
    enable() {
      const swiper = this;
      if (swiper.enabled) return;
      swiper.enabled = true;
      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }
      swiper.emit("enable");
    }
    disable() {
      const swiper = this;
      if (!swiper.enabled) return;
      swiper.enabled = false;
      if (swiper.params.grabCursor) {
        swiper.unsetGrabCursor();
      }
      swiper.emit("disable");
    }
    setProgress(progress, speed) {
      const swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper.minTranslate();
      const max = swiper.maxTranslate();
      const current = (max - min) * progress + min;
      swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const cls = swiper.el.className.split(" ").filter((className) => {
        return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit("_containerClasses", cls.join(" "));
    }
    getSlideClasses(slideEl) {
      const swiper = this;
      if (swiper.destroyed) return "";
      return slideEl.className.split(" ").filter((className) => {
        return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(" ");
    }
    emitSlidesClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el) return;
      const updates = [];
      swiper.slides.each((slideEl) => {
        const classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper.emit("_slideClass", slideEl, classNames);
      });
      swiper.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view = "current", exact = false) {
      const swiper = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper;
      let spv = 1;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex].swiperSlideSize;
        let breakLoop;
        for (let i4 = activeIndex + 1; i4 < slides.length; i4 += 1) {
          if (slides[i4] && !breakLoop) {
            slideSize += slides[i4].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
        for (let i4 = activeIndex - 1; i4 >= 0; i4 -= 1) {
          if (slides[i4] && !breakLoop) {
            slideSize += slides[i4].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        if (view === "current") {
          for (let i4 = activeIndex + 1; i4 < slides.length; i4 += 1) {
            const slideInView = exact ? slidesGrid[i4] + slidesSizesGrid[i4] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i4] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          for (let i4 = activeIndex - 1; i4 >= 0; i4 -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i4] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        }
      }
      return spv;
    }
    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed) return;
      const {
        snapGrid,
        params
      } = swiper;
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      function setTranslate2() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      let translated;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
        setTranslate2();
        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate2();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
      swiper.emit("update");
    }
    changeDirection(newDirection, needUpdate = true) {
      const swiper = this;
      const currentDirection = swiper.params.direction;
      if (!newDirection) {
        newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
      }
      if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
        return swiper;
      }
      swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.each((slideEl) => {
        if (newDirection === "vertical") {
          slideEl.style.width = "";
        } else {
          slideEl.style.height = "";
        }
      });
      swiper.emit("changeDirection");
      if (needUpdate) swiper.update();
      return swiper;
    }
    changeLanguageDirection(direction) {
      const swiper = this;
      if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
      swiper.rtl = direction === "rtl";
      swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
      if (swiper.rtl) {
        swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "rtl";
      } else {
        swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "ltr";
      }
      swiper.update();
    }
    mount(el) {
      const swiper = this;
      if (swiper.mounted) return true;
      const $el = dom_default(el || swiper.params.el);
      el = $el[0];
      if (!el) {
        return false;
      }
      el.swiper = swiper;
      const getWrapperSelector = () => {
        return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
      };
      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = dom_default(el.shadowRoot.querySelector(getWrapperSelector()));
          res.children = (options) => $el.children(options);
          return res;
        }
        if (!$el.children) {
          return dom_default($el).children(getWrapperSelector());
        }
        return $el.children(getWrapperSelector());
      };
      let $wrapperEl = getWrapper();
      if ($wrapperEl.length === 0 && swiper.params.createElements) {
        const document2 = getDocument();
        const wrapper = document2.createElement("div");
        $wrapperEl = dom_default(wrapper);
        wrapper.className = swiper.params.wrapperClass;
        $el.append(wrapper);
        $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {
          $wrapperEl.append(slideEl);
        });
      }
      Object.assign(swiper, {
        $el,
        el,
        $wrapperEl,
        wrapperEl: $wrapperEl[0],
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
        rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
        wrongRTL: $wrapperEl.css("display") === "-webkit-box"
      });
      return true;
    }
    init(el) {
      const swiper = this;
      if (swiper.initialized) return swiper;
      const mounted = swiper.mount(el);
      if (mounted === false) return swiper;
      swiper.emit("beforeInit");
      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      }
      swiper.addClasses();
      if (swiper.params.loop) {
        swiper.loopCreate();
      }
      swiper.updateSize();
      swiper.updateSlides();
      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }
      if (swiper.params.grabCursor && swiper.enabled) {
        swiper.setGrabCursor();
      }
      if (swiper.params.preloadImages) {
        swiper.preloadImages();
      }
      if (swiper.params.loop) {
        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
      }
      swiper.attachEvents();
      swiper.initialized = true;
      swiper.emit("init");
      swiper.emit("afterInit");
      return swiper;
    }
    destroy(deleteInstance = true, cleanStyles = true) {
      const swiper = this;
      const {
        params,
        $el,
        $wrapperEl,
        slides
      } = swiper;
      if (typeof swiper.params === "undefined" || swiper.destroyed) {
        return null;
      }
      swiper.emit("beforeDestroy");
      swiper.initialized = false;
      swiper.detachEvents();
      if (params.loop) {
        swiper.loopDestroy();
      }
      if (cleanStyles) {
        swiper.removeClasses();
        $el.removeAttr("style");
        $wrapperEl.removeAttr("style");
        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
        }
      }
      swiper.emit("destroy");
      Object.keys(swiper.eventsListeners).forEach((eventName) => {
        swiper.off(eventName);
      });
      if (deleteInstance !== false) {
        swiper.$el[0].swiper = null;
        deleteProps(swiper);
      }
      swiper.destroyed = true;
      return null;
    }
    static extendDefaults(newDefaults) {
      extend2(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
      return extendedDefaults;
    }
    static get defaults() {
      return defaults_default;
    }
    static installModule(mod) {
      if (!_Swiper.prototype.__modules__) _Swiper.prototype.__modules__ = [];
      const modules = _Swiper.prototype.__modules__;
      if (typeof mod === "function" && modules.indexOf(mod) < 0) {
        modules.push(mod);
      }
    }
    static use(module) {
      if (Array.isArray(module)) {
        module.forEach((m2) => _Swiper.installModule(m2));
        return _Swiper;
      }
      _Swiper.installModule(module);
      return _Swiper;
    }
  };
  Object.keys(prototypes).forEach((prototypeGroup) => {
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);
  var core_default = Swiper;

  // node_modules/swiper/shared/create-element-if-not-defined.js
  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    const document2 = getDocument();
    if (swiper.params.createElements) {
      Object.keys(checkProps).forEach((key) => {
        if (!params[key] && params.auto === true) {
          let element = swiper.$el.children(`.${checkProps[key]}`)[0];
          if (!element) {
            element = document2.createElement("div");
            element.className = checkProps[key];
            swiper.$el.append(element);
          }
          params[key] = element;
          originalParams[key] = element;
        }
      });
    }
    return params;
  }

  // node_modules/swiper/modules/navigation/navigation.js
  function Navigation({
    swiper,
    extendParams,
    on: on2,
    emit
  }) {
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    });
    swiper.navigation = {
      nextEl: null,
      $nextEl: null,
      prevEl: null,
      $prevEl: null
    };
    function getEl(el) {
      let $el;
      if (el) {
        $el = dom_default(el);
        if (swiper.params.uniqueNavElements && typeof el === "string" && $el.length > 1 && swiper.$el.find(el).length === 1) {
          $el = swiper.$el.find(el);
        }
      }
      return $el;
    }
    function toggleEl($el, disabled) {
      const params = swiper.params.navigation;
      if ($el && $el.length > 0) {
        $el[disabled ? "addClass" : "removeClass"](params.disabledClass);
        if ($el[0] && $el[0].tagName === "BUTTON") $el[0].disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
        }
      }
    }
    function update() {
      if (swiper.params.loop) return;
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;
      toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
      toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
    }
    function onPrevClick(e4) {
      e4.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
      swiper.slidePrev();
      emit("navigationPrev");
    }
    function onNextClick(e4) {
      e4.preventDefault();
      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
      swiper.slideNext();
      emit("navigationNext");
    }
    function init5() {
      const params = swiper.params.navigation;
      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      });
      if (!(params.nextEl || params.prevEl)) return;
      const $nextEl = getEl(params.nextEl);
      const $prevEl = getEl(params.prevEl);
      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on("click", onNextClick);
      }
      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on("click", onPrevClick);
      }
      Object.assign(swiper.navigation, {
        $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl,
        prevEl: $prevEl && $prevEl[0]
      });
      if (!swiper.enabled) {
        if ($nextEl) $nextEl.addClass(params.lockClass);
        if ($prevEl) $prevEl.addClass(params.lockClass);
      }
    }
    function destroy() {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;
      if ($nextEl && $nextEl.length) {
        $nextEl.off("click", onNextClick);
        $nextEl.removeClass(swiper.params.navigation.disabledClass);
      }
      if ($prevEl && $prevEl.length) {
        $prevEl.off("click", onPrevClick);
        $prevEl.removeClass(swiper.params.navigation.disabledClass);
      }
    }
    on2("init", () => {
      if (swiper.params.navigation.enabled === false) {
        disable();
      } else {
        init5();
        update();
      }
    });
    on2("toEdge fromEdge lock unlock", () => {
      update();
    });
    on2("destroy", () => {
      destroy();
    });
    on2("enable disable", () => {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;
      if ($nextEl) {
        $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
      }
      if ($prevEl) {
        $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
      }
    });
    on2("click", (_s, e4) => {
      const {
        $nextEl,
        $prevEl
      } = swiper.navigation;
      const targetEl = e4.target;
      if (swiper.params.navigation.hideOnClick && !dom_default(targetEl).is($prevEl) && !dom_default(targetEl).is($nextEl)) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        let isHidden3;
        if ($nextEl) {
          isHidden3 = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden3 = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }
        if (isHidden3 === true) {
          emit("navigationShow");
        } else {
          emit("navigationHide");
        }
        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    });
    const enable = () => {
      swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
      init5();
      update();
    };
    const disable = () => {
      swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
      destroy();
    };
    Object.assign(swiper.navigation, {
      enable,
      disable,
      update,
      init: init5,
      destroy
    });
  }

  // node_modules/swiper/shared/classes-to-selector.js
  function classesToSelector(classes = "") {
    return `.${classes.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
  }

  // node_modules/swiper/modules/pagination/pagination.js
  function Pagination({
    swiper,
    extendParams,
    on: on2,
    emit
  }) {
    const pfx = "swiper-pagination";
    extendParams({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: "bullets",
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: (number) => number,
        formatFractionTotal: (number) => number,
        bulletClass: `${pfx}-bullet`,
        bulletActiveClass: `${pfx}-bullet-active`,
        modifierClass: `${pfx}-`,
        currentClass: `${pfx}-current`,
        totalClass: `${pfx}-total`,
        hiddenClass: `${pfx}-hidden`,
        progressbarFillClass: `${pfx}-progressbar-fill`,
        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
        clickableClass: `${pfx}-clickable`,
        lockClass: `${pfx}-lock`,
        horizontalClass: `${pfx}-horizontal`,
        verticalClass: `${pfx}-vertical`,
        paginationDisabledClass: `${pfx}-disabled`
      }
    });
    swiper.pagination = {
      el: null,
      $el: null,
      bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;
    function isPaginationDisabled() {
      return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
    }
    function setSideBullets($bulletEl, position) {
      const {
        bulletActiveClass
      } = swiper.params.pagination;
      $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
    }
    function update() {
      const rtl = swiper.rtl;
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const $el = swiper.pagination.$el;
      let current;
      const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.loop) {
        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
        if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
          current -= slidesLength - swiper.loopedSlides * 2;
        }
        if (current > total - 1) current -= total;
        if (current < 0 && swiper.params.paginationType !== "bullets") current = total + current;
      } else if (typeof swiper.snapIndex !== "undefined") {
        current = swiper.snapIndex;
      } else {
        current = swiper.activeIndex || 0;
      }
      if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        const bullets = swiper.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;
        if (params.dynamicBullets) {
          bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
          $el.css(swiper.isHorizontal() ? "width" : "height", `${bulletSize * (params.dynamicMainBullets + 4)}px`);
          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== void 0) {
            dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
              dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (dynamicBulletIndex < 0) {
              dynamicBulletIndex = 0;
            }
          }
          firstIndex = Math.max(current - dynamicBulletIndex, 0);
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }
        bullets.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`).join(" "));
        if ($el.length > 1) {
          bullets.each((bullet) => {
            const $bullet = dom_default(bullet);
            const bulletIndex = $bullet.index();
            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }
            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(`${params.bulletActiveClass}-main`);
              }
              if (bulletIndex === firstIndex) {
                setSideBullets($bullet, "prev");
              }
              if (bulletIndex === lastIndex) {
                setSideBullets($bullet, "next");
              }
            }
          });
        } else {
          const $bullet = bullets.eq(current);
          const bulletIndex = $bullet.index();
          $bullet.addClass(params.bulletActiveClass);
          if (params.dynamicBullets) {
            const $firstDisplayedBullet = bullets.eq(firstIndex);
            const $lastDisplayedBullet = bullets.eq(lastIndex);
            for (let i4 = firstIndex; i4 <= lastIndex; i4 += 1) {
              bullets.eq(i4).addClass(`${params.bulletActiveClass}-main`);
            }
            if (swiper.params.loop) {
              if (bulletIndex >= bullets.length) {
                for (let i4 = params.dynamicMainBullets; i4 >= 0; i4 -= 1) {
                  bullets.eq(bullets.length - i4).addClass(`${params.bulletActiveClass}-main`);
                }
                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
              } else {
                setSideBullets($firstDisplayedBullet, "prev");
                setSideBullets($lastDisplayedBullet, "next");
              }
            } else {
              setSideBullets($firstDisplayedBullet, "prev");
              setSideBullets($lastDisplayedBullet, "next");
            }
          }
        }
        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
          const offsetProp = rtl ? "right" : "left";
          bullets.css(swiper.isHorizontal() ? offsetProp : "top", `${bulletsOffset}px`);
        }
      }
      if (params.type === "fraction") {
        $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
        $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
      }
      if (params.type === "progressbar") {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
        } else {
          progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === "horizontal") {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
      }
      if (params.type === "custom" && params.renderCustom) {
        $el.html(params.renderCustom(swiper, current + 1, total));
        emit("paginationRender", $el[0]);
      } else {
        emit("paginationUpdate", $el[0]);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
      }
    }
    function render6() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const $el = swiper.pagination.$el;
      let paginationHTML = "";
      if (params.type === "bullets") {
        let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
          numberOfBullets = slidesLength;
        }
        for (let i4 = 0; i4 < numberOfBullets; i4 += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i4, params.bulletClass);
          } else {
            paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }
        $el.html(paginationHTML);
        swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
      }
      if (params.type === "fraction") {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
        }
        $el.html(paginationHTML);
      }
      if (params.type === "progressbar") {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }
        $el.html(paginationHTML);
      }
      if (params.type !== "custom") {
        emit("paginationRender", swiper.pagination.$el[0]);
      }
    }
    function init5() {
      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
        el: "swiper-pagination"
      });
      const params = swiper.params.pagination;
      if (!params.el) return;
      let $el = dom_default(params.el);
      if ($el.length === 0) return;
      if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1) {
        $el = swiper.$el.find(params.el);
        if ($el.length > 1) {
          $el = $el.filter((el) => {
            if (dom_default(el).parents(".swiper")[0] !== swiper.el) return false;
            return true;
          });
        }
      }
      if (params.type === "bullets" && params.clickable) {
        $el.addClass(params.clickableClass);
      }
      $el.addClass(params.modifierClass + params.type);
      $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === "bullets" && params.dynamicBullets) {
        $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === "progressbar" && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        $el.on("click", classesToSelector(params.bulletClass), function onClick2(e4) {
          e4.preventDefault();
          let index2 = dom_default(this).index() * swiper.params.slidesPerGroup;
          if (swiper.params.loop) index2 += swiper.loopedSlides;
          swiper.slideTo(index2);
        });
      }
      Object.assign(swiper.pagination, {
        $el,
        el: $el[0]
      });
      if (!swiper.enabled) {
        $el.addClass(params.lockClass);
      }
    }
    function destroy() {
      const params = swiper.params.pagination;
      if (isPaginationDisabled()) return;
      const $el = swiper.pagination.$el;
      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);
      $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
      if (params.clickable) {
        $el.off("click", classesToSelector(params.bulletClass));
      }
    }
    on2("init", () => {
      if (swiper.params.pagination.enabled === false) {
        disable();
      } else {
        init5();
        render6();
        update();
      }
    });
    on2("activeIndexChange", () => {
      if (swiper.params.loop) {
        update();
      } else if (typeof swiper.snapIndex === "undefined") {
        update();
      }
    });
    on2("snapIndexChange", () => {
      if (!swiper.params.loop) {
        update();
      }
    });
    on2("slidesLengthChange", () => {
      if (swiper.params.loop) {
        render6();
        update();
      }
    });
    on2("snapGridLengthChange", () => {
      if (!swiper.params.loop) {
        render6();
        update();
      }
    });
    on2("destroy", () => {
      destroy();
    });
    on2("enable disable", () => {
      const {
        $el
      } = swiper.pagination;
      if ($el) {
        $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.pagination.lockClass);
      }
    });
    on2("lock unlock", () => {
      update();
    });
    on2("click", (_s, e4) => {
      const targetEl = e4.target;
      const {
        $el
      } = swiper.pagination;
      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !dom_default(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        const isHidden3 = $el.hasClass(swiper.params.pagination.hiddenClass);
        if (isHidden3 === true) {
          emit("paginationShow");
        } else {
          emit("paginationHide");
        }
        $el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    });
    const enable = () => {
      swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
      if (swiper.pagination.$el) {
        swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
      }
      init5();
      render6();
      update();
    };
    const disable = () => {
      swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);
      if (swiper.pagination.$el) {
        swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
      }
      destroy();
    };
    Object.assign(swiper.pagination, {
      enable,
      disable,
      render: render6,
      update,
      init: init5,
      destroy
    });
  }

  // node_modules/swiper/modules/lazy/lazy.js
  function Lazy({
    swiper,
    extendParams,
    on: on2,
    emit
  }) {
    extendParams({
      lazy: {
        checkInView: false,
        enabled: false,
        loadPrevNext: false,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: false,
        scrollingElement: "",
        elementClass: "swiper-lazy",
        loadingClass: "swiper-lazy-loading",
        loadedClass: "swiper-lazy-loaded",
        preloaderClass: "swiper-lazy-preloader"
      }
    });
    swiper.lazy = {};
    let scrollHandlerAttached = false;
    let initialImageLoaded = false;
    function loadInSlide(index2, loadInDuplicate = true) {
      const params = swiper.params.lazy;
      if (typeof index2 === "undefined") return;
      if (swiper.slides.length === 0) return;
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index2}"]`) : swiper.slides.eq(index2);
      const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
        $images.push($slideEl[0]);
      }
      if ($images.length === 0) return;
      $images.each((imageEl) => {
        const $imageEl = dom_default(imageEl);
        $imageEl.addClass(params.loadingClass);
        const background = $imageEl.attr("data-background");
        const src = $imageEl.attr("data-src");
        const srcset = $imageEl.attr("data-srcset");
        const sizes = $imageEl.attr("data-sizes");
        const $pictureEl = $imageEl.parent("picture");
        swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
          if (typeof swiper === "undefined" || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
          if (background) {
            $imageEl.css("background-image", `url("${background}")`);
            $imageEl.removeAttr("data-background");
          } else {
            if (srcset) {
              $imageEl.attr("srcset", srcset);
              $imageEl.removeAttr("data-srcset");
            }
            if (sizes) {
              $imageEl.attr("sizes", sizes);
              $imageEl.removeAttr("data-sizes");
            }
            if ($pictureEl.length) {
              $pictureEl.children("source").each((sourceEl) => {
                const $source = dom_default(sourceEl);
                if ($source.attr("data-srcset")) {
                  $source.attr("srcset", $source.attr("data-srcset"));
                  $source.removeAttr("data-srcset");
                }
              });
            }
            if (src) {
              $imageEl.attr("src", src);
              $imageEl.removeAttr("data-src");
            }
          }
          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
          $slideEl.find(`.${params.preloaderClass}`).remove();
          if (swiper.params.loop && loadInDuplicate) {
            const slideOriginalIndex = $slideEl.attr("data-swiper-slide-index");
            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
              const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
              loadInSlide(originalSlide.index(), false);
            } else {
              const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
              loadInSlide(duplicatedSlide.index(), false);
            }
          }
          emit("lazyImageReady", $slideEl[0], $imageEl[0]);
          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        });
        emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
      });
    }
    function load() {
      const {
        $wrapperEl,
        params: swiperParams,
        slides,
        activeIndex
      } = swiper;
      const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
      const params = swiperParams.lazy;
      let slidesPerView = swiperParams.slidesPerView;
      if (slidesPerView === "auto") {
        slidesPerView = 0;
      }
      function slideExist(index2) {
        if (isVirtual) {
          if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index2}"]`).length) {
            return true;
          }
        } else if (slides[index2]) return true;
        return false;
      }
      function slideIndex(slideEl) {
        if (isVirtual) {
          return dom_default(slideEl).attr("data-swiper-slide-index");
        }
        return dom_default(slideEl).index();
      }
      if (!initialImageLoaded) initialImageLoaded = true;
      if (swiper.params.watchSlidesProgress) {
        $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((slideEl) => {
          const index2 = isVirtual ? dom_default(slideEl).attr("data-swiper-slide-index") : dom_default(slideEl).index();
          loadInSlide(index2);
        });
      } else if (slidesPerView > 1) {
        for (let i4 = activeIndex; i4 < activeIndex + slidesPerView; i4 += 1) {
          if (slideExist(i4)) loadInSlide(i4);
        }
      } else {
        loadInSlide(activeIndex);
      }
      if (params.loadPrevNext) {
        if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
          const amount = params.loadPrevNextAmount;
          const spv = Math.ceil(slidesPerView);
          const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
          const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
          for (let i4 = activeIndex + spv; i4 < maxIndex; i4 += 1) {
            if (slideExist(i4)) loadInSlide(i4);
          }
          for (let i4 = minIndex; i4 < activeIndex; i4 += 1) {
            if (slideExist(i4)) loadInSlide(i4);
          }
        } else {
          const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
          if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
          const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
          if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
        }
      }
    }
    function checkInViewOnLoad() {
      const window2 = getWindow();
      if (!swiper || swiper.destroyed) return;
      const $scrollElement = swiper.params.lazy.scrollingElement ? dom_default(swiper.params.lazy.scrollingElement) : dom_default(window2);
      const isWindow = $scrollElement[0] === window2;
      const scrollElementWidth = isWindow ? window2.innerWidth : $scrollElement[0].offsetWidth;
      const scrollElementHeight = isWindow ? window2.innerHeight : $scrollElement[0].offsetHeight;
      const swiperOffset = swiper.$el.offset();
      const {
        rtlTranslate: rtl
      } = swiper;
      let inView = false;
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
      for (let i4 = 0; i4 < swiperCoord.length; i4 += 1) {
        const point = swiperCoord[i4];
        if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
          if (point[0] === 0 && point[1] === 0) continue;
          inView = true;
        }
      }
      const passiveListener = swiper.touchEvents.start === "touchstart" && swiper.support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      if (inView) {
        load();
        $scrollElement.off("scroll", checkInViewOnLoad, passiveListener);
      } else if (!scrollHandlerAttached) {
        scrollHandlerAttached = true;
        $scrollElement.on("scroll", checkInViewOnLoad, passiveListener);
      }
    }
    on2("beforeInit", () => {
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    });
    on2("init", () => {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on2("scroll", () => {
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
        load();
      }
    });
    on2("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on2("transitionStart", () => {
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      }
    });
    on2("transitionEnd", () => {
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    });
    on2("slideChange", () => {
      const {
        lazy,
        cssMode,
        watchSlidesProgress,
        touchReleaseOnEdges,
        resistanceRatio
      } = swiper.params;
      if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
        load();
      }
    });
    on2("destroy", () => {
      if (!swiper.$el) return;
      swiper.$el.find(`.${swiper.params.lazy.loadingClass}`).removeClass(swiper.params.lazy.loadingClass);
    });
    Object.assign(swiper.lazy, {
      load,
      loadInSlide
    });
  }

  // assets/scripts/modules/Gallery.js
  var Gallery_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$container = this.$("container")[0];
      this.$pagination = this.$("pagination")[0];
      this.$nextBtn = this.$("next")[0];
      console.log(this);
    }
    init() {
      this.swiper = new core_default(this.$container, {
        modules: [Lazy, Pagination, Navigation],
        loop: true,
        loopAdditionalSlides: 1,
        preloadImages: false,
        grabCursor: true,
        lazy: {
          checkInView: true,
          loadPrevNext: true
        },
        pagination: {
          el: this.$pagination,
          type: "custom",
          renderCustom(swiper, current, total) {
            return `${current.toString().padStart(2, "0")} / ${total.toString().padStart(2, "0")}`;
          }
        },
        navigation: {
          nextEl: this.$nextBtn
        },
        on: {
          init(swiper) {
            if (swiper.lazy && swiper.lazy.enabled !== false) {
              for (let slide of swiper.slides) {
                slide.classList.add("-pixelated");
              }
            }
          },
          lazyImageReady(swiper, slideEl, imageEl) {
            animDepixelate(imageEl);
            slideEl.classList.remove("-pixelated");
          },
          slideChange(swiper) {
            const activeSlide = swiper.slides[swiper.activeIndex];
            const slideIndex = activeSlide.getAttribute("data-swiper-slide-index");
            for (let slide of swiper.slides.filter((item) => item.getAttribute("data-swiper-slide-index") == slideIndex)) {
              const video = slide.querySelector("video");
              video == null ? void 0 : video.play();
            }
          },
          click(swiper, event2) {
            if (swiper.clickedSlide.classList.contains("swiper-slide-next")) {
              swiper.slideNext();
            }
          }
        }
      });
    }
    inview(e4) {
      if (e4.target == this.el) {
        this.swiper.lazy.load();
      }
    }
  };

  // assets/scripts/modules/GridHelper.js
  var GridHelper = class _GridHelper extends _default {
    static get settings() {
      return {
        GUTTER: "var(--grid-gutter, 0)",
        MARGIN: "var(--grid-margin, 0)",
        COLOR: "var(--grid-color)"
      };
    }
    constructor(m2) {
      super(m2);
    }
    init() {
      this.setColumns();
      this.setStyles();
      this.bindEvents();
      window.addEventListener("resize", this.onResize = () => this.setColumns());
    }
    setColumns() {
      this.el.innerHTML = "";
      const columns = Number(window.getComputedStyle(this.el).getPropertyValue("--grid-columns"));
      let $col;
      for (var i4 = 0; i4 < columns; i4++) {
        $col = document.createElement("div");
        $col.style.flex = "1 1 0";
        $col.style.backgroundColor = _GridHelper.settings.COLOR;
        this.el.appendChild($col);
      }
    }
    setStyles() {
      const elStyles = this.el.style;
      elStyles.zIndex = "10000";
      elStyles.position = "fixed";
      elStyles.top = "0";
      elStyles.left = "0";
      elStyles.display = "flex";
      elStyles.width = "100%";
      elStyles.height = "100%";
      elStyles.columnGap = _GridHelper.settings.GUTTER;
      elStyles.paddingLeft = `calc(${_GridHelper.settings.MARGIN}`;
      elStyles.paddingRight = `calc(${_GridHelper.settings.MARGIN}`;
      elStyles.pointerEvents = "none";
      elStyles.visibility = "hidden";
      elStyles.opacity = 0.1;
    }
    bindEvents() {
      let ctrlDown = false;
      let isActive = false;
      document.addEventListener("keydown", (e4) => {
        if (e4.key == "Control") {
          ctrlDown = true;
        } else {
          if (ctrlDown && e4.key == "g") {
            if (isActive) {
              this.el.style.visibility = "visible";
            } else {
              this.el.style.visibility = "hidden";
            }
            isActive = !isActive;
          }
        }
      });
      document.addEventListener("keyup", (e4) => {
        if (e4.key == "Control") {
          ctrlDown = false;
        }
      });
    }
    destroy() {
      window.removeEventListener("resize", this.onResize);
    }
  };

  // assets/scripts/utils/environment.js
  var html2 = document.documentElement;
  var body = document.body;
  var isDebug = html2.hasAttribute("data-debug");
  var canvas = document.createElement("canvas");
  var gl;
  try {
    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  } catch (e4) {
    console.error(e4);
  }
  var SUPPORT_WEBGL = gl ? true : false;
  if (!SUPPORT_WEBGL) {
    html2.classList.add("has-no-webgl-support");
    alert("Your browser does not support WebGL. Unfortunately that means you will not get the full experience from our website and miss out on cool features. We recommend you to update your browser to a modern version!");
  }
  var models = [];

  // node_modules/tabbable/dist/index.esm.js
  var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    return element.getRootNode();
  } : function(element) {
    return element.ownerDocument;
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter2) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter2);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content = assigned.length ? assigned : element.children;
        var nestedCandidates = getCandidatesIteratively2(content, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
        var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scope: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var getTabindex = function getTabindex2(node, isScope) {
    if (node.tabIndex < 0) {
      if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a3, b2) {
    return a3.tabIndex === b2.tabIndex ? a3.documentOrder - b2.documentOrder : a3.tabIndex - b2.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r3 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r3;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i4 = 0; i4 < nodes.length; i4++) {
      if (nodes[i4].checked && nodes[i4].form === form) {
        return nodes[i4];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isNodeAttached = function isNodeAttached2(node) {
    var _nodeRootHost;
    var nodeRootHost = getRootNode(node).host;
    var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRootHost2;
      nodeRootHost = getRootNode(nodeRootHost).host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
    }
    return attached;
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (isNodeAttached(node)) {
        return !node.getClientRects().length;
      }
      if (displayCheck !== "legacy-full") {
        return true;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i4 = 0; i4 < parentNode.children.length; i4++) {
            var child = parentNode.children.item(i4);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i4) {
      var isScope = !!item.scope;
      var element = isScope ? item.scope : item;
      var candidateTabindex = getTabindex(element, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i4,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options),
        flatten: false,
        getShadowRoot: options.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options),
        flatten: true,
        getShadowRoot: options.getShadowRoot
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };

  // node_modules/focus-trap/dist/focus-trap.esm.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = null != arguments[i4] ? arguments[i4] : {};
      i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var activeFocusTraps = /* @__PURE__ */ function() {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }
        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e4) {
    return e4.key === "Escape" || e4.key === "Esc" || e4.keyCode === 27;
  };
  var isTabEvent = function isTabEvent2(e4) {
    return e4.key === "Tab" || e4.keyCode === 9;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var findIndex = function findIndex2(arr, fn) {
    var idx = -1;
    arr.every(function(value, i4) {
      if (fn(value)) {
        idx = i4;
        return false;
      }
      return true;
    });
    return idx;
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event2) {
    return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
  };
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var config3 = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   firstTabbableNode: HTMLElement|null,
      //   lastTabbableNode: HTMLElement|null,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config3[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element) {
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var optionValue = config3[optionName];
      if (typeof optionValue === "function") {
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }
        optionValue = optionValue.apply(void 0, params);
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        node = doc.querySelector(optionValue);
        if (!node) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus");
      if (node === false) {
        return false;
      }
      if (node === void 0) {
        if (findContainerIndex(doc.activeElement) >= 0) {
          node = doc.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config3.tabbableOptions);
        var focusableNodes = focusable(container, config3.tabbableOptions);
        return {
          container,
          tabbableNodes,
          focusableNodes,
          firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
          lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = focusableNodes.findIndex(function(n4) {
              return n4 === node;
            });
            if (nodeIdx < 0) {
              return void 0;
            }
            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function(n4) {
                return isTabbable(n4, config3.tabbableOptions);
              });
            }
            return focusableNodes.slice(0, nodeIdx).reverse().find(function(n4) {
              return isTabbable(n4, config3.tabbableOptions);
            });
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
    };
    var tryFocus = function tryFocus2(node) {
      if (node === false) {
        return;
      }
      if (node === doc.activeElement) {
        return;
      }
      if (!node || !node.focus) {
        tryFocus2(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config3.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", previousActiveElement);
      return node ? node : node === false ? false : previousActiveElement;
    };
    var checkPointerDown = function checkPointerDown2(e4) {
      var target = getActualTarget(e4);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config3.clickOutsideDeactivates, e4)) {
        trap.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: config3.returnFocusOnDeactivate && !isFocusable(target, config3.tabbableOptions)
        });
        return;
      }
      if (valueOrHandler(config3.allowOutsideClick, e4)) {
        return;
      }
      e4.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(e4) {
      var target = getActualTarget(e4);
      var targetContained = findContainerIndex(target) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        e4.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    };
    var checkTab = function checkTab2(e4) {
      var target = getActualTarget(e4);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (e4.shiftKey) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (e4.shiftKey) {
          var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
            var firstTabbableNode = _ref2.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config3.tabbableOptions) && !isTabbable(target, config3.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = destinationGroup.lastTabbableNode;
          }
        } else {
          var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
            var lastTabbableNode = _ref3.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config3.tabbableOptions) && !isTabbable(target, config3.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = _destinationGroup.firstTabbableNode;
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      if (destinationNode) {
        e4.preventDefault();
        tryFocus(destinationNode);
      }
    };
    var checkKey = function checkKey2(e4) {
      if (isEscapeEvent(e4) && valueOrHandler(config3.escapeDeactivates, e4) !== false) {
        e4.preventDefault();
        trap.deactivate();
        return;
      }
      if (isTabEvent(e4)) {
        checkTab(e4);
        return;
      }
    };
    var checkClick = function checkClick2(e4) {
      var target = getActualTarget(e4);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config3.clickOutsideDeactivates, e4)) {
        return;
      }
      if (valueOrHandler(config3.allowOutsideClick, e4)) {
        return;
      }
      e4.preventDefault();
      e4.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trap);
      state.delayInitialFocusTimer = config3.delayInitialFocus ? delay(function() {
        tryFocus(getInitialFocusNode());
      }) : tryFocus(getInitialFocusNode());
      doc.addEventListener("focusin", checkFocusIn, true);
      doc.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc.addEventListener("keydown", checkKey, {
        capture: true,
        passive: false
      });
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc.removeEventListener("focusin", checkFocusIn, true);
      doc.removeEventListener("mousedown", checkPointerDown, true);
      doc.removeEventListener("touchstart", checkPointerDown, true);
      doc.removeEventListener("click", checkClick, true);
      doc.removeEventListener("keydown", checkKey, true);
      return trap;
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        if (onActivate) {
          onActivate();
        }
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          if (onPostActivate) {
            onPostActivate();
          }
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options = _objectSpread2({
          onDeactivate: config3.onDeactivate,
          onPostDeactivate: config3.onPostDeactivate,
          checkCanReturnFocus: config3.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate = getOption(options, "onDeactivate");
        var onPostDeactivate = getOption(options, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
        var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
        if (onDeactivate) {
          onDeactivate();
        }
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            if (onPostDeactivate) {
              onPostDeactivate();
            }
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause() {
        if (state.paused || !state.active) {
          return this;
        }
        state.paused = true;
        removeListeners();
        return this;
      },
      unpause: function unpause() {
        if (!state.paused || !state.active) {
          return this;
        }
        state.paused = false;
        updateTabbableNodes();
        addListeners();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        return this;
      }
    };
    trap.updateContainerElements(elements);
    return trap;
  };

  // assets/scripts/utils/string.js
  function shuffle4(input) {
    var a3 = typeof input == "string" ? input.split("") : input, n4 = a3.length;
    for (var i4 = n4 - 1; i4 > 0; i4--) {
      var j2 = Math.floor(Math.random() * (i4 + 1));
      var tmp = a3[i4];
      a3[i4] = a3[j2];
      a3[j2] = tmp;
    }
    return a3.join("");
  }
  function moveOneLetter(input) {
    let chars = typeof input == "string" ? input.split("") : input;
    let selectedIndex = Math.floor(Math.random() * chars.length);
    const char = chars.splice(selectedIndex, 1)[0];
    const newPosition = Math.floor(Math.random() * chars.length);
    chars.splice(newPosition, 0, char);
    return chars.join("");
  }

  // assets/scripts/modules/Header.js
  var Header_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$header = this.$("header")[0];
      this.$menuToggler = this.$("menu-toggler")[0];
      this.$menu = this.$("menu")[0];
      this.events = {
        click: {
          "menu-toggler": "toggleMenu",
          "logo": "hideMenu"
        }
      };
    }
    init() {
      window.addEventListener("keydown", this.onKeyDown = (e4) => {
        if (e4.keyCode === 27 && this.hasMenuOpened()) {
          this.hideMenu();
        }
      });
      this.focusTrap = createFocusTrap([this.$header, this.$menu]);
    }
    hasMenuOpened() {
      return html2.classList.contains("has-menu-opened");
    }
    showMenu() {
      html2.classList.add("has-menu-opened");
      this.$menuToggler.innerText = this.getData("close-label", this.$menuToggler);
      this.$menuToggler.setAttribute("aria-expanded", true);
      this.focusTrap.activate();
    }
    hideMenu() {
      html2.classList.remove("has-menu-opened");
      this.$menuToggler.innerText = this.getData("open-label", this.$menuToggler);
      this.$menuToggler.setAttribute("aria-expanded", false);
      this.focusTrap.deactivate();
    }
    toggleMenu() {
      if (!this.hasMenuOpened()) {
        this.showMenu();
      } else {
        this.hideMenu();
      }
    }
    destroy() {
      super.destroy();
      this.focusTrap.deactivate();
    }
  };

  // assets/scripts/modules/HomeHero.js
  var HomeHero_default = class extends _default {
    constructor(m2) {
      super(m2);
    }
    inview(e4) {
      if (e4.target != this.el) return;
      html2.classList.toggle("is-over-home-hero", e4.way == "enter");
    }
    destroy() {
      html2.classList.remove("is-over-home-hero");
    }
  };

  // assets/scripts/modules/Hovers.js
  var DURATION = 0.25;
  var Hovers_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.shuffleElements = [];
    }
    init() {
      this.onItemEnterBind = this.onItemEnter.bind(this);
      this.onItemLeaveBind = this.onItemLeave.bind(this);
      this.update();
    }
    onItemEnter(e4) {
      const $el = e4.currentTarget;
      let targets = [];
      if ($el.dataset.hoverShuffle == "children") {
        $el.querySelectorAll("[data-hover-shuffle-child]").forEach((child) => {
          targets.push(child);
          child.setAttribute("aria-label", child.innerText);
        });
      } else {
        targets = [$el];
        $el.setAttribute("aria-label", $el.innerText);
      }
      this.tw = gsapWithCSS.timeline({
        onComplete: () => {
          targets.forEach(($target) => {
            $target.innerText = $target.getAttribute("aria-label");
            $target.removeAttribute("aria-label");
          });
        }
      });
      const shufflePerSecond = 4;
      const shuffleDelay = DURATION / shufflePerSecond;
      for (let i4 = 0; i4 < shufflePerSecond; i4++) {
        for (let $target of targets) {
          this.tw.add(() => {
            shuffleElementTexts($target, shuffle4);
          }, shuffleDelay * i4);
        }
      }
    }
    onItemLeave(e4) {
      this.tw && this.tw.kill();
      const $el = e4.currentTarget;
      let targets = [];
      if ($el.dataset.hoverShuffle == "children") {
        $el.querySelectorAll("[data-hover-shuffle-child]").forEach((child) => {
          targets.push(child);
        });
      } else {
        targets = [$el];
      }
      targets.forEach(($target) => {
        if ($target.getAttribute("aria-label")) $target.innerText = $target.getAttribute("aria-label");
        $target.removeAttribute("aria-label");
      });
    }
    reset() {
      this.shuffleElements.forEach((el) => {
        el.removeEventListener("mouseenter", this.onItemEnterBind);
        el.removeEventListener("mouseleave", this.onItemLeaveBind);
      });
      this.shuffleElements = [];
    }
    update() {
      this.reset();
      document.querySelectorAll("[data-hover-shuffle]").forEach((el) => {
        el.addEventListener("mouseenter", this.onItemEnterBind);
        el.addEventListener("mouseleave", this.onItemLeaveBind);
        this.shuffleElements.push(el);
      });
    }
  };

  // assets/scripts/modules/ImagesSequence.js
  var START_FRAME = 0;
  Promise.pending = Promise.race.bind(Promise, []);
  var ImagesSequence_default = class extends _default {
    constructor(m2) {
      super(m2);
      const imagesPath = this.getData("images-path");
      if (!imagesPath) {
        console.warn("Please add the sequence path in data-images-sequence-images-path");
        return;
      }
      this.onResizeBind = this.onResize.bind(this);
      this.onUpdateBind = this.onUpdate.bind(this);
      this.$el = this.$("ref")[0];
      this.$canvas = this.$("canvas")[0];
      this.width = false;
      this.height = this.$el.offsetHeight;
      this.dpr = window.devicePixelRatio;
      this.progress = 0;
      this.preloadStep = 16;
      this.isSequenceReady = false;
      this.totalFrames = this.getData("total-frames") || 0;
      this.images = {
        path: imagesPath,
        exension: ".jpg",
        totalLength: parseInt(this.totalFrames),
        framesToLoad: [],
        framesLoaded: []
      };
      this.autoplay = this.getData("autoplay") || false;
      this.raf = {
        framerate: 1 / 120 * 1e3,
        deltaTime: 0,
        time: performance.now(),
        lt: performance.now(),
        elapsedInterval: 0
      };
    }
    ///////////////
    // Lifecyle
    ///////////////
    init() {
      this.updateSize();
      this.bindEvents();
      if (window.isFontsLoaded) {
        this.onFontsLoaded();
      }
      this.setImages();
      if (this.getData("force-launch") != null) {
        this.launch();
      }
    }
    launch() {
      return __async(this, null, function* () {
        this.launched = true;
        yield this.loadSequence(true);
        this.isSequenceReady = true;
        this.el.classList.add("is-sequence-loaded");
        this.onUpdate();
        if (this.autoplay) {
          setTimeout(() => {
            this.play();
          }, 1e3);
        }
      });
    }
    destroy() {
      super.destroy();
      this.aborted = true;
      this.unbindEvents();
      this.onLeave();
    }
    ///////////////
    // Events
    ///////////////
    bindEvents() {
      window.addEventListener("resize", this.onResizeBind);
    }
    unbindEvents() {
      window.removeEventListener("resize", this.onResizeBind);
    }
    ///////////////
    // Callbacks
    ///////////////
    onResize() {
      if (!this.resizeTick) {
        this.resizeTick = true;
        requestAnimationFrame(() => {
          this.updateSize();
          this.resizeTick = false;
        });
      }
    }
    onUpdate() {
      if (!this.isPlaying || !this.isSequenceReady) return;
      this.raf.time = performance.now();
      this.raf.deltaTime = this.raf.time - this.raf.lt;
      this.raf.elapsedInterval += this.raf.deltaTime;
      if (this.raf.elapsedInterval >= this.raf.framerate) {
        this.raf.elapsedInterval = 0;
        this.setCurrentFrame();
        this.drawImage();
      }
      this.raf.lt = this.raf.time;
    }
    onScrollProgress(progress) {
      this.progress = progress;
    }
    onEnter() {
      if (!this.launched) this.launch();
      this.play();
    }
    onLeave() {
      this.pause();
    }
    onToggle(args) {
      if (args.target != this.el) {
        return;
      }
      if (args.way === "enter") {
        this.onEnter();
      } else if (args.way === "exit") {
        this.onLeave();
      }
    }
    ///////////////
    // Methods
    ///////////////
    updateSize() {
      if (this.width && this.width == this.$el.offsetWidth) return;
      this.width = this.$el.offsetWidth;
      this.height = this.$el.offsetHeight;
      this.$canvas.width = Math.ceil(this.dpr * this.width / 4) * 4;
      this.$canvas.height = Math.ceil(this.dpr * this.height / 4) * 4;
      this.$canvas.style = `width: ${this.width}px; height: ${this.height}px;`;
      this.ctx = this.$canvas.getContext("2d");
      this.onUpdate();
    }
    play() {
      if (this.isPlaying) return;
      this.isPlaying = true;
      gsapWithCSS.ticker.add(this.onUpdateBind);
    }
    pause() {
      if (!this.isPlaying) return;
      this.isPlaying = false;
      gsapWithCSS.ticker.remove(this.onUpdateBind);
    }
    setImages() {
      for (let i4 = 0; i4 <= this.images.totalLength; i4++) {
        this.images.framesToLoad[i4] = {
          index: i4,
          src: `${this.images.path}${this._pad(i4, 4)}${this.images.exension}`
        };
      }
    }
    loadSequence(firstLoop = true) {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        const imagesToLoad = [];
        const step = this.preloadStep;
        let index2 = 0;
        while (index2 < this.images.framesToLoad.length) {
          if (this.aborted) {
            resolve();
            return;
          }
          const frame = this.images.framesToLoad[index2];
          if (firstLoop && index2 % step === 0 || !firstLoop && index2 > 0 && index2 % step === 0 && index2 / 2 % step !== 0) {
            const imagePromise = yield loadImage(frame.src, { index: frame.index });
            imagesToLoad.push(imagePromise);
          }
          index2++;
        }
        const loadedFrames = [...this.images.framesLoaded, ...imagesToLoad];
        loadedFrames.sort((a3, b2) => a3.index - b2.index);
        this.images.framesLoaded = loadedFrames;
        resolve();
        if (step > 1) {
          this.preloadStep = step / 2;
          requestAnimationFrame(() => {
            this.loadSequence(false);
          });
        } else {
        }
      }));
    }
    setCurrentFrame() {
      this.currentFrame = (START_FRAME + Math.min(Math.floor(this.progress * this.images.framesLoaded.length), this.images.framesLoaded.length - 1)) % this.images.framesLoaded.length;
    }
    drawImage() {
      const image2 = this.images.framesLoaded[this.currentFrame];
      const scaleX = this.$canvas.width / image2.width;
      const scaleY = this.$canvas.height / image2.height;
      const scale = Math.max(scaleX, scaleY);
      const width = image2.width * scale;
      const height = image2.height * scale;
      const x2 = (this.$canvas.width - width) * 0.5;
      const y2 = (this.$canvas.height - height) * 0.5;
      this.ctx.clearRect(0, 0, this.$canvas.width, this.$canvas.height);
      this.ctx.drawImage(image2.element, x2, y2, width, height);
      if (this.autoplay) {
        this.progress = (this.progress + 2e-3) % 1;
      }
    }
    // Prepend leading 0 to number
    _pad(x2, width) {
      return String(x2).padStart(width, "0");
    }
  };

  // assets/scripts/modules/Load.js
  var import_core2 = __toESM(require_barba_umd(), 1);

  // assets/scripts/transitions/default.js
  var DURATION2 = 0.25;
  var timeline2;
  var default_default = {
    name: "default",
    leave(data) {
      const timeoutPromise = new Promise((resolve) => {
        setTimeout(resolve, 250);
      });
      const shufflePromise = new Promise((resolve) => {
        let inviewItems = [];
        let observer = new IntersectionObserver((entries, observer2) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const target = entry.target;
              if ((!target.children.length || target.dataset.allowShuffle != void 0) && target.innerText) {
                inviewItems.push(target);
              }
            }
          });
          observer2.disconnect();
          observer2 = null;
          timeline2 && timeline2.kill && timeline2.kill();
          timeline2 = gsapWithCSS.timeline({
            onComplete: resolve
          });
          const shufflePerSecond = 16;
          for (let i4 = 0; i4 < shufflePerSecond * 10; i4++) {
            for (let item of inviewItems) {
              item.style.fontKerning = "none";
              timeline2.call(() => {
                shuffleElementTexts(item, moveOneLetter);
              }, {}, 1 / shufflePerSecond * i4);
            }
          }
        }, { threshold: [0] });
        data.current.container.querySelectorAll("*").forEach((item) => {
          observer.observe(item);
        });
      });
      return Promise.all([timeoutPromise]);
    },
    enter(data) {
      document.documentElement.scrollTop = 0;
      const shufflePromise = new Promise((resolve) => {
        let inviewItems = [];
        let observer = new IntersectionObserver((entries, observer2) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const target = entry.target;
              if ((!target.children.length || target.dataset.allowShuffle != void 0) && target.innerText) {
                inviewItems.push(target);
                target.setAttribute("aria-label", target.innerText);
              }
            }
          });
          observer2.disconnect();
          observer2 = null;
          timeline2 && timeline2.kill && timeline2.kill();
          timeline2 = gsapWithCSS.timeline({
            onComplete: () => {
              for (let item of inviewItems) {
                item.innerText = item.getAttribute("aria-label");
                item.removeAttribute("aria-label");
                item.style.fontKerning = "";
              }
              resolve();
            }
          });
          const shufflePerSecond = 4;
          const shuffleDelay = DURATION2 / shufflePerSecond;
          for (let i4 = 0; i4 < shufflePerSecond; i4++) {
            for (let item of inviewItems) {
              item.style.fontKerning = "none";
              timeline2.call(() => {
                shuffleElementTexts(item, moveOneLetter);
              }, {}, shuffleDelay * i4);
            }
          }
        }, { threshold: [0] });
        data.next.container.querySelectorAll("*").forEach((item) => {
          observer.observe(item);
        });
      });
      return shufflePromise;
    }
  };

  // assets/scripts/transitions/workList.js
  var workList_default = {
    name: "work-list",
    leave(data) {
      let scrollPromise = new Promise((resolve) => {
        resolve();
      });
      let animationPromise = gsapWithCSS.to(data.current.container.querySelector(".c-work-list_list"), {
        duration: 0.25,
        opacity: 0.25
      });
      return Promise.all([scrollPromise, animationPromise]);
    },
    enter(data) {
      return gsapWithCSS.from(data.next.container.querySelector(".c-work-list_list"), {
        duration: 0.25,
        opacity: 0.25
      });
    },
    from: {
      custom({ trigger: trigger2 }) {
        return trigger2 && trigger2.dataset && trigger2.dataset.loadTransition == "work-list";
      }
    }
  };

  // assets/scripts/transitions/workNext.js
  var DURATION3 = 0.25;
  var workNext_default = {
    name: "work-next",
    leave(data) {
      const overline = data.current.container.querySelector(".c-work-next_overline");
      const tl = gsapWithCSS.timeline();
      const shufflePerSecond = 16;
      const shuffleDelay = DURATION3 / shufflePerSecond;
      for (let i4 = 0; i4 < shufflePerSecond; i4++) {
        tl.call(() => {
          shuffleContainerTexts(overline, moveOneLetter);
        }, {}, shuffleDelay * i4);
      }
      return Promise.all([tl]);
    },
    enter(data) {
      document.documentElement.scrollTop = 0;
      const fadeInEl = data.next.container.querySelector(".c-work-single-hero_grid.-top");
      let inviewItems = [];
      let targets = fadeInEl.querySelectorAll("*");
      for (let target of targets) {
        if ((!target.children.length || target.dataset.allowShuffle != void 0) && target.innerText) {
          inviewItems.push(target);
          target.setAttribute("aria-label", target.innerText);
        }
      }
      const tl = gsapWithCSS.timeline({
        onComplete: () => {
          for (let item of inviewItems) {
            item.innerText = item.getAttribute("aria-label");
            item.removeAttribute("aria-label");
          }
        }
      });
      const shufflePerSecond = 16;
      const shuffleDelay = DURATION3 / shufflePerSecond;
      for (let i4 = 0; i4 < shufflePerSecond; i4++) {
        for (let item of inviewItems) {
          tl.call(() => {
            shuffleElementTexts(item, moveOneLetter);
          }, {}, shuffleDelay * i4);
        }
      }
      return tl;
    },
    from: {
      custom({ trigger: trigger2 }) {
        return trigger2 && trigger2.dataset && trigger2.dataset.loadTransition == "work-next";
      }
    }
  };

  // assets/scripts/modules/Load.js
  var toDash = (str) => str.split(/(?=[A-Z])/).join("-").toLowerCase();
  var Load_default = class extends _default {
    constructor(m2) {
      super(m2);
    }
    init() {
      import_core2.default.init({
        timeout: 1e4,
        schema: {
          prefix: "data-load"
        },
        transitions: [
          default_default,
          workList_default,
          workNext_default
        ],
        prevent: ({ el, event: event2, href }) => {
          if (window.confirmPageChange && event2.type == "click") {
            this.call("close", null, "Nav");
            import_core2.default.prefetch(href);
            if (window.confirm(window.confirmPageChange.message)) {
              const barbaLoad = import_core2.default.go(href);
              if (!barbaLoad) window.location = href;
            }
            event2.preventDefault();
            return true;
          } else {
            const forceReload = el.getAttribute("data-load") == "false" || false;
            if (window.location.href == href) {
              event2.preventDefault();
              event2.stopPropagation();
              return true;
            } else if (forceReload) {
              return true;
            } else {
              return false;
            }
          }
        }
      });
      import_core2.default.hooks.before(this.before.bind(this));
      import_core2.default.hooks.beforeLeave(this.beforeLeave.bind(this));
      import_core2.default.hooks.leave(this.leave.bind(this));
      import_core2.default.hooks.afterLeave(this.afterLeave.bind(this));
      import_core2.default.hooks.enter(this.enter.bind(this));
      import_core2.default.hooks.after(this.after.bind(this));
    }
    before(data, transition2) {
    }
    beforeLeave() {
    }
    leave() {
      this.call("reset", null, "Hovers");
      this.call("hideMenu", null, "Header");
      html2.classList.add("is-loading");
      html2.classList.remove("is-loaded");
      html2.classList.remove("is-ready");
    }
    afterLeave(data) {
      this.call("destroy", data.current.container, "app");
      data.current.container.remove();
    }
    beforeEnter() {
    }
    enter(data) {
      const parser = new DOMParser();
      let nextDOM = parser.parseFromString(data.next.html, "text/html");
      let newDataset = Object.assign({}, nextDOM.querySelector("html").dataset);
      Object.entries(newDataset).forEach(([key, val]) => {
        html2.setAttribute("data-" + toDash(key), val);
      });
      requestAnimationFrame(() => {
        html2.classList.remove("is-loading");
        html2.classList.add("is-loaded");
        this.call("update", data.next.container, "app");
      });
    }
    manualGo(el) {
      import_core2.default.go(el.href, el);
    }
    after(data) {
      html2.classList.add("is-ready");
      this.call("update", null, "Hovers");
    }
  };

  // node_modules/three/build/three.module.js
  var REVISION = "165";
  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var VSMShadowMap = 3;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var ConstantColorFactor = 211;
  var OneMinusConstantColorFactor = 212;
  var ConstantAlphaFactor = 213;
  var OneMinusConstantAlphaFactor = 214;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var CineonToneMapping = 3;
  var ACESFilmicToneMapping = 4;
  var CustomToneMapping = 5;
  var AgXToneMapping = 6;
  var NeutralToneMapping = 7;
  var AttachedBindMode = "attached";
  var DetachedBindMode = "detached";
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var CubeUVReflectionMapping = 306;
  var RepeatWrapping = 1e3;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipmapNearestFilter = 1004;
  var NearestMipmapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipmapNearestFilter = 1007;
  var LinearMipmapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedInt248Type = 1020;
  var UnsignedInt5999Type = 35902;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RedIntegerFormat = 1029;
  var RGFormat = 1030;
  var RGIntegerFormat = 1031;
  var RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGB_ETC2_Format = 37492;
  var RGBA_ETC2_EAC_Format = 37496;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var RGBA_BPTC_Format = 36492;
  var RGB_BPTC_SIGNED_Format = 36494;
  var RGB_BPTC_UNSIGNED_Format = 36495;
  var RED_RGTC1_Format = 36283;
  var SIGNED_RED_RGTC1_Format = 36284;
  var RED_GREEN_RGTC2_Format = 36285;
  var SIGNED_RED_GREEN_RGTC2_Format = 36286;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var NormalAnimationBlendMode = 2500;
  var AdditiveAnimationBlendMode = 2501;
  var TrianglesDrawMode = 0;
  var TriangleStripDrawMode = 1;
  var TriangleFanDrawMode = 2;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var NoColorSpace = "";
  var SRGBColorSpace = "srgb";
  var LinearSRGBColorSpace = "srgb-linear";
  var DisplayP3ColorSpace = "display-p3";
  var LinearDisplayP3ColorSpace = "display-p3-linear";
  var LinearTransfer = "linear";
  var SRGBTransfer = "srgb";
  var Rec709Primaries = "rec709";
  var P3Primaries = "p3";
  var KeepStencilOp = 7680;
  var AlwaysStencilFunc = 519;
  var NeverCompare = 512;
  var LessCompare = 513;
  var EqualCompare = 514;
  var LessEqualCompare = 515;
  var GreaterCompare = 516;
  var NotEqualCompare = 517;
  var GreaterEqualCompare = 518;
  var AlwaysCompare = 519;
  var StaticDrawUsage = 35044;
  var GLSL3 = "300 es";
  var WebGLCoordinateSystem = 2e3;
  var WebGPUCoordinateSystem = 2001;
  var EventDispatcher = class {
    addEventListener(type, listener) {
      if (this._listeners === void 0) this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
    hasEventListener(type, listener) {
      if (this._listeners === void 0) return false;
      const listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
      if (this._listeners === void 0) return;
      const listeners = this._listeners;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index2 = listenerArray.indexOf(listener);
        if (index2 !== -1) {
          listenerArray.splice(index2, 1);
        }
      }
    }
    dispatchEvent(event2) {
      if (this._listeners === void 0) return;
      const listeners = this._listeners;
      const listenerArray = listeners[event2.type];
      if (listenerArray !== void 0) {
        event2.target = this;
        const array = listenerArray.slice(0);
        for (let i4 = 0, l4 = array.length; i4 < l4; i4++) {
          array[i4].call(this, event2);
        }
        event2.target = null;
      }
    }
  };
  var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
  var _seed = 1234567;
  var DEG2RAD = Math.PI / 180;
  var RAD2DEG = 180 / Math.PI;
  function generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toLowerCase();
  }
  function clamp3(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function euclideanModulo(n4, m2) {
    return (n4 % m2 + m2) % m2;
  }
  function mapLinear(x2, a1, a22, b1, b2) {
    return b1 + (x2 - a1) * (b2 - b1) / (a22 - a1);
  }
  function inverseLerp(x2, y2, value) {
    if (x2 !== y2) {
      return (value - x2) / (y2 - x2);
    } else {
      return 0;
    }
  }
  function lerp2(x2, y2, t3) {
    return (1 - t3) * x2 + t3 * y2;
  }
  function damp(x2, y2, lambda, dt) {
    return lerp2(x2, y2, 1 - Math.exp(-lambda * dt));
  }
  function pingpong(x2, length = 1) {
    return length - Math.abs(euclideanModulo(x2, length * 2) - length);
  }
  function smoothstep(x2, min, max) {
    if (x2 <= min) return 0;
    if (x2 >= max) return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * (3 - 2 * x2);
  }
  function smootherstep(x2, min, max) {
    if (x2 <= min) return 0;
    if (x2 >= max) return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
  }
  function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  }
  function randFloat(low, high) {
    return low + Math.random() * (high - low);
  }
  function randFloatSpread(range) {
    return range * (0.5 - Math.random());
  }
  function seededRandom(s4) {
    if (s4 !== void 0) _seed = s4;
    let t3 = _seed += 1831565813;
    t3 = Math.imul(t3 ^ t3 >>> 15, t3 | 1);
    t3 ^= t3 + Math.imul(t3 ^ t3 >>> 7, t3 | 61);
    return ((t3 ^ t3 >>> 14) >>> 0) / 4294967296;
  }
  function degToRad(degrees) {
    return degrees * DEG2RAD;
  }
  function radToDeg(radians) {
    return radians * RAD2DEG;
  }
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }
  function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
  function setQuaternionFromProperEuler(q2, a3, b2, c3, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c22 = cos(b2 / 2);
    const s22 = sin(b2 / 2);
    const c13 = cos((a3 + c3) / 2);
    const s13 = sin((a3 + c3) / 2);
    const c1_3 = cos((a3 - c3) / 2);
    const s1_3 = sin((a3 - c3) / 2);
    const c3_1 = cos((c3 - a3) / 2);
    const s3_1 = sin((c3 - a3) / 2);
    switch (order) {
      case "XYX":
        q2.set(c22 * s13, s22 * c1_3, s22 * s1_3, c22 * c13);
        break;
      case "YZY":
        q2.set(s22 * s1_3, c22 * s13, s22 * c1_3, c22 * c13);
        break;
      case "ZXZ":
        q2.set(s22 * c1_3, s22 * s1_3, c22 * s13, c22 * c13);
        break;
      case "XZX":
        q2.set(c22 * s13, s22 * s3_1, s22 * c3_1, c22 * c13);
        break;
      case "YXY":
        q2.set(s22 * c3_1, c22 * s13, s22 * s3_1, c22 * c13);
        break;
      case "ZYZ":
        q2.set(s22 * s3_1, s22 * c3_1, c22 * s13, c22 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
  function denormalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return value / 4294967295;
      case Uint16Array:
        return value / 65535;
      case Uint8Array:
        return value / 255;
      case Int32Array:
        return Math.max(value / 2147483647, -1);
      case Int16Array:
        return Math.max(value / 32767, -1);
      case Int8Array:
        return Math.max(value / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function normalize3(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return Math.round(value * 4294967295);
      case Uint16Array:
        return Math.round(value * 65535);
      case Uint8Array:
        return Math.round(value * 255);
      case Int32Array:
        return Math.round(value * 2147483647);
      case Int16Array:
        return Math.round(value * 32767);
      case Int8Array:
        return Math.round(value * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  var MathUtils = {
    DEG2RAD,
    RAD2DEG,
    generateUUID,
    clamp: clamp3,
    euclideanModulo,
    mapLinear,
    inverseLerp,
    lerp: lerp2,
    damp,
    pingpong,
    smoothstep,
    smootherstep,
    randInt,
    randFloat,
    randFloatSpread,
    seededRandom,
    degToRad,
    radToDeg,
    isPowerOfTwo,
    ceilPowerOfTwo,
    floorPowerOfTwo,
    setQuaternionFromProperEuler,
    normalize: normalize3,
    denormalize
  };
  var Vector2 = class _Vector2 {
    constructor(x2 = 0, y2 = 0) {
      _Vector2.prototype.isVector2 = true;
      this.x = x2;
      this.y = y2;
    }
    get width() {
      return this.x;
    }
    set width(value) {
      this.x = value;
    }
    get height() {
      return this.y;
    }
    set height(value) {
      this.y = value;
    }
    set(x2, y2) {
      this.x = x2;
      this.y = y2;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y2) {
      this.y = y2;
      return this;
    }
    setComponent(index2, value) {
      switch (index2) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index2);
      }
      return this;
    }
    getComponent(index2) {
      switch (index2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v2) {
      this.x = v2.x;
      this.y = v2.y;
      return this;
    }
    add(v2) {
      this.x += v2.x;
      this.y += v2.y;
      return this;
    }
    addScalar(s4) {
      this.x += s4;
      this.y += s4;
      return this;
    }
    addVectors(a3, b2) {
      this.x = a3.x + b2.x;
      this.y = a3.y + b2.y;
      return this;
    }
    addScaledVector(v2, s4) {
      this.x += v2.x * s4;
      this.y += v2.y * s4;
      return this;
    }
    sub(v2) {
      this.x -= v2.x;
      this.y -= v2.y;
      return this;
    }
    subScalar(s4) {
      this.x -= s4;
      this.y -= s4;
      return this;
    }
    subVectors(a3, b2) {
      this.x = a3.x - b2.x;
      this.y = a3.y - b2.y;
      return this;
    }
    multiply(v2) {
      this.x *= v2.x;
      this.y *= v2.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v2) {
      this.x /= v2.x;
      this.y /= v2.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m2) {
      const x2 = this.x, y2 = this.y;
      const e4 = m2.elements;
      this.x = e4[0] * x2 + e4[3] * y2 + e4[6];
      this.y = e4[1] * x2 + e4[4] * y2 + e4[7];
      return this;
    }
    min(v2) {
      this.x = Math.min(this.x, v2.x);
      this.y = Math.min(this.y, v2.y);
      return this;
    }
    max(v2) {
      this.x = Math.max(this.x, v2.x);
      this.y = Math.max(this.y, v2.y);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v2) {
      return this.x * v2.x + this.y * v2.y;
    }
    cross(v2) {
      return this.x * v2.y - this.y * v2.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    angleTo(v2) {
      const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      const theta = this.dot(v2) / denominator;
      return Math.acos(clamp3(theta, -1, 1));
    }
    distanceTo(v2) {
      return Math.sqrt(this.distanceToSquared(v2));
    }
    distanceToSquared(v2) {
      const dx = this.x - v2.x, dy = this.y - v2.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v2) {
      return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v2, alpha) {
      this.x += (v2.x - this.x) * alpha;
      this.y += (v2.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v2) {
      return v2.x === this.x && v2.y === this.y;
    }
    fromArray(array, offset2 = 0) {
      this.x = array[offset2];
      this.y = array[offset2 + 1];
      return this;
    }
    toArray(array = [], offset2 = 0) {
      array[offset2] = this.x;
      array[offset2 + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index2) {
      this.x = attribute.getX(index2);
      this.y = attribute.getY(index2);
      return this;
    }
    rotateAround(center, angle) {
      const c3 = Math.cos(angle), s4 = Math.sin(angle);
      const x2 = this.x - center.x;
      const y2 = this.y - center.y;
      this.x = x2 * c3 - y2 * s4 + center.x;
      this.y = x2 * s4 + y2 * c3 + center.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
    }
  };
  var Matrix3 = class _Matrix3 {
    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      _Matrix3.prototype.isMatrix3 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
      }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te2 = this.elements;
      te2[0] = n11;
      te2[1] = n21;
      te2[2] = n31;
      te2[3] = n12;
      te2[4] = n22;
      te2[5] = n32;
      te2[6] = n13;
      te2[7] = n23;
      te2[8] = n33;
      return this;
    }
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      );
      return this;
    }
    copy(m2) {
      const te2 = this.elements;
      const me2 = m2.elements;
      te2[0] = me2[0];
      te2[1] = me2[1];
      te2[2] = me2[2];
      te2[3] = me2[3];
      te2[4] = me2[4];
      te2[5] = me2[5];
      te2[6] = me2[6];
      te2[7] = me2[7];
      te2[8] = me2[8];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    setFromMatrix4(m2) {
      const me2 = m2.elements;
      this.set(
        me2[0],
        me2[4],
        me2[8],
        me2[1],
        me2[5],
        me2[9],
        me2[2],
        me2[6],
        me2[10]
      );
      return this;
    }
    multiply(m2) {
      return this.multiplyMatrices(this, m2);
    }
    premultiply(m2) {
      return this.multiplyMatrices(m2, this);
    }
    multiplyMatrices(a3, b2) {
      const ae2 = a3.elements;
      const be2 = b2.elements;
      const te2 = this.elements;
      const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
      const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
      const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
      const b11 = be2[0], b12 = be2[3], b13 = be2[6];
      const b21 = be2[1], b22 = be2[4], b23 = be2[7];
      const b31 = be2[2], b32 = be2[5], b33 = be2[8];
      te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s4) {
      const te2 = this.elements;
      te2[0] *= s4;
      te2[3] *= s4;
      te2[6] *= s4;
      te2[1] *= s4;
      te2[4] *= s4;
      te2[7] *= s4;
      te2[2] *= s4;
      te2[5] *= s4;
      te2[8] *= s4;
      return this;
    }
    determinant() {
      const te2 = this.elements;
      const a3 = te2[0], b2 = te2[1], c3 = te2[2], d2 = te2[3], e4 = te2[4], f2 = te2[5], g2 = te2[6], h4 = te2[7], i4 = te2[8];
      return a3 * e4 * i4 - a3 * f2 * h4 - b2 * d2 * i4 + b2 * f2 * g2 + c3 * d2 * h4 - c3 * e4 * g2;
    }
    invert() {
      const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te2[0] = t11 * detInv;
      te2[1] = (n31 * n23 - n33 * n21) * detInv;
      te2[2] = (n32 * n21 - n31 * n22) * detInv;
      te2[3] = t12 * detInv;
      te2[4] = (n33 * n11 - n31 * n13) * detInv;
      te2[5] = (n31 * n12 - n32 * n11) * detInv;
      te2[6] = t13 * detInv;
      te2[7] = (n21 * n13 - n23 * n11) * detInv;
      te2[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp;
      const m2 = this.elements;
      tmp = m2[1];
      m2[1] = m2[3];
      m2[3] = tmp;
      tmp = m2[2];
      m2[2] = m2[6];
      m2[6] = tmp;
      tmp = m2[5];
      m2[5] = m2[7];
      m2[7] = tmp;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r3) {
      const m2 = this.elements;
      r3[0] = m2[0];
      r3[1] = m2[3];
      r3[2] = m2[6];
      r3[3] = m2[1];
      r3[4] = m2[4];
      r3[5] = m2[7];
      r3[6] = m2[2];
      r3[7] = m2[5];
      r3[8] = m2[8];
      return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c3 = Math.cos(rotation);
      const s4 = Math.sin(rotation);
      this.set(
        sx * c3,
        sx * s4,
        -sx * (c3 * cx + s4 * cy) + cx + tx,
        -sy * s4,
        sy * c3,
        -sy * (-s4 * cx + c3 * cy) + cy + ty,
        0,
        0,
        1
      );
      return this;
    }
    //
    scale(sx, sy) {
      this.premultiply(_m3.makeScale(sx, sy));
      return this;
    }
    rotate(theta) {
      this.premultiply(_m3.makeRotation(-theta));
      return this;
    }
    translate(tx, ty) {
      this.premultiply(_m3.makeTranslation(tx, ty));
      return this;
    }
    // for 2D Transforms
    makeTranslation(x2, y2) {
      if (x2.isVector2) {
        this.set(
          1,
          0,
          x2.x,
          0,
          1,
          x2.y,
          0,
          0,
          1
        );
      } else {
        this.set(
          1,
          0,
          x2,
          0,
          1,
          y2,
          0,
          0,
          1
        );
      }
      return this;
    }
    makeRotation(theta) {
      const c3 = Math.cos(theta);
      const s4 = Math.sin(theta);
      this.set(
        c3,
        -s4,
        0,
        s4,
        c3,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeScale(x2, y2) {
      this.set(
        x2,
        0,
        0,
        0,
        y2,
        0,
        0,
        0,
        1
      );
      return this;
    }
    //
    equals(matrix) {
      const te2 = this.elements;
      const me2 = matrix.elements;
      for (let i4 = 0; i4 < 9; i4++) {
        if (te2[i4] !== me2[i4]) return false;
      }
      return true;
    }
    fromArray(array, offset2 = 0) {
      for (let i4 = 0; i4 < 9; i4++) {
        this.elements[i4] = array[i4 + offset2];
      }
      return this;
    }
    toArray(array = [], offset2 = 0) {
      const te2 = this.elements;
      array[offset2] = te2[0];
      array[offset2 + 1] = te2[1];
      array[offset2 + 2] = te2[2];
      array[offset2 + 3] = te2[3];
      array[offset2 + 4] = te2[4];
      array[offset2 + 5] = te2[5];
      array[offset2 + 6] = te2[6];
      array[offset2 + 7] = te2[7];
      array[offset2 + 8] = te2[8];
      return array;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
  var _m3 = /* @__PURE__ */ new Matrix3();
  function arrayNeedsUint32(array) {
    for (let i4 = array.length - 1; i4 >= 0; --i4) {
      if (array[i4] >= 65535) return true;
    }
    return false;
  }
  function createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
  }
  function createCanvasElement() {
    const canvas2 = createElementNS("canvas");
    canvas2.style.display = "block";
    return canvas2;
  }
  var _cache = {};
  function warnOnce(message) {
    if (message in _cache) return;
    _cache[message] = true;
    console.warn(message);
  }
  function probeAsync(gl2, sync, interval) {
    return new Promise(function(resolve, reject) {
      function probe() {
        switch (gl2.clientWaitSync(sync, gl2.SYNC_FLUSH_COMMANDS_BIT, 0)) {
          case gl2.WAIT_FAILED:
            reject();
            break;
          case gl2.TIMEOUT_EXPIRED:
            setTimeout(probe, interval);
            break;
          default:
            resolve();
        }
      }
      setTimeout(probe, interval);
    });
  }
  var LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /* @__PURE__ */ new Matrix3().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  );
  var LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /* @__PURE__ */ new Matrix3().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  );
  var COLOR_SPACES = {
    [LinearSRGBColorSpace]: {
      transfer: LinearTransfer,
      primaries: Rec709Primaries,
      toReference: (color) => color,
      fromReference: (color) => color
    },
    [SRGBColorSpace]: {
      transfer: SRGBTransfer,
      primaries: Rec709Primaries,
      toReference: (color) => color.convertSRGBToLinear(),
      fromReference: (color) => color.convertLinearToSRGB()
    },
    [LinearDisplayP3ColorSpace]: {
      transfer: LinearTransfer,
      primaries: P3Primaries,
      toReference: (color) => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
      fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
    },
    [DisplayP3ColorSpace]: {
      transfer: SRGBTransfer,
      primaries: P3Primaries,
      toReference: (color) => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
      fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
    }
  };
  var SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
  var ColorManagement = {
    enabled: true,
    _workingColorSpace: LinearSRGBColorSpace,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(colorSpace) {
      if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
        throw new Error(`Unsupported working color space, "${colorSpace}".`);
      }
      this._workingColorSpace = colorSpace;
    },
    convert: function(color, sourceColorSpace, targetColorSpace) {
      if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
        return color;
      }
      const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
      const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
      return targetFromReference(sourceToReference(color));
    },
    fromWorkingColorSpace: function(color, targetColorSpace) {
      return this.convert(color, this._workingColorSpace, targetColorSpace);
    },
    toWorkingColorSpace: function(color, sourceColorSpace) {
      return this.convert(color, sourceColorSpace, this._workingColorSpace);
    },
    getPrimaries: function(colorSpace) {
      return COLOR_SPACES[colorSpace].primaries;
    },
    getTransfer: function(colorSpace) {
      if (colorSpace === NoColorSpace) return LinearTransfer;
      return COLOR_SPACES[colorSpace].transfer;
    }
  };
  function SRGBToLinear(c3) {
    return c3 < 0.04045 ? c3 * 0.0773993808 : Math.pow(c3 * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c3) {
    return c3 < 31308e-7 ? c3 * 12.92 : 1.055 * Math.pow(c3, 0.41666) - 0.055;
  }
  var _canvas;
  var ImageUtils = class {
    static getDataURL(image2) {
      if (/^data:/i.test(image2.src)) {
        return image2.src;
      }
      if (typeof HTMLCanvasElement === "undefined") {
        return image2.src;
      }
      let canvas2;
      if (image2 instanceof HTMLCanvasElement) {
        canvas2 = image2;
      } else {
        if (_canvas === void 0) _canvas = createElementNS("canvas");
        _canvas.width = image2.width;
        _canvas.height = image2.height;
        const context3 = _canvas.getContext("2d");
        if (image2 instanceof ImageData) {
          context3.putImageData(image2, 0, 0);
        } else {
          context3.drawImage(image2, 0, 0, image2.width, image2.height);
        }
        canvas2 = _canvas;
      }
      if (canvas2.width > 2048 || canvas2.height > 2048) {
        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image2);
        return canvas2.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas2.toDataURL("image/png");
      }
    }
    static sRGBToLinear(image2) {
      if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
        const canvas2 = createElementNS("canvas");
        canvas2.width = image2.width;
        canvas2.height = image2.height;
        const context3 = canvas2.getContext("2d");
        context3.drawImage(image2, 0, 0, image2.width, image2.height);
        const imageData = context3.getImageData(0, 0, image2.width, image2.height);
        const data = imageData.data;
        for (let i4 = 0; i4 < data.length; i4++) {
          data[i4] = SRGBToLinear(data[i4] / 255) * 255;
        }
        context3.putImageData(imageData, 0, 0);
        return canvas2;
      } else if (image2.data) {
        const data = image2.data.slice(0);
        for (let i4 = 0; i4 < data.length; i4++) {
          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
            data[i4] = Math.floor(SRGBToLinear(data[i4] / 255) * 255);
          } else {
            data[i4] = SRGBToLinear(data[i4]);
          }
        }
        return {
          data,
          width: image2.width,
          height: image2.height
        };
      } else {
        console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
        return image2;
      }
    }
  };
  var _sourceId = 0;
  var Source = class {
    constructor(data = null) {
      this.isSource = true;
      Object.defineProperty(this, "id", { value: _sourceId++ });
      this.uuid = generateUUID();
      this.data = data;
      this.dataReady = true;
      this.version = 0;
    }
    set needsUpdate(value) {
      if (value === true) this.version++;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.images[this.uuid] !== void 0) {
        return meta.images[this.uuid];
      }
      const output = {
        uuid: this.uuid,
        url: ""
      };
      const data = this.data;
      if (data !== null) {
        let url;
        if (Array.isArray(data)) {
          url = [];
          for (let i4 = 0, l4 = data.length; i4 < l4; i4++) {
            if (data[i4].isDataTexture) {
              url.push(serializeImage(data[i4].image));
            } else {
              url.push(serializeImage(data[i4]));
            }
          }
        } else {
          url = serializeImage(data);
        }
        output.url = url;
      }
      if (!isRootObject) {
        meta.images[this.uuid] = output;
      }
      return output;
    }
  };
  function serializeImage(image2) {
    if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image2);
    } else {
      if (image2.data) {
        return {
          data: Array.from(image2.data),
          width: image2.width,
          height: image2.height,
          type: image2.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  var _textureId = 0;
  var Texture = class _Texture extends EventDispatcher {
    constructor(image2 = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
      super();
      this.isTexture = true;
      Object.defineProperty(this, "id", { value: _textureId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.source = new Source(image2);
      this.mipmaps = [];
      this.mapping = mapping;
      this.channel = 0;
      this.wrapS = wrapS;
      this.wrapT = wrapT;
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.anisotropy = anisotropy;
      this.format = format;
      this.internalFormat = null;
      this.type = type;
      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;
      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.colorSpace = colorSpace;
      this.userData = {};
      this.version = 0;
      this.onUpdate = null;
      this.isRenderTargetTexture = false;
      this.pmremVersion = 0;
    }
    get image() {
      return this.source.data;
    }
    set image(value = null) {
      this.source.data = value;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.source = source.source;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.channel = source.channel;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.colorSpace = source.colorSpace;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.needsUpdate = true;
      return this;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      const output = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(meta).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (Object.keys(this.userData).length > 0) output.userData = this.userData;
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(uv) {
      if (this.mapping !== UVMapping) return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
    set needsUpdate(value) {
      if (value === true) {
        this.version++;
        this.source.needsUpdate = true;
      }
    }
    set needsPMREMUpdate(value) {
      if (value === true) {
        this.pmremVersion++;
      }
    }
  };
  Texture.DEFAULT_IMAGE = null;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.DEFAULT_ANISOTROPY = 1;
  var Vector4 = class _Vector4 {
    constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
      _Vector4.prototype.isVector4 = true;
      this.x = x2;
      this.y = y2;
      this.z = z2;
      this.w = w2;
    }
    get width() {
      return this.z;
    }
    set width(value) {
      this.z = value;
    }
    get height() {
      return this.w;
    }
    set height(value) {
      this.w = value;
    }
    set(x2, y2, z2, w2) {
      this.x = x2;
      this.y = y2;
      this.z = z2;
      this.w = w2;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y2) {
      this.y = y2;
      return this;
    }
    setZ(z2) {
      this.z = z2;
      return this;
    }
    setW(w2) {
      this.w = w2;
      return this;
    }
    setComponent(index2, value) {
      switch (index2) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index2);
      }
      return this;
    }
    getComponent(index2) {
      switch (index2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v2) {
      this.x = v2.x;
      this.y = v2.y;
      this.z = v2.z;
      this.w = v2.w !== void 0 ? v2.w : 1;
      return this;
    }
    add(v2) {
      this.x += v2.x;
      this.y += v2.y;
      this.z += v2.z;
      this.w += v2.w;
      return this;
    }
    addScalar(s4) {
      this.x += s4;
      this.y += s4;
      this.z += s4;
      this.w += s4;
      return this;
    }
    addVectors(a3, b2) {
      this.x = a3.x + b2.x;
      this.y = a3.y + b2.y;
      this.z = a3.z + b2.z;
      this.w = a3.w + b2.w;
      return this;
    }
    addScaledVector(v2, s4) {
      this.x += v2.x * s4;
      this.y += v2.y * s4;
      this.z += v2.z * s4;
      this.w += v2.w * s4;
      return this;
    }
    sub(v2) {
      this.x -= v2.x;
      this.y -= v2.y;
      this.z -= v2.z;
      this.w -= v2.w;
      return this;
    }
    subScalar(s4) {
      this.x -= s4;
      this.y -= s4;
      this.z -= s4;
      this.w -= s4;
      return this;
    }
    subVectors(a3, b2) {
      this.x = a3.x - b2.x;
      this.y = a3.y - b2.y;
      this.z = a3.z - b2.z;
      this.w = a3.w - b2.w;
      return this;
    }
    multiply(v2) {
      this.x *= v2.x;
      this.y *= v2.y;
      this.z *= v2.z;
      this.w *= v2.w;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
    applyMatrix4(m2) {
      const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
      const e4 = m2.elements;
      this.x = e4[0] * x2 + e4[4] * y2 + e4[8] * z2 + e4[12] * w2;
      this.y = e4[1] * x2 + e4[5] * y2 + e4[9] * z2 + e4[13] * w2;
      this.z = e4[2] * x2 + e4[6] * y2 + e4[10] * z2 + e4[14] * w2;
      this.w = e4[3] * x2 + e4[7] * y2 + e4[11] * z2 + e4[15] * w2;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q2) {
      this.w = 2 * Math.acos(q2.w);
      const s4 = Math.sqrt(1 - q2.w * q2.w);
      if (s4 < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q2.x / s4;
        this.y = q2.y / s4;
        this.z = q2.z / s4;
      }
      return this;
    }
    setAxisAngleFromRotationMatrix(m2) {
      let angle, x2, y2, z2;
      const epsilon = 0.01, epsilon2 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        const xx = (m11 + 1) / 2;
        const yy = (m22 + 1) / 2;
        const zz = (m33 + 1) / 2;
        const xy = (m12 + m21) / 4;
        const xz = (m13 + m31) / 4;
        const yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x2 = 0;
            y2 = 0.707106781;
            z2 = 0.707106781;
          } else {
            x2 = Math.sqrt(xx);
            y2 = xy / x2;
            z2 = xz / x2;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x2 = 0.707106781;
            y2 = 0;
            z2 = 0.707106781;
          } else {
            y2 = Math.sqrt(yy);
            x2 = xy / y2;
            z2 = yz / y2;
          }
        } else {
          if (zz < epsilon) {
            x2 = 0.707106781;
            y2 = 0.707106781;
            z2 = 0;
          } else {
            z2 = Math.sqrt(zz);
            x2 = xz / z2;
            y2 = yz / z2;
          }
        }
        this.set(x2, y2, z2, angle);
        return this;
      }
      let s4 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s4) < 1e-3) s4 = 1;
      this.x = (m32 - m23) / s4;
      this.y = (m13 - m31) / s4;
      this.z = (m21 - m12) / s4;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
    min(v2) {
      this.x = Math.min(this.x, v2.x);
      this.y = Math.min(this.y, v2.y);
      this.z = Math.min(this.z, v2.z);
      this.w = Math.min(this.w, v2.w);
      return this;
    }
    max(v2) {
      this.x = Math.max(this.x, v2.x);
      this.y = Math.max(this.y, v2.y);
      this.z = Math.max(this.z, v2.z);
      this.w = Math.max(this.w, v2.w);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      this.w = Math.trunc(this.w);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    dot(v2) {
      return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v2, alpha) {
      this.x += (v2.x - this.x) * alpha;
      this.y += (v2.y - this.y) * alpha;
      this.z += (v2.z - this.z) * alpha;
      this.w += (v2.w - this.w) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
    equals(v2) {
      return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
    }
    fromArray(array, offset2 = 0) {
      this.x = array[offset2];
      this.y = array[offset2 + 1];
      this.z = array[offset2 + 2];
      this.w = array[offset2 + 3];
      return this;
    }
    toArray(array = [], offset2 = 0) {
      array[offset2] = this.x;
      array[offset2 + 1] = this.y;
      array[offset2 + 2] = this.z;
      array[offset2 + 3] = this.w;
      return array;
    }
    fromBufferAttribute(attribute, index2) {
      this.x = attribute.getX(index2);
      this.y = attribute.getY(index2);
      this.z = attribute.getZ(index2);
      this.w = attribute.getW(index2);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
      yield this.w;
    }
  };
  var RenderTarget = class extends EventDispatcher {
    constructor(width = 1, height = 1, options = {}) {
      super();
      this.isRenderTarget = true;
      this.width = width;
      this.height = height;
      this.depth = 1;
      this.scissor = new Vector4(0, 0, width, height);
      this.scissorTest = false;
      this.viewport = new Vector4(0, 0, width, height);
      const image2 = { width, height, depth: 1 };
      options = Object.assign({
        generateMipmaps: false,
        internalFormat: null,
        minFilter: LinearFilter,
        depthBuffer: true,
        stencilBuffer: false,
        resolveDepthBuffer: true,
        resolveStencilBuffer: true,
        depthTexture: null,
        samples: 0,
        count: 1
      }, options);
      const texture = new Texture(image2, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
      texture.flipY = false;
      texture.generateMipmaps = options.generateMipmaps;
      texture.internalFormat = options.internalFormat;
      this.textures = [];
      const count = options.count;
      for (let i4 = 0; i4 < count; i4++) {
        this.textures[i4] = texture.clone();
        this.textures[i4].isRenderTargetTexture = true;
      }
      this.depthBuffer = options.depthBuffer;
      this.stencilBuffer = options.stencilBuffer;
      this.resolveDepthBuffer = options.resolveDepthBuffer;
      this.resolveStencilBuffer = options.resolveStencilBuffer;
      this.depthTexture = options.depthTexture;
      this.samples = options.samples;
    }
    get texture() {
      return this.textures[0];
    }
    set texture(value) {
      this.textures[0] = value;
    }
    setSize(width, height, depth = 1) {
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        for (let i4 = 0, il = this.textures.length; i4 < il; i4++) {
          this.textures[i4].image.width = width;
          this.textures[i4].image.height = height;
          this.textures[i4].image.depth = depth;
        }
        this.dispose();
      }
      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.scissor.copy(source.scissor);
      this.scissorTest = source.scissorTest;
      this.viewport.copy(source.viewport);
      this.textures.length = 0;
      for (let i4 = 0, il = source.textures.length; i4 < il; i4++) {
        this.textures[i4] = source.textures[i4].clone();
        this.textures[i4].isRenderTargetTexture = true;
      }
      const image2 = Object.assign({}, source.texture.image);
      this.texture.source = new Source(image2);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.resolveDepthBuffer = source.resolveDepthBuffer;
      this.resolveStencilBuffer = source.resolveStencilBuffer;
      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
      this.samples = source.samples;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  var WebGLRenderTarget = class extends RenderTarget {
    constructor(width = 1, height = 1, options = {}) {
      super(width, height, options);
      this.isWebGLRenderTarget = true;
    }
  };
  var DataArrayTexture = class extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.isDataArrayTexture = true;
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.layerUpdates = /* @__PURE__ */ new Set();
    }
    addLayerUpdate(layerIndex) {
      this.layerUpdates.add(layerIndex);
    }
    clearLayerUpdates() {
      this.layerUpdates.clear();
    }
  };
  var Data3DTexture = class extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.isData3DTexture = true;
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  var Quaternion = class {
    constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
      this.isQuaternion = true;
      this._x = x2;
      this._y = y2;
      this._z = z2;
      this._w = w2;
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t3) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t3 === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t3 === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s4 = 1 - t3;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s4 = Math.sin(s4 * len) / sin;
          t3 = Math.sin(t3 * len) / sin;
        }
        const tDir = t3 * dir;
        x0 = x0 * s4 + x1 * tDir;
        y0 = y0 * s4 + y1 * tDir;
        z0 = z0 * s4 + z1 * tDir;
        w0 = w0 * s4 + w1 * tDir;
        if (s4 === 1 - t3) {
          const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f2;
          y0 *= f2;
          z0 *= f2;
          w0 *= f2;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    set(x2, y2, z2, w2) {
      this._x = x2;
      this._y = y2;
      this._z = z2;
      this._w = w2;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    setFromEuler(euler, update = true) {
      const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x2 / 2);
      const c22 = cos(y2 / 2);
      const c3 = cos(z2 / 2);
      const s1 = sin(x2 / 2);
      const s22 = sin(y2 / 2);
      const s32 = sin(z2 / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c22 * c3 + c1 * s22 * s32;
          this._y = c1 * s22 * c3 - s1 * c22 * s32;
          this._z = c1 * c22 * s32 + s1 * s22 * c3;
          this._w = c1 * c22 * c3 - s1 * s22 * s32;
          break;
        case "YXZ":
          this._x = s1 * c22 * c3 + c1 * s22 * s32;
          this._y = c1 * s22 * c3 - s1 * c22 * s32;
          this._z = c1 * c22 * s32 - s1 * s22 * c3;
          this._w = c1 * c22 * c3 + s1 * s22 * s32;
          break;
        case "ZXY":
          this._x = s1 * c22 * c3 - c1 * s22 * s32;
          this._y = c1 * s22 * c3 + s1 * c22 * s32;
          this._z = c1 * c22 * s32 + s1 * s22 * c3;
          this._w = c1 * c22 * c3 - s1 * s22 * s32;
          break;
        case "ZYX":
          this._x = s1 * c22 * c3 - c1 * s22 * s32;
          this._y = c1 * s22 * c3 + s1 * c22 * s32;
          this._z = c1 * c22 * s32 - s1 * s22 * c3;
          this._w = c1 * c22 * c3 + s1 * s22 * s32;
          break;
        case "YZX":
          this._x = s1 * c22 * c3 + c1 * s22 * s32;
          this._y = c1 * s22 * c3 + s1 * c22 * s32;
          this._z = c1 * c22 * s32 - s1 * s22 * c3;
          this._w = c1 * c22 * c3 - s1 * s22 * s32;
          break;
        case "XZY":
          this._x = s1 * c22 * c3 - c1 * s22 * s32;
          this._y = c1 * s22 * c3 - s1 * c22 * s32;
          this._z = c1 * c22 * s32 + s1 * s22 * c3;
          this._w = c1 * c22 * c3 + s1 * s22 * s32;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update === true) this._onChangeCallback();
      return this;
    }
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s4 = Math.sin(halfAngle);
      this._x = axis.x * s4;
      this._y = axis.y * s4;
      this._z = axis.z * s4;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m2) {
      const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s4 = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s4;
        this._x = (m32 - m23) * s4;
        this._y = (m13 - m31) * s4;
        this._z = (m21 - m12) * s4;
      } else if (m11 > m22 && m11 > m33) {
        const s4 = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s4;
        this._x = 0.25 * s4;
        this._y = (m12 + m21) / s4;
        this._z = (m13 + m31) / s4;
      } else if (m22 > m33) {
        const s4 = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s4;
        this._x = (m12 + m21) / s4;
        this._y = 0.25 * s4;
        this._z = (m23 + m32) / s4;
      } else {
        const s4 = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s4;
        this._x = (m13 + m31) / s4;
        this._y = (m23 + m32) / s4;
        this._z = 0.25 * s4;
      }
      this._onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      let r3 = vFrom.dot(vTo) + 1;
      if (r3 < Number.EPSILON) {
        r3 = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r3;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r3;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r3;
      }
      return this.normalize();
    }
    angleTo(q2) {
      return 2 * Math.acos(Math.abs(clamp3(this.dot(q2), -1, 1)));
    }
    rotateTowards(q2, step) {
      const angle = this.angleTo(q2);
      if (angle === 0) return this;
      const t3 = Math.min(1, step / angle);
      this.slerp(q2, t3);
      return this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    dot(v2) {
      return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l4 = this.length();
      if (l4 === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l4 = 1 / l4;
        this._x = this._x * l4;
        this._y = this._y * l4;
        this._z = this._z * l4;
        this._w = this._w * l4;
      }
      this._onChangeCallback();
      return this;
    }
    multiply(q2) {
      return this.multiplyQuaternions(this, q2);
    }
    premultiply(q2) {
      return this.multiplyQuaternions(q2, this);
    }
    multiplyQuaternions(a3, b2) {
      const qax = a3._x, qay = a3._y, qaz = a3._z, qaw = a3._w;
      const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    slerp(qb, t3) {
      if (t3 === 0) return this;
      if (t3 === 1) return this.copy(qb);
      const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
      let cosHalfTheta = w2 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w2;
        this._x = x2;
        this._y = y2;
        this._z = z2;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s4 = 1 - t3;
        this._w = s4 * w2 + t3 * this._w;
        this._x = s4 * x2 + t3 * this._x;
        this._y = s4 * y2 + t3 * this._y;
        this._z = s4 * z2 + t3 * this._z;
        this.normalize();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t3) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t3 * halfTheta) / sinHalfTheta;
      this._w = w2 * ratioA + this._w * ratioB;
      this._x = x2 * ratioA + this._x * ratioB;
      this._y = y2 * ratioA + this._y * ratioB;
      this._z = z2 * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    slerpQuaternions(qa, qb, t3) {
      return this.copy(qa).slerp(qb, t3);
    }
    random() {
      const theta1 = 2 * Math.PI * Math.random();
      const theta2 = 2 * Math.PI * Math.random();
      const x0 = Math.random();
      const r1 = Math.sqrt(1 - x0);
      const r22 = Math.sqrt(x0);
      return this.set(
        r1 * Math.sin(theta1),
        r1 * Math.cos(theta1),
        r22 * Math.sin(theta2),
        r22 * Math.cos(theta2)
      );
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset2 = 0) {
      this._x = array[offset2];
      this._y = array[offset2 + 1];
      this._z = array[offset2 + 2];
      this._w = array[offset2 + 3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset2 = 0) {
      array[offset2] = this._x;
      array[offset2 + 1] = this._y;
      array[offset2 + 2] = this._z;
      array[offset2 + 3] = this._w;
      return array;
    }
    fromBufferAttribute(attribute, index2) {
      this._x = attribute.getX(index2);
      this._y = attribute.getY(index2);
      this._z = attribute.getZ(index2);
      this._w = attribute.getW(index2);
      this._onChangeCallback();
      return this;
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._w;
    }
  };
  var Vector3 = class _Vector3 {
    constructor(x2 = 0, y2 = 0, z2 = 0) {
      _Vector3.prototype.isVector3 = true;
      this.x = x2;
      this.y = y2;
      this.z = z2;
    }
    set(x2, y2, z2) {
      if (z2 === void 0) z2 = this.z;
      this.x = x2;
      this.y = y2;
      this.z = z2;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y2) {
      this.y = y2;
      return this;
    }
    setZ(z2) {
      this.z = z2;
      return this;
    }
    setComponent(index2, value) {
      switch (index2) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index2);
      }
      return this;
    }
    getComponent(index2) {
      switch (index2) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index2);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(v2) {
      this.x = v2.x;
      this.y = v2.y;
      this.z = v2.z;
      return this;
    }
    add(v2) {
      this.x += v2.x;
      this.y += v2.y;
      this.z += v2.z;
      return this;
    }
    addScalar(s4) {
      this.x += s4;
      this.y += s4;
      this.z += s4;
      return this;
    }
    addVectors(a3, b2) {
      this.x = a3.x + b2.x;
      this.y = a3.y + b2.y;
      this.z = a3.z + b2.z;
      return this;
    }
    addScaledVector(v2, s4) {
      this.x += v2.x * s4;
      this.y += v2.y * s4;
      this.z += v2.z * s4;
      return this;
    }
    sub(v2) {
      this.x -= v2.x;
      this.y -= v2.y;
      this.z -= v2.z;
      return this;
    }
    subScalar(s4) {
      this.x -= s4;
      this.y -= s4;
      this.z -= s4;
      return this;
    }
    subVectors(a3, b2) {
      this.x = a3.x - b2.x;
      this.y = a3.y - b2.y;
      this.z = a3.z - b2.z;
      return this;
    }
    multiply(v2) {
      this.x *= v2.x;
      this.y *= v2.y;
      this.z *= v2.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a3, b2) {
      this.x = a3.x * b2.x;
      this.y = a3.y * b2.y;
      this.z = a3.z * b2.z;
      return this;
    }
    applyEuler(euler) {
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m2) {
      const x2 = this.x, y2 = this.y, z2 = this.z;
      const e4 = m2.elements;
      this.x = e4[0] * x2 + e4[3] * y2 + e4[6] * z2;
      this.y = e4[1] * x2 + e4[4] * y2 + e4[7] * z2;
      this.z = e4[2] * x2 + e4[5] * y2 + e4[8] * z2;
      return this;
    }
    applyNormalMatrix(m2) {
      return this.applyMatrix3(m2).normalize();
    }
    applyMatrix4(m2) {
      const x2 = this.x, y2 = this.y, z2 = this.z;
      const e4 = m2.elements;
      const w2 = 1 / (e4[3] * x2 + e4[7] * y2 + e4[11] * z2 + e4[15]);
      this.x = (e4[0] * x2 + e4[4] * y2 + e4[8] * z2 + e4[12]) * w2;
      this.y = (e4[1] * x2 + e4[5] * y2 + e4[9] * z2 + e4[13]) * w2;
      this.z = (e4[2] * x2 + e4[6] * y2 + e4[10] * z2 + e4[14]) * w2;
      return this;
    }
    applyQuaternion(q2) {
      const vx = this.x, vy = this.y, vz = this.z;
      const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
      const tx = 2 * (qy * vz - qz * vy);
      const ty = 2 * (qz * vx - qx * vz);
      const tz = 2 * (qx * vy - qy * vx);
      this.x = vx + qw * tx + qy * tz - qz * ty;
      this.y = vy + qw * ty + qz * tx - qx * tz;
      this.z = vz + qw * tz + qx * ty - qy * tx;
      return this;
    }
    project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m2) {
      const x2 = this.x, y2 = this.y, z2 = this.z;
      const e4 = m2.elements;
      this.x = e4[0] * x2 + e4[4] * y2 + e4[8] * z2;
      this.y = e4[1] * x2 + e4[5] * y2 + e4[9] * z2;
      this.z = e4[2] * x2 + e4[6] * y2 + e4[10] * z2;
      return this.normalize();
    }
    divide(v2) {
      this.x /= v2.x;
      this.y /= v2.y;
      this.z /= v2.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v2) {
      this.x = Math.min(this.x, v2.x);
      this.y = Math.min(this.y, v2.y);
      this.z = Math.min(this.z, v2.z);
      return this;
    }
    max(v2) {
      this.x = Math.max(this.x, v2.x);
      this.y = Math.max(this.y, v2.y);
      this.z = Math.max(this.z, v2.z);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = Math.trunc(this.x);
      this.y = Math.trunc(this.y);
      this.z = Math.trunc(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v2) {
      return this.x * v2.x + this.y * v2.y + this.z * v2.z;
    }
    // TODO lengthSquared?
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v2, alpha) {
      this.x += (v2.x - this.x) * alpha;
      this.y += (v2.y - this.y) * alpha;
      this.z += (v2.z - this.z) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    cross(v2) {
      return this.crossVectors(this, v2);
    }
    crossVectors(a3, b2) {
      const ax = a3.x, ay = a3.y, az = a3.z;
      const bx = b2.x, by = b2.y, bz = b2.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(v2) {
      const denominator = v2.lengthSq();
      if (denominator === 0) return this.set(0, 0, 0);
      const scalar = v2.dot(this) / denominator;
      return this.copy(v2).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v2) {
      const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
      if (denominator === 0) return Math.PI / 2;
      const theta = this.dot(v2) / denominator;
      return Math.acos(clamp3(theta, -1, 1));
    }
    distanceTo(v2) {
      return Math.sqrt(this.distanceToSquared(v2));
    }
    distanceToSquared(v2) {
      const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v2) {
      return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
    }
    setFromSpherical(s4) {
      return this.setFromSphericalCoords(s4.radius, s4.phi, s4.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    setFromCylindrical(c3) {
      return this.setFromCylindricalCoords(c3.radius, c3.theta, c3.y);
    }
    setFromCylindricalCoords(radius, theta, y2) {
      this.x = radius * Math.sin(theta);
      this.y = y2;
      this.z = radius * Math.cos(theta);
      return this;
    }
    setFromMatrixPosition(m2) {
      const e4 = m2.elements;
      this.x = e4[12];
      this.y = e4[13];
      this.z = e4[14];
      return this;
    }
    setFromMatrixScale(m2) {
      const sx = this.setFromMatrixColumn(m2, 0).length();
      const sy = this.setFromMatrixColumn(m2, 1).length();
      const sz = this.setFromMatrixColumn(m2, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m2, index2) {
      return this.fromArray(m2.elements, index2 * 4);
    }
    setFromMatrix3Column(m2, index2) {
      return this.fromArray(m2.elements, index2 * 3);
    }
    setFromEuler(e4) {
      this.x = e4._x;
      this.y = e4._y;
      this.z = e4._z;
      return this;
    }
    setFromColor(c3) {
      this.x = c3.r;
      this.y = c3.g;
      this.z = c3.b;
      return this;
    }
    equals(v2) {
      return v2.x === this.x && v2.y === this.y && v2.z === this.z;
    }
    fromArray(array, offset2 = 0) {
      this.x = array[offset2];
      this.y = array[offset2 + 1];
      this.z = array[offset2 + 2];
      return this;
    }
    toArray(array = [], offset2 = 0) {
      array[offset2] = this.x;
      array[offset2 + 1] = this.y;
      array[offset2 + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index2) {
      this.x = attribute.getX(index2);
      this.y = attribute.getY(index2);
      this.z = attribute.getZ(index2);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
    randomDirection() {
      const theta = Math.random() * Math.PI * 2;
      const u2 = Math.random() * 2 - 1;
      const c3 = Math.sqrt(1 - u2 * u2);
      this.x = c3 * Math.cos(theta);
      this.y = u2;
      this.z = c3 * Math.sin(theta);
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
    }
  };
  var _vector$c = /* @__PURE__ */ new Vector3();
  var _quaternion$4 = /* @__PURE__ */ new Quaternion();
  var Box3 = class {
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.isBox3 = true;
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromArray(array) {
      this.makeEmpty();
      for (let i4 = 0, il = array.length; i4 < il; i4 += 3) {
        this.expandByPoint(_vector$b.fromArray(array, i4));
      }
      return this;
    }
    setFromBufferAttribute(attribute) {
      this.makeEmpty();
      for (let i4 = 0, il = attribute.count; i4 < il; i4++) {
        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i4));
      }
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i4 = 0, il = points.length; i4 < il; i4++) {
        this.expandByPoint(points[i4]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object, precise = false) {
      this.makeEmpty();
      return this.expandByObject(object, precise);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object, precise = false) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        const positionAttribute = geometry.getAttribute("position");
        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
          for (let i4 = 0, l4 = positionAttribute.count; i4 < l4; i4++) {
            if (object.isMesh === true) {
              object.getVertexPosition(i4, _vector$b);
            } else {
              _vector$b.fromBufferAttribute(positionAttribute, i4);
            }
            _vector$b.applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$b);
          }
        } else {
          if (object.boundingBox !== void 0) {
            if (object.boundingBox === null) {
              object.computeBoundingBox();
            }
            _box$4.copy(object.boundingBox);
          } else {
            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$4.copy(geometry.boundingBox);
          }
          _box$4.applyMatrix4(object.matrixWorld);
          this.union(_box$4);
        }
      }
      const children2 = object.children;
      for (let i4 = 0, l4 = children2.length; i4 < l4; i4++) {
        this.expandByObject(children2[i4], precise);
      }
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      return target.set(
        (point.x - this.min.x) / (this.max.x - this.min.x),
        (point.y - this.min.y) / (this.max.y - this.min.y),
        (point.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$4.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$4, _v1$7);
      _f2.subVectors(_v0$2, _v2$4);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      return this.clampPoint(point, _vector$b).distanceTo(point);
    }
    getBoundingSphere(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
      } else {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
      }
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty()) this.makeEmpty();
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty()) return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    translate(offset2) {
      this.min.add(offset2);
      this.max.add(offset2);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  var _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  var _vector$b = /* @__PURE__ */ new Vector3();
  var _box$4 = /* @__PURE__ */ new Box3();
  var _v0$2 = /* @__PURE__ */ new Vector3();
  var _v1$7 = /* @__PURE__ */ new Vector3();
  var _v2$4 = /* @__PURE__ */ new Vector3();
  var _f0 = /* @__PURE__ */ new Vector3();
  var _f1 = /* @__PURE__ */ new Vector3();
  var _f2 = /* @__PURE__ */ new Vector3();
  var _center = /* @__PURE__ */ new Vector3();
  var _extents = /* @__PURE__ */ new Vector3();
  var _triangleNormal = /* @__PURE__ */ new Vector3();
  var _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i4 = 0, j2 = axes.length - 3; i4 <= j2; i4 += 3) {
      _testAxis.fromArray(axes, i4);
      const r3 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r3) {
        return false;
      }
    }
    return true;
  }
  var _box$3 = /* @__PURE__ */ new Box3();
  var _v1$6 = /* @__PURE__ */ new Vector3();
  var _v2$3 = /* @__PURE__ */ new Vector3();
  var Sphere = class {
    constructor(center = new Vector3(), radius = -1) {
      this.isSphere = true;
      this.center = center;
      this.radius = radius;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      const center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        _box$3.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i4 = 0, il = points.length; i4 < il; i4++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i4]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      const radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
      const deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset2) {
      this.center.add(offset2);
      return this;
    }
    expandByPoint(point) {
      if (this.isEmpty()) {
        this.center.copy(point);
        this.radius = 0;
        return this;
      }
      _v1$6.subVectors(point, this.center);
      const lengthSq = _v1$6.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        const length = Math.sqrt(lengthSq);
        const delta = (length - this.radius) * 0.5;
        this.center.addScaledVector(_v1$6, delta / length);
        this.radius += delta;
      }
      return this;
    }
    union(sphere) {
      if (sphere.isEmpty()) {
        return this;
      }
      if (this.isEmpty()) {
        this.copy(sphere);
        return this;
      }
      if (this.center.equals(sphere.center) === true) {
        this.radius = Math.max(this.radius, sphere.radius);
      } else {
        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
      }
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$a = /* @__PURE__ */ new Vector3();
  var _segCenter = /* @__PURE__ */ new Vector3();
  var _segDir = /* @__PURE__ */ new Vector3();
  var _diff = /* @__PURE__ */ new Vector3();
  var _edge1 = /* @__PURE__ */ new Vector3();
  var _edge2 = /* @__PURE__ */ new Vector3();
  var _normal$1 = /* @__PURE__ */ new Vector3();
  var Ray = class {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
      this.origin = origin;
      this.direction = direction;
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t3, target) {
      return target.copy(this.origin).addScaledVector(this.direction, t3);
    }
    lookAt(v2) {
      this.direction.copy(v2).sub(this.origin).normalize();
      return this;
    }
    recast(t3) {
      this.origin.copy(this.at(t3, _vector$a));
      return this;
    }
    closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      const directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
      return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      const segExtent = v0.distanceTo(v1) * 0.5;
      const a01 = -this.direction.dot(_segDir);
      const b0 = _diff.dot(this.direction);
      const b1 = -_diff.dot(_segDir);
      const c3 = _diff.lengthSq();
      const det = Math.abs(1 - a01 * a01);
      let s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              const invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c3;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c3;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      const tca = _vector$a.dot(this.direction);
      const d2 = _vector$a.dot(_vector$a) - tca * tca;
      const radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      const thc = Math.sqrt(radius2 - d2);
      const t0 = tca - thc;
      const t1 = tca + thc;
      if (t1 < 0) return null;
      if (t0 < 0) return this.at(t1, target);
      return this.at(t0, target);
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      const denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      const t3 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t3 >= 0 ? t3 : null;
    }
    intersectPlane(plane, target) {
      const t3 = this.distanceToPlane(plane);
      if (t3 === null) {
        return null;
      }
      return this.at(t3, target);
    }
    intersectsPlane(plane) {
      const distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      const denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    }
    intersectBox(box, target) {
      let tmin, tmax, tymin, tymax, tzmin, tzmax;
      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      const origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax) return null;
      if (tymin > tmin || isNaN(tmin)) tmin = tymin;
      if (tymax < tmax || isNaN(tmax)) tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax) return null;
      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
      if (tmax < 0) return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a3, b2, c3, backfaceCulling, target) {
      _edge1.subVectors(b2, a3);
      _edge2.subVectors(c3, a3);
      _normal$1.crossVectors(_edge1, _edge2);
      let DdN = this.direction.dot(_normal$1);
      let sign;
      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign = 1;
      } else if (DdN < 0) {
        sign = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a3);
      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      const QdN = -sign * _diff.dot(_normal$1);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Matrix4 = class _Matrix4 {
    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      _Matrix4.prototype.isMatrix4 = true;
      this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      if (n11 !== void 0) {
        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
      }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te2 = this.elements;
      te2[0] = n11;
      te2[4] = n12;
      te2[8] = n13;
      te2[12] = n14;
      te2[1] = n21;
      te2[5] = n22;
      te2[9] = n23;
      te2[13] = n24;
      te2[2] = n31;
      te2[6] = n32;
      te2[10] = n33;
      te2[14] = n34;
      te2[3] = n41;
      te2[7] = n42;
      te2[11] = n43;
      te2[15] = n44;
      return this;
    }
    identity() {
      this.set(
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    clone() {
      return new _Matrix4().fromArray(this.elements);
    }
    copy(m2) {
      const te2 = this.elements;
      const me2 = m2.elements;
      te2[0] = me2[0];
      te2[1] = me2[1];
      te2[2] = me2[2];
      te2[3] = me2[3];
      te2[4] = me2[4];
      te2[5] = me2[5];
      te2[6] = me2[6];
      te2[7] = me2[7];
      te2[8] = me2[8];
      te2[9] = me2[9];
      te2[10] = me2[10];
      te2[11] = me2[11];
      te2[12] = me2[12];
      te2[13] = me2[13];
      te2[14] = me2[14];
      te2[15] = me2[15];
      return this;
    }
    copyPosition(m2) {
      const te2 = this.elements, me2 = m2.elements;
      te2[12] = me2[12];
      te2[13] = me2[13];
      te2[14] = me2[14];
      return this;
    }
    setFromMatrix3(m2) {
      const me2 = m2.elements;
      this.set(
        me2[0],
        me2[3],
        me2[6],
        0,
        me2[1],
        me2[4],
        me2[7],
        0,
        me2[2],
        me2[5],
        me2[8],
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(
        xAxis.x,
        yAxis.x,
        zAxis.x,
        0,
        xAxis.y,
        yAxis.y,
        zAxis.y,
        0,
        xAxis.z,
        yAxis.z,
        zAxis.z,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    extractRotation(m2) {
      const te2 = this.elements;
      const me2 = m2.elements;
      const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
      const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
      te2[0] = me2[0] * scaleX;
      te2[1] = me2[1] * scaleX;
      te2[2] = me2[2] * scaleX;
      te2[3] = 0;
      te2[4] = me2[4] * scaleY;
      te2[5] = me2[5] * scaleY;
      te2[6] = me2[6] * scaleY;
      te2[7] = 0;
      te2[8] = me2[8] * scaleZ;
      te2[9] = me2[9] * scaleZ;
      te2[10] = me2[10] * scaleZ;
      te2[11] = 0;
      te2[12] = 0;
      te2[13] = 0;
      te2[14] = 0;
      te2[15] = 1;
      return this;
    }
    makeRotationFromEuler(euler) {
      const te2 = this.elements;
      const x2 = euler.x, y2 = euler.y, z2 = euler.z;
      const a3 = Math.cos(x2), b2 = Math.sin(x2);
      const c3 = Math.cos(y2), d2 = Math.sin(y2);
      const e4 = Math.cos(z2), f2 = Math.sin(z2);
      if (euler.order === "XYZ") {
        const ae2 = a3 * e4, af = a3 * f2, be2 = b2 * e4, bf = b2 * f2;
        te2[0] = c3 * e4;
        te2[4] = -c3 * f2;
        te2[8] = d2;
        te2[1] = af + be2 * d2;
        te2[5] = ae2 - bf * d2;
        te2[9] = -b2 * c3;
        te2[2] = bf - ae2 * d2;
        te2[6] = be2 + af * d2;
        te2[10] = a3 * c3;
      } else if (euler.order === "YXZ") {
        const ce2 = c3 * e4, cf = c3 * f2, de2 = d2 * e4, df = d2 * f2;
        te2[0] = ce2 + df * b2;
        te2[4] = de2 * b2 - cf;
        te2[8] = a3 * d2;
        te2[1] = a3 * f2;
        te2[5] = a3 * e4;
        te2[9] = -b2;
        te2[2] = cf * b2 - de2;
        te2[6] = df + ce2 * b2;
        te2[10] = a3 * c3;
      } else if (euler.order === "ZXY") {
        const ce2 = c3 * e4, cf = c3 * f2, de2 = d2 * e4, df = d2 * f2;
        te2[0] = ce2 - df * b2;
        te2[4] = -a3 * f2;
        te2[8] = de2 + cf * b2;
        te2[1] = cf + de2 * b2;
        te2[5] = a3 * e4;
        te2[9] = df - ce2 * b2;
        te2[2] = -a3 * d2;
        te2[6] = b2;
        te2[10] = a3 * c3;
      } else if (euler.order === "ZYX") {
        const ae2 = a3 * e4, af = a3 * f2, be2 = b2 * e4, bf = b2 * f2;
        te2[0] = c3 * e4;
        te2[4] = be2 * d2 - af;
        te2[8] = ae2 * d2 + bf;
        te2[1] = c3 * f2;
        te2[5] = bf * d2 + ae2;
        te2[9] = af * d2 - be2;
        te2[2] = -d2;
        te2[6] = b2 * c3;
        te2[10] = a3 * c3;
      } else if (euler.order === "YZX") {
        const ac = a3 * c3, ad = a3 * d2, bc = b2 * c3, bd = b2 * d2;
        te2[0] = c3 * e4;
        te2[4] = bd - ac * f2;
        te2[8] = bc * f2 + ad;
        te2[1] = f2;
        te2[5] = a3 * e4;
        te2[9] = -b2 * e4;
        te2[2] = -d2 * e4;
        te2[6] = ad * f2 + bc;
        te2[10] = ac - bd * f2;
      } else if (euler.order === "XZY") {
        const ac = a3 * c3, ad = a3 * d2, bc = b2 * c3, bd = b2 * d2;
        te2[0] = c3 * e4;
        te2[4] = -f2;
        te2[8] = d2 * e4;
        te2[1] = ac * f2 + bd;
        te2[5] = a3 * e4;
        te2[9] = ad * f2 - bc;
        te2[2] = bc * f2 - ad;
        te2[6] = b2 * e4;
        te2[10] = bd * f2 + ac;
      }
      te2[3] = 0;
      te2[7] = 0;
      te2[11] = 0;
      te2[12] = 0;
      te2[13] = 0;
      te2[14] = 0;
      te2[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q2) {
      return this.compose(_zero, q2, _one);
    }
    lookAt(eye, target, up) {
      const te2 = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te2[0] = _x.x;
      te2[4] = _y.x;
      te2[8] = _z.x;
      te2[1] = _x.y;
      te2[5] = _y.y;
      te2[9] = _z.y;
      te2[2] = _x.z;
      te2[6] = _y.z;
      te2[10] = _z.z;
      return this;
    }
    multiply(m2) {
      return this.multiplyMatrices(this, m2);
    }
    premultiply(m2) {
      return this.multiplyMatrices(m2, this);
    }
    multiplyMatrices(a3, b2) {
      const ae2 = a3.elements;
      const be2 = b2.elements;
      const te2 = this.elements;
      const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
      const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
      const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
      const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
      const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
      const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
      const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
      const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
      te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    multiplyScalar(s4) {
      const te2 = this.elements;
      te2[0] *= s4;
      te2[4] *= s4;
      te2[8] *= s4;
      te2[12] *= s4;
      te2[1] *= s4;
      te2[5] *= s4;
      te2[9] *= s4;
      te2[13] *= s4;
      te2[2] *= s4;
      te2[6] *= s4;
      te2[10] *= s4;
      te2[14] *= s4;
      te2[3] *= s4;
      te2[7] *= s4;
      te2[11] *= s4;
      te2[15] *= s4;
      return this;
    }
    determinant() {
      const te2 = this.elements;
      const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
      const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
      const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
      const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      const te2 = this.elements;
      let tmp;
      tmp = te2[1];
      te2[1] = te2[4];
      te2[4] = tmp;
      tmp = te2[2];
      te2[2] = te2[8];
      te2[8] = tmp;
      tmp = te2[6];
      te2[6] = te2[9];
      te2[9] = tmp;
      tmp = te2[3];
      te2[3] = te2[12];
      te2[12] = tmp;
      tmp = te2[7];
      te2[7] = te2[13];
      te2[13] = tmp;
      tmp = te2[11];
      te2[11] = te2[14];
      te2[14] = tmp;
      return this;
    }
    setPosition(x2, y2, z2) {
      const te2 = this.elements;
      if (x2.isVector3) {
        te2[12] = x2.x;
        te2[13] = x2.y;
        te2[14] = x2.z;
      } else {
        te2[12] = x2;
        te2[13] = y2;
        te2[14] = z2;
      }
      return this;
    }
    invert() {
      const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te2[0] = t11 * detInv;
      te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te2[4] = t12 * detInv;
      te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te2[8] = t13 * detInv;
      te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te2[12] = t14 * detInv;
      te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v2) {
      const te2 = this.elements;
      const x2 = v2.x, y2 = v2.y, z2 = v2.z;
      te2[0] *= x2;
      te2[4] *= y2;
      te2[8] *= z2;
      te2[1] *= x2;
      te2[5] *= y2;
      te2[9] *= z2;
      te2[2] *= x2;
      te2[6] *= y2;
      te2[10] *= z2;
      te2[3] *= x2;
      te2[7] *= y2;
      te2[11] *= z2;
      return this;
    }
    getMaxScaleOnAxis() {
      const te2 = this.elements;
      const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
      const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
      const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x2, y2, z2) {
      if (x2.isVector3) {
        this.set(
          1,
          0,
          0,
          x2.x,
          0,
          1,
          0,
          x2.y,
          0,
          0,
          1,
          x2.z,
          0,
          0,
          0,
          1
        );
      } else {
        this.set(
          1,
          0,
          0,
          x2,
          0,
          1,
          0,
          y2,
          0,
          0,
          1,
          z2,
          0,
          0,
          0,
          1
        );
      }
      return this;
    }
    makeRotationX(theta) {
      const c3 = Math.cos(theta), s4 = Math.sin(theta);
      this.set(
        1,
        0,
        0,
        0,
        0,
        c3,
        -s4,
        0,
        0,
        s4,
        c3,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationY(theta) {
      const c3 = Math.cos(theta), s4 = Math.sin(theta);
      this.set(
        c3,
        0,
        s4,
        0,
        0,
        1,
        0,
        0,
        -s4,
        0,
        c3,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationZ(theta) {
      const c3 = Math.cos(theta), s4 = Math.sin(theta);
      this.set(
        c3,
        -s4,
        0,
        0,
        s4,
        c3,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeRotationAxis(axis, angle) {
      const c3 = Math.cos(angle);
      const s4 = Math.sin(angle);
      const t3 = 1 - c3;
      const x2 = axis.x, y2 = axis.y, z2 = axis.z;
      const tx = t3 * x2, ty = t3 * y2;
      this.set(
        tx * x2 + c3,
        tx * y2 - s4 * z2,
        tx * z2 + s4 * y2,
        0,
        tx * y2 + s4 * z2,
        ty * y2 + c3,
        ty * z2 - s4 * x2,
        0,
        tx * z2 - s4 * y2,
        ty * z2 + s4 * x2,
        t3 * z2 * z2 + c3,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeScale(x2, y2, z2) {
      this.set(
        x2,
        0,
        0,
        0,
        0,
        y2,
        0,
        0,
        0,
        0,
        z2,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(
        1,
        yx,
        zx,
        0,
        xy,
        1,
        zy,
        0,
        xz,
        yz,
        1,
        0,
        0,
        0,
        0,
        1
      );
      return this;
    }
    compose(position, quaternion, scale) {
      const te2 = this.elements;
      const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
      const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
      const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
      const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
      const wx = w2 * x22, wy = w2 * y22, wz = w2 * z22;
      const sx = scale.x, sy = scale.y, sz = scale.z;
      te2[0] = (1 - (yy + zz)) * sx;
      te2[1] = (xy + wz) * sx;
      te2[2] = (xz - wy) * sx;
      te2[3] = 0;
      te2[4] = (xy - wz) * sy;
      te2[5] = (1 - (xx + zz)) * sy;
      te2[6] = (yz + wx) * sy;
      te2[7] = 0;
      te2[8] = (xz + wy) * sz;
      te2[9] = (yz - wx) * sz;
      te2[10] = (1 - (xx + yy)) * sz;
      te2[11] = 0;
      te2[12] = position.x;
      te2[13] = position.y;
      te2[14] = position.z;
      te2[15] = 1;
      return this;
    }
    decompose(position, quaternion, scale) {
      const te2 = this.elements;
      let sx = _v1$5.set(te2[0], te2[1], te2[2]).length();
      const sy = _v1$5.set(te2[4], te2[5], te2[6]).length();
      const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
      const det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te2[12];
      position.y = te2[13];
      position.z = te2[14];
      _m1$4.copy(this);
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      _m1$4.elements[0] *= invSX;
      _m1$4.elements[1] *= invSX;
      _m1$4.elements[2] *= invSX;
      _m1$4.elements[4] *= invSY;
      _m1$4.elements[5] *= invSY;
      _m1$4.elements[6] *= invSY;
      _m1$4.elements[8] *= invSZ;
      _m1$4.elements[9] *= invSZ;
      _m1$4.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$4);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
      const te2 = this.elements;
      const x2 = 2 * near / (right - left);
      const y2 = 2 * near / (top - bottom);
      const a3 = (right + left) / (right - left);
      const b2 = (top + bottom) / (top - bottom);
      let c3, d2;
      if (coordinateSystem === WebGLCoordinateSystem) {
        c3 = -(far + near) / (far - near);
        d2 = -2 * far * near / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c3 = -far / (far - near);
        d2 = -far * near / (far - near);
      } else {
        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
      }
      te2[0] = x2;
      te2[4] = 0;
      te2[8] = a3;
      te2[12] = 0;
      te2[1] = 0;
      te2[5] = y2;
      te2[9] = b2;
      te2[13] = 0;
      te2[2] = 0;
      te2[6] = 0;
      te2[10] = c3;
      te2[14] = d2;
      te2[3] = 0;
      te2[7] = 0;
      te2[11] = -1;
      te2[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
      const te2 = this.elements;
      const w2 = 1 / (right - left);
      const h4 = 1 / (top - bottom);
      const p2 = 1 / (far - near);
      const x2 = (right + left) * w2;
      const y2 = (top + bottom) * h4;
      let z2, zInv;
      if (coordinateSystem === WebGLCoordinateSystem) {
        z2 = (far + near) * p2;
        zInv = -2 * p2;
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        z2 = near * p2;
        zInv = -1 * p2;
      } else {
        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
      }
      te2[0] = 2 * w2;
      te2[4] = 0;
      te2[8] = 0;
      te2[12] = -x2;
      te2[1] = 0;
      te2[5] = 2 * h4;
      te2[9] = 0;
      te2[13] = -y2;
      te2[2] = 0;
      te2[6] = 0;
      te2[10] = zInv;
      te2[14] = -z2;
      te2[3] = 0;
      te2[7] = 0;
      te2[11] = 0;
      te2[15] = 1;
      return this;
    }
    equals(matrix) {
      const te2 = this.elements;
      const me2 = matrix.elements;
      for (let i4 = 0; i4 < 16; i4++) {
        if (te2[i4] !== me2[i4]) return false;
      }
      return true;
    }
    fromArray(array, offset2 = 0) {
      for (let i4 = 0; i4 < 16; i4++) {
        this.elements[i4] = array[i4 + offset2];
      }
      return this;
    }
    toArray(array = [], offset2 = 0) {
      const te2 = this.elements;
      array[offset2] = te2[0];
      array[offset2 + 1] = te2[1];
      array[offset2 + 2] = te2[2];
      array[offset2 + 3] = te2[3];
      array[offset2 + 4] = te2[4];
      array[offset2 + 5] = te2[5];
      array[offset2 + 6] = te2[6];
      array[offset2 + 7] = te2[7];
      array[offset2 + 8] = te2[8];
      array[offset2 + 9] = te2[9];
      array[offset2 + 10] = te2[10];
      array[offset2 + 11] = te2[11];
      array[offset2 + 12] = te2[12];
      array[offset2 + 13] = te2[13];
      array[offset2 + 14] = te2[14];
      array[offset2 + 15] = te2[15];
      return array;
    }
  };
  var _v1$5 = /* @__PURE__ */ new Vector3();
  var _m1$4 = /* @__PURE__ */ new Matrix4();
  var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
  var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
  var _x = /* @__PURE__ */ new Vector3();
  var _y = /* @__PURE__ */ new Vector3();
  var _z = /* @__PURE__ */ new Vector3();
  var _matrix$2 = /* @__PURE__ */ new Matrix4();
  var _quaternion$3 = /* @__PURE__ */ new Quaternion();
  var Euler = class _Euler {
    constructor(x2 = 0, y2 = 0, z2 = 0, order = _Euler.DEFAULT_ORDER) {
      this.isEuler = true;
      this._x = x2;
      this._y = y2;
      this._z = z2;
      this._order = order;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(value) {
      this._order = value;
      this._onChangeCallback();
    }
    set(x2, y2, z2, order = this._order) {
      this._x = x2;
      this._y = y2;
      this._z = z2;
      this._order = order;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m2, order = this._order, update = true) {
      const te2 = m2.elements;
      const m11 = te2[0], m12 = te2[4], m13 = te2[8];
      const m21 = te2[1], m22 = te2[5], m23 = te2[9];
      const m31 = te2[2], m32 = te2[6], m33 = te2[10];
      switch (order) {
        case "XYZ":
          this._y = Math.asin(clamp3(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case "YXZ":
          this._x = Math.asin(-clamp3(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case "ZXY":
          this._x = Math.asin(clamp3(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case "ZYX":
          this._y = Math.asin(-clamp3(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case "YZX":
          this._z = Math.asin(clamp3(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case "XZY":
          this._z = Math.asin(-clamp3(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
      }
      this._order = order;
      if (update === true) this._onChangeCallback();
      return this;
    }
    setFromQuaternion(q2, order, update) {
      _matrix$2.makeRotationFromQuaternion(q2);
      return this.setFromRotationMatrix(_matrix$2, order, update);
    }
    setFromVector3(v2, order = this._order) {
      return this.set(v2.x, v2.y, v2.z, order);
    }
    reorder(newOrder) {
      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0) this._order = array[3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset2 = 0) {
      array[offset2] = this._x;
      array[offset2 + 1] = this._y;
      array[offset2 + 2] = this._z;
      array[offset2 + 3] = this._order;
      return array;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x;
      yield this._y;
      yield this._z;
      yield this._order;
    }
  };
  Euler.DEFAULT_ORDER = "XYZ";
  var Layers = class {
    constructor() {
      this.mask = 1 | 0;
    }
    set(channel) {
      this.mask = (1 << channel | 0) >>> 0;
    }
    enable(channel) {
      this.mask |= 1 << channel | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
    isEnabled(channel) {
      return (this.mask & (1 << channel | 0)) !== 0;
    }
  };
  var _object3DId = 0;
  var _v1$4 = /* @__PURE__ */ new Vector3();
  var _q1 = /* @__PURE__ */ new Quaternion();
  var _m1$3 = /* @__PURE__ */ new Matrix4();
  var _target = /* @__PURE__ */ new Vector3();
  var _position$3 = /* @__PURE__ */ new Vector3();
  var _scale$2 = /* @__PURE__ */ new Vector3();
  var _quaternion$2 = /* @__PURE__ */ new Quaternion();
  var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
  var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
  var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
  var _addedEvent = { type: "added" };
  var _removedEvent = { type: "removed" };
  var _childaddedEvent = { type: "childadded", child: null };
  var _childremovedEvent = { type: "childremoved", child: null };
  var Object3D = class _Object3D extends EventDispatcher {
    constructor() {
      super();
      this.isObject3D = true;
      Object.defineProperty(this, "id", { value: _object3DId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Object3D";
      this.parent = null;
      this.children = [];
      this.up = _Object3D.DEFAULT_UP.clone();
      const position = new Vector3();
      const rotation = new Euler();
      const quaternion = new Quaternion();
      const scale = new Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, void 0, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix4()
        },
        normalMatrix: {
          value: new Matrix3()
        }
      });
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
      this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
      this.matrixWorldNeedsUpdate = false;
      this.layers = new Layers();
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.animations = [];
      this.userData = {};
    }
    onBeforeShadow() {
    }
    onAfterShadow() {
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(matrix) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q2) {
      this.quaternion.premultiply(q2);
      return this;
    }
    setRotationFromAxisAngle(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m2) {
      this.quaternion.setFromRotationMatrix(m2);
    }
    setRotationFromQuaternion(q2) {
      this.quaternion.copy(q2);
    }
    rotateOnAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    }
    rotateOnWorldAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    }
    rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
    rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
    rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
    translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
    translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
    translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
    localToWorld(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
      this.updateWorldMatrix(true, false);
      return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
    }
    lookAt(x2, y2, z2) {
      if (x2.isVector3) {
        _target.copy(x2);
      } else {
        _target.set(x2, y2, z2);
      }
      const parent2 = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$3.lookAt(_position$3, _target, this.up);
      } else {
        _m1$3.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$3);
      if (parent2) {
        _m1$3.extractRotation(parent2.matrixWorld);
        _q1.setFromRotationMatrix(_m1$3);
        this.quaternion.premultiply(_q1.invert());
      }
    }
    add(object) {
      if (arguments.length > 1) {
        for (let i4 = 0; i4 < arguments.length; i4++) {
          this.add(arguments[i4]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        object.removeFromParent();
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
        _childaddedEvent.child = object;
        this.dispatchEvent(_childaddedEvent);
        _childaddedEvent.child = null;
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    }
    remove(object) {
      if (arguments.length > 1) {
        for (let i4 = 0; i4 < arguments.length; i4++) {
          this.remove(arguments[i4]);
        }
        return this;
      }
      const index2 = this.children.indexOf(object);
      if (index2 !== -1) {
        object.parent = null;
        this.children.splice(index2, 1);
        object.dispatchEvent(_removedEvent);
        _childremovedEvent.child = object;
        this.dispatchEvent(_childremovedEvent);
        _childremovedEvent.child = null;
      }
      return this;
    }
    removeFromParent() {
      const parent2 = this.parent;
      if (parent2 !== null) {
        parent2.remove(this);
      }
      return this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(object) {
      this.updateWorldMatrix(true, false);
      _m1$3.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$3.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$3);
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.updateWorldMatrix(false, true);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
      return this;
    }
    getObjectById(id) {
      return this.getObjectByProperty("id", id);
    }
    getObjectByName(name) {
      return this.getObjectByProperty("name", name);
    }
    getObjectByProperty(name, value) {
      if (this[name] === value) return this;
      for (let i4 = 0, l4 = this.children.length; i4 < l4; i4++) {
        const child = this.children[i4];
        const object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    }
    getObjectsByProperty(name, value, result = []) {
      if (this[name] === value) result.push(this);
      const children2 = this.children;
      for (let i4 = 0, l4 = children2.length; i4 < l4; i4++) {
        children2[i4].getObjectsByProperty(name, value, result);
      }
      return result;
    }
    getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
    getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e4 = this.matrixWorld.elements;
      return target.set(e4[8], e4[9], e4[10]).normalize();
    }
    raycast() {
    }
    traverse(callback) {
      callback(this);
      const children2 = this.children;
      for (let i4 = 0, l4 = children2.length; i4 < l4; i4++) {
        children2[i4].traverse(callback);
      }
    }
    traverseVisible(callback) {
      if (this.visible === false) return;
      callback(this);
      const children2 = this.children;
      for (let i4 = 0, l4 = children2.length; i4 < l4; i4++) {
        children2[i4].traverseVisible(callback);
      }
    }
    traverseAncestors(callback) {
      const parent2 = this.parent;
      if (parent2 !== null) {
        callback(parent2);
        parent2.traverseAncestors(callback);
      }
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
      if (this.matrixAutoUpdate) this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      const children2 = this.children;
      for (let i4 = 0, l4 = children2.length; i4 < l4; i4++) {
        const child = children2[i4];
        if (child.matrixWorldAutoUpdate === true || force === true) {
          child.updateMatrixWorld(force);
        }
      }
    }
    updateWorldMatrix(updateParents, updateChildren) {
      const parent2 = this.parent;
      if (updateParents === true && parent2 !== null && parent2.matrixWorldAutoUpdate === true) {
        parent2.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate) this.updateMatrix();
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      if (updateChildren === true) {
        const children2 = this.children;
        for (let i4 = 0, l4 = children2.length; i4 < l4; i4++) {
          const child = children2[i4];
          if (child.matrixWorldAutoUpdate === true) {
            child.updateWorldMatrix(false, true);
          }
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      const output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        };
        output.metadata = {
          version: 4.6,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      const object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "") object.name = this.name;
      if (this.castShadow === true) object.castShadow = true;
      if (this.receiveShadow === true) object.receiveShadow = true;
      if (this.visible === false) object.visible = false;
      if (this.frustumCulled === false) object.frustumCulled = false;
      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
      if (Object.keys(this.userData).length > 0) object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      object.up = this.up.toArray();
      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
      if (this.isInstancedMesh) {
        object.type = "InstancedMesh";
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
      }
      if (this.isBatchedMesh) {
        object.type = "BatchedMesh";
        object.perObjectFrustumCulled = this.perObjectFrustumCulled;
        object.sortObjects = this.sortObjects;
        object.drawRanges = this._drawRanges;
        object.reservedRanges = this._reservedRanges;
        object.visibility = this._visibility;
        object.active = this._active;
        object.bounds = this._bounds.map((bound) => ({
          boxInitialized: bound.boxInitialized,
          boxMin: bound.box.min.toArray(),
          boxMax: bound.box.max.toArray(),
          sphereInitialized: bound.sphereInitialized,
          sphereRadius: bound.sphere.radius,
          sphereCenter: bound.sphere.center.toArray()
        }));
        object.maxGeometryCount = this._maxGeometryCount;
        object.maxVertexCount = this._maxVertexCount;
        object.maxIndexCount = this._maxIndexCount;
        object.geometryInitialized = this._geometryInitialized;
        object.geometryCount = this._geometryCount;
        object.matricesTexture = this._matricesTexture.toJSON(meta);
        if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
        if (this.boundingSphere !== null) {
          object.boundingSphere = {
            center: object.boundingSphere.center.toArray(),
            radius: object.boundingSphere.radius
          };
        }
        if (this.boundingBox !== null) {
          object.boundingBox = {
            min: object.boundingBox.min.toArray(),
            max: object.boundingBox.max.toArray()
          };
        }
      }
      function serialize(library, element) {
        if (library[element.uuid] === void 0) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }
        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        const parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          const shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (let i4 = 0, l4 = shapes.length; i4 < l4; i4++) {
              const shape = shapes[i4];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== void 0) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          const uuids = [];
          for (let i4 = 0, l4 = this.material.length; i4 < l4; i4++) {
            uuids.push(serialize(meta.materials, this.material[i4]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (let i4 = 0; i4 < this.children.length; i4++) {
          object.children.push(this.children[i4].toJSON(meta).object);
        }
      }
      if (this.animations.length > 0) {
        object.animations = [];
        for (let i4 = 0; i4 < this.animations.length; i4++) {
          const animation = this.animations[i4];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        const geometries = extractFromCache(meta.geometries);
        const materials = extractFromCache(meta.materials);
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        const shapes = extractFromCache(meta.shapes);
        const skeletons = extractFromCache(meta.skeletons);
        const animations = extractFromCache(meta.animations);
        const nodes = extractFromCache(meta.nodes);
        if (geometries.length > 0) output.geometries = geometries;
        if (materials.length > 0) output.materials = materials;
        if (textures.length > 0) output.textures = textures;
        if (images.length > 0) output.images = images;
        if (shapes.length > 0) output.shapes = shapes;
        if (skeletons.length > 0) output.skeletons = skeletons;
        if (animations.length > 0) output.animations = animations;
        if (nodes.length > 0) output.nodes = nodes;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    }
    clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.animations = source.animations.slice();
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (let i4 = 0; i4 < source.children.length; i4++) {
          const child = source.children[i4];
          this.add(child.clone());
        }
      }
      return this;
    }
  };
  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  var _v0$1 = /* @__PURE__ */ new Vector3();
  var _v1$3 = /* @__PURE__ */ new Vector3();
  var _v2$2 = /* @__PURE__ */ new Vector3();
  var _v3$2 = /* @__PURE__ */ new Vector3();
  var _vab = /* @__PURE__ */ new Vector3();
  var _vac = /* @__PURE__ */ new Vector3();
  var _vbc = /* @__PURE__ */ new Vector3();
  var _vap = /* @__PURE__ */ new Vector3();
  var _vbp = /* @__PURE__ */ new Vector3();
  var _vcp = /* @__PURE__ */ new Vector3();
  var Triangle = class _Triangle {
    constructor(a3 = new Vector3(), b2 = new Vector3(), c3 = new Vector3()) {
      this.a = a3;
      this.b = b2;
      this.c = c3;
    }
    static getNormal(a3, b2, c3, target) {
      target.subVectors(c3, b2);
      _v0$1.subVectors(a3, b2);
      target.cross(_v0$1);
      const targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    static getBarycoord(point, a3, b2, c3, target) {
      _v0$1.subVectors(c3, a3);
      _v1$3.subVectors(b2, a3);
      _v2$2.subVectors(point, a3);
      const dot00 = _v0$1.dot(_v0$1);
      const dot01 = _v0$1.dot(_v1$3);
      const dot02 = _v0$1.dot(_v2$2);
      const dot11 = _v1$3.dot(_v1$3);
      const dot12 = _v1$3.dot(_v2$2);
      const denom = dot00 * dot11 - dot01 * dot01;
      if (denom === 0) {
        target.set(0, 0, 0);
        return null;
      }
      const invDenom = 1 / denom;
      const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u2 - v2, v2, u2);
    }
    static containsPoint(point, a3, b2, c3) {
      if (this.getBarycoord(point, a3, b2, c3, _v3$2) === null) {
        return false;
      }
      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
    }
    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
        target.x = 0;
        target.y = 0;
        if ("z" in target) target.z = 0;
        if ("w" in target) target.w = 0;
        return null;
      }
      target.setScalar(0);
      target.addScaledVector(v1, _v3$2.x);
      target.addScaledVector(v2, _v3$2.y);
      target.addScaledVector(v3, _v3$2.z);
      return target;
    }
    static isFrontFacing(a3, b2, c3, direction) {
      _v0$1.subVectors(c3, b2);
      _v1$3.subVectors(a3, b2);
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a3, b2, c3) {
      this.a.copy(a3);
      this.b.copy(b2);
      this.c.copy(c3);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i22) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i22]);
      return this;
    }
    setFromAttributeAndIndices(attribute, i0, i1, i22) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i22);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return _Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return _Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getInterpolation(point, v1, v2, v3, target) {
      return _Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
    }
    containsPoint(point) {
      return _Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
      return _Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    closestPointToPoint(p2, target) {
      const a3 = this.a, b2 = this.b, c3 = this.c;
      let v2, w2;
      _vab.subVectors(b2, a3);
      _vac.subVectors(c3, a3);
      _vap.subVectors(p2, a3);
      const d1 = _vab.dot(_vap);
      const d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a3);
      }
      _vbp.subVectors(p2, b2);
      const d3 = _vab.dot(_vbp);
      const d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b2);
      }
      const vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v2 = d1 / (d1 - d3);
        return target.copy(a3).addScaledVector(_vab, v2);
      }
      _vcp.subVectors(p2, c3);
      const d5 = _vab.dot(_vcp);
      const d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c3);
      }
      const vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w2 = d2 / (d2 - d6);
        return target.copy(a3).addScaledVector(_vac, w2);
      }
      const va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c3, b2);
        w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b2).addScaledVector(_vbc, w2);
      }
      const denom = 1 / (va + vb + vc);
      v2 = vb * denom;
      w2 = vc * denom;
      return target.copy(a3).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  };
  var _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  var _hslA = { h: 0, s: 0, l: 0 };
  var _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p2, q2, t3) {
    if (t3 < 0) t3 += 1;
    if (t3 > 1) t3 -= 1;
    if (t3 < 1 / 6) return p2 + (q2 - p2) * 6 * t3;
    if (t3 < 1 / 2) return q2;
    if (t3 < 2 / 3) return p2 + (q2 - p2) * 6 * (2 / 3 - t3);
    return p2;
  }
  var Color = class {
    constructor(r3, g2, b2) {
      this.isColor = true;
      this.r = 1;
      this.g = 1;
      this.b = 1;
      return this.set(r3, g2, b2);
    }
    set(r3, g2, b2) {
      if (g2 === void 0 && b2 === void 0) {
        const value = r3;
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
      } else {
        this.setRGB(r3, g2, b2);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex, colorSpace = SRGBColorSpace) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setRGB(r3, g2, b2, colorSpace = ColorManagement.workingColorSpace) {
      this.r = r3;
      this.g = g2;
      this.b = b2;
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setHSL(h4, s4, l4, colorSpace = ColorManagement.workingColorSpace) {
      h4 = euclideanModulo(h4, 1);
      s4 = clamp3(s4, 0, 1);
      l4 = clamp3(l4, 0, 1);
      if (s4 === 0) {
        this.r = this.g = this.b = l4;
      } else {
        const p2 = l4 <= 0.5 ? l4 * (1 + s4) : l4 + s4 - l4 * s4;
        const q2 = 2 * l4 - p2;
        this.r = hue2rgb(q2, p2, h4 + 1 / 3);
        this.g = hue2rgb(q2, p2, h4);
        this.b = hue2rgb(q2, p2, h4 - 1 / 3);
      }
      ColorManagement.toWorkingColorSpace(this, colorSpace);
      return this;
    }
    setStyle(style, colorSpace = SRGBColorSpace) {
      function handleAlpha(string) {
        if (string === void 0) return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m2;
      if (m2 = /^(\w+)\(([^\)]*)\)/.exec(style)) {
        let color;
        const name = m2[1];
        const components = m2[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(255, parseInt(color[1], 10)) / 255,
                Math.min(255, parseInt(color[2], 10)) / 255,
                Math.min(255, parseInt(color[3], 10)) / 255,
                colorSpace
              );
            }
            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setRGB(
                Math.min(100, parseInt(color[1], 10)) / 100,
                Math.min(100, parseInt(color[2], 10)) / 100,
                Math.min(100, parseInt(color[3], 10)) / 100,
                colorSpace
              );
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              handleAlpha(color[4]);
              return this.setHSL(
                parseFloat(color[1]) / 360,
                parseFloat(color[2]) / 100,
                parseFloat(color[3]) / 100,
                colorSpace
              );
            }
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + style);
        }
      } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        const hex = m2[1];
        const size = hex.length;
        if (size === 3) {
          return this.setRGB(
            parseInt(hex.charAt(0), 16) / 15,
            parseInt(hex.charAt(1), 16) / 15,
            parseInt(hex.charAt(2), 16) / 15,
            colorSpace
          );
        } else if (size === 6) {
          return this.setHex(parseInt(hex, 16), colorSpace);
        } else {
          console.warn("THREE.Color: Invalid hex color " + style);
        }
      } else if (style && style.length > 0) {
        return this.setColorName(style, colorSpace);
      }
      return this;
    }
    setColorName(style, colorSpace = SRGBColorSpace) {
      const hex = _colorKeywords[style.toLowerCase()];
      if (hex !== void 0) {
        this.setHex(hex, colorSpace);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    getHex(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      return Math.round(clamp3(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp3(_color.g * 255, 0, 255)) * 256 + Math.round(clamp3(_color.b * 255, 0, 255));
    }
    getHexString(colorSpace = SRGBColorSpace) {
      return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
    }
    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      const r3 = _color.r, g2 = _color.g, b2 = _color.b;
      const max = Math.max(r3, g2, b2);
      const min = Math.min(r3, g2, b2);
      let hue, saturation;
      const lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r3:
            hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            hue = (b2 - r3) / delta + 2;
            break;
          case b2:
            hue = (r3 - g2) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      target.r = _color.r;
      target.g = _color.g;
      target.b = _color.b;
      return target;
    }
    getStyle(colorSpace = SRGBColorSpace) {
      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
      const r3 = _color.r, g2 = _color.g, b2 = _color.b;
      if (colorSpace !== SRGBColorSpace) {
        return `color(${colorSpace} ${r3.toFixed(3)} ${g2.toFixed(3)} ${b2.toFixed(3)})`;
      }
      return `rgb(${Math.round(r3 * 255)},${Math.round(g2 * 255)},${Math.round(b2 * 255)})`;
    }
    offsetHSL(h4, s4, l4) {
      this.getHSL(_hslA);
      return this.setHSL(_hslA.h + h4, _hslA.s + s4, _hslA.l + l4);
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s4) {
      this.r += s4;
      this.g += s4;
      this.b += s4;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s4) {
      this.r *= s4;
      this.g *= s4;
      this.b *= s4;
      return this;
    }
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h4 = lerp2(_hslA.h, _hslB.h, alpha);
      const s4 = lerp2(_hslA.s, _hslB.s, alpha);
      const l4 = lerp2(_hslA.l, _hslB.l, alpha);
      this.setHSL(h4, s4, l4);
      return this;
    }
    setFromVector3(v2) {
      this.r = v2.x;
      this.g = v2.y;
      this.b = v2.z;
      return this;
    }
    applyMatrix3(m2) {
      const r3 = this.r, g2 = this.g, b2 = this.b;
      const e4 = m2.elements;
      this.r = e4[0] * r3 + e4[3] * g2 + e4[6] * b2;
      this.g = e4[1] * r3 + e4[4] * g2 + e4[7] * b2;
      this.b = e4[2] * r3 + e4[5] * g2 + e4[8] * b2;
      return this;
    }
    equals(c3) {
      return c3.r === this.r && c3.g === this.g && c3.b === this.b;
    }
    fromArray(array, offset2 = 0) {
      this.r = array[offset2];
      this.g = array[offset2 + 1];
      this.b = array[offset2 + 2];
      return this;
    }
    toArray(array = [], offset2 = 0) {
      array[offset2] = this.r;
      array[offset2 + 1] = this.g;
      array[offset2 + 2] = this.b;
      return array;
    }
    fromBufferAttribute(attribute, index2) {
      this.r = attribute.getX(index2);
      this.g = attribute.getY(index2);
      this.b = attribute.getZ(index2);
      return this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r;
      yield this.g;
      yield this.b;
    }
  };
  var _color = /* @__PURE__ */ new Color();
  Color.NAMES = _colorKeywords;
  var _materialId = 0;
  var Material = class extends EventDispatcher {
    constructor() {
      super();
      this.isMaterial = true;
      Object.defineProperty(this, "id", { value: _materialId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Material";
      this.blending = NormalBlending;
      this.side = FrontSide;
      this.vertexColors = false;
      this.opacity = 1;
      this.transparent = false;
      this.alphaHash = false;
      this.blendSrc = SrcAlphaFactor;
      this.blendDst = OneMinusSrcAlphaFactor;
      this.blendEquation = AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.blendColor = new Color(0, 0, 0);
      this.blendAlpha = 0;
      this.depthFunc = LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.stencilWriteMask = 255;
      this.stencilFunc = AlwaysStencilFunc;
      this.stencilRef = 0;
      this.stencilFuncMask = 255;
      this.stencilFail = KeepStencilOp;
      this.stencilZFail = KeepStencilOp;
      this.stencilZPass = KeepStencilOp;
      this.stencilWrite = false;
      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;
      this.shadowSide = null;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.dithering = false;
      this.alphaToCoverage = false;
      this.premultipliedAlpha = false;
      this.forceSinglePass = false;
      this.visible = true;
      this.toneMapped = true;
      this.userData = {};
      this.version = 0;
      this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }
      this._alphaTest = value;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(values) {
      if (values === void 0) return;
      for (const key in values) {
        const newValue = values[key];
        if (newValue === void 0) {
          console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
          continue;
        }
        const currentValue = this[key];
        if (currentValue === void 0) {
          console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (isRootObject) {
        meta = {
          textures: {},
          images: {}
        };
      }
      const data = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "") data.name = this.name;
      if (this.color && this.color.isColor) data.color = this.color.getHex();
      if (this.roughness !== void 0) data.roughness = this.roughness;
      if (this.metalness !== void 0) data.metalness = this.metalness;
      if (this.sheen !== void 0) data.sheen = this.sheen;
      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
      if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
      if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
      if (this.shininess !== void 0) data.shininess = this.shininess;
      if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.dispersion !== void 0) data.dispersion = this.dispersion;
      if (this.iridescence !== void 0) data.iridescence = this.iridescence;
      if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
      if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
      if (this.iridescenceMap && this.iridescenceMap.isTexture) {
        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
      }
      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
      }
      if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
      if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
      if (this.anisotropyMap && this.anisotropyMap.isTexture) {
        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
      }
      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== void 0) data.combine = this.combine;
      }
      if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.transmission !== void 0) data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== void 0) data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
      if (this.size !== void 0) data.size = this.size;
      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending) data.blending = this.blending;
      if (this.side !== FrontSide) data.side = this.side;
      if (this.vertexColors === true) data.vertexColors = true;
      if (this.opacity < 1) data.opacity = this.opacity;
      if (this.transparent === true) data.transparent = true;
      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
      if (this.depthTest === false) data.depthTest = this.depthTest;
      if (this.depthWrite === false) data.depthWrite = this.depthWrite;
      if (this.colorWrite === false) data.colorWrite = this.colorWrite;
      if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
      if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
      if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
      if (this.polygonOffset === true) data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
      if (this.dashSize !== void 0) data.dashSize = this.dashSize;
      if (this.gapSize !== void 0) data.gapSize = this.gapSize;
      if (this.scale !== void 0) data.scale = this.scale;
      if (this.dithering === true) data.dithering = true;
      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
      if (this.alphaHash === true) data.alphaHash = true;
      if (this.alphaToCoverage === true) data.alphaToCoverage = true;
      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
      if (this.forceSinglePass === true) data.forceSinglePass = true;
      if (this.wireframe === true) data.wireframe = true;
      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true) data.flatShading = true;
      if (this.visible === false) data.visible = false;
      if (this.toneMapped === false) data.toneMapped = false;
      if (this.fog === false) data.fog = false;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRootObject) {
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        if (textures.length > 0) data.textures = textures;
        if (images.length > 0) data.images = images;
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.blendColor.copy(source.blendColor);
      this.blendAlpha = source.blendAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      const srcPlanes = source.clippingPlanes;
      let dstPlanes = null;
      if (srcPlanes !== null) {
        const n4 = srcPlanes.length;
        dstPlanes = new Array(n4);
        for (let i4 = 0; i4 !== n4; ++i4) {
          dstPlanes[i4] = srcPlanes[i4].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaHash = source.alphaHash;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.forceSinglePass = source.forceSinglePass;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(value) {
      if (value === true) this.version++;
    }
  };
  var MeshBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshBasicMaterial = true;
      this.type = "MeshBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapRotation = new Euler();
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapRotation.copy(source.envMapRotation);
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.fog = source.fog;
      return this;
    }
  };
  var _vector$9 = /* @__PURE__ */ new Vector3();
  var _vector2$1 = /* @__PURE__ */ new Vector2();
  var BufferAttribute = class {
    constructor(array, itemSize, normalized = false) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.isBufferAttribute = true;
      this.name = "";
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== void 0 ? array.length / itemSize : 0;
      this.normalized = normalized;
      this.usage = StaticDrawUsage;
      this._updateRange = { offset: 0, count: -1 };
      this.updateRanges = [];
      this.gpuType = FloatType;
      this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true) this.version++;
    }
    get updateRange() {
      warnOnce("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.");
      return this._updateRange;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    addUpdateRange(start, count) {
      this.updateRanges.push({ start, count });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      this.gpuType = source.gpuType;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (let i4 = 0, l4 = this.itemSize; i4 < l4; i4++) {
        this.array[index1 + i4] = attribute.array[index2 + i4];
      }
      return this;
    }
    copyArray(array) {
      this.array.set(array);
      return this;
    }
    applyMatrix3(m2) {
      if (this.itemSize === 2) {
        for (let i4 = 0, l4 = this.count; i4 < l4; i4++) {
          _vector2$1.fromBufferAttribute(this, i4);
          _vector2$1.applyMatrix3(m2);
          this.setXY(i4, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (let i4 = 0, l4 = this.count; i4 < l4; i4++) {
          _vector$9.fromBufferAttribute(this, i4);
          _vector$9.applyMatrix3(m2);
          this.setXYZ(i4, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    }
    applyMatrix4(m2) {
      for (let i4 = 0, l4 = this.count; i4 < l4; i4++) {
        _vector$9.fromBufferAttribute(this, i4);
        _vector$9.applyMatrix4(m2);
        this.setXYZ(i4, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    applyNormalMatrix(m2) {
      for (let i4 = 0, l4 = this.count; i4 < l4; i4++) {
        _vector$9.fromBufferAttribute(this, i4);
        _vector$9.applyNormalMatrix(m2);
        this.setXYZ(i4, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    transformDirection(m2) {
      for (let i4 = 0, l4 = this.count; i4 < l4; i4++) {
        _vector$9.fromBufferAttribute(this, i4);
        _vector$9.transformDirection(m2);
        this.setXYZ(i4, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    set(value, offset2 = 0) {
      this.array.set(value, offset2);
      return this;
    }
    getComponent(index2, component) {
      let value = this.array[index2 * this.itemSize + component];
      if (this.normalized) value = denormalize(value, this.array);
      return value;
    }
    setComponent(index2, component, value) {
      if (this.normalized) value = normalize3(value, this.array);
      this.array[index2 * this.itemSize + component] = value;
      return this;
    }
    getX(index2) {
      let x2 = this.array[index2 * this.itemSize];
      if (this.normalized) x2 = denormalize(x2, this.array);
      return x2;
    }
    setX(index2, x2) {
      if (this.normalized) x2 = normalize3(x2, this.array);
      this.array[index2 * this.itemSize] = x2;
      return this;
    }
    getY(index2) {
      let y2 = this.array[index2 * this.itemSize + 1];
      if (this.normalized) y2 = denormalize(y2, this.array);
      return y2;
    }
    setY(index2, y2) {
      if (this.normalized) y2 = normalize3(y2, this.array);
      this.array[index2 * this.itemSize + 1] = y2;
      return this;
    }
    getZ(index2) {
      let z2 = this.array[index2 * this.itemSize + 2];
      if (this.normalized) z2 = denormalize(z2, this.array);
      return z2;
    }
    setZ(index2, z2) {
      if (this.normalized) z2 = normalize3(z2, this.array);
      this.array[index2 * this.itemSize + 2] = z2;
      return this;
    }
    getW(index2) {
      let w2 = this.array[index2 * this.itemSize + 3];
      if (this.normalized) w2 = denormalize(w2, this.array);
      return w2;
    }
    setW(index2, w2) {
      if (this.normalized) w2 = normalize3(w2, this.array);
      this.array[index2 * this.itemSize + 3] = w2;
      return this;
    }
    setXY(index2, x2, y2) {
      index2 *= this.itemSize;
      if (this.normalized) {
        x2 = normalize3(x2, this.array);
        y2 = normalize3(y2, this.array);
      }
      this.array[index2 + 0] = x2;
      this.array[index2 + 1] = y2;
      return this;
    }
    setXYZ(index2, x2, y2, z2) {
      index2 *= this.itemSize;
      if (this.normalized) {
        x2 = normalize3(x2, this.array);
        y2 = normalize3(y2, this.array);
        z2 = normalize3(z2, this.array);
      }
      this.array[index2 + 0] = x2;
      this.array[index2 + 1] = y2;
      this.array[index2 + 2] = z2;
      return this;
    }
    setXYZW(index2, x2, y2, z2, w2) {
      index2 *= this.itemSize;
      if (this.normalized) {
        x2 = normalize3(x2, this.array);
        y2 = normalize3(y2, this.array);
        z2 = normalize3(z2, this.array);
        w2 = normalize3(w2, this.array);
      }
      this.array[index2 + 0] = x2;
      this.array[index2 + 1] = y2;
      this.array[index2 + 2] = z2;
      this.array[index2 + 3] = w2;
      return this;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      if (this.name !== "") data.name = this.name;
      if (this.usage !== StaticDrawUsage) data.usage = this.usage;
      return data;
    }
  };
  var Uint16BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint16Array(array), itemSize, normalized);
    }
  };
  var Uint32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint32Array(array), itemSize, normalized);
    }
  };
  var Float32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Float32Array(array), itemSize, normalized);
    }
  };
  var _id$2 = 0;
  var _m1$2 = /* @__PURE__ */ new Matrix4();
  var _obj = /* @__PURE__ */ new Object3D();
  var _offset = /* @__PURE__ */ new Vector3();
  var _box$2 = /* @__PURE__ */ new Box3();
  var _boxMorphTargets = /* @__PURE__ */ new Box3();
  var _vector$8 = /* @__PURE__ */ new Vector3();
  var BufferGeometry = class _BufferGeometry extends EventDispatcher {
    constructor() {
      super();
      this.isBufferGeometry = true;
      Object.defineProperty(this, "id", { value: _id$2++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "BufferGeometry";
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.morphTargetsRelative = false;
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = { start: 0, count: Infinity };
      this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(index2) {
      if (Array.isArray(index2)) {
        this.index = new (arrayNeedsUint32(index2) ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
      } else {
        this.index = index2;
      }
      return this;
    }
    getAttribute(name) {
      return this.attributes[name];
    }
    setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
    deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    hasAttribute(name) {
      return this.attributes[name] !== void 0;
    }
    addGroup(start, count, materialIndex = 0) {
      this.groups.push({
        start,
        count,
        materialIndex
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
      const position = this.attributes.position;
      if (position !== void 0) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      const normal = this.attributes.normal;
      if (normal !== void 0) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      const tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    }
    applyQuaternion(q2) {
      _m1$2.makeRotationFromQuaternion(q2);
      this.applyMatrix4(_m1$2);
      return this;
    }
    rotateX(angle) {
      _m1$2.makeRotationX(angle);
      this.applyMatrix4(_m1$2);
      return this;
    }
    rotateY(angle) {
      _m1$2.makeRotationY(angle);
      this.applyMatrix4(_m1$2);
      return this;
    }
    rotateZ(angle) {
      _m1$2.makeRotationZ(angle);
      this.applyMatrix4(_m1$2);
      return this;
    }
    translate(x2, y2, z2) {
      _m1$2.makeTranslation(x2, y2, z2);
      this.applyMatrix4(_m1$2);
      return this;
    }
    scale(x2, y2, z2) {
      _m1$2.makeScale(x2, y2, z2);
      this.applyMatrix4(_m1$2);
      return this;
    }
    lookAt(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    }
    center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
    setFromPoints(points) {
      const position = [];
      for (let i4 = 0, l4 = points.length; i4 < l4; i4++) {
        const point = points[i4];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
      return this;
    }
    computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
        this.boundingBox.set(
          new Vector3(-Infinity, -Infinity, -Infinity),
          new Vector3(Infinity, Infinity, Infinity)
        );
        return;
      }
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i4 = 0, il = morphAttributesPosition.length; i4 < il; i4++) {
            const morphAttribute = morphAttributesPosition[i4];
            _box$2.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$2.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$2.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$2.min);
              this.boundingBox.expandByPoint(_box$2.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        const center = this.boundingSphere.center;
        _box$2.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i4 = 0, il = morphAttributesPosition.length; i4 < il; i4++) {
            const morphAttribute = morphAttributesPosition[i4];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
              _box$2.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
              _box$2.expandByPoint(_vector$8);
            } else {
              _box$2.expandByPoint(_boxMorphTargets.min);
              _box$2.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$2.getCenter(center);
        let maxRadiusSq = 0;
        for (let i4 = 0, il = position.count; i4 < il; i4++) {
          _vector$8.fromBufferAttribute(position, i4);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }
        if (morphAttributesPosition) {
          for (let i4 = 0, il = morphAttributesPosition.length; i4 < il; i4++) {
            const morphAttribute = morphAttributesPosition[i4];
            const morphTargetsRelative = this.morphTargetsRelative;
            for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
              _vector$8.fromBufferAttribute(morphAttribute, j2);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j2);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
    computeTangents() {
      const index2 = this.index;
      const attributes = this.attributes;
      if (index2 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const positionAttribute = attributes.position;
      const normalAttribute = attributes.normal;
      const uvAttribute = attributes.uv;
      if (this.hasAttribute("tangent") === false) {
        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
      }
      const tangentAttribute = this.getAttribute("tangent");
      const tan1 = [], tan2 = [];
      for (let i4 = 0; i4 < positionAttribute.count; i4++) {
        tan1[i4] = new Vector3();
        tan2[i4] = new Vector3();
      }
      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
      function handleTriangle(a3, b2, c3) {
        vA.fromBufferAttribute(positionAttribute, a3);
        vB.fromBufferAttribute(positionAttribute, b2);
        vC.fromBufferAttribute(positionAttribute, c3);
        uvA.fromBufferAttribute(uvAttribute, a3);
        uvB.fromBufferAttribute(uvAttribute, b2);
        uvC.fromBufferAttribute(uvAttribute, c3);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        const r3 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
        if (!isFinite(r3)) return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r3);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r3);
        tan1[a3].add(sdir);
        tan1[b2].add(sdir);
        tan1[c3].add(sdir);
        tan2[a3].add(tdir);
        tan2[b2].add(tdir);
        tan2[c3].add(tdir);
      }
      let groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: index2.count
        }];
      }
      for (let i4 = 0, il = groups.length; i4 < il; ++i4) {
        const group = groups[i4];
        const start = group.start;
        const count = group.count;
        for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
          handleTriangle(
            index2.getX(j2 + 0),
            index2.getX(j2 + 1),
            index2.getX(j2 + 2)
          );
        }
      }
      const tmp = new Vector3(), tmp2 = new Vector3();
      const n4 = new Vector3(), n22 = new Vector3();
      function handleVertex(v2) {
        n4.fromBufferAttribute(normalAttribute, v2);
        n22.copy(n4);
        const t3 = tan1[v2];
        tmp.copy(t3);
        tmp.sub(n4.multiplyScalar(n4.dot(t3))).normalize();
        tmp2.crossVectors(n22, t3);
        const test = tmp2.dot(tan2[v2]);
        const w2 = test < 0 ? -1 : 1;
        tangentAttribute.setXYZW(v2, tmp.x, tmp.y, tmp.z, w2);
      }
      for (let i4 = 0, il = groups.length; i4 < il; ++i4) {
        const group = groups[i4];
        const start = group.start;
        const count = group.count;
        for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
          handleVertex(index2.getX(j2 + 0));
          handleVertex(index2.getX(j2 + 1));
          handleVertex(index2.getX(j2 + 2));
        }
      }
    }
    computeVertexNormals() {
      const index2 = this.index;
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute !== void 0) {
        let normalAttribute = this.getAttribute("normal");
        if (normalAttribute === void 0) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute("normal", normalAttribute);
        } else {
          for (let i4 = 0, il = normalAttribute.count; i4 < il; i4++) {
            normalAttribute.setXYZ(i4, 0, 0, 0);
          }
        }
        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
        const cb = new Vector3(), ab = new Vector3();
        if (index2) {
          for (let i4 = 0, il = index2.count; i4 < il; i4 += 3) {
            const vA = index2.getX(i4 + 0);
            const vB = index2.getX(i4 + 1);
            const vC = index2.getX(i4 + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          for (let i4 = 0, il = positionAttribute.count; i4 < il; i4 += 3) {
            pA.fromBufferAttribute(positionAttribute, i4 + 0);
            pB.fromBufferAttribute(positionAttribute, i4 + 1);
            pC.fromBufferAttribute(positionAttribute, i4 + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(i4 + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i4 + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i4 + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
    normalizeNormals() {
      const normals = this.attributes.normal;
      for (let i4 = 0, il = normals.count; i4 < il; i4++) {
        _vector$8.fromBufferAttribute(normals, i4);
        _vector$8.normalize();
        normals.setXYZ(i4, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    toNonIndexed() {
      function convertBufferAttribute(attribute, indices2) {
        const array = attribute.array;
        const itemSize = attribute.itemSize;
        const normalized = attribute.normalized;
        const array2 = new array.constructor(indices2.length * itemSize);
        let index2 = 0, index22 = 0;
        for (let i4 = 0, l4 = indices2.length; i4 < l4; i4++) {
          if (attribute.isInterleavedBufferAttribute) {
            index2 = indices2[i4] * attribute.data.stride + attribute.offset;
          } else {
            index2 = indices2[i4] * itemSize;
          }
          for (let j2 = 0; j2 < itemSize; j2++) {
            array2[index22++] = array[index2++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
        return this;
      }
      const geometry2 = new _BufferGeometry();
      const indices = this.index.array;
      const attributes = this.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        const newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }
      const morphAttributes = this.morphAttributes;
      for (const name in morphAttributes) {
        const morphArray = [];
        const morphAttribute = morphAttributes[name];
        for (let i4 = 0, il = morphAttribute.length; i4 < il; i4++) {
          const attribute = morphAttribute[i4];
          const newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      const groups = this.groups;
      for (let i4 = 0, l4 = groups.length; i4 < l4; i4++) {
        const group = groups[i4];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "") data.name = this.name;
      if (Object.keys(this.userData).length > 0) data.userData = this.userData;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0) data[key] = parameters[key];
        }
        return data;
      }
      data.data = { attributes: {} };
      const index2 = this.index;
      if (index2 !== null) {
        data.data.index = {
          type: index2.array.constructor.name,
          array: Array.prototype.slice.call(index2.array)
        };
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        data.data.attributes[key] = attribute.toJSON(data.data);
      }
      const morphAttributes = {};
      let hasMorphAttributes = false;
      for (const key in this.morphAttributes) {
        const attributeArray = this.morphAttributes[key];
        const array = [];
        for (let i4 = 0, il = attributeArray.length; i4 < il; i4++) {
          const attribute = attributeArray[i4];
          array.push(attribute.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      const groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      const boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      const data = {};
      this.name = source.name;
      const index2 = source.index;
      if (index2 !== null) {
        this.setIndex(index2.clone(data));
      }
      const attributes = source.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }
      const morphAttributes = source.morphAttributes;
      for (const name in morphAttributes) {
        const array = [];
        const morphAttribute = morphAttributes[name];
        for (let i4 = 0, l4 = morphAttribute.length; i4 < l4; i4++) {
          array.push(morphAttribute[i4].clone(data));
        }
        this.morphAttributes[name] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;
      const groups = source.groups;
      for (let i4 = 0, l4 = groups.length; i4 < l4; i4++) {
        const group = groups[i4];
        this.addGroup(group.start, group.count, group.materialIndex);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  var _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
  var _ray$3 = /* @__PURE__ */ new Ray();
  var _sphere$6 = /* @__PURE__ */ new Sphere();
  var _sphereHitAt = /* @__PURE__ */ new Vector3();
  var _vA$1 = /* @__PURE__ */ new Vector3();
  var _vB$1 = /* @__PURE__ */ new Vector3();
  var _vC$1 = /* @__PURE__ */ new Vector3();
  var _tempA = /* @__PURE__ */ new Vector3();
  var _morphA = /* @__PURE__ */ new Vector3();
  var _uvA$1 = /* @__PURE__ */ new Vector2();
  var _uvB$1 = /* @__PURE__ */ new Vector2();
  var _uvC$1 = /* @__PURE__ */ new Vector2();
  var _normalA = /* @__PURE__ */ new Vector3();
  var _normalB = /* @__PURE__ */ new Vector3();
  var _normalC = /* @__PURE__ */ new Vector3();
  var _intersectionPoint = /* @__PURE__ */ new Vector3();
  var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
  var Mesh = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
      super();
      this.isMesh = true;
      this.type = "Mesh";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    }
    getVertexPosition(index2, target) {
      const geometry = this.geometry;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      target.fromBufferAttribute(position, index2);
      const morphInfluences = this.morphTargetInfluences;
      if (morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        for (let i4 = 0, il = morphPosition.length; i4 < il; i4++) {
          const influence = morphInfluences[i4];
          const morphAttribute = morphPosition[i4];
          if (influence === 0) continue;
          _tempA.fromBufferAttribute(morphAttribute, index2);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(target), influence);
          }
        }
        target.add(_morphA);
      }
      return target;
    }
    raycast(raycaster, intersects) {
      const geometry = this.geometry;
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0) return;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$6.copy(geometry.boundingSphere);
      _sphere$6.applyMatrix4(matrixWorld);
      _ray$3.copy(raycaster.ray).recast(raycaster.near);
      if (_sphere$6.containsPoint(_ray$3.origin) === false) {
        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > __pow(raycaster.far - raycaster.near, 2)) return;
      }
      _inverseMatrix$3.copy(matrixWorld).invert();
      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
      if (geometry.boundingBox !== null) {
        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
      }
      this._computeIntersections(raycaster, intersects, _ray$3);
    }
    _computeIntersections(raycaster, intersects, rayLocalSpace) {
      let intersection;
      const geometry = this.geometry;
      const material = this.material;
      const index2 = geometry.index;
      const position = geometry.attributes.position;
      const uv = geometry.attributes.uv;
      const uv1 = geometry.attributes.uv1;
      const normal = geometry.attributes.normal;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index2 !== null) {
        if (Array.isArray(material)) {
          for (let i4 = 0, il = groups.length; i4 < il; i4++) {
            const group = groups[i4];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(index2.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a3 = index2.getX(j2);
              const b2 = index2.getX(j2 + 1);
              const c3 = index2.getX(j2 + 2);
              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a3, b2, c3);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index2.count, drawRange.start + drawRange.count);
          for (let i4 = start, il = end; i4 < il; i4 += 3) {
            const a3 = index2.getX(i4);
            const b2 = index2.getX(i4 + 1);
            const c3 = index2.getX(i4 + 2);
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a3, b2, c3);
            if (intersection) {
              intersection.faceIndex = Math.floor(i4 / 3);
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i4 = 0, il = groups.length; i4 < il; i4++) {
            const group = groups[i4];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a3 = j2;
              const b2 = j2 + 1;
              const c3 = j2 + 2;
              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a3, b2, c3);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i4 = start, il = end; i4 < il; i4 += 3) {
            const a3 = i4;
            const b2 = i4 + 1;
            const c3 = i4 + 2;
            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a3, b2, c3);
            if (intersection) {
              intersection.faceIndex = Math.floor(i4 / 3);
              intersects.push(intersection);
            }
          }
        }
      }
    }
  };
  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
    }
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a3, b2, c3) {
    object.getVertexPosition(a3, _vA$1);
    object.getVertexPosition(b2, _vB$1);
    object.getVertexPosition(c3, _vC$1);
    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA$1.fromBufferAttribute(uv, a3);
        _uvB$1.fromBufferAttribute(uv, b2);
        _uvC$1.fromBufferAttribute(uv, c3);
        intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (uv1) {
        _uvA$1.fromBufferAttribute(uv1, a3);
        _uvB$1.fromBufferAttribute(uv1, b2);
        _uvC$1.fromBufferAttribute(uv1, c3);
        intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (normal) {
        _normalA.fromBufferAttribute(normal, a3);
        _normalB.fromBufferAttribute(normal, b2);
        _normalC.fromBufferAttribute(normal, c3);
        intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3());
        if (intersection.normal.dot(ray.direction) > 0) {
          intersection.normal.multiplyScalar(-1);
        }
      }
      const face = {
        a: a3,
        b: b2,
        c: c3,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  var BoxGeometry = class _BoxGeometry extends BufferGeometry {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
      super();
      this.type = "BoxGeometry";
      this.parameters = {
        width,
        height,
        depth,
        widthSegments,
        heightSegments,
        depthSegments
      };
      const scope = this;
      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let numberOfVertices = 0;
      let groupStart = 0;
      buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
      buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
      buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
      buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
      buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
      buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
        const segmentWidth = width2 / gridX;
        const segmentHeight = height2 / gridY;
        const widthHalf = width2 / 2;
        const heightHalf = height2 / 2;
        const depthHalf = depth2 / 2;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        let vertexCounter = 0;
        let groupCount = 0;
        const vector = new Vector3();
        for (let iy = 0; iy < gridY1; iy++) {
          const y2 = iy * segmentHeight - heightHalf;
          for (let ix = 0; ix < gridX1; ix++) {
            const x2 = ix * segmentWidth - widthHalf;
            vector[u2] = x2 * udir;
            vector[v2] = y2 * vdir;
            vector[w2] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u2] = 0;
            vector[v2] = 0;
            vector[w2] = depth2 > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a3 = numberOfVertices + ix + gridX1 * iy;
            const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
            const c3 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a3, b2, d2);
            indices.push(b2, c3, d2);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
      }
    }
    copy(source) {
      super.copy(source);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
    static fromJSON(data) {
      return new _BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
  };
  function cloneUniforms(src) {
    const dst = {};
    for (const u2 in src) {
      dst[u2] = {};
      for (const p2 in src[u2]) {
        const property = src[u2][p2];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          if (property.isRenderTargetTexture) {
            console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
            dst[u2][p2] = null;
          } else {
            dst[u2][p2] = property.clone();
          }
        } else if (Array.isArray(property)) {
          dst[u2][p2] = property.slice();
        } else {
          dst[u2][p2] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u2 = 0; u2 < uniforms.length; u2++) {
      const tmp = cloneUniforms(uniforms[u2]);
      for (const p2 in tmp) {
        merged[p2] = tmp[p2];
      }
    }
    return merged;
  }
  function cloneUniformsGroups(src) {
    const dst = [];
    for (let u2 = 0; u2 < src.length; u2++) {
      dst.push(src[u2].clone());
    }
    return dst;
  }
  function getUnlitUniformColorSpace(renderer) {
    const currentRenderTarget = renderer.getRenderTarget();
    if (currentRenderTarget === null) {
      return renderer.outputColorSpace;
    }
    if (currentRenderTarget.isXRRenderTarget === true) {
      return currentRenderTarget.texture.colorSpace;
    }
    return ColorManagement.workingColorSpace;
  }
  var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  var ShaderMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isShaderMaterial = true;
      this.type = "ShaderMaterial";
      this.defines = {};
      this.uniforms = {};
      this.uniformsGroups = [];
      this.vertexShader = default_vertex;
      this.fragmentShader = default_fragment;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.clipping = false;
      this.forceSinglePass = true;
      this.extensions = {
        clipCullDistance: false,
        // set to use vertex shader clipping
        multiDraw: false
        // set to use vertex shader multi_draw / enable gl_DrawID
      };
      this.defaultAttributeValues = {
        "color": [1, 1, 1],
        "uv": [0, 0],
        "uv1": [0, 0]
      };
      this.index0AttributeName = void 0;
      this.uniformsNeedUpdate = false;
      this.glslVersion = null;
      if (parameters !== void 0) {
        this.setValues(parameters);
      }
    }
    copy(source) {
      super.copy(source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.fog = source.fog;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (const name in this.uniforms) {
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name] = {
            type: "t",
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name] = {
            type: "c",
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name] = {
            type: "v2",
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name] = {
            type: "v3",
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name] = {
            type: "v4",
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name] = {
            type: "m3",
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name] = {
            type: "m4",
            value: value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value
          };
        }
      }
      if (Object.keys(this.defines).length > 0) data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      data.lights = this.lights;
      data.clipping = this.clipping;
      const extensions = {};
      for (const key in this.extensions) {
        if (this.extensions[key] === true) extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0) data.extensions = extensions;
      return data;
    }
  };
  var Camera = class extends Object3D {
    constructor() {
      super();
      this.isCamera = true;
      this.type = "Camera";
      this.matrixWorldInverse = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.projectionMatrixInverse = new Matrix4();
      this.coordinateSystem = WebGLCoordinateSystem;
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      this.coordinateSystem = source.coordinateSystem;
      return this;
    }
    getWorldDirection(target) {
      return super.getWorldDirection(target).negate();
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
      super.updateWorldMatrix(updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _v3$1 = /* @__PURE__ */ new Vector3();
  var _minTarget = /* @__PURE__ */ new Vector2();
  var _maxTarget = /* @__PURE__ */ new Vector2();
  var PerspectiveCamera = class extends Camera {
    constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
      super();
      this.isPerspectiveCamera = true;
      this.type = "PerspectiveCamera";
      this.fov = fov2;
      this.zoom = 1;
      this.near = near;
      this.far = far;
      this.focus = 10;
      this.aspect = aspect2;
      this.view = null;
      this.filmGauge = 35;
      this.filmOffset = 0;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }
    /**
     * Sets the FOV by focal length in respect to the current .filmGauge.
     *
     * The default film gauge is 35, so that the focal length can be specified for
     * a 35mm (full frame) camera.
     *
     * Values for focal length and film gauge must have the same unit.
     */
    setFocalLength(focalLength) {
      const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    }
    /**
     * Calculates the focal length from the current .fov and .filmGauge.
     */
    getFocalLength() {
      const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
      return RAD2DEG * 2 * Math.atan(
        Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
      );
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    /**
     * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
     * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
     */
    getViewBounds(distance, minTarget, maxTarget) {
      _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
      minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
      _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
      maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    }
    /**
     * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
     * Copies the result into the target Vector2, where x is width and y is height.
     */
    getViewSize(distance, target) {
      this.getViewBounds(distance, _minTarget, _maxTarget);
      return target.subVectors(_maxTarget, _minTarget);
    }
    /**
     * Sets an offset in a larger frustum. This is useful for multi-window or
     * multi-monitor/multi-machine setups.
     *
     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
     * the monitors are in grid like this
     *
     *   +---+---+---+
     *   | A | B | C |
     *   +---+---+---+
     *   | D | E | F |
     *   +---+---+---+
     *
     * then for each monitor you would call it like this
     *
     *   const w = 1920;
     *   const h = 1080;
     *   const fullWidth = w * 3;
     *   const fullHeight = h * 2;
     *
     *   --A--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
     *   --B--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
     *   --C--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
     *   --D--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
     *   --E--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
     *   --F--
     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
     *
     *   Note there is no reason monitors have to be the same size or in a grid.
     */
    setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x2;
      this.view.offsetY = y2;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const near = this.near;
      let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
      let height = 2 * top;
      let width = this.aspect * height;
      let left = -0.5 * width;
      const view = this.view;
      if (this.view !== null && this.view.enabled) {
        const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }
      const skew = this.filmOffset;
      if (skew !== 0) left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  };
  var fov = -90;
  var aspect = 1;
  var CubeCamera = class extends Object3D {
    constructor(near, far, renderTarget) {
      super();
      this.type = "CubeCamera";
      this.renderTarget = renderTarget;
      this.coordinateSystem = null;
      this.activeMipmapLevel = 0;
      const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.layers = this.layers;
      this.add(cameraPX);
      const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.layers = this.layers;
      this.add(cameraNX);
      const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.layers = this.layers;
      this.add(cameraPY);
      const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.layers = this.layers;
      this.add(cameraNY);
      const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.layers = this.layers;
      this.add(cameraPZ);
      const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.layers = this.layers;
      this.add(cameraNZ);
    }
    updateCoordinateSystem() {
      const coordinateSystem = this.coordinateSystem;
      const cameras = this.children.concat();
      const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
      for (const camera of cameras) this.remove(camera);
      if (coordinateSystem === WebGLCoordinateSystem) {
        cameraPX.up.set(0, 1, 0);
        cameraPX.lookAt(1, 0, 0);
        cameraNX.up.set(0, 1, 0);
        cameraNX.lookAt(-1, 0, 0);
        cameraPY.up.set(0, 0, -1);
        cameraPY.lookAt(0, 1, 0);
        cameraNY.up.set(0, 0, 1);
        cameraNY.lookAt(0, -1, 0);
        cameraPZ.up.set(0, 1, 0);
        cameraPZ.lookAt(0, 0, 1);
        cameraNZ.up.set(0, 1, 0);
        cameraNZ.lookAt(0, 0, -1);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(-1, 0, 0);
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(1, 0, 0);
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(0, 1, 0);
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(0, -1, 0);
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(0, 0, 1);
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(0, 0, -1);
      } else {
        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
      }
      for (const camera of cameras) {
        this.add(camera);
        camera.updateMatrixWorld();
      }
    }
    update(renderer, scene) {
      if (this.parent === null) this.updateMatrixWorld();
      const { renderTarget, activeMipmapLevel } = this;
      if (this.coordinateSystem !== renderer.coordinateSystem) {
        this.coordinateSystem = renderer.coordinateSystem;
        this.updateCoordinateSystem();
      }
      const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentActiveCubeFace = renderer.getActiveCubeFace();
      const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
      const currentXrEnabled = renderer.xr.enabled;
      renderer.xr.enabled = false;
      const generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
      renderer.render(scene, cameraPX);
      renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
      renderer.render(scene, cameraNX);
      renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
      renderer.render(scene, cameraPY);
      renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
      renderer.render(scene, cameraNY);
      renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
      renderer.render(scene, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
      renderer.render(scene, cameraNZ);
      renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
      renderer.xr.enabled = currentXrEnabled;
      renderTarget.texture.needsPMREMUpdate = true;
    }
  };
  var CubeTexture = class extends Texture {
    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
      images = images !== void 0 ? images : [];
      mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
      super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
      this.isCubeTexture = true;
      this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(value) {
      this.image = value;
    }
  };
  var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
    constructor(size = 1, options = {}) {
      super(size, size, options);
      this.isWebGLCubeRenderTarget = true;
      const image2 = { width: size, height: size, depth: 1 };
      const images = [image2, image2, image2, image2, image2, image2];
      this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
      this.texture.isRenderTargetTexture = true;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    }
    fromEquirectangularTexture(renderer, texture) {
      this.texture.type = texture.type;
      this.texture.colorSpace = texture.colorSpace;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      const shader = {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: (
          /* glsl */
          `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
        ),
        fragmentShader: (
          /* glsl */
          `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        )
      };
      const geometry = new BoxGeometry(5, 5, 5);
      const material = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      const mesh = new Mesh(geometry, material);
      const currentMinFilter = texture.minFilter;
      if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
      const camera = new CubeCamera(1, 10, this);
      camera.update(renderer, mesh);
      texture.minFilter = currentMinFilter;
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    }
    clear(renderer, color, depth, stencil) {
      const currentRenderTarget = renderer.getRenderTarget();
      for (let i4 = 0; i4 < 6; i4++) {
        renderer.setRenderTarget(this, i4);
        renderer.clear(color, depth, stencil);
      }
      renderer.setRenderTarget(currentRenderTarget);
    }
  };
  var _vector1 = /* @__PURE__ */ new Vector3();
  var _vector2 = /* @__PURE__ */ new Vector3();
  var _normalMatrix = /* @__PURE__ */ new Matrix3();
  var Plane = class {
    constructor(normal = new Vector3(1, 0, 0), constant = 0) {
      this.isPlane = true;
      this.normal = normal;
      this.constant = constant;
    }
    set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
    setComponents(x2, y2, z2, w2) {
      this.normal.set(x2, y2, z2);
      this.constant = w2;
      return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
    setFromCoplanarPoints(a3, b2, c3) {
      const normal = _vector1.subVectors(c3, b2).cross(_vector2.subVectors(a3, b2)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a3);
      return this;
    }
    copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
    normalize() {
      const inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
    negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
    distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
      return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
    }
    intersectLine(line, target) {
      const direction = line.delta(_vector1);
      const denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }
        return null;
      }
      const t3 = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t3 < 0 || t3 > 1) {
        return null;
      }
      return target.copy(line.start).addScaledVector(direction, t3);
    }
    intersectsLine(line) {
      const startSign = this.distanceToPoint(line.start);
      const endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
      return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
      const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      const normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
    translate(offset2) {
      this.constant -= offset2.dot(this.normal);
      return this;
    }
    equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _sphere$5 = /* @__PURE__ */ new Sphere();
  var _vector$7 = /* @__PURE__ */ new Vector3();
  var Frustum = class {
    constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
      this.planes = [p0, p1, p2, p3, p4, p5];
    }
    set(p0, p1, p2, p3, p4, p5) {
      const planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
    copy(frustum) {
      const planes = this.planes;
      for (let i4 = 0; i4 < 6; i4++) {
        planes[i4].copy(frustum.planes[i4]);
      }
      return this;
    }
    setFromProjectionMatrix(m2, coordinateSystem = WebGLCoordinateSystem) {
      const planes = this.planes;
      const me2 = m2.elements;
      const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
      const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
      const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
      const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
      if (coordinateSystem === WebGLCoordinateSystem) {
        planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        planes[5].setComponents(me22, me6, me10, me14).normalize();
      } else {
        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
      }
      return this;
    }
    intersectsObject(object) {
      if (object.boundingSphere !== void 0) {
        if (object.boundingSphere === null) object.computeBoundingSphere();
        _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
      } else {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      }
      return this.intersectsSphere(_sphere$5);
    }
    intersectsSprite(sprite) {
      _sphere$5.center.set(0, 0, 0);
      _sphere$5.radius = 0.7071067811865476;
      _sphere$5.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$5);
    }
    intersectsSphere(sphere) {
      const planes = this.planes;
      const center = sphere.center;
      const negRadius = -sphere.radius;
      for (let i4 = 0; i4 < 6; i4++) {
        const distance = planes[i4].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
    intersectsBox(box) {
      const planes = this.planes;
      for (let i4 = 0; i4 < 6; i4++) {
        const plane = planes[i4];
        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$7) < 0) {
          return false;
        }
      }
      return true;
    }
    containsPoint(point) {
      const planes = this.planes;
      for (let i4 = 0; i4 < 6; i4++) {
        if (planes[i4].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  function WebGLAnimation() {
    let context3 = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context3.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true) return;
        if (animationLoop === null) return;
        requestId = context3.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context3.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context3 = value;
      }
    };
  }
  function WebGLAttributes(gl2) {
    const buffers = /* @__PURE__ */ new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const size = array.byteLength;
      const buffer = gl2.createBuffer();
      gl2.bindBuffer(bufferType, buffer);
      gl2.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type;
      if (array instanceof Float32Array) {
        type = gl2.FLOAT;
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          type = gl2.HALF_FLOAT;
        } else {
          type = gl2.UNSIGNED_SHORT;
        }
      } else if (array instanceof Int16Array) {
        type = gl2.SHORT;
      } else if (array instanceof Uint32Array) {
        type = gl2.UNSIGNED_INT;
      } else if (array instanceof Int32Array) {
        type = gl2.INT;
      } else if (array instanceof Int8Array) {
        type = gl2.BYTE;
      } else if (array instanceof Uint8Array) {
        type = gl2.UNSIGNED_BYTE;
      } else if (array instanceof Uint8ClampedArray) {
        type = gl2.UNSIGNED_BYTE;
      } else {
        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version,
        size
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute._updateRange;
      const updateRanges = attribute.updateRanges;
      gl2.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1 && updateRanges.length === 0) {
        gl2.bufferSubData(bufferType, 0, array);
      }
      if (updateRanges.length !== 0) {
        for (let i4 = 0, l4 = updateRanges.length; i4 < l4; i4++) {
          const range = updateRanges[i4];
          gl2.bufferSubData(
            bufferType,
            range.start * array.BYTES_PER_ELEMENT,
            array,
            range.start,
            range.count
          );
        }
        attribute.clearUpdateRanges();
      }
      if (updateRange.count !== -1) {
        gl2.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array,
          updateRange.offset,
          updateRange.count
        );
        updateRange.count = -1;
      }
      attribute.onUploadCallback();
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove2(attribute) {
      if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl2.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        if (data.size !== attribute.array.byteLength) {
          throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
        }
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove: remove2,
      update
    };
  }
  var PlaneGeometry = class _PlaneGeometry extends BufferGeometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
      super();
      this.type = "PlaneGeometry";
      this.parameters = {
        width,
        height,
        widthSegments,
        heightSegments
      };
      const width_half = width / 2;
      const height_half = height / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segment_width = width / gridX;
      const segment_height = height / gridY;
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segment_height - height_half;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segment_width - width_half;
          vertices.push(x2, -y2, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a3 = ix + gridX1 * iy;
          const b2 = ix + gridX1 * (iy + 1);
          const c3 = ix + 1 + gridX1 * (iy + 1);
          const d2 = ix + 1 + gridX1 * iy;
          indices.push(a3, b2, d2);
          indices.push(b2, c3, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    copy(source) {
      super.copy(source);
      this.parameters = Object.assign({}, source.parameters);
      return this;
    }
    static fromJSON(data) {
      return new _PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  };
  var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
  var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
  var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
  var batching_pars_vertex = "#ifdef USE_BATCHING\n	attribute float batchId;\n	uniform highp sampler2D batchingTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif";
  var batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
  var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( batchId );\n	vColor.xyz *= batchingColor.xyz;\n#endif";
  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
  var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return sRGBTransferOETF( value );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
  var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
  var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
  var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
  var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
  var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
  var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
  var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
  var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
  var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
  var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
  var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
  var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return shadow;\n	}\n#endif";
  var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
  var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
  var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
  var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
  var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
  var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
  var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
  var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
  var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
  var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
  var vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
  var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
  var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
  var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
  var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
  var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
  var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
  var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
  var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
  var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
  var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
  var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
  var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
  var ShaderChunk = {
    alphahash_fragment,
    alphahash_pars_fragment,
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    batching_pars_vertex,
    batching_vertex,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    colorspace_fragment,
    colorspace_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphinstance_vertex,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    opaque_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
  };
  var UniformsLib = {
    common: {
      diffuse: { value: /* @__PURE__ */ new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaTest: { value: 0 }
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      // basic, lambert, phong
      ior: { value: 1.5 },
      // physical
      refractionRatio: { value: 0.98 }
      // basic, lambert, phong
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    gradientmap: {
      gradientMap: { value: null }
    },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: /* @__PURE__ */ new Color(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: {
        direction: {},
        color: {}
      } },
      directionalLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: { value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      } },
      spotLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: { value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      } },
      pointLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      } },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      } },
      // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
      rectAreaLights: { value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      } },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: /* @__PURE__ */ new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaTest: { value: 0 },
      uvTransform: { value: /* @__PURE__ */ new Matrix3() }
    },
    sprite: {
      diffuse: { value: /* @__PURE__ */ new Color(16777215) },
      opacity: { value: 1 },
      center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      alphaTest: { value: 0 }
    }
  };
  var ShaderLib = {
    basic: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: /* @__PURE__ */ new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: /* @__PURE__ */ new Color(0) },
          specular: { value: /* @__PURE__ */ new Color(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: /* @__PURE__ */ new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: /* @__PURE__ */ new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.points,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.sprite,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: /* @__PURE__ */ new Matrix3() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 }
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }
      },
      vertexShader: ShaderChunk.backgroundCube_vert,
      fragmentShader: ShaderChunk.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: /* @__PURE__ */ new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: /* @__PURE__ */ mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: { value: /* @__PURE__ */ new Color(0) },
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: /* @__PURE__ */ mergeUniforms([
      ShaderLib.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        clearcoatNormalMap: { value: null },
        clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        dispersion: { value: 0 },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        sheen: { value: 0 },
        sheenColor: { value: /* @__PURE__ */ new Color(0) },
        sheenColorMap: { value: null },
        sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: /* @__PURE__ */ new Color(0) },
        specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
        specularColorMap: { value: null },
        specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
        anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
        anisotropyMap: { value: null },
        anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };
  var _rgb = { r: 0, b: 0, g: 0 };
  var _e1$1 = /* @__PURE__ */ new Euler();
  var _m1$1 = /* @__PURE__ */ new Matrix4();
  function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = alpha === true ? 0 : 1;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function getBackground(scene) {
      let background = scene.isScene === true ? scene.background : null;
      if (background && background.isTexture) {
        const usePMREM = scene.backgroundBlurriness > 0;
        background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
      }
      return background;
    }
    function render6(scene) {
      let forceClear = false;
      const background = getBackground(scene);
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
      if (environmentBlendMode === "additive") {
        state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
      } else if (environmentBlendMode === "alpha-blend") {
        state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
      }
      if (renderer.autoClear || forceClear) {
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
    }
    function addToRenderList(renderList, scene) {
      const background = getBackground(scene);
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(
            new BoxGeometry(1, 1, 1),
            new ShaderMaterial({
              name: "BackgroundCubeMaterial",
              uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
              vertexShader: ShaderLib.backgroundCube.vertexShader,
              fragmentShader: ShaderLib.backgroundCube.fragmentShader,
              side: BackSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
            this.matrixWorld.copyPosition(camera.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        _e1$1.copy(scene.backgroundRotation);
        _e1$1.x *= -1;
        _e1$1.y *= -1;
        _e1$1.z *= -1;
        if (background.isCubeTexture && background.isRenderTargetTexture === false) {
          _e1$1.y *= -1;
          _e1$1.z *= -1;
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
        boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
        boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
        boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
        boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        boxMesh.layers.enableAll();
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(
            new PlaneGeometry(2, 2),
            new ShaderMaterial({
              name: "BackgroundMaterial",
              uniforms: cloneUniforms(ShaderLib.background.uniforms),
              vertexShader: ShaderLib.background.vertexShader,
              fragmentShader: ShaderLib.background.fragmentShader,
              side: FrontSide,
              depthTest: false,
              depthWrite: false,
              fog: false
            })
          );
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
        planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        planeMesh.layers.enableAll();
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha2) {
      color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
      state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha2 = 1) {
        clearColor.set(color);
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha2) {
        clearAlpha = alpha2;
        setClear(clearColor, clearAlpha);
      },
      render: render6,
      addToRenderList
    };
  }
  function WebGLBindingStates(gl2, attributes) {
    const maxVertexAttributes = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS);
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    let forceUpdate = false;
    function setup2(object, material, program, geometry, index2) {
      let updateBuffers = false;
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(object, geometry, program, index2);
      if (updateBuffers) saveCache(object, geometry, program, index2);
      if (index2 !== null) {
        attributes.update(index2, gl2.ELEMENT_ARRAY_BUFFER);
      }
      if (updateBuffers || forceUpdate) {
        forceUpdate = false;
        setupVertexAttributes(object, material, program, geometry);
        if (index2 !== null) {
          gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, attributes.get(index2).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      return gl2.createVertexArray();
    }
    function bindVertexArrayObject(vao) {
      return gl2.bindVertexArray(vao);
    }
    function deleteVertexArrayObject(vao) {
      return gl2.deleteVertexArray(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state = stateMap[wireframe];
      if (state === void 0) {
        state = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state;
      }
      return state;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i4 = 0; i4 < maxVertexAttributes; i4++) {
        newAttributes[i4] = 0;
        enabledAttributes[i4] = 0;
        attributeDivisors[i4] = 0;
      }
      return {
        // for backward compatibility on non-VAO support browser
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(object, geometry, program, index2) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          const cachedAttribute = cachedAttributes[name];
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
          }
          if (cachedAttribute === void 0) return true;
          if (cachedAttribute.attribute !== geometryAttribute) return true;
          if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
          attributesNum++;
        }
      }
      if (currentState.attributesNum !== attributesNum) return true;
      if (currentState.index !== index2) return true;
      return false;
    }
    function saveCache(object, geometry, program, index2) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      const programAttributes = program.getAttributes();
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let attribute = attributes2[name];
          if (attribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
          }
          const data = {};
          data.attribute = attribute;
          if (attribute && attribute.data) {
            data.data = attribute.data;
          }
          cache[name] = data;
          attributesNum++;
        }
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index2;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i4 = 0, il = newAttributes.length; i4 < il; i4++) {
        newAttributes[i4] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl2.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        gl2.vertexAttribDivisor(attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i4 = 0, il = enabledAttributes.length; i4 < il; i4++) {
        if (enabledAttributes[i4] !== newAttributes[i4]) {
          gl2.disableVertexAttribArray(i4);
          enabledAttributes[i4] = 0;
        }
      }
    }
    function vertexAttribPointer(index2, size, type, normalized, stride, offset2, integer) {
      if (integer === true) {
        gl2.vertexAttribIPointer(index2, size, type, stride, offset2);
      } else {
        gl2.vertexAttribPointer(index2, size, type, normalized, stride, offset2);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
          }
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0) continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            const integer = type === gl2.INT || type === gl2.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset2 = geometryAttribute.offset;
              if (data.isInstancedInterleavedBuffer) {
                for (let i4 = 0; i4 < programAttribute.locationSize; i4++) {
                  enableAttributeAndDivisor(programAttribute.location + i4, data.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                for (let i4 = 0; i4 < programAttribute.locationSize; i4++) {
                  enableAttribute(programAttribute.location + i4);
                }
              }
              gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
              for (let i4 = 0; i4 < programAttribute.locationSize; i4++) {
                vertexAttribPointer(
                  programAttribute.location + i4,
                  size / programAttribute.locationSize,
                  type,
                  normalized,
                  stride * bytesPerElement,
                  (offset2 + size / programAttribute.locationSize * i4) * bytesPerElement,
                  integer
                );
              }
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                for (let i4 = 0; i4 < programAttribute.locationSize; i4++) {
                  enableAttributeAndDivisor(programAttribute.location + i4, geometryAttribute.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                for (let i4 = 0; i4 < programAttribute.locationSize; i4++) {
                  enableAttribute(programAttribute.location + i4);
                }
              }
              gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
              for (let i4 = 0; i4 < programAttribute.locationSize; i4++) {
                vertexAttribPointer(
                  programAttribute.location + i4,
                  size / programAttribute.locationSize,
                  type,
                  normalized,
                  size * bytesPerElement,
                  size / programAttribute.locationSize * i4 * bytesPerElement,
                  integer
                );
              }
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl2.vertexAttrib2fv(programAttribute.location, value);
                  break;
                case 3:
                  gl2.vertexAttrib3fv(programAttribute.location, value);
                  break;
                case 4:
                  gl2.vertexAttrib4fv(programAttribute.location, value);
                  break;
                default:
                  gl2.vertexAttrib1fv(programAttribute.location, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0) return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0) continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      forceUpdate = true;
      if (currentState === defaultState) return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup: setup2,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl2, extensions, info) {
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render6(start, count) {
      gl2.drawArrays(mode, start, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0) return;
      gl2.drawArraysInstanced(mode, start, count, primcount);
      info.update(count, mode, primcount);
    }
    function renderMultiDraw(starts, counts, drawCount) {
      if (drawCount === 0) return;
      const extension = extensions.get("WEBGL_multi_draw");
      if (extension === null) {
        for (let i4 = 0; i4 < drawCount; i4++) {
          this.render(starts[i4], counts[i4]);
        }
      } else {
        extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
        let elementCount = 0;
        for (let i4 = 0; i4 < drawCount; i4++) {
          elementCount += counts[i4];
        }
        info.update(elementCount, mode, 1);
      }
    }
    function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
      if (drawCount === 0) return;
      const extension = extensions.get("WEBGL_multi_draw");
      if (extension === null) {
        for (let i4 = 0; i4 < starts.length; i4++) {
          renderInstances(starts[i4], counts[i4], primcount[i4]);
        }
      } else {
        extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
        let elementCount = 0;
        for (let i4 = 0; i4 < drawCount; i4++) {
          elementCount += counts[i4];
        }
        for (let i4 = 0; i4 < primcount.length; i4++) {
          info.update(elementCount, mode, primcount[i4]);
        }
      }
    }
    this.setMode = setMode;
    this.render = render6;
    this.renderInstances = renderInstances;
    this.renderMultiDraw = renderMultiDraw;
    this.renderMultiDrawInstances = renderMultiDrawInstances;
  }
  function WebGLCapabilities(gl2, extensions, parameters, utils) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0) return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl2.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function textureFormatReadable(textureFormat) {
      if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl2.getParameter(gl2.IMPLEMENTATION_COLOR_READ_FORMAT)) {
        return false;
      }
      return true;
    }
    function textureTypeReadable(textureType) {
      const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
      if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl2.getParameter(gl2.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
      textureType !== FloatType && !halfFloatSupportedByExt) {
        return false;
      }
      return true;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl2.getShaderPrecisionFormat(gl2.VERTEX_SHADER, gl2.HIGH_FLOAT).precision > 0 && gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.HIGH_FLOAT).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl2.getShaderPrecisionFormat(gl2.VERTEX_SHADER, gl2.MEDIUM_FLOAT).precision > 0 && gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.MEDIUM_FLOAT).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS);
    const maxVertexTextures = gl2.getParameter(gl2.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    const maxTextureSize = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
    const maxCubemapSize = gl2.getParameter(gl2.MAX_CUBE_MAP_TEXTURE_SIZE);
    const maxAttributes = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS);
    const maxVertexUniforms = gl2.getParameter(gl2.MAX_VERTEX_UNIFORM_VECTORS);
    const maxVaryings = gl2.getParameter(gl2.MAX_VARYING_VECTORS);
    const maxFragmentUniforms = gl2.getParameter(gl2.MAX_FRAGMENT_UNIFORM_VECTORS);
    const vertexTextures = maxVertexTextures > 0;
    const maxSamples = gl2.getParameter(gl2.MAX_SAMPLES);
    return {
      isWebGL2: true,
      // keeping this for backwards compatibility
      getMaxAnisotropy,
      getMaxPrecision,
      textureFormatReadable,
      textureTypeReadable,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping) {
      const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
      // run another frame in order to reset the state:
      numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
    };
    this.setGlobalState = function(planes, camera) {
      globalState = projectPlanes(planes, camera, 0);
    };
    this.setState = function(material, camera, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, useCache);
        for (let i4 = 0; i4 !== lGlobal; ++i4) {
          dstArray[i4] = globalState[i4];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i4 = 0, i42 = dstOffset; i4 !== nPlanes; ++i4, i42 += 4) {
            plane.copy(planes[i4]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i42);
            dstArray[i42 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer) {
    let cubemaps = /* @__PURE__ */ new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image2 = texture.image;
            if (image2 && image2.height > 0) {
              const renderTarget = new WebGLCubeRenderTarget(image2.height);
              renderTarget.fromEquirectangularTexture(renderer, texture);
              cubemaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event2) {
      const texture = event2.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var OrthographicCamera = class extends Camera {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
      super();
      this.isOrthographicCamera = true;
      this.type = "OrthographicCamera";
      this.zoom = 1;
      this.view = null;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = near;
      this.far = far;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
    setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x2;
      this.view.offsetY = y2;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const dx = (this.right - this.left) / (2 * this.zoom);
      const dy = (this.top - this.bottom) / (2 * this.zoom);
      const cx = (this.right + this.left) / 2;
      const cy = (this.top + this.bottom) / 2;
      let left = cx - dx;
      let right = cx + dx;
      let top = cy + dy;
      let bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null) data.object.view = Object.assign({}, this.view);
      return data;
    }
  };
  var LOD_MIN = 4;
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var MAX_SAMPLES = 20;
  var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
  var _clearColor = /* @__PURE__ */ new Color();
  var _oldTarget = null;
  var _oldActiveCubeFace = 0;
  var _oldActiveMipmapLevel = 0;
  var _oldXrEnabled = false;
  var PHI = (1 + Math.sqrt(5)) / 2;
  var INV_PHI = 1 / PHI;
  var _axisDirections = [
    /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
    /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
    /* @__PURE__ */ new Vector3(-1, 1, -1),
    /* @__PURE__ */ new Vector3(1, 1, -1),
    /* @__PURE__ */ new Vector3(-1, 1, 1),
    /* @__PURE__ */ new Vector3(1, 1, 1)
  ];
  var PMREMGenerator = class {
    constructor(renderer) {
      this._renderer = renderer;
      this._pingPongRenderTarget = null;
      this._lodMax = 0;
      this._cubeSize = 0;
      this._lodPlanes = [];
      this._sizeLods = [];
      this._sigmas = [];
      this._blurMaterial = null;
      this._cubemapMaterial = null;
      this._equirectMaterial = null;
      this._compileMaterial(this._blurMaterial);
    }
    /**
     * Generates a PMREM from a supplied Scene, which can be faster than using an
     * image if networking bandwidth is low. Optional sigma specifies a blur radius
     * in radians to be applied to the scene before PMREM generation. Optional near
     * and far planes ensure the scene is rendered in its entirety (the cubeCamera
     * is placed at the origin).
     */
    fromScene(scene, sigma = 0, near = 0.1, far = 100) {
      _oldTarget = this._renderer.getRenderTarget();
      _oldActiveCubeFace = this._renderer.getActiveCubeFace();
      _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
      _oldXrEnabled = this._renderer.xr.enabled;
      this._renderer.xr.enabled = false;
      this._setSize(256);
      const cubeUVRenderTarget = this._allocateTargets();
      cubeUVRenderTarget.depthBuffer = true;
      this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
      if (sigma > 0) {
        this._blur(cubeUVRenderTarget, 0, 0, sigma);
      }
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    /**
     * Generates a PMREM from an equirectangular texture, which can be either LDR
     * or HDR. The ideal input image size is 1k (1024 x 512),
     * as this matches best with the 256 x 256 cubemap output.
     * The smallest supported equirectangular image size is 64 x 32.
     */
    fromEquirectangular(equirectangular, renderTarget = null) {
      return this._fromTexture(equirectangular, renderTarget);
    }
    /**
     * Generates a PMREM from an cubemap texture, which can be either LDR
     * or HDR. The ideal input cube size is 256 x 256,
     * as this matches best with the 256 x 256 cubemap output.
     * The smallest supported cube size is 16 x 16.
     */
    fromCubemap(cubemap, renderTarget = null) {
      return this._fromTexture(cubemap, renderTarget);
    }
    /**
     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileCubemapShader() {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
        this._compileMaterial(this._cubemapMaterial);
      }
    }
    /**
     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
     * your texture's network fetch for increased concurrency.
     */
    compileEquirectangularShader() {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
        this._compileMaterial(this._equirectMaterial);
      }
    }
    /**
     * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
     * one of them will cause any others to also become unusable.
     */
    dispose() {
      this._dispose();
      if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
      if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    }
    // private interface
    _setSize(cubeSize) {
      this._lodMax = Math.floor(Math.log2(cubeSize));
      this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      if (this._blurMaterial !== null) this._blurMaterial.dispose();
      if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
      for (let i4 = 0; i4 < this._lodPlanes.length; i4++) {
        this._lodPlanes[i4].dispose();
      }
    }
    _cleanup(outputTarget) {
      this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
      this._renderer.xr.enabled = _oldXrEnabled;
      outputTarget.scissorTest = false;
      _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture, renderTarget) {
      if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
        this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
      } else {
        this._setSize(texture.image.width / 4);
      }
      _oldTarget = this._renderer.getRenderTarget();
      _oldActiveCubeFace = this._renderer.getActiveCubeFace();
      _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
      _oldXrEnabled = this._renderer.xr.enabled;
      this._renderer.xr.enabled = false;
      const cubeUVRenderTarget = renderTarget || this._allocateTargets();
      this._textureToCubeUV(texture, cubeUVRenderTarget);
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    _allocateTargets() {
      const width = 3 * Math.max(this._cubeSize, 16 * 7);
      const height = 4 * this._cubeSize;
      const params = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: false,
        type: HalfFloatType,
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace,
        depthBuffer: false
      };
      const cubeUVRenderTarget = _createRenderTarget(width, height, params);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
        if (this._pingPongRenderTarget !== null) {
          this._dispose();
        }
        this._pingPongRenderTarget = _createRenderTarget(width, height, params);
        const { _lodMax } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
        this._blurMaterial = _getBlurShader(_lodMax, width, height);
      }
      return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
      const tmpMesh = new Mesh(this._lodPlanes[0], material);
      this._renderer.compile(tmpMesh, _flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
      const fov2 = 90;
      const aspect2 = 1;
      const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
      const upSign = [1, -1, 1, 1, 1, 1];
      const forwardSign = [1, 1, 1, -1, -1, -1];
      const renderer = this._renderer;
      const originalAutoClear = renderer.autoClear;
      const toneMapping = renderer.toneMapping;
      renderer.getClearColor(_clearColor);
      renderer.toneMapping = NoToneMapping;
      renderer.autoClear = false;
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
      let useSolidColor = false;
      const background = scene.background;
      if (background) {
        if (background.isColor) {
          backgroundMaterial.color.copy(background);
          scene.background = null;
          useSolidColor = true;
        }
      } else {
        backgroundMaterial.color.copy(_clearColor);
        useSolidColor = true;
      }
      for (let i4 = 0; i4 < 6; i4++) {
        const col = i4 % 3;
        if (col === 0) {
          cubeCamera.up.set(0, upSign[i4], 0);
          cubeCamera.lookAt(forwardSign[i4], 0, 0);
        } else if (col === 1) {
          cubeCamera.up.set(0, 0, upSign[i4]);
          cubeCamera.lookAt(0, forwardSign[i4], 0);
        } else {
          cubeCamera.up.set(0, upSign[i4], 0);
          cubeCamera.lookAt(0, 0, forwardSign[i4]);
        }
        const size = this._cubeSize;
        _setViewport(cubeUVRenderTarget, col * size, i4 > 2 ? size : 0, size, size);
        renderer.setRenderTarget(cubeUVRenderTarget);
        if (useSolidColor) {
          renderer.render(backgroundBox, cubeCamera);
        }
        renderer.render(scene, cubeCamera);
      }
      backgroundBox.geometry.dispose();
      backgroundBox.material.dispose();
      renderer.toneMapping = toneMapping;
      renderer.autoClear = originalAutoClear;
      scene.background = background;
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
      const renderer = this._renderer;
      const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
      if (isCubeTexture) {
        if (this._cubemapMaterial === null) {
          this._cubemapMaterial = _getCubemapMaterial();
        }
        this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
      } else {
        if (this._equirectMaterial === null) {
          this._equirectMaterial = _getEquirectMaterial();
        }
      }
      const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
      const mesh = new Mesh(this._lodPlanes[0], material);
      const uniforms = material.uniforms;
      uniforms["envMap"].value = texture;
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      renderer.render(mesh, _flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
      const renderer = this._renderer;
      const autoClear = renderer.autoClear;
      renderer.autoClear = false;
      const n4 = this._lodPlanes.length;
      for (let i4 = 1; i4 < n4; i4++) {
        const sigma = Math.sqrt(this._sigmas[i4] * this._sigmas[i4] - this._sigmas[i4 - 1] * this._sigmas[i4 - 1]);
        const poleAxis = _axisDirections[(n4 - i4 - 1) % _axisDirections.length];
        this._blur(cubeUVRenderTarget, i4 - 1, i4, sigma, poleAxis);
      }
      renderer.autoClear = autoClear;
    }
    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     */
    _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
      const pingPongRenderTarget = this._pingPongRenderTarget;
      this._halfBlur(
        cubeUVRenderTarget,
        pingPongRenderTarget,
        lodIn,
        lodOut,
        sigma,
        "latitudinal",
        poleAxis
      );
      this._halfBlur(
        pingPongRenderTarget,
        cubeUVRenderTarget,
        lodOut,
        lodOut,
        sigma,
        "longitudinal",
        poleAxis
      );
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
      const renderer = this._renderer;
      const blurMaterial = this._blurMaterial;
      if (direction !== "latitudinal" && direction !== "longitudinal") {
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      }
      const STANDARD_DEVIATIONS = 3;
      const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
      const blurUniforms = blurMaterial.uniforms;
      const pixels = this._sizeLods[lodIn] - 1;
      const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
      const sigmaPixels = sigmaRadians / radiansPerPixel;
      const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
      if (samples > MAX_SAMPLES) {
        console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
      }
      const weights = [];
      let sum = 0;
      for (let i4 = 0; i4 < MAX_SAMPLES; ++i4) {
        const x3 = i4 / sigmaPixels;
        const weight = Math.exp(-x3 * x3 / 2);
        weights.push(weight);
        if (i4 === 0) {
          sum += weight;
        } else if (i4 < samples) {
          sum += 2 * weight;
        }
      }
      for (let i4 = 0; i4 < weights.length; i4++) {
        weights[i4] = weights[i4] / sum;
      }
      blurUniforms["envMap"].value = targetIn.texture;
      blurUniforms["samples"].value = samples;
      blurUniforms["weights"].value = weights;
      blurUniforms["latitudinal"].value = direction === "latitudinal";
      if (poleAxis) {
        blurUniforms["poleAxis"].value = poleAxis;
      }
      const { _lodMax } = this;
      blurUniforms["dTheta"].value = radiansPerPixel;
      blurUniforms["mipInt"].value = _lodMax - lodIn;
      const outputSize = this._sizeLods[lodOut];
      const x2 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
      const y2 = 4 * (this._cubeSize - outputSize);
      _setViewport(targetOut, x2, y2, 3 * outputSize, 2 * outputSize);
      renderer.setRenderTarget(targetOut);
      renderer.render(blurMesh, _flatCamera);
    }
  };
  function _createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (let i4 = 0; i4 < totalLods; i4++) {
      const sizeLod = Math.pow(2, lod);
      sizeLods.push(sizeLod);
      let sigma = 1 / sizeLod;
      if (i4 > lodMax - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i4 - lodMax + LOD_MIN - 1];
      } else if (i4 === 0) {
        sigma = 0;
      }
      sigmas.push(sigma);
      const texelSize = 1 / (sizeLod - 2);
      const min = -texelSize;
      const max = 1 + texelSize;
      const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
      const cubeFaces = 6;
      const vertices = 6;
      const positionSize = 3;
      const uvSize = 2;
      const faceIndexSize = 1;
      const position = new Float32Array(positionSize * vertices * cubeFaces);
      const uv = new Float32Array(uvSize * vertices * cubeFaces);
      const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (let face = 0; face < cubeFaces; face++) {
        const x2 = face % 3 * 2 / 3 - 1;
        const y2 = face > 2 ? 0 : -1;
        const coordinates = [
          x2,
          y2,
          0,
          x2 + 2 / 3,
          y2,
          0,
          x2 + 2 / 3,
          y2 + 1,
          0,
          x2,
          y2,
          0,
          x2 + 2 / 3,
          y2 + 1,
          0,
          x2,
          y2 + 1,
          0
        ];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        const fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }
      const planes = new BufferGeometry();
      planes.setAttribute("position", new BufferAttribute(position, positionSize));
      planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
      planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
      lodPlanes.push(planes);
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return { lodPlanes, sizeLods, sigmas };
  }
  function _createRenderTarget(width, height, params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x2, y2, width, height) {
    target.viewport.set(x2, y2, width, height);
    target.scissor.set(x2, y2, width, height);
  }
  function _getBlurShader(lodMax, width, height) {
    const weights = new Float32Array(MAX_SAMPLES);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new ShaderMaterial({
      name: "SphericalGaussianBlur",
      defines: {
        "n": MAX_SAMPLES,
        "CUBEUV_TEXEL_WIDTH": 1 / width,
        "CUBEUV_TEXEL_HEIGHT": 1 / height,
        "CUBEUV_MAX_MIP": `${lodMax}.0`
      },
      uniforms: {
        "envMap": { value: null },
        "samples": { value: 1 },
        "weights": { value: weights },
        "latitudinal": { value: false },
        "dTheta": { value: 0 },
        "mipInt": { value: 0 },
        "poleAxis": { value: poleAxis }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getEquirectMaterial() {
    return new ShaderMaterial({
      name: "EquirectangularToCubeUV",
      uniforms: {
        "envMap": { value: null }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCubemapMaterial() {
    return new ShaderMaterial({
      name: "CubemapToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "flipEnvMap": { value: -1 }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: (
        /* glsl */
        `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
      ),
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
  }
  function _getCommonVertexShader() {
    return (
      /* glsl */
      `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
    );
  }
  function WebGLCubeUVMaps(renderer) {
    let cubeUVmaps = /* @__PURE__ */ new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
        const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
        if (isEquirectMap || isCubeMap) {
          let renderTarget = cubeUVmaps.get(texture);
          const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
          if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
            if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
            renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
            renderTarget.texture.pmremVersion = texture.pmremVersion;
            cubeUVmaps.set(texture, renderTarget);
            return renderTarget.texture;
          } else {
            if (renderTarget !== void 0) {
              return renderTarget.texture;
            } else {
              const image2 = texture.image;
              if (isEquirectMap && image2 && image2.height > 0 || isCubeMap && image2 && isCubeTextureComplete(image2)) {
                if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
                renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                renderTarget.texture.pmremVersion = texture.pmremVersion;
                cubeUVmaps.set(texture, renderTarget);
                texture.addEventListener("dispose", onTextureDispose);
                return renderTarget.texture;
              } else {
                return null;
              }
            }
          }
        }
      }
      return texture;
    }
    function isCubeTextureComplete(image2) {
      let count = 0;
      const length = 6;
      for (let i4 = 0; i4 < length; i4++) {
        if (image2[i4] !== void 0) count++;
      }
      return count === length;
    }
    function onTextureDispose(event2) {
      const texture = event2.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemapUV = cubeUVmaps.get(texture);
      if (cubemapUV !== void 0) {
        cubeUVmaps.delete(texture);
        cubemapUV.dispose();
      }
    }
    function dispose() {
      cubeUVmaps = /* @__PURE__ */ new WeakMap();
      if (pmremGenerator !== null) {
        pmremGenerator.dispose();
        pmremGenerator = null;
      }
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl2) {
    const extensions = {};
    function getExtension(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl2.getExtension("WEBGL_depth_texture") || gl2.getExtension("MOZ_WEBGL_depth_texture") || gl2.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl2.getExtension("EXT_texture_filter_anisotropic") || gl2.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl2.getExtension("WEBGL_compressed_texture_s3tc") || gl2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl2.getExtension("WEBGL_compressed_texture_pvrtc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl2.getExtension(name);
      }
      extensions[name] = extension;
      return extension;
    }
    return {
      has: function(name) {
        return getExtension(name) !== null;
      },
      init: function() {
        getExtension("EXT_color_buffer_float");
        getExtension("WEBGL_clip_cull_distance");
        getExtension("OES_texture_float_linear");
        getExtension("EXT_color_buffer_half_float");
        getExtension("WEBGL_multisampled_render_to_texture");
        getExtension("WEBGL_render_shared_exponent");
      },
      get: function(name) {
        const extension = getExtension(name);
        if (extension === null) {
          warnOnce("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl2, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = /* @__PURE__ */ new WeakMap();
    function onGeometryDispose(event2) {
      const geometry = event2.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name in geometry.attributes) {
        attributes.remove(geometry.attributes[name]);
      }
      for (const name in geometry.morphAttributes) {
        const array = geometry.morphAttributes[name];
        for (let i4 = 0, l4 = array.length; i4 < l4; i4++) {
          attributes.remove(array[i4]);
        }
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true) return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info.memory.geometries++;
      return geometry;
    }
    function update(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], gl2.ARRAY_BUFFER);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name in morphAttributes) {
        const array = morphAttributes[name];
        for (let i4 = 0, l4 = array.length; i4 < l4; i4++) {
          attributes.update(array[i4], gl2.ARRAY_BUFFER);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i4 = 0, l4 = array.length; i4 < l4; i4 += 3) {
          const a3 = array[i4 + 0];
          const b2 = array[i4 + 1];
          const c3 = array[i4 + 2];
          indices.push(a3, b2, b2, c3, c3, a3);
        }
      } else if (geometryPosition !== void 0) {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i4 = 0, l4 = array.length / 3 - 1; i4 < l4; i4 += 3) {
          const a3 = i4 + 0;
          const b2 = i4 + 1;
          const c3 = i4 + 2;
          indices.push(a3, b2, b2, c3, c3, a3);
        }
      } else {
        return;
      }
      const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute) attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl2, extensions, info) {
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render6(start, count) {
      gl2.drawElements(mode, count, type, start * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0) return;
      gl2.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    function renderMultiDraw(starts, counts, drawCount) {
      if (drawCount === 0) return;
      const extension = extensions.get("WEBGL_multi_draw");
      if (extension === null) {
        for (let i4 = 0; i4 < drawCount; i4++) {
          this.render(starts[i4] / bytesPerElement, counts[i4]);
        }
      } else {
        extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
        let elementCount = 0;
        for (let i4 = 0; i4 < drawCount; i4++) {
          elementCount += counts[i4];
        }
        info.update(elementCount, mode, 1);
      }
    }
    function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
      if (drawCount === 0) return;
      const extension = extensions.get("WEBGL_multi_draw");
      if (extension === null) {
        for (let i4 = 0; i4 < starts.length; i4++) {
          renderInstances(starts[i4] / bytesPerElement, counts[i4], primcount[i4]);
        }
      } else {
        extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
        let elementCount = 0;
        for (let i4 = 0; i4 < drawCount; i4++) {
          elementCount += counts[i4];
        }
        for (let i4 = 0; i4 < primcount.length; i4++) {
          info.update(elementCount, mode, primcount[i4]);
        }
      }
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render6;
    this.renderInstances = renderInstances;
    this.renderMultiDraw = renderMultiDraw;
    this.renderMultiDrawInstances = renderMultiDrawInstances;
  }
  function WebGLInfo(gl2) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render6 = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update(count, mode, instanceCount) {
      render6.calls++;
      switch (mode) {
        case gl2.TRIANGLES:
          render6.triangles += instanceCount * (count / 3);
          break;
        case gl2.LINES:
          render6.lines += instanceCount * (count / 2);
          break;
        case gl2.LINE_STRIP:
          render6.lines += instanceCount * (count - 1);
          break;
        case gl2.LINE_LOOP:
          render6.lines += instanceCount * count;
          break;
        case gl2.POINTS:
          render6.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render6.calls = 0;
      render6.triangles = 0;
      render6.points = 0;
      render6.lines = 0;
    }
    return {
      memory,
      render: render6,
      programs: null,
      autoReset: true,
      reset,
      update
    };
  }
  function WebGLMorphtargets(gl2, capabilities, textures) {
    const morphTextures = /* @__PURE__ */ new WeakMap();
    const morph = new Vector4();
    function update(object, geometry, program) {
      const objectInfluences = object.morphTargetInfluences;
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0) entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true) vertexDataCount = 1;
        if (hasMorphNormals === true) vertexDataCount = 2;
        if (hasMorphColors === true) vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture.type = FloatType;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i4 = 0; i4 < morphTargetsCount; i4++) {
          const morphTarget = morphTargets[i4];
          const morphNormal = morphNormals[i4];
          const morphColor = morphColors[i4];
          const offset2 = width * height * 4 * i4;
          for (let j2 = 0; j2 < morphTarget.count; j2++) {
            const stride = j2 * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j2);
              buffer[offset2 + stride + 0] = morph.x;
              buffer[offset2 + stride + 1] = morph.y;
              buffer[offset2 + stride + 2] = morph.z;
              buffer[offset2 + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j2);
              buffer[offset2 + stride + 4] = morph.x;
              buffer[offset2 + stride + 5] = morph.y;
              buffer[offset2 + stride + 6] = morph.z;
              buffer[offset2 + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j2);
              buffer[offset2 + stride + 8] = morph.x;
              buffer[offset2 + stride + 9] = morph.y;
              buffer[offset2 + stride + 10] = morph.z;
              buffer[offset2 + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      if (object.isInstancedMesh === true && object.morphTexture !== null) {
        program.getUniforms().setValue(gl2, "morphTexture", object.morphTexture, textures);
      } else {
        let morphInfluencesSum = 0;
        for (let i4 = 0; i4 < objectInfluences.length; i4++) {
          morphInfluencesSum += objectInfluences[i4];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl2, "morphTargetInfluences", objectInfluences);
      }
      program.getUniforms().setValue(gl2, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl2, "morphTargetsTextureSize", entry.size);
    }
    return {
      update
    };
  }
  function WebGLObjects(gl2, geometries, attributes, info) {
    let updateMap = /* @__PURE__ */ new WeakMap();
    function update(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        if (updateMap.get(object) !== frame) {
          attributes.update(object.instanceMatrix, gl2.ARRAY_BUFFER);
          if (object.instanceColor !== null) {
            attributes.update(object.instanceColor, gl2.ARRAY_BUFFER);
          }
          updateMap.set(object, frame);
        }
      }
      if (object.isSkinnedMesh) {
        const skeleton = object.skeleton;
        if (updateMap.get(skeleton) !== frame) {
          skeleton.update();
          updateMap.set(skeleton, frame);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = /* @__PURE__ */ new WeakMap();
    }
    function onInstancedMeshDispose(event2) {
      const instancedMesh = event2.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update,
      dispose
    };
  }
  var DepthTexture = class extends Texture {
    constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {
      if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      }
      if (type === void 0 && format === DepthFormat) type = UnsignedIntType;
      if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.isDepthTexture = true;
      this.image = { width, height };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
      this.compareFunction = null;
    }
    copy(source) {
      super.copy(source);
      this.compareFunction = source.compareFunction;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
      return data;
    }
  };
  var emptyTexture = /* @__PURE__ */ new Texture();
  var emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
  emptyShadowTexture.compareFunction = LessEqualCompare;
  var emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
  var empty3dTexture = /* @__PURE__ */ new Data3DTexture();
  var emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    const n4 = nBlocks * blockSize;
    let r3 = arrayCacheF32[n4];
    if (r3 === void 0) {
      r3 = new Float32Array(n4);
      arrayCacheF32[n4] = r3;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r3, 0);
      for (let i4 = 1, offset2 = 0; i4 !== nBlocks; ++i4) {
        offset2 += blockSize;
        array[i4].toArray(r3, offset2);
      }
    }
    return r3;
  }
  function arraysEqual(a3, b2) {
    if (a3.length !== b2.length) return false;
    for (let i4 = 0, l4 = a3.length; i4 < l4; i4++) {
      if (a3[i4] !== b2[i4]) return false;
    }
    return true;
  }
  function copyArray(a3, b2) {
    for (let i4 = 0, l4 = b2.length; i4 < l4; i4++) {
      a3[i4] = b2[i4];
    }
  }
  function allocTexUnits(textures, n4) {
    let r3 = arrayCacheI32[n4];
    if (r3 === void 0) {
      r3 = new Int32Array(n4);
      arrayCacheI32[n4] = r3;
    }
    for (let i4 = 0; i4 !== n4; ++i4) {
      r3[i4] = textures.allocateTextureUnit();
    }
    return r3;
  }
  function setValueV1f(gl2, v2) {
    const cache = this.cache;
    if (cache[0] === v2) return;
    gl2.uniform1f(this.addr, v2);
    cache[0] = v2;
  }
  function setValueV2f(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y) {
        gl2.uniform2f(this.addr, v2.x, v2.y);
        cache[0] = v2.x;
        cache[1] = v2.y;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform2fv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV3f(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
        gl2.uniform3f(this.addr, v2.x, v2.y, v2.z);
        cache[0] = v2.x;
        cache[1] = v2.y;
        cache[2] = v2.z;
      }
    } else if (v2.r !== void 0) {
      if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
        gl2.uniform3f(this.addr, v2.r, v2.g, v2.b);
        cache[0] = v2.r;
        cache[1] = v2.g;
        cache[2] = v2.b;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform3fv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV4f(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
        gl2.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
        cache[0] = v2.x;
        cache[1] = v2.y;
        cache[2] = v2.z;
        cache[3] = v2.w;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform4fv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueM2(gl2, v2) {
    const cache = this.cache;
    const elements = v2.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v2)) return;
      gl2.uniformMatrix2fv(this.addr, false, v2);
      copyArray(cache, v2);
    } else {
      if (arraysEqual(cache, elements)) return;
      mat2array.set(elements);
      gl2.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl2, v2) {
    const cache = this.cache;
    const elements = v2.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v2)) return;
      gl2.uniformMatrix3fv(this.addr, false, v2);
      copyArray(cache, v2);
    } else {
      if (arraysEqual(cache, elements)) return;
      mat3array.set(elements);
      gl2.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl2, v2) {
    const cache = this.cache;
    const elements = v2.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v2)) return;
      gl2.uniformMatrix4fv(this.addr, false, v2);
      copyArray(cache, v2);
    } else {
      if (arraysEqual(cache, elements)) return;
      mat4array.set(elements);
      gl2.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl2, v2) {
    const cache = this.cache;
    if (cache[0] === v2) return;
    gl2.uniform1i(this.addr, v2);
    cache[0] = v2;
  }
  function setValueV2i(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y) {
        gl2.uniform2i(this.addr, v2.x, v2.y);
        cache[0] = v2.x;
        cache[1] = v2.y;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform2iv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV3i(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
        gl2.uniform3i(this.addr, v2.x, v2.y, v2.z);
        cache[0] = v2.x;
        cache[1] = v2.y;
        cache[2] = v2.z;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform3iv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV4i(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
        gl2.uniform4i(this.addr, v2.x, v2.y, v2.z, v2.w);
        cache[0] = v2.x;
        cache[1] = v2.y;
        cache[2] = v2.z;
        cache[3] = v2.w;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform4iv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV1ui(gl2, v2) {
    const cache = this.cache;
    if (cache[0] === v2) return;
    gl2.uniform1ui(this.addr, v2);
    cache[0] = v2;
  }
  function setValueV2ui(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y) {
        gl2.uniform2ui(this.addr, v2.x, v2.y);
        cache[0] = v2.x;
        cache[1] = v2.y;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform2uiv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV3ui(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
        gl2.uniform3ui(this.addr, v2.x, v2.y, v2.z);
        cache[0] = v2.x;
        cache[1] = v2.y;
        cache[2] = v2.z;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform3uiv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV4ui(gl2, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
        gl2.uniform4ui(this.addr, v2.x, v2.y, v2.z, v2.w);
        cache[0] = v2.x;
        cache[1] = v2.y;
        cache[2] = v2.z;
        cache[3] = v2.w;
      }
    } else {
      if (arraysEqual(cache, v2)) return;
      gl2.uniform4uiv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueT1(gl2, v2, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl2.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    const emptyTexture2D = this.type === gl2.SAMPLER_2D_SHADOW ? emptyShadowTexture : emptyTexture;
    textures.setTexture2D(v2 || emptyTexture2D, unit);
  }
  function setValueT3D1(gl2, v2, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl2.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v2 || empty3dTexture, unit);
  }
  function setValueT6(gl2, v2, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl2.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTextureCube(v2 || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl2, v2, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl2.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v2 || emptyArrayTexture, unit);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      // FLOAT
      case 35664:
        return setValueV2f;
      // _VEC2
      case 35665:
        return setValueV3f;
      // _VEC3
      case 35666:
        return setValueV4f;
      // _VEC4
      case 35674:
        return setValueM2;
      // _MAT2
      case 35675:
        return setValueM3;
      // _MAT3
      case 35676:
        return setValueM4;
      // _MAT4
      case 5124:
      case 35670:
        return setValueV1i;
      // INT, BOOL
      case 35667:
      case 35671:
        return setValueV2i;
      // _VEC2
      case 35668:
      case 35672:
        return setValueV3i;
      // _VEC3
      case 35669:
      case 35673:
        return setValueV4i;
      // _VEC4
      case 5125:
        return setValueV1ui;
      // UINT
      case 36294:
        return setValueV2ui;
      // _VEC2
      case 36295:
        return setValueV3ui;
      // _VEC3
      case 36296:
        return setValueV4ui;
      // _VEC4
      case 35678:
      // SAMPLER_2D
      case 36198:
      // SAMPLER_EXTERNAL_OES
      case 36298:
      // INT_SAMPLER_2D
      case 36306:
      // UNSIGNED_INT_SAMPLER_2D
      case 35682:
        return setValueT1;
      case 35679:
      // SAMPLER_3D
      case 36299:
      // INT_SAMPLER_3D
      case 36307:
        return setValueT3D1;
      case 35680:
      // SAMPLER_CUBE
      case 36300:
      // INT_SAMPLER_CUBE
      case 36308:
      // UNSIGNED_INT_SAMPLER_CUBE
      case 36293:
        return setValueT6;
      case 36289:
      // SAMPLER_2D_ARRAY
      case 36303:
      // INT_SAMPLER_2D_ARRAY
      case 36311:
      // UNSIGNED_INT_SAMPLER_2D_ARRAY
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl2, v2) {
    gl2.uniform1fv(this.addr, v2);
  }
  function setValueV2fArray(gl2, v2) {
    const data = flatten(v2, this.size, 2);
    gl2.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl2, v2) {
    const data = flatten(v2, this.size, 3);
    gl2.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl2, v2) {
    const data = flatten(v2, this.size, 4);
    gl2.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl2, v2) {
    const data = flatten(v2, this.size, 4);
    gl2.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl2, v2) {
    const data = flatten(v2, this.size, 9);
    gl2.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl2, v2) {
    const data = flatten(v2, this.size, 16);
    gl2.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl2, v2) {
    gl2.uniform1iv(this.addr, v2);
  }
  function setValueV2iArray(gl2, v2) {
    gl2.uniform2iv(this.addr, v2);
  }
  function setValueV3iArray(gl2, v2) {
    gl2.uniform3iv(this.addr, v2);
  }
  function setValueV4iArray(gl2, v2) {
    gl2.uniform4iv(this.addr, v2);
  }
  function setValueV1uiArray(gl2, v2) {
    gl2.uniform1uiv(this.addr, v2);
  }
  function setValueV2uiArray(gl2, v2) {
    gl2.uniform2uiv(this.addr, v2);
  }
  function setValueV3uiArray(gl2, v2) {
    gl2.uniform3uiv(this.addr, v2);
  }
  function setValueV4uiArray(gl2, v2) {
    gl2.uniform4uiv(this.addr, v2);
  }
  function setValueT1Array(gl2, v2, textures) {
    const cache = this.cache;
    const n4 = v2.length;
    const units = allocTexUnits(textures, n4);
    if (!arraysEqual(cache, units)) {
      gl2.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i4 = 0; i4 !== n4; ++i4) {
      textures.setTexture2D(v2[i4] || emptyTexture, units[i4]);
    }
  }
  function setValueT3DArray(gl2, v2, textures) {
    const cache = this.cache;
    const n4 = v2.length;
    const units = allocTexUnits(textures, n4);
    if (!arraysEqual(cache, units)) {
      gl2.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i4 = 0; i4 !== n4; ++i4) {
      textures.setTexture3D(v2[i4] || empty3dTexture, units[i4]);
    }
  }
  function setValueT6Array(gl2, v2, textures) {
    const cache = this.cache;
    const n4 = v2.length;
    const units = allocTexUnits(textures, n4);
    if (!arraysEqual(cache, units)) {
      gl2.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i4 = 0; i4 !== n4; ++i4) {
      textures.setTextureCube(v2[i4] || emptyCubeTexture, units[i4]);
    }
  }
  function setValueT2DArrayArray(gl2, v2, textures) {
    const cache = this.cache;
    const n4 = v2.length;
    const units = allocTexUnits(textures, n4);
    if (!arraysEqual(cache, units)) {
      gl2.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (let i4 = 0; i4 !== n4; ++i4) {
      textures.setTexture2DArray(v2[i4] || emptyArrayTexture, units[i4]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      // FLOAT
      case 35664:
        return setValueV2fArray;
      // _VEC2
      case 35665:
        return setValueV3fArray;
      // _VEC3
      case 35666:
        return setValueV4fArray;
      // _VEC4
      case 35674:
        return setValueM2Array;
      // _MAT2
      case 35675:
        return setValueM3Array;
      // _MAT3
      case 35676:
        return setValueM4Array;
      // _MAT4
      case 5124:
      case 35670:
        return setValueV1iArray;
      // INT, BOOL
      case 35667:
      case 35671:
        return setValueV2iArray;
      // _VEC2
      case 35668:
      case 35672:
        return setValueV3iArray;
      // _VEC3
      case 35669:
      case 35673:
        return setValueV4iArray;
      // _VEC4
      case 5125:
        return setValueV1uiArray;
      // UINT
      case 36294:
        return setValueV2uiArray;
      // _VEC2
      case 36295:
        return setValueV3uiArray;
      // _VEC3
      case 36296:
        return setValueV4uiArray;
      // _VEC4
      case 35678:
      // SAMPLER_2D
      case 36198:
      // SAMPLER_EXTERNAL_OES
      case 36298:
      // INT_SAMPLER_2D
      case 36306:
      // UNSIGNED_INT_SAMPLER_2D
      case 35682:
        return setValueT1Array;
      case 35679:
      // SAMPLER_3D
      case 36299:
      // INT_SAMPLER_3D
      case 36307:
        return setValueT3DArray;
      case 35680:
      // SAMPLER_CUBE
      case 36300:
      // INT_SAMPLER_CUBE
      case 36308:
      // UNSIGNED_INT_SAMPLER_CUBE
      case 36293:
        return setValueT6Array;
      case 36289:
      // SAMPLER_2D_ARRAY
      case 36303:
      // INT_SAMPLER_2D_ARRAY
      case 36311:
      // UNSIGNED_INT_SAMPLER_2D_ARRAY
      case 36292:
        return setValueT2DArrayArray;
    }
  }
  var SingleUniform = class {
    constructor(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.type = activeInfo.type;
      this.setValue = getSingularSetter(activeInfo.type);
    }
  };
  var PureArrayUniform = class {
    constructor(id, activeInfo, addr) {
      this.id = id;
      this.addr = addr;
      this.cache = [];
      this.type = activeInfo.type;
      this.size = activeInfo.size;
      this.setValue = getPureArraySetter(activeInfo.type);
    }
  };
  var StructuredUniform = class {
    constructor(id) {
      this.id = id;
      this.seq = [];
      this.map = {};
    }
    setValue(gl2, value, textures) {
      const seq = this.seq;
      for (let i4 = 0, n4 = seq.length; i4 !== n4; ++i4) {
        const u2 = seq[i4];
        u2.setValue(gl2, value[u2.id], textures);
      }
    }
  };
  var RePathPart = /(\w+)(\])?(\[|\.)?/g;
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex) id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        const map2 = container.map;
        let next2 = map2[id];
        if (next2 === void 0) {
          next2 = new StructuredUniform(id);
          addUniform(container, next2);
        }
        container = next2;
      }
    }
  }
  var WebGLUniforms = class {
    constructor(gl2, program) {
      this.seq = [];
      this.map = {};
      const n4 = gl2.getProgramParameter(program, gl2.ACTIVE_UNIFORMS);
      for (let i4 = 0; i4 < n4; ++i4) {
        const info = gl2.getActiveUniform(program, i4), addr = gl2.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
      }
    }
    setValue(gl2, name, value, textures) {
      const u2 = this.map[name];
      if (u2 !== void 0) u2.setValue(gl2, value, textures);
    }
    setOptional(gl2, object, name) {
      const v2 = object[name];
      if (v2 !== void 0) this.setValue(gl2, name, v2);
    }
    static upload(gl2, seq, values, textures) {
      for (let i4 = 0, n4 = seq.length; i4 !== n4; ++i4) {
        const u2 = seq[i4], v2 = values[u2.id];
        if (v2.needsUpdate !== false) {
          u2.setValue(gl2, v2.value, textures);
        }
      }
    }
    static seqWithValue(seq, values) {
      const r3 = [];
      for (let i4 = 0, n4 = seq.length; i4 !== n4; ++i4) {
        const u2 = seq[i4];
        if (u2.id in values) r3.push(u2);
      }
      return r3;
    }
  };
  function WebGLShader(gl2, type, string) {
    const shader = gl2.createShader(type);
    gl2.shaderSource(shader, string);
    gl2.compileShader(shader);
    return shader;
  }
  var COMPLETION_STATUS_KHR = 37297;
  var programIdCount = 0;
  function handleSource(string, errorLine) {
    const lines = string.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for (let i4 = from; i4 < to; i4++) {
      const line = i4 + 1;
      lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i4]}`);
    }
    return lines2.join("\n");
  }
  function getEncodingComponents(colorSpace) {
    const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
    const encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
    let gamutMapping;
    if (workingPrimaries === encodingPrimaries) {
      gamutMapping = "";
    } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
      gamutMapping = "LinearDisplayP3ToLinearSRGB";
    } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
      gamutMapping = "LinearSRGBToLinearDisplayP3";
    }
    switch (colorSpace) {
      case LinearSRGBColorSpace:
      case LinearDisplayP3ColorSpace:
        return [gamutMapping, "LinearTransferOETF"];
      case SRGBColorSpace:
      case DisplayP3ColorSpace:
        return [gamutMapping, "sRGBTransferOETF"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
        return [gamutMapping, "LinearTransferOETF"];
    }
  }
  function getShaderErrors(gl2, shader, type) {
    const status = gl2.getShaderParameter(shader, gl2.COMPILE_STATUS);
    const errors = gl2.getShaderInfoLog(shader).trim();
    if (status && errors === "") return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
      const errorLine = parseInt(errorMatches[1]);
      return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl2.getShaderSource(shader), errorLine);
    } else {
      return errors;
    }
  }
  function getTexelEncodingFunction(functionName, colorSpace) {
    const components = getEncodingComponents(colorSpace);
    return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`;
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case AgXToneMapping:
        toneMappingName = "AgX";
        break;
      case NeutralToneMapping:
        toneMappingName = "Neutral";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateVertexExtensions(parameters) {
    const chunks = [
      parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
      parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false) continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl2, program) {
    const attributes = {};
    const n4 = gl2.getProgramParameter(program, gl2.ACTIVE_ATTRIBUTES);
    for (let i4 = 0; i4 < n4; i4++) {
      const info = gl2.getActiveAttrib(program, i4);
      const name = info.name;
      let locationSize = 1;
      if (info.type === gl2.FLOAT_MAT2) locationSize = 2;
      if (info.type === gl2.FLOAT_MAT3) locationSize = 3;
      if (info.type === gl2.FLOAT_MAT4) locationSize = 4;
      attributes[name] = {
        type: info.type,
        location: gl2.getAttribLocation(program, name),
        locationSize
      };
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  var shaderChunkMap = /* @__PURE__ */ new Map();
  function includeReplacer(match, include) {
    let string = ShaderChunk[include];
    if (string === void 0) {
      const newInclude = shaderChunkMap.get(include);
      if (newInclude !== void 0) {
        string = ShaderChunk[newInclude];
        console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
      } else {
        throw new Error("Can not resolve #include <" + include + ">");
      }
    }
    return resolveIncludes(string);
  }
  var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer);
  }
  function loopReplacer(match, start, end, snippet) {
    let string = "";
    for (let i4 = parseInt(start); i4 < parseInt(end); i4++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i4 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i4);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function generateCubeUVSize(parameters) {
    const imageHeight = parameters.envMapCubeUVHeight;
    if (imageHeight === null) return null;
    const maxMip = Math.log2(imageHeight) - 2;
    const texelHeight = 1 / imageHeight;
    const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return { texelWidth, texelHeight, maxMip };
  }
  function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl2 = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const envMapCubeUVSize = generateCubeUVSize(parameters);
    const customVertexExtensions = generateVertexExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl2.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        parameters.batching ? "#define USE_BATCHING" : "",
        parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
        parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        //
        parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
        parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
        parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
        parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
        parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
        parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
        parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
        parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
        parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
        parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
        parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
        parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
        parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
        parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
        parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
        parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
        parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
        parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
        parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
        parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
        parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
        parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
        parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
        //
        parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUv1s ? "#define USE_UV1" : "",
        parameters.vertexUv2s ? "#define USE_UV2" : "",
        parameters.vertexUv3s ? "#define USE_UV3" : "",
        parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
        parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
        parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        generatePrecision(parameters),
        "#define SHADER_TYPE " + parameters.shaderType,
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
        envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
        envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
        parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.dispersion ? "#define USE_DISPERSION" : "",
        parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
        parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaTest ? "#define USE_ALPHATEST" : "",
        parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUv1s ? "#define USE_UV1" : "",
        parameters.vertexUv2s ? "#define USE_UV2" : "",
        parameters.vertexUv3s ? "#define USE_UV3" : "",
        parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        // this code is required here because it is used by the toneMapping() function defined below
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.opaque ? "#define OPAQUE" : "",
        ShaderChunk["colorspace_pars_fragment"],
        // this code is required here because it is used by the various encoding/decoding function defined below
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
        parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        customVertexExtensions,
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl2, gl2.VERTEX_SHADER, vertexGlsl);
    const glFragmentShader = WebGLShader(gl2, gl2.FRAGMENT_SHADER, fragmentGlsl);
    gl2.attachShader(program, glVertexShader);
    gl2.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl2.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl2.bindAttribLocation(program, 0, "position");
    }
    gl2.linkProgram(program);
    function onFirstUse(self2) {
      if (renderer.debug.checkShaderErrors) {
        const programLog = gl2.getProgramInfoLog(program).trim();
        const vertexLog = gl2.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl2.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl2.getProgramParameter(program, gl2.LINK_STATUS) === false) {
          runnable = false;
          if (typeof renderer.debug.onShaderError === "function") {
            renderer.debug.onShaderError(gl2, program, glVertexShader, glFragmentShader);
          } else {
            const vertexErrors = getShaderErrors(gl2, glVertexShader, "vertex");
            const fragmentErrors = getShaderErrors(gl2, glFragmentShader, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " + gl2.getError() + " - VALIDATE_STATUS " + gl2.getProgramParameter(program, gl2.VALIDATE_STATUS) + "\n\nMaterial Name: " + self2.name + "\nMaterial Type: " + self2.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
            );
          }
        } else if (programLog !== "") {
          console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
        } else if (vertexLog === "" || fragmentLog === "") {
          haveDiagnostics = false;
        }
        if (haveDiagnostics) {
          self2.diagnostics = {
            runnable,
            programLog,
            vertexShader: {
              log: vertexLog,
              prefix: prefixVertex
            },
            fragmentShader: {
              log: fragmentLog,
              prefix: prefixFragment
            }
          };
        }
      }
      gl2.deleteShader(glVertexShader);
      gl2.deleteShader(glFragmentShader);
      cachedUniforms = new WebGLUniforms(gl2, program);
      cachedAttributes = fetchAttributeLocations(gl2, program);
    }
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        onFirstUse(this);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        onFirstUse(this);
      }
      return cachedAttributes;
    };
    let programReady = parameters.rendererExtensionParallelShaderCompile === false;
    this.isReady = function() {
      if (programReady === false) {
        programReady = gl2.getProgramParameter(program, COMPLETION_STATUS_KHR);
      }
      return programReady;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl2.deleteProgram(program);
      this.program = void 0;
    };
    this.type = parameters.shaderType;
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  var _id$1 = 0;
  var WebGLShaderCache = class {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map();
      this.materialCache = /* @__PURE__ */ new Map();
    }
    update(material) {
      const vertexShader = material.vertexShader;
      const fragmentShader = material.fragmentShader;
      const vertexShaderStage = this._getShaderStage(vertexShader);
      const fragmentShaderStage = this._getShaderStage(fragmentShader);
      const materialShaders = this._getShaderCacheForMaterial(material);
      if (materialShaders.has(vertexShaderStage) === false) {
        materialShaders.add(vertexShaderStage);
        vertexShaderStage.usedTimes++;
      }
      if (materialShaders.has(fragmentShaderStage) === false) {
        materialShaders.add(fragmentShaderStage);
        fragmentShaderStage.usedTimes++;
      }
      return this;
    }
    remove(material) {
      const materialShaders = this.materialCache.get(material);
      for (const shaderStage of materialShaders) {
        shaderStage.usedTimes--;
        if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
      }
      this.materialCache.delete(material);
      return this;
    }
    getVertexShaderID(material) {
      return this._getShaderStage(material.vertexShader).id;
    }
    getFragmentShaderID(material) {
      return this._getShaderStage(material.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear();
      this.materialCache.clear();
    }
    _getShaderCacheForMaterial(material) {
      const cache = this.materialCache;
      let set2 = cache.get(material);
      if (set2 === void 0) {
        set2 = /* @__PURE__ */ new Set();
        cache.set(material, set2);
      }
      return set2;
    }
    _getShaderStage(code) {
      const cache = this.shaderCache;
      let stage = cache.get(code);
      if (stage === void 0) {
        stage = new WebGLShaderStage(code);
        cache.set(code, stage);
      }
      return stage;
    }
  };
  var WebGLShaderStage = class {
    constructor(code) {
      this.id = _id$1++;
      this.code = code;
      this.usedTimes = 0;
    }
  };
  function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const _programLayers = new Layers();
    const _customShaders = new WebGLShaderCache();
    const _activeChannels = /* @__PURE__ */ new Set();
    const programs = [];
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function getChannel(value) {
      _activeChannels.add(value);
      if (value === 0) return "uv";
      return `uv${value}`;
    }
    function getParameters(material, lights, shadows, scene, object) {
      const fog = scene.fog;
      const geometry = object.geometry;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
      const shaderID = shaderIDs[material.type];
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let morphTextureStride = 0;
      if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
      if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
      if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
      let vertexShader, fragmentShader;
      let customVertexShaderID, customFragmentShaderID;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
        _customShaders.update(material);
        customVertexShaderID = _customShaders.getVertexShaderID(material);
        customFragmentShaderID = _customShaders.getFragmentShaderID(material);
      }
      const currentRenderTarget = renderer.getRenderTarget();
      const IS_INSTANCEDMESH = object.isInstancedMesh === true;
      const IS_BATCHEDMESH = object.isBatchedMesh === true;
      const HAS_MAP = !!material.map;
      const HAS_MATCAP = !!material.matcap;
      const HAS_ENVMAP = !!envMap;
      const HAS_AOMAP = !!material.aoMap;
      const HAS_LIGHTMAP = !!material.lightMap;
      const HAS_BUMPMAP = !!material.bumpMap;
      const HAS_NORMALMAP = !!material.normalMap;
      const HAS_DISPLACEMENTMAP = !!material.displacementMap;
      const HAS_EMISSIVEMAP = !!material.emissiveMap;
      const HAS_METALNESSMAP = !!material.metalnessMap;
      const HAS_ROUGHNESSMAP = !!material.roughnessMap;
      const HAS_ANISOTROPY = material.anisotropy > 0;
      const HAS_CLEARCOAT = material.clearcoat > 0;
      const HAS_DISPERSION = material.dispersion > 0;
      const HAS_IRIDESCENCE = material.iridescence > 0;
      const HAS_SHEEN = material.sheen > 0;
      const HAS_TRANSMISSION = material.transmission > 0;
      const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
      const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
      const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
      const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
      const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
      const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
      const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
      const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
      const HAS_SPECULARMAP = !!material.specularMap;
      const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
      const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
      const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
      const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
      const HAS_GRADIENTMAP = !!material.gradientMap;
      const HAS_ALPHAMAP = !!material.alphaMap;
      const HAS_ALPHATEST = material.alphaTest > 0;
      const HAS_ALPHAHASH = !!material.alphaHash;
      const HAS_EXTENSIONS = !!material.extensions;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = renderer.toneMapping;
        }
      }
      const parameters = {
        shaderID,
        shaderType: material.type,
        shaderName: material.name,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        customVertexShaderID,
        customFragmentShaderID,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        batching: IS_BATCHEDMESH,
        batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
        instancing: IS_INSTANCEDMESH,
        instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
        instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
        supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
        outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
        alphaToCoverage: !!material.alphaToCoverage,
        map: HAS_MAP,
        matcap: HAS_MATCAP,
        envMap: HAS_ENVMAP,
        envMapMode: HAS_ENVMAP && envMap.mapping,
        envMapCubeUVHeight,
        aoMap: HAS_AOMAP,
        lightMap: HAS_LIGHTMAP,
        bumpMap: HAS_BUMPMAP,
        normalMap: HAS_NORMALMAP,
        displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
        emissiveMap: HAS_EMISSIVEMAP,
        normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
        normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
        metalnessMap: HAS_METALNESSMAP,
        roughnessMap: HAS_ROUGHNESSMAP,
        anisotropy: HAS_ANISOTROPY,
        anisotropyMap: HAS_ANISOTROPYMAP,
        clearcoat: HAS_CLEARCOAT,
        clearcoatMap: HAS_CLEARCOATMAP,
        clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
        clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
        dispersion: HAS_DISPERSION,
        iridescence: HAS_IRIDESCENCE,
        iridescenceMap: HAS_IRIDESCENCEMAP,
        iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
        sheen: HAS_SHEEN,
        sheenColorMap: HAS_SHEEN_COLORMAP,
        sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
        specularMap: HAS_SPECULARMAP,
        specularColorMap: HAS_SPECULAR_COLORMAP,
        specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
        transmission: HAS_TRANSMISSION,
        transmissionMap: HAS_TRANSMISSIONMAP,
        thicknessMap: HAS_THICKNESSMAP,
        gradientMap: HAS_GRADIENTMAP,
        opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
        alphaMap: HAS_ALPHAMAP,
        alphaTest: HAS_ALPHATEST,
        alphaHash: HAS_ALPHAHASH,
        combine: material.combine,
        //
        mapUv: HAS_MAP && getChannel(material.map.channel),
        aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
        lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
        bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
        normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
        displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
        emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
        metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
        roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
        anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
        clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
        clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
        iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
        iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
        sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
        sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
        specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
        specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
        specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
        transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
        thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
        alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
        //
        vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
        pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
        fog: !!fog,
        useFog: material.fog === true,
        fogExp2: !!fog && fog.isFogExp2,
        flatShading: material.flatShading === true,
        sizeAttenuation: material.sizeAttenuation === true,
        logarithmicDepthBuffer,
        skinning: object.isSkinnedMesh === true,
        morphTargets: geometry.morphAttributes.position !== void 0,
        morphNormals: geometry.morphAttributes.normal !== void 0,
        morphColors: geometry.morphAttributes.color !== void 0,
        morphTargetsCount,
        morphTextureStride,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numSpotLightMaps: lights.spotLightMap.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
        numLightProbes: lights.numLightProbes,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping,
        decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
        premultipliedAlpha: material.premultipliedAlpha,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        useDepthPacking: material.depthPacking >= 0,
        depthPacking: material.depthPacking || 0,
        index0AttributeName: material.index0AttributeName,
        extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
        extensionMultiDraw: HAS_EXTENSIONS && material.extensions.multiDraw === true && extensions.has("WEBGL_multi_draw"),
        rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      parameters.vertexUv1s = _activeChannels.has(1);
      parameters.vertexUv2s = _activeChannels.has(2);
      parameters.vertexUv3s = _activeChannels.has(3);
      _activeChannels.clear();
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.customVertexShaderID);
        array.push(parameters.customFragmentShaderID);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        getProgramCacheKeyParameters(array, parameters);
        getProgramCacheKeyBooleans(array, parameters);
        array.push(renderer.outputColorSpace);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getProgramCacheKeyParameters(array, parameters) {
      array.push(parameters.precision);
      array.push(parameters.outputColorSpace);
      array.push(parameters.envMapMode);
      array.push(parameters.envMapCubeUVHeight);
      array.push(parameters.mapUv);
      array.push(parameters.alphaMapUv);
      array.push(parameters.lightMapUv);
      array.push(parameters.aoMapUv);
      array.push(parameters.bumpMapUv);
      array.push(parameters.normalMapUv);
      array.push(parameters.displacementMapUv);
      array.push(parameters.emissiveMapUv);
      array.push(parameters.metalnessMapUv);
      array.push(parameters.roughnessMapUv);
      array.push(parameters.anisotropyMapUv);
      array.push(parameters.clearcoatMapUv);
      array.push(parameters.clearcoatNormalMapUv);
      array.push(parameters.clearcoatRoughnessMapUv);
      array.push(parameters.iridescenceMapUv);
      array.push(parameters.iridescenceThicknessMapUv);
      array.push(parameters.sheenColorMapUv);
      array.push(parameters.sheenRoughnessMapUv);
      array.push(parameters.specularMapUv);
      array.push(parameters.specularColorMapUv);
      array.push(parameters.specularIntensityMapUv);
      array.push(parameters.transmissionMapUv);
      array.push(parameters.thicknessMapUv);
      array.push(parameters.combine);
      array.push(parameters.fogExp2);
      array.push(parameters.sizeAttenuation);
      array.push(parameters.morphTargetsCount);
      array.push(parameters.morphAttributeCount);
      array.push(parameters.numDirLights);
      array.push(parameters.numPointLights);
      array.push(parameters.numSpotLights);
      array.push(parameters.numSpotLightMaps);
      array.push(parameters.numHemiLights);
      array.push(parameters.numRectAreaLights);
      array.push(parameters.numDirLightShadows);
      array.push(parameters.numPointLightShadows);
      array.push(parameters.numSpotLightShadows);
      array.push(parameters.numSpotLightShadowsWithMaps);
      array.push(parameters.numLightProbes);
      array.push(parameters.shadowMapType);
      array.push(parameters.toneMapping);
      array.push(parameters.numClippingPlanes);
      array.push(parameters.numClipIntersection);
      array.push(parameters.depthPacking);
    }
    function getProgramCacheKeyBooleans(array, parameters) {
      _programLayers.disableAll();
      if (parameters.supportsVertexTextures)
        _programLayers.enable(0);
      if (parameters.instancing)
        _programLayers.enable(1);
      if (parameters.instancingColor)
        _programLayers.enable(2);
      if (parameters.instancingMorph)
        _programLayers.enable(3);
      if (parameters.matcap)
        _programLayers.enable(4);
      if (parameters.envMap)
        _programLayers.enable(5);
      if (parameters.normalMapObjectSpace)
        _programLayers.enable(6);
      if (parameters.normalMapTangentSpace)
        _programLayers.enable(7);
      if (parameters.clearcoat)
        _programLayers.enable(8);
      if (parameters.iridescence)
        _programLayers.enable(9);
      if (parameters.alphaTest)
        _programLayers.enable(10);
      if (parameters.vertexColors)
        _programLayers.enable(11);
      if (parameters.vertexAlphas)
        _programLayers.enable(12);
      if (parameters.vertexUv1s)
        _programLayers.enable(13);
      if (parameters.vertexUv2s)
        _programLayers.enable(14);
      if (parameters.vertexUv3s)
        _programLayers.enable(15);
      if (parameters.vertexTangents)
        _programLayers.enable(16);
      if (parameters.anisotropy)
        _programLayers.enable(17);
      if (parameters.alphaHash)
        _programLayers.enable(18);
      if (parameters.batching)
        _programLayers.enable(19);
      if (parameters.dispersion)
        _programLayers.enable(20);
      if (parameters.batchingColor)
        _programLayers.enable(21);
      array.push(_programLayers.mask);
      _programLayers.disableAll();
      if (parameters.fog)
        _programLayers.enable(0);
      if (parameters.useFog)
        _programLayers.enable(1);
      if (parameters.flatShading)
        _programLayers.enable(2);
      if (parameters.logarithmicDepthBuffer)
        _programLayers.enable(3);
      if (parameters.skinning)
        _programLayers.enable(4);
      if (parameters.morphTargets)
        _programLayers.enable(5);
      if (parameters.morphNormals)
        _programLayers.enable(6);
      if (parameters.morphColors)
        _programLayers.enable(7);
      if (parameters.premultipliedAlpha)
        _programLayers.enable(8);
      if (parameters.shadowMapEnabled)
        _programLayers.enable(9);
      if (parameters.doubleSided)
        _programLayers.enable(10);
      if (parameters.flipSided)
        _programLayers.enable(11);
      if (parameters.useDepthPacking)
        _programLayers.enable(12);
      if (parameters.dithering)
        _programLayers.enable(13);
      if (parameters.transmission)
        _programLayers.enable(14);
      if (parameters.sheen)
        _programLayers.enable(15);
      if (parameters.opaque)
        _programLayers.enable(16);
      if (parameters.pointsUvs)
        _programLayers.enable(17);
      if (parameters.decodeVideoTexture)
        _programLayers.enable(18);
      if (parameters.alphaToCoverage)
        _programLayers.enable(19);
      array.push(_programLayers.mask);
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
        const preexistingProgram = programs[p2];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i4 = programs.indexOf(program);
        programs[i4] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    function releaseShaderCache(material) {
      _customShaders.remove(material);
    }
    function dispose() {
      _customShaders.dispose();
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      releaseShaderCache,
      // Exposed for resource monitoring & error feedback via renderer.info:
      programs,
      dispose
    };
  }
  function WebGLProperties() {
    let properties = /* @__PURE__ */ new WeakMap();
    function get(object) {
      let map2 = properties.get(object);
      if (map2 === void 0) {
        map2 = {};
        properties.set(object, map2);
      }
      return map2;
    }
    function remove2(object) {
      properties.delete(object);
    }
    function update(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      remove: remove2,
      update,
      dispose
    };
  }
  function painterSortStable(a3, b2) {
    if (a3.groupOrder !== b2.groupOrder) {
      return a3.groupOrder - b2.groupOrder;
    } else if (a3.renderOrder !== b2.renderOrder) {
      return a3.renderOrder - b2.renderOrder;
    } else if (a3.material.id !== b2.material.id) {
      return a3.material.id - b2.material.id;
    } else if (a3.z !== b2.z) {
      return a3.z - b2.z;
    } else {
      return a3.id - b2.id;
    }
  }
  function reversePainterSortStable(a3, b2) {
    if (a3.groupOrder !== b2.groupOrder) {
      return a3.groupOrder - b2.groupOrder;
    } else if (a3.renderOrder !== b2.renderOrder) {
      return a3.renderOrder - b2.renderOrder;
    } else if (a3.z !== b2.z) {
      return b2.z - a3.z;
    } else {
      return a3.id - b2.id;
    }
  }
  function WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    function init5() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transmissive.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
      let renderItem = renderItems[renderItemsIndex];
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          groupOrder,
          renderOrder: object.renderOrder,
          z: z2,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z2;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push2(object, geometry, material, groupOrder, z2, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
      if (material.transmission > 0) {
        transmissive.push(renderItem);
      } else if (material.transparent === true) {
        transparent.push(renderItem);
      } else {
        opaque.push(renderItem);
      }
    }
    function unshift(object, geometry, material, groupOrder, z2, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
      if (material.transmission > 0) {
        transmissive.unshift(renderItem);
      } else if (material.transparent === true) {
        transparent.unshift(renderItem);
      } else {
        opaque.unshift(renderItem);
      }
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
      if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
      if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i4 = renderItemsIndex, il = renderItems.length; i4 < il; i4++) {
        const renderItem = renderItems[i4];
        if (renderItem.id === null) break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transmissive,
      transparent,
      init: init5,
      push: push2,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists() {
    let lists = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth) {
      const listArray = lists.get(scene);
      let list;
      if (listArray === void 0) {
        list = new WebGLRenderList();
        lists.set(scene, [list]);
      } else {
        if (renderCallDepth >= listArray.length) {
          list = new WebGLRenderList();
          listArray.push(list);
        } else {
          list = listArray[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  var nextVersion = 0;
  function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
  }
  function WebGLLights(extensions) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0
    };
    for (let i4 = 0; i4 < 9; i4++) state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup2(lights) {
      let r3 = 0, g2 = 0, b2 = 0;
      for (let i4 = 0; i4 < 9; i4++) state.probe[i4].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      let numSpotMaps = 0;
      let numSpotShadowsWithMaps = 0;
      let numLightProbes = 0;
      lights.sort(shadowCastingAndTexturingLightsFirst);
      for (let i4 = 0, l4 = lights.length; i4 < l4; i4++) {
        const light = lights[i4];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r3 += color.r * intensity;
          g2 += color.g * intensity;
          b2 += color.b * intensity;
        } else if (light.isLightProbe) {
          for (let j2 = 0; j2 < 9; j2++) {
            state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
          }
          numLightProbes++;
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.directionalShadow[directionalLength] = shadowUniforms;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          state.spot[spotLength] = uniforms;
          const shadow = light.shadow;
          if (light.map) {
            state.spotLightMap[numSpotMaps] = light.map;
            numSpotMaps++;
            shadow.updateMatrices(light);
            if (light.castShadow) numSpotShadowsWithMaps++;
          }
          state.spotLightMatrix[spotLength] = shadow.matrix;
          if (light.castShadow) {
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.spotShadow[spotLength] = shadowUniforms;
            state.spotShadowMap[spotLength] = shadowMap;
            numSpotShadows++;
          }
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state.pointShadow[pointLength] = shadowUniforms;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        }
      }
      state.ambient[0] = r3;
      state.ambient[1] = g2;
      state.ambient[2] = b2;
      const hash = state.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadow.length = numDirectionalShadows;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadow.length = numPointShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadow.length = numSpotShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
        state.spotLightMap.length = numSpotMaps;
        state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
        state.numLightProbes = numLightProbes;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        hash.numSpotMaps = numSpotMaps;
        hash.numLightProbes = numLightProbes;
        state.version = nextVersion++;
      }
    }
    function setupView(lights, camera) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera.matrixWorldInverse;
      for (let i4 = 0, l4 = lights.length; i4 < l4; i4++) {
        const light = lights[i4];
        if (light.isDirectionalLight) {
          const uniforms = state.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = state.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = state.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = state.point[pointLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = state.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          hemiLength++;
        }
      }
    }
    return {
      setup: setup2,
      setupView,
      state
    };
  }
  function WebGLRenderState(extensions) {
    const lights = new WebGLLights(extensions);
    const lightsArray = [];
    const shadowsArray = [];
    function init5(camera) {
      state.camera = camera;
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights() {
      lights.setup(lightsArray);
    }
    function setupLightsView(camera) {
      lights.setupView(lightsArray, camera);
    }
    const state = {
      lightsArray,
      shadowsArray,
      camera: null,
      lights,
      transmissionRenderTarget: {}
    };
    return {
      init: init5,
      state,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions) {
    let renderStates = /* @__PURE__ */ new WeakMap();
    function get(scene, renderCallDepth = 0) {
      const renderStateArray = renderStates.get(scene);
      let renderState;
      if (renderStateArray === void 0) {
        renderState = new WebGLRenderState(extensions);
        renderStates.set(scene, [renderState]);
      } else {
        if (renderCallDepth >= renderStateArray.length) {
          renderState = new WebGLRenderState(extensions);
          renderStateArray.push(renderState);
        } else {
          renderState = renderStateArray[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var MeshDepthMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshDepthMaterial = true;
      this.type = "MeshDepthMaterial";
      this.depthPacking = BasicDepthPacking;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.depthPacking = source.depthPacking;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    }
  };
  var MeshDistanceMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshDistanceMaterial = true;
      this.type = "MeshDistanceMaterial";
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    }
  };
  var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
  var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  function WebGLShadowMap(renderer, objects, capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport2 = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
    const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 }
      },
      vertexShader: vertex,
      fragmentShader: fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute(
      "position",
      new BufferAttribute(
        new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
        3
      )
    );
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    let _previousType = this.type;
    this.render = function(lights, scene, camera) {
      if (scope.enabled === false) return;
      if (scope.autoUpdate === false && scope.needsUpdate === false) return;
      if (lights.length === 0) return;
      const currentRenderTarget = renderer.getRenderTarget();
      const activeCubeFace = renderer.getActiveCubeFace();
      const activeMipmapLevel = renderer.getActiveMipmapLevel();
      const _state = renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
      const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
      for (let i4 = 0, il = lights.length; i4 < il; i4++) {
        const light = lights[i4];
        const shadow = light.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null || toVSM === true || fromVSM === true) {
          const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
          if (shadow.map !== null) {
            shadow.map.dispose();
          }
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        renderer.setRenderTarget(shadow.map);
        renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow.getViewport(vp);
          _viewport2.set(
            _viewportSize.x * viewport.x,
            _viewportSize.y * viewport.y,
            _viewportSize.x * viewport.z,
            _viewportSize.y * viewport.w
          );
          _state.viewport(_viewport2);
          shadow.updateMatrices(light, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene, camera, shadow.camera, light, this.type);
        }
        if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }
        shadow.needsUpdate = false;
      }
      _previousType = this.type;
      scope.needsUpdate = false;
      renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
      const geometry = objects.update(fullScreenMesh);
      if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
        shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
        shadowMaterialVertical.needsUpdate = true;
        shadowMaterialHorizontal.needsUpdate = true;
      }
      if (shadow.mapPass === null) {
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
      }
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      renderer.setRenderTarget(shadow.mapPass);
      renderer.clear();
      renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
      renderer.setRenderTarget(shadow.map);
      renderer.clear();
      renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, material, light, type) {
      let result = null;
      const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
      if (customMaterial !== void 0) {
        result = customMaterial;
      } else {
        result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
        if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
          const keyA = result.uuid, keyB = material.uuid;
          let materialsForVariant = _materialCache[keyA];
          if (materialsForVariant === void 0) {
            materialsForVariant = {};
            _materialCache[keyA] = materialsForVariant;
          }
          let cachedMaterial = materialsForVariant[keyB];
          if (cachedMaterial === void 0) {
            cachedMaterial = result.clone();
            materialsForVariant[keyB] = cachedMaterial;
            material.addEventListener("dispose", onMaterialDispose);
          }
          result = cachedMaterial;
        }
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.alphaMap = material.alphaMap;
      result.alphaTest = material.alphaTest;
      result.map = material.map;
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.displacementMap = material.displacementMap;
      result.displacementScale = material.displacementScale;
      result.displacementBias = material.displacementBias;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        const materialProperties = renderer.properties.get(result);
        materialProperties.light = light;
      }
      return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
      if (object.visible === false) return;
      const visible = object.layers.test(camera.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k2 = 0, kl = groups.length; k2 < kl; k2++) {
              const group = groups[k2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
                object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
                renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, material, light, type);
            object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
            renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
            object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
          }
        }
      }
      const children2 = object.children;
      for (let i4 = 0, l4 = children2.length; i4 < l4; i4++) {
        renderObject(children2[i4], camera, shadowCamera, light, type);
      }
    }
    function onMaterialDispose(event2) {
      const material = event2.target;
      material.removeEventListener("dispose", onMaterialDispose);
      for (const id in _materialCache) {
        const cache = _materialCache[id];
        const uuid = event2.target.uuid;
        if (uuid in cache) {
          const shadowMaterial = cache[uuid];
          shadowMaterial.dispose();
          delete cache[uuid];
        }
      }
    }
  }
  function WebGLState(gl2) {
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl2.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r3, g2, b2, a3, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r3 *= a3;
            g2 *= a3;
            b2 *= a3;
          }
          color.set(r3, g2, b2, a3);
          if (currentColorClear.equals(color) === false) {
            gl2.clearColor(r3, g2, b2, a3);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(gl2.DEPTH_TEST);
          } else {
            disable(gl2.DEPTH_TEST);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl2.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl2.depthFunc(gl2.NEVER);
                break;
              case AlwaysDepth:
                gl2.depthFunc(gl2.ALWAYS);
                break;
              case LessDepth:
                gl2.depthFunc(gl2.LESS);
                break;
              case LessEqualDepth:
                gl2.depthFunc(gl2.LEQUAL);
                break;
              case EqualDepth:
                gl2.depthFunc(gl2.EQUAL);
                break;
              case GreaterEqualDepth:
                gl2.depthFunc(gl2.GEQUAL);
                break;
              case GreaterDepth:
                gl2.depthFunc(gl2.GREATER);
                break;
              case NotEqualDepth:
                gl2.depthFunc(gl2.NOTEQUAL);
                break;
              default:
                gl2.depthFunc(gl2.LEQUAL);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl2.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(gl2.STENCIL_TEST);
            } else {
              disable(gl2.STENCIL_TEST);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl2.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl2.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl2.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl2.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    const uboBindings = /* @__PURE__ */ new WeakMap();
    const uboProgramMap = /* @__PURE__ */ new WeakMap();
    let enabledCapabilities = {};
    let currentBoundFramebuffers = {};
    let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    let defaultDrawbuffers = [];
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentBlendColor = new Color(0, 0, 0);
    let currentBlendAlpha = 0;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl2.getParameter(gl2.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl2.getParameter(gl2.VERSION);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl2.getParameter(gl2.SCISSOR_BOX);
    const viewportParam = gl2.getParameter(gl2.VIEWPORT);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type, target, count, dimensions) {
      const data = new Uint8Array(4);
      const texture = gl2.createTexture();
      gl2.bindTexture(type, texture);
      gl2.texParameteri(type, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
      gl2.texParameteri(type, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
      for (let i4 = 0; i4 < count; i4++) {
        if (type === gl2.TEXTURE_3D || type === gl2.TEXTURE_2D_ARRAY) {
          gl2.texImage3D(target, 0, gl2.RGBA, 1, 1, dimensions, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
        } else {
          gl2.texImage2D(target + i4, 0, gl2.RGBA, 1, 1, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
        }
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[gl2.TEXTURE_2D] = createTexture(gl2.TEXTURE_2D, gl2.TEXTURE_2D, 1);
    emptyTextures[gl2.TEXTURE_CUBE_MAP] = createTexture(gl2.TEXTURE_CUBE_MAP, gl2.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    emptyTextures[gl2.TEXTURE_2D_ARRAY] = createTexture(gl2.TEXTURE_2D_ARRAY, gl2.TEXTURE_2D_ARRAY, 1, 1);
    emptyTextures[gl2.TEXTURE_3D] = createTexture(gl2.TEXTURE_3D, gl2.TEXTURE_3D, 1, 1);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(gl2.DEPTH_TEST);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(gl2.CULL_FACE);
    setBlending(NoBlending);
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl2.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl2.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl2.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
        if (target === gl2.DRAW_FRAMEBUFFER) {
          currentBoundFramebuffers[gl2.FRAMEBUFFER] = framebuffer;
        }
        if (target === gl2.FRAMEBUFFER) {
          currentBoundFramebuffers[gl2.DRAW_FRAMEBUFFER] = framebuffer;
        }
        return true;
      }
      return false;
    }
    function drawBuffers(renderTarget, framebuffer) {
      let drawBuffers2 = defaultDrawbuffers;
      let needsUpdate = false;
      if (renderTarget) {
        drawBuffers2 = currentDrawbuffers.get(framebuffer);
        if (drawBuffers2 === void 0) {
          drawBuffers2 = [];
          currentDrawbuffers.set(framebuffer, drawBuffers2);
        }
        const textures = renderTarget.textures;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl2.COLOR_ATTACHMENT0) {
          for (let i4 = 0, il = textures.length; i4 < il; i4++) {
            drawBuffers2[i4] = gl2.COLOR_ATTACHMENT0 + i4;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== gl2.BACK) {
          drawBuffers2[0] = gl2.BACK;
          needsUpdate = true;
        }
      }
      if (needsUpdate) {
        gl2.drawBuffers(drawBuffers2);
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl2.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: gl2.FUNC_ADD,
      [SubtractEquation]: gl2.FUNC_SUBTRACT,
      [ReverseSubtractEquation]: gl2.FUNC_REVERSE_SUBTRACT
    };
    equationToGL[MinEquation] = gl2.MIN;
    equationToGL[MaxEquation] = gl2.MAX;
    const factorToGL = {
      [ZeroFactor]: gl2.ZERO,
      [OneFactor]: gl2.ONE,
      [SrcColorFactor]: gl2.SRC_COLOR,
      [SrcAlphaFactor]: gl2.SRC_ALPHA,
      [SrcAlphaSaturateFactor]: gl2.SRC_ALPHA_SATURATE,
      [DstColorFactor]: gl2.DST_COLOR,
      [DstAlphaFactor]: gl2.DST_ALPHA,
      [OneMinusSrcColorFactor]: gl2.ONE_MINUS_SRC_COLOR,
      [OneMinusSrcAlphaFactor]: gl2.ONE_MINUS_SRC_ALPHA,
      [OneMinusDstColorFactor]: gl2.ONE_MINUS_DST_COLOR,
      [OneMinusDstAlphaFactor]: gl2.ONE_MINUS_DST_ALPHA,
      [ConstantColorFactor]: gl2.CONSTANT_COLOR,
      [OneMinusConstantColorFactor]: gl2.ONE_MINUS_CONSTANT_COLOR,
      [ConstantAlphaFactor]: gl2.CONSTANT_ALPHA,
      [OneMinusConstantAlphaFactor]: gl2.ONE_MINUS_CONSTANT_ALPHA
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(gl2.BLEND);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(gl2.BLEND);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl2.blendEquation(gl2.FUNC_ADD);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl2.blendFuncSeparate(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
                break;
              case AdditiveBlending:
                gl2.blendFunc(gl2.ONE, gl2.ONE);
                break;
              case SubtractiveBlending:
                gl2.blendFuncSeparate(gl2.ZERO, gl2.ONE_MINUS_SRC_COLOR, gl2.ZERO, gl2.ONE);
                break;
              case MultiplyBlending:
                gl2.blendFuncSeparate(gl2.ZERO, gl2.SRC_COLOR, gl2.ZERO, gl2.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl2.blendFuncSeparate(gl2.SRC_ALPHA, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
                break;
              case AdditiveBlending:
                gl2.blendFunc(gl2.SRC_ALPHA, gl2.ONE);
                break;
              case SubtractiveBlending:
                gl2.blendFuncSeparate(gl2.ZERO, gl2.ONE_MINUS_SRC_COLOR, gl2.ZERO, gl2.ONE);
                break;
              case MultiplyBlending:
                gl2.blendFunc(gl2.ZERO, gl2.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlendColor.set(0, 0, 0);
          currentBlendAlpha = 0;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl2.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl2.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
        gl2.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
        currentBlendColor.copy(blendColor);
        currentBlendAlpha = blendAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = false;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(gl2.CULL_FACE) : enable(gl2.CULL_FACE);
      let flipSided = material.side === BackSide;
      if (frontFaceCW) flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(gl2.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl2.SAMPLE_ALPHA_TO_COVERAGE);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl2.frontFace(gl2.CW);
        } else {
          gl2.frontFace(gl2.CCW);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(gl2.CULL_FACE);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl2.cullFace(gl2.BACK);
          } else if (cullFace === CullFaceFront) {
            gl2.cullFace(gl2.FRONT);
          } else {
            gl2.cullFace(gl2.FRONT_AND_BACK);
          }
        }
      } else {
        disable(gl2.CULL_FACE);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width) {
      if (width !== currentLineWidth) {
        if (lineWidthAvailable) gl2.lineWidth(width);
        currentLineWidth = width;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(gl2.POLYGON_OFFSET_FILL);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl2.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(gl2.POLYGON_OFFSET_FILL);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(gl2.SCISSOR_TEST);
      } else {
        disable(gl2.SCISSOR_TEST);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0) webglSlot = gl2.TEXTURE0 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl2.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture, webglSlot) {
      if (webglSlot === void 0) {
        if (currentTextureSlot === null) {
          webglSlot = gl2.TEXTURE0 + maxTextures - 1;
        } else {
          webglSlot = currentTextureSlot;
        }
      }
      let boundTexture = currentBoundTextures[webglSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[webglSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        if (currentTextureSlot !== webglSlot) {
          gl2.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
        gl2.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl2.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl2.compressedTexImage2D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexImage3D() {
      try {
        gl2.compressedTexImage3D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage2D() {
      try {
        gl2.texSubImage2D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texSubImage3D() {
      try {
        gl2.texSubImage3D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage2D() {
      try {
        gl2.compressedTexSubImage2D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function compressedTexSubImage3D() {
      try {
        gl2.compressedTexSubImage3D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage2D() {
      try {
        gl2.texStorage2D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texStorage3D() {
      try {
        gl2.texStorage3D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl2.texImage2D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl2.texImage3D.apply(gl2, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl2.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl2.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function updateUBOMapping(uniformsGroup, program) {
      let mapping = uboProgramMap.get(program);
      if (mapping === void 0) {
        mapping = /* @__PURE__ */ new WeakMap();
        uboProgramMap.set(program, mapping);
      }
      let blockIndex = mapping.get(uniformsGroup);
      if (blockIndex === void 0) {
        blockIndex = gl2.getUniformBlockIndex(program, uniformsGroup.name);
        mapping.set(uniformsGroup, blockIndex);
      }
    }
    function uniformBlockBinding(uniformsGroup, program) {
      const mapping = uboProgramMap.get(program);
      const blockIndex = mapping.get(uniformsGroup);
      if (uboBindings.get(program) !== blockIndex) {
        gl2.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
        uboBindings.set(program, blockIndex);
      }
    }
    function reset() {
      gl2.disable(gl2.BLEND);
      gl2.disable(gl2.CULL_FACE);
      gl2.disable(gl2.DEPTH_TEST);
      gl2.disable(gl2.POLYGON_OFFSET_FILL);
      gl2.disable(gl2.SCISSOR_TEST);
      gl2.disable(gl2.STENCIL_TEST);
      gl2.disable(gl2.SAMPLE_ALPHA_TO_COVERAGE);
      gl2.blendEquation(gl2.FUNC_ADD);
      gl2.blendFunc(gl2.ONE, gl2.ZERO);
      gl2.blendFuncSeparate(gl2.ONE, gl2.ZERO, gl2.ONE, gl2.ZERO);
      gl2.blendColor(0, 0, 0, 0);
      gl2.colorMask(true, true, true, true);
      gl2.clearColor(0, 0, 0, 0);
      gl2.depthMask(true);
      gl2.depthFunc(gl2.LESS);
      gl2.clearDepth(1);
      gl2.stencilMask(4294967295);
      gl2.stencilFunc(gl2.ALWAYS, 0, 4294967295);
      gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.KEEP);
      gl2.clearStencil(0);
      gl2.cullFace(gl2.BACK);
      gl2.frontFace(gl2.CCW);
      gl2.polygonOffset(0, 0);
      gl2.activeTexture(gl2.TEXTURE0);
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
      gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, null);
      gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, null);
      gl2.useProgram(null);
      gl2.lineWidth(1);
      gl2.scissor(0, 0, gl2.canvas.width, gl2.canvas.height);
      gl2.viewport(0, 0, gl2.canvas.width, gl2.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentBoundFramebuffers = {};
      currentDrawbuffers = /* @__PURE__ */ new WeakMap();
      defaultDrawbuffers = [];
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentBlendColor = new Color(0, 0, 0);
      currentBlendAlpha = 0;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl2.canvas.width, gl2.canvas.height);
      currentViewport.set(0, 0, gl2.canvas.width, gl2.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      drawBuffers,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      compressedTexImage3D,
      texImage2D,
      texImage3D,
      updateUBOMapping,
      uniformBlockBinding,
      texStorage2D,
      texStorage3D,
      texSubImage2D,
      texSubImage3D,
      compressedTexSubImage2D,
      compressedTexSubImage3D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
    const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
    const _imageDimensions = new Vector2();
    const _videoTextures = /* @__PURE__ */ new WeakMap();
    let _canvas2;
    const _sources = /* @__PURE__ */ new WeakMap();
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width, height) {
      return useOffscreenCanvas ? (
        // eslint-disable-next-line compat/compat
        new OffscreenCanvas(width, height)
      ) : createElementNS("canvas");
    }
    function resizeImage(image2, needsNewCanvas, maxSize) {
      let scale = 1;
      const dimensions = getDimensions(image2);
      if (dimensions.width > maxSize || dimensions.height > maxSize) {
        scale = maxSize / Math.max(dimensions.width, dimensions.height);
      }
      if (scale < 1) {
        if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image2 instanceof VideoFrame) {
          const width = Math.floor(scale * dimensions.width);
          const height = Math.floor(scale * dimensions.height);
          if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
          const canvas2 = needsNewCanvas ? createCanvas(width, height) : _canvas2;
          canvas2.width = width;
          canvas2.height = height;
          const context3 = canvas2.getContext("2d");
          context3.drawImage(image2, 0, 0, width, height);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
          return canvas2;
        } else {
          if ("data" in image2) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
          }
          return image2;
        }
      }
      return image2;
    }
    function textureNeedsGenerateMipmaps(texture) {
      return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target) {
      _gl.generateMipmap(target);
    }
    function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === _gl.RED) {
        if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
        if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
        if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
      }
      if (glFormat === _gl.RED_INTEGER) {
        if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
        if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
        if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
        if (glType === _gl.BYTE) internalFormat = _gl.R8I;
        if (glType === _gl.SHORT) internalFormat = _gl.R16I;
        if (glType === _gl.INT) internalFormat = _gl.R32I;
      }
      if (glFormat === _gl.RG) {
        if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
        if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
        if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
      }
      if (glFormat === _gl.RG_INTEGER) {
        if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
        if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
        if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
        if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
        if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
        if (glType === _gl.INT) internalFormat = _gl.RG32I;
      }
      if (glFormat === _gl.RGB) {
        if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
      }
      if (glFormat === _gl.RGBA) {
        const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
        if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
        if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
        if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
        if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
        if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
      }
      if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function getInternalDepthFormat(useStencil, depthType) {
      let glInternalFormat;
      if (useStencil) {
        if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
          glInternalFormat = _gl.DEPTH24_STENCIL8;
        } else if (depthType === FloatType) {
          glInternalFormat = _gl.DEPTH32F_STENCIL8;
        } else if (depthType === UnsignedShortType) {
          glInternalFormat = _gl.DEPTH24_STENCIL8;
          console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
        }
      } else {
        if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
          glInternalFormat = _gl.DEPTH_COMPONENT24;
        } else if (depthType === FloatType) {
          glInternalFormat = _gl.DEPTH_COMPONENT32F;
        } else if (depthType === UnsignedShortType) {
          glInternalFormat = _gl.DEPTH_COMPONENT16;
        }
      }
      return glInternalFormat;
    }
    function getMipLevels(texture, image2) {
      if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        return Math.log2(Math.max(image2.width, image2.height)) + 1;
      } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
        return texture.mipmaps.length;
      } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
        return image2.mipmaps.length;
      } else {
        return 1;
      }
    }
    function onTextureDispose(event2) {
      const texture = event2.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
    }
    function onRenderTargetDispose(event2) {
      const renderTarget = event2.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0) return;
      const source = texture.source;
      const webglTextures = _sources.get(source);
      if (webglTextures) {
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        webglTexture.usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
        if (Object.keys(webglTextures).length === 0) {
          _sources.delete(source);
        }
      }
      properties.remove(texture);
    }
    function deleteTexture(texture) {
      const textureProperties = properties.get(texture);
      _gl.deleteTexture(textureProperties.__webglTexture);
      const source = texture.source;
      const webglTextures = _sources.get(source);
      delete webglTextures[textureProperties.__cacheKey];
      info.memory.textures--;
    }
    function deallocateRenderTarget(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i4 = 0; i4 < 6; i4++) {
          if (Array.isArray(renderTargetProperties.__webglFramebuffer[i4])) {
            for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i4].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i4][level]);
          } else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i4]);
          }
          if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i4]);
        }
      } else {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        }
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer) {
          for (let i4 = 0; i4 < renderTargetProperties.__webglColorRenderbuffer.length; i4++) {
            if (renderTargetProperties.__webglColorRenderbuffer[i4]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i4]);
          }
        }
        if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      const textures = renderTarget.textures;
      for (let i4 = 0, il = textures.length; i4 < il; i4++) {
        const attachmentProperties = properties.get(textures[i4]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(textures[i4]);
      }
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= capabilities.maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function getTextureCacheKey(texture) {
      const array = [];
      array.push(texture.wrapS);
      array.push(texture.wrapT);
      array.push(texture.wrapR || 0);
      array.push(texture.magFilter);
      array.push(texture.minFilter);
      array.push(texture.anisotropy);
      array.push(texture.internalFormat);
      array.push(texture.format);
      array.push(texture.type);
      array.push(texture.generateMipmaps);
      array.push(texture.premultiplyAlpha);
      array.push(texture.flipY);
      array.push(texture.unpackAlignment);
      array.push(texture.colorSpace);
      return array.join();
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture) updateVideoTexture(texture);
      if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
        const image2 = texture.image;
        if (image2 === null) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        } else if (image2.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    }
    const wrappingToGL = {
      [RepeatWrapping]: _gl.REPEAT,
      [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
    };
    const filterToGL = {
      [NearestFilter]: _gl.NEAREST,
      [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: _gl.LINEAR,
      [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
    };
    const compareToGL = {
      [NeverCompare]: _gl.NEVER,
      [AlwaysCompare]: _gl.ALWAYS,
      [LessCompare]: _gl.LESS,
      [LessEqualCompare]: _gl.LEQUAL,
      [EqualCompare]: _gl.EQUAL,
      [GreaterEqualCompare]: _gl.GEQUAL,
      [GreaterCompare]: _gl.GREATER,
      [NotEqualCompare]: _gl.NOTEQUAL
    };
    function setTextureParameters(textureType, texture) {
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
        console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
      if (texture.compareFunction) {
        _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
        _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        if (texture.magFilter === NearestFilter) return;
        if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          const extension = extensions.get("EXT_texture_filter_anisotropic");
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      let forceUpload = false;
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
      }
      const source = texture.source;
      let webglTextures = _sources.get(source);
      if (webglTextures === void 0) {
        webglTextures = {};
        _sources.set(source, webglTextures);
      }
      const textureCacheKey = getTextureCacheKey(texture);
      if (textureCacheKey !== textureProperties.__cacheKey) {
        if (webglTextures[textureCacheKey] === void 0) {
          webglTextures[textureCacheKey] = {
            texture: _gl.createTexture(),
            usedTimes: 0
          };
          info.memory.textures++;
          forceUpload = true;
        }
        webglTextures[textureCacheKey].usedTimes++;
        const webglTexture = webglTextures[textureProperties.__cacheKey];
        if (webglTexture !== void 0) {
          webglTextures[textureProperties.__cacheKey].usedTimes--;
          if (webglTexture.usedTimes === 0) {
            deleteTexture(texture);
          }
        }
        textureProperties.__cacheKey = textureCacheKey;
        textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
      }
      return forceUpload;
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = _gl.TEXTURE_2D;
      if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
      if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
      const sourceProperties = properties.get(source);
      if (source.version !== sourceProperties.__version || forceUpload === true) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
        const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
        const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
        let image2 = resizeImage(texture.image, false, capabilities.maxTextureSize);
        image2 = verifyColorSpace(texture, image2);
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
        setTextureParameters(textureType, texture);
        let mipmap;
        const mipmaps = texture.mipmaps;
        const useTexStorage = texture.isVideoTexture !== true;
        const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
        const dataReady = source.dataReady;
        const levels = getMipLevels(texture, image2);
        if (texture.isDepthTexture) {
          glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
          if (allocateMemory) {
            if (useTexStorage) {
              state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image2.width, image2.height);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, null);
            }
          }
        } else if (texture.isDataTexture) {
          if (mipmaps.length > 0) {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i4 = 0, il = mipmaps.length; i4 < il; i4++) {
              mipmap = mipmaps[i4];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i4, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i4, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image2.width, image2.height);
              }
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image2.width, image2.height, glFormat, glType, image2.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, image2.data);
            }
          }
        } else if (texture.isCompressedTexture) {
          if (texture.isCompressedArrayTexture) {
            if (useTexStorage && allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image2.depth);
            }
            for (let i4 = 0, il = mipmaps.length; i4 < il; i4++) {
              mipmap = mipmaps[i4];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    if (dataReady) {
                      if (texture.layerUpdates.size > 0) {
                        for (const layerIndex of texture.layerUpdates) {
                          const layerSize = mipmap.width * mipmap.height;
                          state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i4, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, mipmap.data.slice(layerSize * layerIndex, layerSize * (layerIndex + 1)), 0, 0);
                        }
                        texture.clearLayerUpdates();
                      } else {
                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i4, 0, 0, 0, mipmap.width, mipmap.height, image2.depth, glFormat, mipmap.data, 0, 0);
                      }
                    }
                  } else {
                    state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i4, glInternalFormat, mipmap.width, mipmap.height, image2.depth, 0, mipmap.data, 0, 0);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i4, 0, 0, 0, mipmap.width, mipmap.height, image2.depth, glFormat, glType, mipmap.data);
                  }
                } else {
                  state.texImage3D(_gl.TEXTURE_2D_ARRAY, i4, glInternalFormat, mipmap.width, mipmap.height, image2.depth, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          } else {
            if (useTexStorage && allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
            }
            for (let i4 = 0, il = mipmaps.length; i4 < il; i4++) {
              mipmap = mipmaps[i4];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    if (dataReady) {
                      state.compressedTexSubImage2D(_gl.TEXTURE_2D, i4, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                    }
                  } else {
                    state.compressedTexImage2D(_gl.TEXTURE_2D, i4, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                }
              } else {
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage2D(_gl.TEXTURE_2D, i4, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_2D, i4, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else if (texture.isDataArrayTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image2.width, image2.height, image2.depth);
            }
            if (dataReady) {
              if (texture.layerUpdates.size > 0) {
                let texelSize;
                switch (glType) {
                  case _gl.UNSIGNED_BYTE:
                    switch (glFormat) {
                      case _gl.ALPHA:
                        texelSize = 1;
                        break;
                      case _gl.LUMINANCE:
                        texelSize = 1;
                        break;
                      case _gl.LUMINANCE_ALPHA:
                        texelSize = 2;
                        break;
                      case _gl.RGB:
                        texelSize = 3;
                        break;
                      case _gl.RGBA:
                        texelSize = 4;
                        break;
                      default:
                        throw new Error(`Unknown texel size for format ${glFormat}.`);
                    }
                    break;
                  case _gl.UNSIGNED_SHORT_4_4_4_4:
                  case _gl.UNSIGNED_SHORT_5_5_5_1:
                  case _gl.UNSIGNED_SHORT_5_6_5:
                    texelSize = 1;
                    break;
                  default:
                    throw new Error(`Unknown texel size for type ${glType}.`);
                }
                const layerSize = image2.width * image2.height * texelSize;
                for (const layerIndex of texture.layerUpdates) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image2.width, image2.height, 1, glFormat, glType, image2.data.slice(layerSize * layerIndex, layerSize * (layerIndex + 1)));
                }
                texture.clearLayerUpdates();
              } else {
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image2.width, image2.height, image2.depth, glFormat, glType, image2.data);
              }
            }
          } else {
            state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
          }
        } else if (texture.isData3DTexture) {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image2.width, image2.height, image2.depth);
            }
            if (dataReady) {
              state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image2.width, image2.height, image2.depth, glFormat, glType, image2.data);
            }
          } else {
            state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
          }
        } else if (texture.isFramebufferTexture) {
          if (allocateMemory) {
            if (useTexStorage) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image2.width, image2.height);
            } else {
              let width = image2.width, height = image2.height;
              for (let i4 = 0; i4 < levels; i4++) {
                state.texImage2D(_gl.TEXTURE_2D, i4, glInternalFormat, width, height, 0, glFormat, glType, null);
                width >>= 1;
                height >>= 1;
              }
            }
          }
        } else {
          if (mipmaps.length > 0) {
            if (useTexStorage && allocateMemory) {
              const dimensions = getDimensions(mipmaps[0]);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
            }
            for (let i4 = 0, il = mipmaps.length; i4 < il; i4++) {
              mipmap = mipmaps[i4];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i4, 0, 0, glFormat, glType, mipmap);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i4, glInternalFormat, glFormat, glType, mipmap);
              }
            }
            texture.generateMipmaps = false;
          } else {
            if (useTexStorage) {
              if (allocateMemory) {
                const dimensions = getDimensions(image2);
                state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
              }
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image2);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image2);
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture)) {
          generateMipmap(textureType);
        }
        sourceProperties.__version = source.version;
        if (texture.onUpdate) texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6) return;
      const forceUpload = initTexture(textureProperties, texture);
      const source = texture.source;
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
      const sourceProperties = properties.get(source);
      if (source.version !== sourceProperties.__version || forceUpload === true) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
        const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
        const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
        const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for (let i4 = 0; i4 < 6; i4++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i4] = resizeImage(texture.image[i4], true, capabilities.maxCubemapSize);
          } else {
            cubeImage[i4] = isDataTexture ? texture.image[i4].image : texture.image[i4];
          }
          cubeImage[i4] = verifyColorSpace(texture, cubeImage[i4]);
        }
        const image2 = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const useTexStorage = texture.isVideoTexture !== true;
        const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
        const dataReady = source.dataReady;
        let levels = getMipLevels(texture, image2);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
        let mipmaps;
        if (isCompressed) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image2.width, image2.height);
          }
          for (let i4 = 0; i4 < 6; i4++) {
            mipmaps = cubeImage[i4].mipmaps;
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              if (texture.format !== RGBAFormat) {
                if (glFormat !== null) {
                  if (useTexStorage) {
                    if (dataReady) {
                      state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, j2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                    }
                  } else {
                    state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  }
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, j2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
        } else {
          mipmaps = texture.mipmaps;
          if (useTexStorage && allocateMemory) {
            if (mipmaps.length > 0) levels++;
            const dimensions = getDimensions(cubeImage[0]);
            state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (let i4 = 0; i4 < 6; i4++) {
            if (isDataTexture) {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, 0, 0, 0, cubeImage[i4].width, cubeImage[i4].height, glFormat, glType, cubeImage[i4].data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, 0, glInternalFormat, cubeImage[i4].width, cubeImage[i4].height, 0, glFormat, glType, cubeImage[i4].data);
              }
              for (let j2 = 0; j2 < mipmaps.length; j2++) {
                const mipmap = mipmaps[j2];
                const mipmapImage = mipmap.image[i4].image;
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, j2 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, 0, 0, 0, glFormat, glType, cubeImage[i4]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, 0, glInternalFormat, glFormat, glType, cubeImage[i4]);
              }
              for (let j2 = 0; j2 < mipmaps.length; j2++) {
                const mipmap = mipmaps[j2];
                if (useTexStorage) {
                  if (dataReady) {
                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, j2 + 1, 0, 0, glFormat, glType, mipmap.image[i4]);
                  }
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i4]);
                }
              }
            }
          }
        }
        if (textureNeedsGenerateMipmaps(texture)) {
          generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        sourceProperties.__version = source.version;
        if (texture.onUpdate) texture.onUpdate(texture);
      }
      textureProperties.__version = texture.version;
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const renderTargetProperties = properties.get(renderTarget);
      if (!renderTargetProperties.__hasExternalTextures) {
        const width = Math.max(1, renderTarget.width >> level);
        const height = Math.max(1, renderTarget.height >> level);
        if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
          state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
        } else {
          state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
        }
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
      } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level);
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
      if (renderTarget.depthBuffer) {
        const depthTexture = renderTarget.depthTexture;
        const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
        const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
        const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const samples = getRenderTargetSamples(renderTarget);
        const isUseMultisampledRTT = useMultisampledRTT(renderTarget);
        if (isUseMultisampledRTT) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (isMultisample) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
      } else {
        const textures = renderTarget.textures;
        for (let i4 = 0; i4 < textures.length; i4++) {
          const texture = textures[i4];
          const glFormat = utils.convert(texture.format, texture.colorSpace);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
          const samples = getRenderTargetSamples(renderTarget);
          if (isMultisample && useMultisampledRTT(renderTarget) === false) {
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else if (useMultisampledRTT(renderTarget)) {
            multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          } else {
            _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
          }
        }
      }
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      const samples = getRenderTargetSamples(renderTarget);
      if (renderTarget.depthTexture.format === DepthFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        }
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
        } else {
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        }
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
        if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i4 = 0; i4 < 6; i4++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i4]);
            renderTargetProperties.__webglDepthbuffer[i4] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i4], renderTarget, false);
          }
        } else {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      state.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function rebindTextures(renderTarget, colorTexture, depthTexture) {
      const renderTargetProperties = properties.get(renderTarget);
      if (colorTexture !== void 0) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
      }
      if (depthTexture !== void 0) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      const textures = renderTarget.textures;
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultipleRenderTargets = textures.length > 1;
      if (!isMultipleRenderTargets) {
        if (textureProperties.__webglTexture === void 0) {
          textureProperties.__webglTexture = _gl.createTexture();
        }
        textureProperties.__version = texture.version;
        info.memory.textures++;
      }
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i4 = 0; i4 < 6; i4++) {
          if (texture.mipmaps && texture.mipmaps.length > 0) {
            renderTargetProperties.__webglFramebuffer[i4] = [];
            for (let level = 0; level < texture.mipmaps.length; level++) {
              renderTargetProperties.__webglFramebuffer[i4][level] = _gl.createFramebuffer();
            }
          } else {
            renderTargetProperties.__webglFramebuffer[i4] = _gl.createFramebuffer();
          }
        }
      } else {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        }
        if (isMultipleRenderTargets) {
          for (let i4 = 0, il = textures.length; i4 < il; i4++) {
            const attachmentProperties = properties.get(textures[i4]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        }
        if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = [];
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          for (let i4 = 0; i4 < textures.length; i4++) {
            const texture2 = textures[i4];
            renderTargetProperties.__webglColorRenderbuffer[i4] = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i4]);
            const glFormat = utils.convert(texture2.format, texture2.colorSpace);
            const glType = utils.convert(texture2.type);
            const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i4, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i4]);
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
      }
      if (isCube) {
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
        for (let i4 = 0; i4 < 6; i4++) {
          if (texture.mipmaps && texture.mipmaps.length > 0) {
            for (let level = 0; level < texture.mipmaps.length; level++) {
              setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i4][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, level);
            }
          } else {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i4], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i4, 0);
          }
        }
        if (textureNeedsGenerateMipmaps(texture)) {
          generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        state.unbindTexture();
      } else if (isMultipleRenderTargets) {
        for (let i4 = 0, il = textures.length; i4 < il; i4++) {
          const attachment = textures[i4];
          const attachmentProperties = properties.get(attachment);
          state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
          setTextureParameters(_gl.TEXTURE_2D, attachment);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i4, _gl.TEXTURE_2D, 0);
          if (textureNeedsGenerateMipmaps(attachment)) {
            generateMipmap(_gl.TEXTURE_2D);
          }
        }
        state.unbindTexture();
      } else {
        let glTextureType = _gl.TEXTURE_2D;
        if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
        }
        state.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture);
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
        }
        if (textureNeedsGenerateMipmaps(texture)) {
          generateMipmap(glTextureType);
        }
        state.unbindTexture();
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const textures = renderTarget.textures;
      for (let i4 = 0, il = textures.length; i4 < il; i4++) {
        const texture = textures[i4];
        if (textureNeedsGenerateMipmaps(texture)) {
          const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
          const webglTexture = properties.get(texture).__webglTexture;
          state.bindTexture(target, webglTexture);
          generateMipmap(target);
          state.unbindTexture();
        }
      }
    }
    const invalidationArrayRead = [];
    const invalidationArrayDraw = [];
    function updateMultisampleRenderTarget(renderTarget) {
      if (renderTarget.samples > 0) {
        if (useMultisampledRTT(renderTarget) === false) {
          const textures = renderTarget.textures;
          const width = renderTarget.width;
          const height = renderTarget.height;
          let mask = _gl.COLOR_BUFFER_BIT;
          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          const renderTargetProperties = properties.get(renderTarget);
          const isMultipleRenderTargets = textures.length > 1;
          if (isMultipleRenderTargets) {
            for (let i4 = 0; i4 < textures.length; i4++) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i4, _gl.RENDERBUFFER, null);
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i4, _gl.TEXTURE_2D, null, 0);
            }
          }
          state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          for (let i4 = 0; i4 < textures.length; i4++) {
            if (renderTarget.resolveDepthBuffer) {
              if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
              if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
            }
            if (isMultipleRenderTargets) {
              _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i4]);
              const webglTexture = properties.get(textures[i4]).__webglTexture;
              _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
            }
            _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
            if (supportsInvalidateFramebuffer === true) {
              invalidationArrayRead.length = 0;
              invalidationArrayDraw.length = 0;
              invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i4);
              if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
                invalidationArrayRead.push(depthStyle);
                invalidationArrayDraw.push(depthStyle);
                _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
              }
              _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
            }
          }
          state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
          if (isMultipleRenderTargets) {
            for (let i4 = 0; i4 < textures.length; i4++) {
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
              _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i4, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i4]);
              const webglTexture = properties.get(textures[i4]).__webglTexture;
              state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
              _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i4, _gl.TEXTURE_2D, webglTexture, 0);
            }
          }
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        } else {
          if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
            const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
          }
        }
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return Math.min(capabilities.maxSamples, renderTarget.samples);
    }
    function useMultisampledRTT(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    function verifyColorSpace(texture, image2) {
      const colorSpace = texture.colorSpace;
      const format = texture.format;
      const type = texture.type;
      if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image2;
      if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
        if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        } else {
          console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
        }
      }
      return image2;
    }
    function getDimensions(image2) {
      if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement) {
        _imageDimensions.width = image2.naturalWidth || image2.width;
        _imageDimensions.height = image2.naturalHeight || image2.height;
      } else if (typeof VideoFrame !== "undefined" && image2 instanceof VideoFrame) {
        _imageDimensions.width = image2.displayWidth;
        _imageDimensions.height = image2.displayHeight;
      } else {
        _imageDimensions.width = image2.width;
        _imageDimensions.height = image2.height;
      }
      return _imageDimensions;
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.rebindTextures = rebindTextures;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    this.setupFrameBufferTexture = setupFrameBufferTexture;
    this.useMultisampledRTT = useMultisampledRTT;
  }
  function WebGLUtils(gl2, extensions) {
    function convert(p2, colorSpace = NoColorSpace) {
      let extension;
      const transfer = ColorManagement.getTransfer(colorSpace);
      if (p2 === UnsignedByteType) return gl2.UNSIGNED_BYTE;
      if (p2 === UnsignedShort4444Type) return gl2.UNSIGNED_SHORT_4_4_4_4;
      if (p2 === UnsignedShort5551Type) return gl2.UNSIGNED_SHORT_5_5_5_1;
      if (p2 === UnsignedInt5999Type) return gl2.UNSIGNED_INT_5_9_9_9_REV;
      if (p2 === ByteType) return gl2.BYTE;
      if (p2 === ShortType) return gl2.SHORT;
      if (p2 === UnsignedShortType) return gl2.UNSIGNED_SHORT;
      if (p2 === IntType) return gl2.INT;
      if (p2 === UnsignedIntType) return gl2.UNSIGNED_INT;
      if (p2 === FloatType) return gl2.FLOAT;
      if (p2 === HalfFloatType) return gl2.HALF_FLOAT;
      if (p2 === AlphaFormat) return gl2.ALPHA;
      if (p2 === RGBFormat) return gl2.RGB;
      if (p2 === RGBAFormat) return gl2.RGBA;
      if (p2 === LuminanceFormat) return gl2.LUMINANCE;
      if (p2 === LuminanceAlphaFormat) return gl2.LUMINANCE_ALPHA;
      if (p2 === DepthFormat) return gl2.DEPTH_COMPONENT;
      if (p2 === DepthStencilFormat) return gl2.DEPTH_STENCIL;
      if (p2 === RedFormat) return gl2.RED;
      if (p2 === RedIntegerFormat) return gl2.RED_INTEGER;
      if (p2 === RGFormat) return gl2.RG;
      if (p2 === RGIntegerFormat) return gl2.RG_INTEGER;
      if (p2 === RGBAIntegerFormat) return gl2.RGBA_INTEGER;
      if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
        if (transfer === SRGBTransfer) {
          extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
          if (extension !== null) {
            if (p2 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (p2 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (p2 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (p2 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        } else {
          extension = extensions.get("WEBGL_compressed_texture_s3tc");
          if (extension !== null) {
            if (p2 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (p2 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (p2 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (p2 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else {
            return null;
          }
        }
      }
      if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p2 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p2 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p2 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p2 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p2 === RGB_ETC1_Format || p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p2 === RGB_ETC1_Format || p2 === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
          if (p2 === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        } else {
          return null;
        }
      }
      if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          if (p2 === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (p2 === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (p2 === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (p2 === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (p2 === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (p2 === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (p2 === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (p2 === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (p2 === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (p2 === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (p2 === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (p2 === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (p2 === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (p2 === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else {
          return null;
        }
      }
      if (p2 === RGBA_BPTC_Format || p2 === RGB_BPTC_SIGNED_Format || p2 === RGB_BPTC_UNSIGNED_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          if (p2 === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          if (p2 === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
          if (p2 === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
        } else {
          return null;
        }
      }
      if (p2 === RED_RGTC1_Format || p2 === SIGNED_RED_RGTC1_Format || p2 === RED_GREEN_RGTC2_Format || p2 === SIGNED_RED_GREEN_RGTC2_Format) {
        extension = extensions.get("EXT_texture_compression_rgtc");
        if (extension !== null) {
          if (p2 === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
          if (p2 === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (p2 === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (p2 === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        } else {
          return null;
        }
      }
      if (p2 === UnsignedInt248Type) return gl2.UNSIGNED_INT_24_8;
      return gl2[p2] !== void 0 ? gl2[p2] : null;
    }
    return { convert };
  }
  var ArrayCamera = class extends PerspectiveCamera {
    constructor(array = []) {
      super();
      this.isArrayCamera = true;
      this.cameras = array;
    }
  };
  var Group = class extends Object3D {
    constructor() {
      super();
      this.isGroup = true;
      this.type = "Group";
    }
  };
  var _moveEvent = { type: "move" };
  var WebXRController = class {
    constructor() {
      this._targetRay = null;
      this._grip = null;
      this._hand = null;
    }
    getHandSpace() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = {};
        this._hand.inputState = { pinching: false };
      }
      return this._hand;
    }
    getTargetRaySpace() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
        this._targetRay.hasLinearVelocity = false;
        this._targetRay.linearVelocity = new Vector3();
        this._targetRay.hasAngularVelocity = false;
        this._targetRay.angularVelocity = new Vector3();
      }
      return this._targetRay;
    }
    getGripSpace() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
        this._grip.hasLinearVelocity = false;
        this._grip.linearVelocity = new Vector3();
        this._grip.hasAngularVelocity = false;
        this._grip.angularVelocity = new Vector3();
      }
      return this._grip;
    }
    dispatchEvent(event2) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event2);
      }
      if (this._grip !== null) {
        this._grip.dispatchEvent(event2);
      }
      if (this._hand !== null) {
        this._hand.dispatchEvent(event2);
      }
      return this;
    }
    connect(inputSource) {
      if (inputSource && inputSource.hand) {
        const hand = this._hand;
        if (hand) {
          for (const inputjoint of inputSource.hand.values()) {
            this._getHandJoint(hand, inputjoint);
          }
        }
      }
      this.dispatchEvent({ type: "connected", data: inputSource });
      return this;
    }
    disconnect(inputSource) {
      this.dispatchEvent({ type: "disconnected", data: inputSource });
      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }
      if (this._grip !== null) {
        this._grip.visible = false;
      }
      if (this._hand !== null) {
        this._hand.visible = false;
      }
      return this;
    }
    update(inputSource, frame, referenceSpace) {
      let inputPose = null;
      let gripPose = null;
      let handPose = null;
      const targetRay = this._targetRay;
      const grip = this._grip;
      const hand = this._hand;
      if (inputSource && frame.session.visibilityState !== "visible-blurred") {
        if (hand && inputSource.hand) {
          handPose = true;
          for (const inputjoint of inputSource.hand.values()) {
            const jointPose = frame.getJointPose(inputjoint, referenceSpace);
            const joint = this._getHandJoint(hand, inputjoint);
            if (jointPose !== null) {
              joint.matrix.fromArray(jointPose.transform.matrix);
              joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
              joint.matrixWorldNeedsUpdate = true;
              joint.jointRadius = jointPose.radius;
            }
            joint.visible = jointPose !== null;
          }
          const indexTip = hand.joints["index-finger-tip"];
          const thumbTip = hand.joints["thumb-tip"];
          const distance = indexTip.position.distanceTo(thumbTip.position);
          const distanceToPinch = 0.02;
          const threshold = 5e-3;
          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
            hand.inputState.pinching = false;
            this.dispatchEvent({
              type: "pinchend",
              handedness: inputSource.handedness,
              target: this
            });
          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
            hand.inputState.pinching = true;
            this.dispatchEvent({
              type: "pinchstart",
              handedness: inputSource.handedness,
              target: this
            });
          }
        } else {
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
              grip.matrixWorldNeedsUpdate = true;
              if (gripPose.linearVelocity) {
                grip.hasLinearVelocity = true;
                grip.linearVelocity.copy(gripPose.linearVelocity);
              } else {
                grip.hasLinearVelocity = false;
              }
              if (gripPose.angularVelocity) {
                grip.hasAngularVelocity = true;
                grip.angularVelocity.copy(gripPose.angularVelocity);
              } else {
                grip.hasAngularVelocity = false;
              }
            }
          }
        }
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose === null && gripPose !== null) {
            inputPose = gripPose;
          }
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
            targetRay.matrixWorldNeedsUpdate = true;
            if (inputPose.linearVelocity) {
              targetRay.hasLinearVelocity = true;
              targetRay.linearVelocity.copy(inputPose.linearVelocity);
            } else {
              targetRay.hasLinearVelocity = false;
            }
            if (inputPose.angularVelocity) {
              targetRay.hasAngularVelocity = true;
              targetRay.angularVelocity.copy(inputPose.angularVelocity);
            } else {
              targetRay.hasAngularVelocity = false;
            }
            this.dispatchEvent(_moveEvent);
          }
        }
      }
      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }
      if (grip !== null) {
        grip.visible = gripPose !== null;
      }
      if (hand !== null) {
        hand.visible = handPose !== null;
      }
      return this;
    }
    // private method
    _getHandJoint(hand, inputjoint) {
      if (hand.joints[inputjoint.jointName] === void 0) {
        const joint = new Group();
        joint.matrixAutoUpdate = false;
        joint.visible = false;
        hand.joints[inputjoint.jointName] = joint;
        hand.add(joint);
      }
      return hand.joints[inputjoint.jointName];
    }
  };
  var _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
  var _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
  var WebXRDepthSensing = class {
    constructor() {
      this.texture = null;
      this.mesh = null;
      this.depthNear = 0;
      this.depthFar = 0;
    }
    init(renderer, depthData, renderState) {
      if (this.texture === null) {
        const texture = new Texture();
        const texProps = renderer.properties.get(texture);
        texProps.__webglTexture = depthData.texture;
        if (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) {
          this.depthNear = depthData.depthNear;
          this.depthFar = depthData.depthFar;
        }
        this.texture = texture;
      }
    }
    getMesh(cameraXR) {
      if (this.texture !== null) {
        if (this.mesh === null) {
          const viewport = cameraXR.cameras[0].viewport;
          const material = new ShaderMaterial({
            vertexShader: _occlusion_vertex,
            fragmentShader: _occlusion_fragment,
            uniforms: {
              depthColor: { value: this.texture },
              depthWidth: { value: viewport.z },
              depthHeight: { value: viewport.w }
            }
          });
          this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
        }
      }
      return this.mesh;
    }
    reset() {
      this.texture = null;
      this.mesh = null;
    }
  };
  var WebXRManager = class extends EventDispatcher {
    constructor(renderer, gl2) {
      super();
      const scope = this;
      let session = null;
      let framebufferScaleFactor = 1;
      let referenceSpace = null;
      let referenceSpaceType = "local-floor";
      let foveation = 1;
      let customReferenceSpace = null;
      let pose = null;
      let glBinding = null;
      let glProjLayer = null;
      let glBaseLayer = null;
      let xrFrame = null;
      const depthSensing = new WebXRDepthSensing();
      const attributes = gl2.getContextAttributes();
      let initialRenderTarget = null;
      let newRenderTarget = null;
      const controllers = [];
      const controllerInputSources = [];
      const currentSize = new Vector2();
      let currentPixelRatio = null;
      const cameraL = new PerspectiveCamera();
      cameraL.layers.enable(1);
      cameraL.viewport = new Vector4();
      const cameraR = new PerspectiveCamera();
      cameraR.layers.enable(2);
      cameraR.viewport = new Vector4();
      const cameras = [cameraL, cameraR];
      const cameraXR = new ArrayCamera();
      cameraXR.layers.enable(1);
      cameraXR.layers.enable(2);
      let _currentDepthNear = null;
      let _currentDepthFar = null;
      this.cameraAutoUpdate = true;
      this.enabled = false;
      this.isPresenting = false;
      this.getController = function(index2) {
        let controller = controllers[index2];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index2] = controller;
        }
        return controller.getTargetRaySpace();
      };
      this.getControllerGrip = function(index2) {
        let controller = controllers[index2];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index2] = controller;
        }
        return controller.getGripSpace();
      };
      this.getHand = function(index2) {
        let controller = controllers[index2];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index2] = controller;
        }
        return controller.getHandSpace();
      };
      function onSessionEvent(event2) {
        const controllerIndex = controllerInputSources.indexOf(event2.inputSource);
        if (controllerIndex === -1) {
          return;
        }
        const controller = controllers[controllerIndex];
        if (controller !== void 0) {
          controller.update(event2.inputSource, event2.frame, customReferenceSpace || referenceSpace);
          controller.dispatchEvent({ type: event2.type, data: event2.inputSource });
        }
      }
      function onSessionEnd() {
        session.removeEventListener("select", onSessionEvent);
        session.removeEventListener("selectstart", onSessionEvent);
        session.removeEventListener("selectend", onSessionEvent);
        session.removeEventListener("squeeze", onSessionEvent);
        session.removeEventListener("squeezestart", onSessionEvent);
        session.removeEventListener("squeezeend", onSessionEvent);
        session.removeEventListener("end", onSessionEnd);
        session.removeEventListener("inputsourceschange", onInputSourcesChange);
        for (let i4 = 0; i4 < controllers.length; i4++) {
          const inputSource = controllerInputSources[i4];
          if (inputSource === null) continue;
          controllerInputSources[i4] = null;
          controllers[i4].disconnect(inputSource);
        }
        _currentDepthNear = null;
        _currentDepthFar = null;
        depthSensing.reset();
        renderer.setRenderTarget(initialRenderTarget);
        glBaseLayer = null;
        glProjLayer = null;
        glBinding = null;
        session = null;
        newRenderTarget = null;
        animation.stop();
        scope.isPresenting = false;
        renderer.setPixelRatio(currentPixelRatio);
        renderer.setSize(currentSize.width, currentSize.height, false);
        scope.dispatchEvent({ type: "sessionend" });
      }
      this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }
      };
      this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }
      };
      this.getReferenceSpace = function() {
        return customReferenceSpace || referenceSpace;
      };
      this.setReferenceSpace = function(space) {
        customReferenceSpace = space;
      };
      this.getBaseLayer = function() {
        return glProjLayer !== null ? glProjLayer : glBaseLayer;
      };
      this.getBinding = function() {
        return glBinding;
      };
      this.getFrame = function() {
        return xrFrame;
      };
      this.getSession = function() {
        return session;
      };
      this.setSession = function(value) {
        return __async(this, null, function* () {
          session = value;
          if (session !== null) {
            initialRenderTarget = renderer.getRenderTarget();
            session.addEventListener("select", onSessionEvent);
            session.addEventListener("selectstart", onSessionEvent);
            session.addEventListener("selectend", onSessionEvent);
            session.addEventListener("squeeze", onSessionEvent);
            session.addEventListener("squeezestart", onSessionEvent);
            session.addEventListener("squeezeend", onSessionEvent);
            session.addEventListener("end", onSessionEnd);
            session.addEventListener("inputsourceschange", onInputSourcesChange);
            if (attributes.xrCompatible !== true) {
              yield gl2.makeXRCompatible();
            }
            currentPixelRatio = renderer.getPixelRatio();
            renderer.getSize(currentSize);
            if (session.renderState.layers === void 0) {
              const layerInit = {
                antialias: attributes.antialias,
                alpha: true,
                depth: attributes.depth,
                stencil: attributes.stencil,
                framebufferScaleFactor
              };
              glBaseLayer = new XRWebGLLayer(session, gl2, layerInit);
              session.updateRenderState({ baseLayer: glBaseLayer });
              renderer.setPixelRatio(1);
              renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
              newRenderTarget = new WebGLRenderTarget(
                glBaseLayer.framebufferWidth,
                glBaseLayer.framebufferHeight,
                {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  colorSpace: renderer.outputColorSpace,
                  stencilBuffer: attributes.stencil
                }
              );
            } else {
              let depthFormat = null;
              let depthType = null;
              let glDepthFormat = null;
              if (attributes.depth) {
                glDepthFormat = attributes.stencil ? gl2.DEPTH24_STENCIL8 : gl2.DEPTH_COMPONENT24;
                depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
              }
              const projectionlayerInit = {
                colorFormat: gl2.RGBA8,
                depthFormat: glDepthFormat,
                scaleFactor: framebufferScaleFactor
              };
              glBinding = new XRWebGLBinding(session, gl2);
              glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
              session.updateRenderState({ layers: [glProjLayer] });
              renderer.setPixelRatio(1);
              renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
              newRenderTarget = new WebGLRenderTarget(
                glProjLayer.textureWidth,
                glProjLayer.textureHeight,
                {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                  stencilBuffer: attributes.stencil,
                  colorSpace: renderer.outputColorSpace,
                  samples: attributes.antialias ? 4 : 0,
                  resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
                }
              );
            }
            newRenderTarget.isXRRenderTarget = true;
            this.setFoveation(foveation);
            customReferenceSpace = null;
            referenceSpace = yield session.requestReferenceSpace(referenceSpaceType);
            animation.setContext(session);
            animation.start();
            scope.isPresenting = true;
            scope.dispatchEvent({ type: "sessionstart" });
          }
        });
      };
      this.getEnvironmentBlendMode = function() {
        if (session !== null) {
          return session.environmentBlendMode;
        }
      };
      function onInputSourcesChange(event2) {
        for (let i4 = 0; i4 < event2.removed.length; i4++) {
          const inputSource = event2.removed[i4];
          const index2 = controllerInputSources.indexOf(inputSource);
          if (index2 >= 0) {
            controllerInputSources[index2] = null;
            controllers[index2].disconnect(inputSource);
          }
        }
        for (let i4 = 0; i4 < event2.added.length; i4++) {
          const inputSource = event2.added[i4];
          let controllerIndex = controllerInputSources.indexOf(inputSource);
          if (controllerIndex === -1) {
            for (let i5 = 0; i5 < controllers.length; i5++) {
              if (i5 >= controllerInputSources.length) {
                controllerInputSources.push(inputSource);
                controllerIndex = i5;
                break;
              } else if (controllerInputSources[i5] === null) {
                controllerInputSources[i5] = inputSource;
                controllerIndex = i5;
                break;
              }
            }
            if (controllerIndex === -1) break;
          }
          const controller = controllers[controllerIndex];
          if (controller) {
            controller.connect(inputSource);
          }
        }
      }
      const cameraLPos = new Vector3();
      const cameraRPos = new Vector3();
      function setProjectionFromUnion(camera, cameraL2, cameraR2) {
        cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL2.projectionMatrix.elements;
        const projR = cameraR2.projectionMatrix.elements;
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
      }
      function updateCamera(camera, parent2) {
        if (parent2 === null) {
          camera.matrixWorld.copy(camera.matrix);
        } else {
          camera.matrixWorld.multiplyMatrices(parent2.matrixWorld, camera.matrix);
        }
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      }
      this.updateCamera = function(camera) {
        if (session === null) return;
        if (depthSensing.texture !== null) {
          camera.near = depthSensing.depthNear;
          camera.far = depthSensing.depthFar;
        }
        cameraXR.near = cameraR.near = cameraL.near = camera.near;
        cameraXR.far = cameraR.far = cameraL.far = camera.far;
        if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
          session.updateRenderState({
            depthNear: cameraXR.near,
            depthFar: cameraXR.far
          });
          _currentDepthNear = cameraXR.near;
          _currentDepthFar = cameraXR.far;
          cameraL.near = _currentDepthNear;
          cameraL.far = _currentDepthFar;
          cameraR.near = _currentDepthNear;
          cameraR.far = _currentDepthFar;
          cameraL.updateProjectionMatrix();
          cameraR.updateProjectionMatrix();
          camera.updateProjectionMatrix();
        }
        const parent2 = camera.parent;
        const cameras2 = cameraXR.cameras;
        updateCamera(cameraXR, parent2);
        for (let i4 = 0; i4 < cameras2.length; i4++) {
          updateCamera(cameras2[i4], parent2);
        }
        if (cameras2.length === 2) {
          setProjectionFromUnion(cameraXR, cameraL, cameraR);
        } else {
          cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
        }
        updateUserCamera(camera, cameraXR, parent2);
      };
      function updateUserCamera(camera, cameraXR2, parent2) {
        if (parent2 === null) {
          camera.matrix.copy(cameraXR2.matrixWorld);
        } else {
          camera.matrix.copy(parent2.matrixWorld);
          camera.matrix.invert();
          camera.matrix.multiply(cameraXR2.matrixWorld);
        }
        camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
        camera.updateMatrixWorld(true);
        camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
        camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
        if (camera.isPerspectiveCamera) {
          camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
          camera.zoom = 1;
        }
      }
      this.getCamera = function() {
        return cameraXR;
      };
      this.getFoveation = function() {
        if (glProjLayer === null && glBaseLayer === null) {
          return void 0;
        }
        return foveation;
      };
      this.setFoveation = function(value) {
        foveation = value;
        if (glProjLayer !== null) {
          glProjLayer.fixedFoveation = value;
        }
        if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
          glBaseLayer.fixedFoveation = value;
        }
      };
      this.hasDepthSensing = function() {
        return depthSensing.texture !== null;
      };
      this.getDepthSensingMesh = function() {
        return depthSensing.getMesh(cameraXR);
      };
      let onAnimationFrameCallback = null;
      function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
        xrFrame = frame;
        if (pose !== null) {
          const views = pose.views;
          if (glBaseLayer !== null) {
            renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
            renderer.setRenderTarget(newRenderTarget);
          }
          let cameraXRNeedsUpdate = false;
          if (views.length !== cameraXR.cameras.length) {
            cameraXR.cameras.length = 0;
            cameraXRNeedsUpdate = true;
          }
          for (let i4 = 0; i4 < views.length; i4++) {
            const view = views[i4];
            let viewport = null;
            if (glBaseLayer !== null) {
              viewport = glBaseLayer.getViewport(view);
            } else {
              const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
              viewport = glSubImage.viewport;
              if (i4 === 0) {
                renderer.setRenderTargetTextures(
                  newRenderTarget,
                  glSubImage.colorTexture,
                  glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
                );
                renderer.setRenderTarget(newRenderTarget);
              }
            }
            let camera = cameras[i4];
            if (camera === void 0) {
              camera = new PerspectiveCamera();
              camera.layers.enable(i4);
              camera.viewport = new Vector4();
              cameras[i4] = camera;
            }
            camera.matrix.fromArray(view.transform.matrix);
            camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
            camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
            if (i4 === 0) {
              cameraXR.matrix.copy(camera.matrix);
              cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
            }
            if (cameraXRNeedsUpdate === true) {
              cameraXR.cameras.push(camera);
            }
          }
          const enabledFeatures = session.enabledFeatures;
          if (enabledFeatures && enabledFeatures.includes("depth-sensing")) {
            const depthData = glBinding.getDepthInformation(views[0]);
            if (depthData && depthData.isValid && depthData.texture) {
              depthSensing.init(renderer, depthData, session.renderState);
            }
          }
        }
        for (let i4 = 0; i4 < controllers.length; i4++) {
          const inputSource = controllerInputSources[i4];
          const controller = controllers[i4];
          if (inputSource !== null && controller !== void 0) {
            controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
          }
        }
        if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
        if (frame.detectedPlanes) {
          scope.dispatchEvent({ type: "planesdetected", data: frame });
        }
        xrFrame = null;
      }
      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
      };
      this.dispose = function() {
      };
    }
  };
  var _e1 = /* @__PURE__ */ new Euler();
  var _m1 = /* @__PURE__ */ new Matrix4();
  function WebGLMaterials(renderer, properties) {
    function refreshTransformUniform(map2, uniform) {
      if (map2.matrixAutoUpdate === true) {
        map2.updateMatrix();
      }
      uniform.value.copy(map2.matrix);
    }
    function refreshFogUniforms(uniforms, fog) {
      fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsStandard(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide) {
          uniforms.bumpScale.value *= -1;
        }
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide) {
          uniforms.normalScale.value.negate();
        }
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
        refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
        refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      const materialProperties = properties.get(material);
      const envMap = materialProperties.envMap;
      const envMapRotation = materialProperties.envMapRotation;
      if (envMap) {
        uniforms.envMap.value = envMap;
        _e1.copy(envMapRotation);
        _e1.x *= -1;
        _e1.y *= -1;
        _e1.z *= -1;
        if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
          _e1.y *= -1;
          _e1.z *= -1;
        }
        uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.ior.value = material.ior;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
        refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
        refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.uvTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
        refreshTransformUniform(material.map, uniforms.mapTransform);
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
        refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.metalness.value = material.metalness;
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
        refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
      }
      uniforms.roughness.value = material.roughness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
        refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
      }
      if (material.envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
      uniforms.ior.value = material.ior;
      if (material.sheen > 0) {
        uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
        uniforms.sheenRoughness.value = material.sheenRoughness;
        if (material.sheenColorMap) {
          uniforms.sheenColorMap.value = material.sheenColorMap;
          refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
        }
        if (material.sheenRoughnessMap) {
          uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
          refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
        }
      }
      if (material.clearcoat > 0) {
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
          refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
          refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          if (material.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
      }
      if (material.dispersion > 0) {
        uniforms.dispersion.value = material.dispersion;
      }
      if (material.iridescence > 0) {
        uniforms.iridescence.value = material.iridescence;
        uniforms.iridescenceIOR.value = material.iridescenceIOR;
        uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
        uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
        if (material.iridescenceMap) {
          uniforms.iridescenceMap.value = material.iridescenceMap;
          refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
        }
        if (material.iridescenceThicknessMap) {
          uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
          refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
        }
      }
      if (material.transmission > 0) {
        uniforms.transmission.value = material.transmission;
        uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
        uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
          refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
        }
        uniforms.thickness.value = material.thickness;
        if (material.thicknessMap) {
          uniforms.thicknessMap.value = material.thicknessMap;
          refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
        }
        uniforms.attenuationDistance.value = material.attenuationDistance;
        uniforms.attenuationColor.value.copy(material.attenuationColor);
      }
      if (material.anisotropy > 0) {
        uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
        if (material.anisotropyMap) {
          uniforms.anisotropyMap.value = material.anisotropyMap;
          refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
        }
      }
      uniforms.specularIntensity.value = material.specularIntensity;
      uniforms.specularColor.value.copy(material.specularColor);
      if (material.specularColorMap) {
        uniforms.specularColorMap.value = material.specularColorMap;
        refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
      }
      if (material.specularIntensityMap) {
        uniforms.specularIntensityMap.value = material.specularIntensityMap;
        refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      const light = properties.get(material).light;
      uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
      uniforms.nearDistance.value = light.shadow.camera.near;
      uniforms.farDistance.value = light.shadow.camera.far;
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function WebGLUniformsGroups(gl2, info, capabilities, state) {
    let buffers = {};
    let updateList = {};
    let allocatedBindingPoints = [];
    const maxBindingPoints = gl2.getParameter(gl2.MAX_UNIFORM_BUFFER_BINDINGS);
    function bind(uniformsGroup, program) {
      const webglProgram = program.program;
      state.uniformBlockBinding(uniformsGroup, webglProgram);
    }
    function update(uniformsGroup, program) {
      let buffer = buffers[uniformsGroup.id];
      if (buffer === void 0) {
        prepareUniformsGroup(uniformsGroup);
        buffer = createBuffer(uniformsGroup);
        buffers[uniformsGroup.id] = buffer;
        uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
      }
      const webglProgram = program.program;
      state.updateUBOMapping(uniformsGroup, webglProgram);
      const frame = info.render.frame;
      if (updateList[uniformsGroup.id] !== frame) {
        updateBufferData(uniformsGroup);
        updateList[uniformsGroup.id] = frame;
      }
    }
    function createBuffer(uniformsGroup) {
      const bindingPointIndex = allocateBindingPointIndex();
      uniformsGroup.__bindingPointIndex = bindingPointIndex;
      const buffer = gl2.createBuffer();
      const size = uniformsGroup.__size;
      const usage = uniformsGroup.usage;
      gl2.bindBuffer(gl2.UNIFORM_BUFFER, buffer);
      gl2.bufferData(gl2.UNIFORM_BUFFER, size, usage);
      gl2.bindBuffer(gl2.UNIFORM_BUFFER, null);
      gl2.bindBufferBase(gl2.UNIFORM_BUFFER, bindingPointIndex, buffer);
      return buffer;
    }
    function allocateBindingPointIndex() {
      for (let i4 = 0; i4 < maxBindingPoints; i4++) {
        if (allocatedBindingPoints.indexOf(i4) === -1) {
          allocatedBindingPoints.push(i4);
          return i4;
        }
      }
      console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
      return 0;
    }
    function updateBufferData(uniformsGroup) {
      const buffer = buffers[uniformsGroup.id];
      const uniforms = uniformsGroup.uniforms;
      const cache = uniformsGroup.__cache;
      gl2.bindBuffer(gl2.UNIFORM_BUFFER, buffer);
      for (let i4 = 0, il = uniforms.length; i4 < il; i4++) {
        const uniformArray = Array.isArray(uniforms[i4]) ? uniforms[i4] : [uniforms[i4]];
        for (let j2 = 0, jl = uniformArray.length; j2 < jl; j2++) {
          const uniform = uniformArray[j2];
          if (hasUniformChanged(uniform, i4, j2, cache) === true) {
            const offset2 = uniform.__offset;
            const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
            let arrayOffset = 0;
            for (let k2 = 0; k2 < values.length; k2++) {
              const value = values[k2];
              const info2 = getUniformSize(value);
              if (typeof value === "number" || typeof value === "boolean") {
                uniform.__data[0] = value;
                gl2.bufferSubData(gl2.UNIFORM_BUFFER, offset2 + arrayOffset, uniform.__data);
              } else if (value.isMatrix3) {
                uniform.__data[0] = value.elements[0];
                uniform.__data[1] = value.elements[1];
                uniform.__data[2] = value.elements[2];
                uniform.__data[3] = 0;
                uniform.__data[4] = value.elements[3];
                uniform.__data[5] = value.elements[4];
                uniform.__data[6] = value.elements[5];
                uniform.__data[7] = 0;
                uniform.__data[8] = value.elements[6];
                uniform.__data[9] = value.elements[7];
                uniform.__data[10] = value.elements[8];
                uniform.__data[11] = 0;
              } else {
                value.toArray(uniform.__data, arrayOffset);
                arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
              }
            }
            gl2.bufferSubData(gl2.UNIFORM_BUFFER, offset2, uniform.__data);
          }
        }
      }
      gl2.bindBuffer(gl2.UNIFORM_BUFFER, null);
    }
    function hasUniformChanged(uniform, index2, indexArray, cache) {
      const value = uniform.value;
      const indexString = index2 + "_" + indexArray;
      if (cache[indexString] === void 0) {
        if (typeof value === "number" || typeof value === "boolean") {
          cache[indexString] = value;
        } else {
          cache[indexString] = value.clone();
        }
        return true;
      } else {
        const cachedObject = cache[indexString];
        if (typeof value === "number" || typeof value === "boolean") {
          if (cachedObject !== value) {
            cache[indexString] = value;
            return true;
          }
        } else {
          if (cachedObject.equals(value) === false) {
            cachedObject.copy(value);
            return true;
          }
        }
      }
      return false;
    }
    function prepareUniformsGroup(uniformsGroup) {
      const uniforms = uniformsGroup.uniforms;
      let offset2 = 0;
      const chunkSize = 16;
      for (let i4 = 0, l4 = uniforms.length; i4 < l4; i4++) {
        const uniformArray = Array.isArray(uniforms[i4]) ? uniforms[i4] : [uniforms[i4]];
        for (let j2 = 0, jl = uniformArray.length; j2 < jl; j2++) {
          const uniform = uniformArray[j2];
          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          for (let k2 = 0, kl = values.length; k2 < kl; k2++) {
            const value = values[k2];
            const info2 = getUniformSize(value);
            const chunkOffsetUniform = offset2 % chunkSize;
            if (chunkOffsetUniform !== 0 && chunkSize - chunkOffsetUniform < info2.boundary) {
              offset2 += chunkSize - chunkOffsetUniform;
            }
            uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
            uniform.__offset = offset2;
            offset2 += info2.storage;
          }
        }
      }
      const chunkOffset = offset2 % chunkSize;
      if (chunkOffset > 0) offset2 += chunkSize - chunkOffset;
      uniformsGroup.__size = offset2;
      uniformsGroup.__cache = {};
      return this;
    }
    function getUniformSize(value) {
      const info2 = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      };
      if (typeof value === "number" || typeof value === "boolean") {
        info2.boundary = 4;
        info2.storage = 4;
      } else if (value.isVector2) {
        info2.boundary = 8;
        info2.storage = 8;
      } else if (value.isVector3 || value.isColor) {
        info2.boundary = 16;
        info2.storage = 12;
      } else if (value.isVector4) {
        info2.boundary = 16;
        info2.storage = 16;
      } else if (value.isMatrix3) {
        info2.boundary = 48;
        info2.storage = 48;
      } else if (value.isMatrix4) {
        info2.boundary = 64;
        info2.storage = 64;
      } else if (value.isTexture) {
        console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
      } else {
        console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
      }
      return info2;
    }
    function onUniformsGroupsDispose(event2) {
      const uniformsGroup = event2.target;
      uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
      const index2 = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
      allocatedBindingPoints.splice(index2, 1);
      gl2.deleteBuffer(buffers[uniformsGroup.id]);
      delete buffers[uniformsGroup.id];
      delete updateList[uniformsGroup.id];
    }
    function dispose() {
      for (const id in buffers) {
        gl2.deleteBuffer(buffers[id]);
      }
      allocatedBindingPoints = [];
      buffers = {};
      updateList = {};
    }
    return {
      bind,
      update,
      dispose
    };
  }
  var WebGLRenderer = class {
    constructor(parameters = {}) {
      const {
        canvas: canvas2 = createCanvasElement(),
        context: context3 = null,
        depth = true,
        stencil = false,
        alpha = false,
        antialias = false,
        premultipliedAlpha = true,
        preserveDrawingBuffer = false,
        powerPreference = "default",
        failIfMajorPerformanceCaveat = false
      } = parameters;
      this.isWebGLRenderer = true;
      let _alpha;
      if (context3 !== null) {
        if (typeof WebGLRenderingContext !== "undefined" && context3 instanceof WebGLRenderingContext) {
          throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
        }
        _alpha = context3.getContextAttributes().alpha;
      } else {
        _alpha = alpha;
      }
      const uintClearColor = new Uint32Array(4);
      const intClearColor = new Int32Array(4);
      let currentRenderList = null;
      let currentRenderState = null;
      const renderListStack = [];
      const renderStateStack = [];
      this.domElement = canvas2;
      this.debug = {
        /**
         * Enables error checking and reporting when shader programs are being compiled
         * @type {boolean}
         */
        checkShaderErrors: true,
        /**
         * Callback for custom error reporting.
         * @type {?Function}
         */
        onShaderError: null
      };
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.clippingPlanes = [];
      this.localClippingEnabled = false;
      this._outputColorSpace = SRGBColorSpace;
      this.toneMapping = NoToneMapping;
      this.toneMappingExposure = 1;
      const _this = this;
      let _isContextLost = false;
      let _currentActiveCubeFace = 0;
      let _currentActiveMipmapLevel = 0;
      let _currentRenderTarget = null;
      let _currentMaterialId = -1;
      let _currentCamera = null;
      const _currentViewport = new Vector4();
      const _currentScissor = new Vector4();
      let _currentScissorTest = null;
      const _currentClearColor = new Color(0);
      let _currentClearAlpha = 0;
      let _width = canvas2.width;
      let _height = canvas2.height;
      let _pixelRatio = 1;
      let _opaqueSort = null;
      let _transparentSort = null;
      const _viewport2 = new Vector4(0, 0, _width, _height);
      const _scissor = new Vector4(0, 0, _width, _height);
      let _scissorTest = false;
      const _frustum = new Frustum();
      let _clippingEnabled = false;
      let _localClippingEnabled = false;
      const _projScreenMatrix2 = new Matrix4();
      const _vector32 = new Vector3();
      const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
      let _renderBackground = false;
      function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
      }
      let _gl = context3;
      function getContext(contextName, contextAttributes) {
        return canvas2.getContext(contextName, contextAttributes);
      }
      try {
        const contextAttributes = {
          alpha: true,
          depth,
          stencil,
          antialias,
          premultipliedAlpha,
          preserveDrawingBuffer,
          powerPreference,
          failIfMajorPerformanceCaveat
        };
        if ("setAttribute" in canvas2) canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
        canvas2.addEventListener("webglcontextlost", onContextLost, false);
        canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
        canvas2.addEventListener("webglcontextcreationerror", onContextCreationError, false);
        if (_gl === null) {
          const contextName = "webgl2";
          _gl = getContext(contextName, contextAttributes);
          if (_gl === null) {
            if (getContext(contextName)) {
              throw new Error("Error creating WebGL context with your selected attributes.");
            } else {
              throw new Error("Error creating WebGL context.");
            }
          }
        }
      } catch (error) {
        console.error("THREE.WebGLRenderer: " + error.message);
        throw error;
      }
      let extensions, capabilities, state, info;
      let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
      let programCache, materials, renderLists, renderStates, clipping, shadowMap;
      let background, morphtargets, bufferRenderer, indexedBufferRenderer;
      let utils, bindingStates, uniformsGroups;
      function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        extensions.init();
        utils = new WebGLUtils(_gl, extensions);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
        state = new WebGLState(_gl);
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps(_this);
        cubeuvmaps = new WebGLCubeUVMaps(_this);
        attributes = new WebGLAttributes(_gl);
        bindingStates = new WebGLBindingStates(_gl, attributes);
        geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
        clipping = new WebGLClipping(properties);
        programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
        materials = new WebGLMaterials(_this, properties);
        renderLists = new WebGLRenderLists();
        renderStates = new WebGLRenderStates(extensions);
        background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
        shadowMap = new WebGLShadowMap(_this, objects, capabilities);
        uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.shadowMap = shadowMap;
        _this.state = state;
        _this.info = info;
      }
      initGLContext();
      const xr = new WebXRManager(_this, _gl);
      this.xr = xr;
      this.getContext = function() {
        return _gl;
      };
      this.getContextAttributes = function() {
        return _gl.getContextAttributes();
      };
      this.forceContextLoss = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension) extension.loseContext();
      };
      this.forceContextRestore = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension) extension.restoreContext();
      };
      this.getPixelRatio = function() {
        return _pixelRatio;
      };
      this.setPixelRatio = function(value) {
        if (value === void 0) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
      };
      this.getSize = function(target) {
        return target.set(_width, _height);
      };
      this.setSize = function(width, height, updateStyle = true) {
        if (xr.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        _width = width;
        _height = height;
        canvas2.width = Math.floor(width * _pixelRatio);
        canvas2.height = Math.floor(height * _pixelRatio);
        if (updateStyle === true) {
          canvas2.style.width = width + "px";
          canvas2.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
      };
      this.getDrawingBufferSize = function(target) {
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
      };
      this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        canvas2.width = Math.floor(width * pixelRatio);
        canvas2.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
      };
      this.getCurrentViewport = function(target) {
        return target.copy(_currentViewport);
      };
      this.getViewport = function(target) {
        return target.copy(_viewport2);
      };
      this.setViewport = function(x2, y2, width, height) {
        if (x2.isVector4) {
          _viewport2.set(x2.x, x2.y, x2.z, x2.w);
        } else {
          _viewport2.set(x2, y2, width, height);
        }
        state.viewport(_currentViewport.copy(_viewport2).multiplyScalar(_pixelRatio).round());
      };
      this.getScissor = function(target) {
        return target.copy(_scissor);
      };
      this.setScissor = function(x2, y2, width, height) {
        if (x2.isVector4) {
          _scissor.set(x2.x, x2.y, x2.z, x2.w);
        } else {
          _scissor.set(x2, y2, width, height);
        }
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
      };
      this.getScissorTest = function() {
        return _scissorTest;
      };
      this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
      };
      this.setOpaqueSort = function(method) {
        _opaqueSort = method;
      };
      this.setTransparentSort = function(method) {
        _transparentSort = method;
      };
      this.getClearColor = function(target) {
        return target.copy(background.getClearColor());
      };
      this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
      };
      this.getClearAlpha = function() {
        return background.getClearAlpha();
      };
      this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
      };
      this.clear = function(color = true, depth2 = true, stencil2 = true) {
        let bits = 0;
        if (color) {
          let isIntegerFormat = false;
          if (_currentRenderTarget !== null) {
            const targetFormat = _currentRenderTarget.texture.format;
            isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
          }
          if (isIntegerFormat) {
            const targetType = _currentRenderTarget.texture.type;
            const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
            const clearColor = background.getClearColor();
            const a3 = background.getClearAlpha();
            const r3 = clearColor.r;
            const g2 = clearColor.g;
            const b2 = clearColor.b;
            if (isUnsignedType) {
              uintClearColor[0] = r3;
              uintClearColor[1] = g2;
              uintClearColor[2] = b2;
              uintClearColor[3] = a3;
              _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
            } else {
              intClearColor[0] = r3;
              intClearColor[1] = g2;
              intClearColor[2] = b2;
              intClearColor[3] = a3;
              _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
            }
          } else {
            bits |= _gl.COLOR_BUFFER_BIT;
          }
        }
        if (depth2) bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil2) {
          bits |= _gl.STENCIL_BUFFER_BIT;
          this.state.buffers.stencil.setMask(4294967295);
        }
        _gl.clear(bits);
      };
      this.clearColor = function() {
        this.clear(true, false, false);
      };
      this.clearDepth = function() {
        this.clear(false, true, false);
      };
      this.clearStencil = function() {
        this.clear(false, false, true);
      };
      this.dispose = function() {
        canvas2.removeEventListener("webglcontextlost", onContextLost, false);
        canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
        canvas2.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        cubeuvmaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        uniformsGroups.dispose();
        programCache.dispose();
        xr.dispose();
        xr.removeEventListener("sessionstart", onXRSessionStart);
        xr.removeEventListener("sessionend", onXRSessionEnd);
        animation.stop();
      };
      function onContextLost(event2) {
        event2.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        _isContextLost = true;
      }
      function onContextRestore() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        _isContextLost = false;
        const infoAutoReset = info.autoReset;
        const shadowMapEnabled = shadowMap.enabled;
        const shadowMapAutoUpdate = shadowMap.autoUpdate;
        const shadowMapNeedsUpdate = shadowMap.needsUpdate;
        const shadowMapType = shadowMap.type;
        initGLContext();
        info.autoReset = infoAutoReset;
        shadowMap.enabled = shadowMapEnabled;
        shadowMap.autoUpdate = shadowMapAutoUpdate;
        shadowMap.needsUpdate = shadowMapNeedsUpdate;
        shadowMap.type = shadowMapType;
      }
      function onContextCreationError(event2) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event2.statusMessage);
      }
      function onMaterialDispose(event2) {
        const material = event2.target;
        material.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material);
      }
      function deallocateMaterial(material) {
        releaseMaterialProgramReferences(material);
        properties.remove(material);
      }
      function releaseMaterialProgramReferences(material) {
        const programs = properties.get(material).programs;
        if (programs !== void 0) {
          programs.forEach(function(program) {
            programCache.releaseProgram(program);
          });
          if (material.isShaderMaterial) {
            programCache.releaseShaderCache(material);
          }
        }
      }
      this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null) scene = _emptyScene;
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, geometry, material, object);
        state.setMaterial(material, frontFaceCW);
        let index2 = geometry.index;
        let rangeFactor = 1;
        if (material.wireframe === true) {
          index2 = geometries.getWireframeAttribute(geometry);
          if (index2 === void 0) return;
          rangeFactor = 2;
        }
        const drawRange = geometry.drawRange;
        const position = geometry.attributes.position;
        let drawStart = drawRange.start * rangeFactor;
        let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
        if (group !== null) {
          drawStart = Math.max(drawStart, group.start * rangeFactor);
          drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
        }
        if (index2 !== null) {
          drawStart = Math.max(drawStart, 0);
          drawEnd = Math.min(drawEnd, index2.count);
        } else if (position !== void 0 && position !== null) {
          drawStart = Math.max(drawStart, 0);
          drawEnd = Math.min(drawEnd, position.count);
        }
        const drawCount = drawEnd - drawStart;
        if (drawCount < 0 || drawCount === Infinity) return;
        bindingStates.setup(object, material, program, geometry, index2);
        let attribute;
        let renderer = bufferRenderer;
        if (index2 !== null) {
          attribute = attributes.get(index2);
          renderer = indexedBufferRenderer;
          renderer.setIndex(attribute);
        }
        if (object.isMesh) {
          if (material.wireframe === true) {
            state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
            renderer.setMode(_gl.LINES);
          } else {
            renderer.setMode(_gl.TRIANGLES);
          }
        } else if (object.isLine) {
          let lineWidth = material.linewidth;
          if (lineWidth === void 0) lineWidth = 1;
          state.setLineWidth(lineWidth * getTargetPixelRatio());
          if (object.isLineSegments) {
            renderer.setMode(_gl.LINES);
          } else if (object.isLineLoop) {
            renderer.setMode(_gl.LINE_LOOP);
          } else {
            renderer.setMode(_gl.LINE_STRIP);
          }
        } else if (object.isPoints) {
          renderer.setMode(_gl.POINTS);
        } else if (object.isSprite) {
          renderer.setMode(_gl.TRIANGLES);
        }
        if (object.isBatchedMesh) {
          if (object._multiDrawInstances !== null) {
            renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
          } else {
            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
          }
        } else if (object.isInstancedMesh) {
          renderer.renderInstances(drawStart, drawCount, object.count);
        } else if (geometry.isInstancedBufferGeometry) {
          const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
          const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
          renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else {
          renderer.render(drawStart, drawCount);
        }
      };
      function prepareMaterial(material, scene, object) {
        if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
          material.side = BackSide;
          material.needsUpdate = true;
          getProgram(material, scene, object);
          material.side = FrontSide;
          material.needsUpdate = true;
          getProgram(material, scene, object);
          material.side = DoubleSide;
        } else {
          getProgram(material, scene, object);
        }
      }
      this.compile = function(scene, camera, targetScene = null) {
        if (targetScene === null) targetScene = scene;
        currentRenderState = renderStates.get(targetScene);
        currentRenderState.init(camera);
        renderStateStack.push(currentRenderState);
        targetScene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
        if (scene !== targetScene) {
          scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
              currentRenderState.pushLight(object);
              if (object.castShadow) {
                currentRenderState.pushShadow(object);
              }
            }
          });
        }
        currentRenderState.setupLights();
        const materials2 = /* @__PURE__ */ new Set();
        scene.traverse(function(object) {
          const material = object.material;
          if (material) {
            if (Array.isArray(material)) {
              for (let i4 = 0; i4 < material.length; i4++) {
                const material2 = material[i4];
                prepareMaterial(material2, targetScene, object);
                materials2.add(material2);
              }
            } else {
              prepareMaterial(material, targetScene, object);
              materials2.add(material);
            }
          }
        });
        renderStateStack.pop();
        currentRenderState = null;
        return materials2;
      };
      this.compileAsync = function(scene, camera, targetScene = null) {
        const materials2 = this.compile(scene, camera, targetScene);
        return new Promise((resolve) => {
          function checkMaterialsReady() {
            materials2.forEach(function(material) {
              const materialProperties = properties.get(material);
              const program = materialProperties.currentProgram;
              if (program.isReady()) {
                materials2.delete(material);
              }
            });
            if (materials2.size === 0) {
              resolve(scene);
              return;
            }
            setTimeout(checkMaterialsReady, 10);
          }
          if (extensions.get("KHR_parallel_shader_compile") !== null) {
            checkMaterialsReady();
          } else {
            setTimeout(checkMaterialsReady, 10);
          }
        });
      };
      let onAnimationFrameCallback = null;
      function onAnimationFrame(time) {
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
      }
      function onXRSessionStart() {
        animation.stop();
      }
      function onXRSessionEnd() {
        animation.start();
      }
      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      if (typeof self !== "undefined") animation.setContext(self);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
      };
      xr.addEventListener("sessionstart", onXRSessionStart);
      xr.addEventListener("sessionend", onXRSessionEnd);
      this.render = function(scene, camera) {
        if (camera !== void 0 && camera.isCamera !== true) {
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          return;
        }
        if (_isContextLost === true) return;
        if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
        if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) {
          if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
          camera = xr.getCamera();
        }
        if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
        currentRenderState = renderStates.get(scene, renderStateStack.length);
        currentRenderState.init(camera);
        renderStateStack.push(currentRenderState);
        _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix2);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
        currentRenderList = renderLists.get(scene, renderListStack.length);
        currentRenderList.init();
        renderListStack.push(currentRenderList);
        if (xr.enabled === true && xr.isPresenting === true) {
          const depthSensingMesh = _this.xr.getDepthSensingMesh();
          if (depthSensingMesh !== null) {
            projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
          }
        }
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) {
          currentRenderList.sort(_opaqueSort, _transparentSort);
        }
        _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
        if (_renderBackground) {
          background.addToRenderList(currentRenderList, scene);
        }
        this.info.render.frame++;
        if (_clippingEnabled === true) clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        if (_clippingEnabled === true) clipping.endShadows();
        if (this.info.autoReset === true) this.info.reset();
        const opaqueObjects = currentRenderList.opaque;
        const transmissiveObjects = currentRenderList.transmissive;
        currentRenderState.setupLights();
        if (camera.isArrayCamera) {
          const cameras = camera.cameras;
          if (transmissiveObjects.length > 0) {
            for (let i4 = 0, l4 = cameras.length; i4 < l4; i4++) {
              const camera2 = cameras[i4];
              renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
            }
          }
          if (_renderBackground) background.render(scene);
          for (let i4 = 0, l4 = cameras.length; i4 < l4; i4++) {
            const camera2 = cameras[i4];
            renderScene(currentRenderList, scene, camera2, camera2.viewport);
          }
        } else {
          if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
          if (_renderBackground) background.render(scene);
          renderScene(currentRenderList, scene, camera);
        }
        if (_currentRenderTarget !== null) {
          textures.updateMultisampleRenderTarget(_currentRenderTarget);
          textures.updateRenderTargetMipmap(_currentRenderTarget);
        }
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        renderStateStack.pop();
        if (renderStateStack.length > 0) {
          currentRenderState = renderStateStack[renderStateStack.length - 1];
          if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
        } else {
          currentRenderState = null;
        }
        renderListStack.pop();
        if (renderListStack.length > 0) {
          currentRenderList = renderListStack[renderListStack.length - 1];
        } else {
          currentRenderList = null;
        }
      };
      function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
          if (object.isGroup) {
            groupOrder = object.renderOrder;
          } else if (object.isLOD) {
            if (object.autoUpdate === true) object.update(camera);
          } else if (object.isLight) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          } else if (object.isSprite) {
            if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
              if (sortObjects) {
                _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
              }
              const geometry = objects.update(object);
              const material = object.material;
              if (material.visible) {
                currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
              }
            }
          } else if (object.isMesh || object.isLine || object.isPoints) {
            if (!object.frustumCulled || _frustum.intersectsObject(object)) {
              const geometry = objects.update(object);
              const material = object.material;
              if (sortObjects) {
                if (object.boundingSphere !== void 0) {
                  if (object.boundingSphere === null) object.computeBoundingSphere();
                  _vector32.copy(object.boundingSphere.center);
                } else {
                  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                  _vector32.copy(geometry.boundingSphere.center);
                }
                _vector32.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
              }
              if (Array.isArray(material)) {
                const groups = geometry.groups;
                for (let i4 = 0, l4 = groups.length; i4 < l4; i4++) {
                  const group = groups[i4];
                  const groupMaterial = material[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector32.z, group);
                  }
                }
              } else if (material.visible) {
                currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
              }
            }
          }
        }
        const children2 = object.children;
        for (let i4 = 0, l4 = children2.length; i4 < l4; i4++) {
          projectObject(children2[i4], camera, groupOrder, sortObjects);
        }
      }
      function renderScene(currentRenderList2, scene, camera, viewport) {
        const opaqueObjects = currentRenderList2.opaque;
        const transmissiveObjects = currentRenderList2.transmissive;
        const transparentObjects = currentRenderList2.transparent;
        currentRenderState.setupLightsView(camera);
        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
        if (viewport) state.viewport(_currentViewport.copy(viewport));
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
        if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
      }
      function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        if (overrideMaterial !== null) {
          return;
        }
        if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {
          currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
            generateMipmaps: true,
            type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
            minFilter: LinearMipmapLinearFilter,
            samples: 4,
            stencilBuffer: stencil,
            resolveDepthBuffer: false,
            resolveStencilBuffer: false,
            colorSpace: ColorManagement.workingColorSpace
          });
        }
        const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
        const activeViewport = camera.viewport || _currentViewport;
        transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);
        const currentRenderTarget = _this.getRenderTarget();
        _this.setRenderTarget(transmissionRenderTarget);
        _this.getClearColor(_currentClearColor);
        _currentClearAlpha = _this.getClearAlpha();
        if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
        if (_renderBackground) {
          background.render(scene);
        } else {
          _this.clear();
        }
        const currentToneMapping = _this.toneMapping;
        _this.toneMapping = NoToneMapping;
        const currentCameraViewport = camera.viewport;
        if (camera.viewport !== void 0) camera.viewport = void 0;
        currentRenderState.setupLightsView(camera);
        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
        renderObjects(opaqueObjects, scene, camera);
        textures.updateMultisampleRenderTarget(transmissionRenderTarget);
        textures.updateRenderTargetMipmap(transmissionRenderTarget);
        if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
          let renderTargetNeedsUpdate = false;
          for (let i4 = 0, l4 = transmissiveObjects.length; i4 < l4; i4++) {
            const renderItem = transmissiveObjects[i4];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = renderItem.material;
            const group = renderItem.group;
            if (material.side === DoubleSide && object.layers.test(camera.layers)) {
              const currentSide = material.side;
              material.side = BackSide;
              material.needsUpdate = true;
              renderObject(object, scene, camera, geometry, material, group);
              material.side = currentSide;
              material.needsUpdate = true;
              renderTargetNeedsUpdate = true;
            }
          }
          if (renderTargetNeedsUpdate === true) {
            textures.updateMultisampleRenderTarget(transmissionRenderTarget);
            textures.updateRenderTargetMipmap(transmissionRenderTarget);
          }
        }
        _this.setRenderTarget(currentRenderTarget);
        _this.setClearColor(_currentClearColor, _currentClearAlpha);
        if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;
        _this.toneMapping = currentToneMapping;
      }
      function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for (let i4 = 0, l4 = renderList.length; i4 < l4; i4++) {
          const renderItem = renderList[i4];
          const object = renderItem.object;
          const geometry = renderItem.geometry;
          const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
          const group = renderItem.group;
          if (object.layers.test(camera.layers)) {
            renderObject(object, scene, camera, geometry, material, group);
          }
        }
      }
      function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        material.onBeforeRender(_this, scene, camera, geometry, object, group);
        if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
          material.side = BackSide;
          material.needsUpdate = true;
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          material.side = FrontSide;
          material.needsUpdate = true;
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
          material.side = DoubleSide;
        } else {
          _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        }
        object.onAfterRender(_this, scene, camera, geometry, material, group);
      }
      function getProgram(material, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters2);
        let programs = materialProperties.programs;
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
        materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
        if (programs === void 0) {
          material.addEventListener("dispose", onMaterialDispose);
          programs = /* @__PURE__ */ new Map();
          materialProperties.programs = programs;
        }
        let program = programs.get(programCacheKey);
        if (program !== void 0) {
          if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
            updateCommonMaterialProperties(material, parameters2);
            return program;
          }
        } else {
          parameters2.uniforms = programCache.getUniforms(material);
          material.onBuild(object, parameters2, _this);
          material.onBeforeCompile(parameters2, _this);
          program = programCache.acquireProgram(parameters2, programCacheKey);
          programs.set(programCacheKey, program);
          materialProperties.uniforms = parameters2.uniforms;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
          uniforms.clippingPlanes = clipping.uniform;
        }
        updateCommonMaterialProperties(material, parameters2);
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
          uniforms.ambientLightColor.value = lights.state.ambient;
          uniforms.lightProbe.value = lights.state.probe;
          uniforms.directionalLights.value = lights.state.directional;
          uniforms.directionalLightShadows.value = lights.state.directionalShadow;
          uniforms.spotLights.value = lights.state.spot;
          uniforms.spotLightShadows.value = lights.state.spotShadow;
          uniforms.rectAreaLights.value = lights.state.rectArea;
          uniforms.ltc_1.value = lights.state.rectAreaLTC1;
          uniforms.ltc_2.value = lights.state.rectAreaLTC2;
          uniforms.pointLights.value = lights.state.point;
          uniforms.pointLightShadows.value = lights.state.pointShadow;
          uniforms.hemisphereLights.value = lights.state.hemi;
          uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
          uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
          uniforms.spotShadowMap.value = lights.state.spotShadowMap;
          uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
          uniforms.spotLightMap.value = lights.state.spotLightMap;
          uniforms.pointShadowMap.value = lights.state.pointShadowMap;
          uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        }
        materialProperties.currentProgram = program;
        materialProperties.uniformsList = null;
        return program;
      }
      function getUniformList(materialProperties) {
        if (materialProperties.uniformsList === null) {
          const progUniforms = materialProperties.currentProgram.getUniforms();
          materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
        }
        return materialProperties.uniformsList;
      }
      function updateCommonMaterialProperties(material, parameters2) {
        const materialProperties = properties.get(material);
        materialProperties.outputColorSpace = parameters2.outputColorSpace;
        materialProperties.batching = parameters2.batching;
        materialProperties.batchingColor = parameters2.batchingColor;
        materialProperties.instancing = parameters2.instancing;
        materialProperties.instancingColor = parameters2.instancingColor;
        materialProperties.instancingMorph = parameters2.instancingMorph;
        materialProperties.skinning = parameters2.skinning;
        materialProperties.morphTargets = parameters2.morphTargets;
        materialProperties.morphNormals = parameters2.morphNormals;
        materialProperties.morphColors = parameters2.morphColors;
        materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
        materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
        materialProperties.numIntersection = parameters2.numClipIntersection;
        materialProperties.vertexAlphas = parameters2.vertexAlphas;
        materialProperties.vertexTangents = parameters2.vertexTangents;
        materialProperties.toneMapping = parameters2.toneMapping;
      }
      function setProgram(camera, scene, geometry, material, object) {
        if (scene.isScene !== true) scene = _emptyScene;
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
        const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
        const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
        const morphTargets = !!geometry.morphAttributes.position;
        const morphNormals = !!geometry.morphAttributes.normal;
        const morphColors = !!geometry.morphAttributes.color;
        let toneMapping = NoToneMapping;
        if (material.toneMapped) {
          if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
            toneMapping = _this.toneMapping;
          }
        }
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
          if (_localClippingEnabled === true || camera !== _currentCamera) {
            const useCache = camera === _currentCamera && material.id === _currentMaterialId;
            clipping.setState(material, camera, useCache);
          }
        }
        let needsProgramChange = false;
        if (material.version === materialProperties.__version) {
          if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
            needsProgramChange = true;
          } else if (materialProperties.outputColorSpace !== colorSpace) {
            needsProgramChange = true;
          } else if (object.isBatchedMesh && materialProperties.batching === false) {
            needsProgramChange = true;
          } else if (!object.isBatchedMesh && materialProperties.batching === true) {
            needsProgramChange = true;
          } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
            needsProgramChange = true;
          } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancing === false) {
            needsProgramChange = true;
          } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
            needsProgramChange = true;
          } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
            needsProgramChange = true;
          } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
            needsProgramChange = true;
          } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
            needsProgramChange = true;
          } else if (materialProperties.envMap !== envMap) {
            needsProgramChange = true;
          } else if (material.fog === true && materialProperties.fog !== fog) {
            needsProgramChange = true;
          } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
            needsProgramChange = true;
          } else if (materialProperties.vertexAlphas !== vertexAlphas) {
            needsProgramChange = true;
          } else if (materialProperties.vertexTangents !== vertexTangents) {
            needsProgramChange = true;
          } else if (materialProperties.morphTargets !== morphTargets) {
            needsProgramChange = true;
          } else if (materialProperties.morphNormals !== morphNormals) {
            needsProgramChange = true;
          } else if (materialProperties.morphColors !== morphColors) {
            needsProgramChange = true;
          } else if (materialProperties.toneMapping !== toneMapping) {
            needsProgramChange = true;
          } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
            needsProgramChange = true;
          }
        } else {
          needsProgramChange = true;
          materialProperties.__version = material.version;
        }
        let program = materialProperties.currentProgram;
        if (needsProgramChange === true) {
          program = getProgram(material, scene, object);
        }
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
          _currentMaterialId = material.id;
          refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
          p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
          p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
          }
          if (capabilities.logarithmicDepthBuffer) {
            p_uniforms.setValue(
              _gl,
              "logDepthBufFC",
              2 / (Math.log(camera.far + 1) / Math.LN2)
            );
          }
          if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
            p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
          }
          if (_currentCamera !== camera) {
            _currentCamera = camera;
            refreshMaterial = true;
            refreshLights = true;
          }
        }
        if (object.isSkinnedMesh) {
          p_uniforms.setOptional(_gl, object, "bindMatrix");
          p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
          const skeleton = object.skeleton;
          if (skeleton) {
            if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          }
        }
        if (object.isBatchedMesh) {
          p_uniforms.setOptional(_gl, object, "batchingTexture");
          p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
          p_uniforms.setOptional(_gl, object, "batchingColorTexture");
          if (object._colorsTexture !== null) {
            p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
          }
        }
        const morphAttributes = geometry.morphAttributes;
        if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {
          morphtargets.update(object, geometry, program);
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
          materialProperties.receiveShadow = object.receiveShadow;
          p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
        }
        if (material.isMeshGouraudMaterial && material.envMap !== null) {
          m_uniforms.envMap.value = envMap;
          m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        }
        if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
          m_uniforms.envMapIntensity.value = scene.environmentIntensity;
        }
        if (refreshMaterial) {
          p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
          if (materialProperties.needsLights) {
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
          }
          if (fog && material.fog === true) {
            materials.refreshFogUniforms(m_uniforms, fog);
          }
          materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
          WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
          WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
          material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) {
          p_uniforms.setValue(_gl, "center", object.center);
        }
        p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
        p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
        if (material.isShaderMaterial || material.isRawShaderMaterial) {
          const groups = material.uniformsGroups;
          for (let i4 = 0, l4 = groups.length; i4 < l4; i4++) {
            const group = groups[i4];
            uniformsGroups.update(group, program);
            uniformsGroups.bind(group, program);
          }
        }
        return program;
      }
      function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
      }
      function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
      }
      this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
      };
      this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
      };
      this.getRenderTarget = function() {
        return _currentRenderTarget;
      };
      this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
        properties.get(renderTarget.texture).__webglTexture = colorTexture;
        properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
        const renderTargetProperties = properties.get(renderTarget);
        renderTargetProperties.__hasExternalTextures = true;
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      };
      this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
        const renderTargetProperties = properties.get(renderTarget);
        renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
        renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
      };
      this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        let useDefaultFramebuffer = true;
        let framebuffer = null;
        let isCube = false;
        let isRenderTarget3D = false;
        if (renderTarget) {
          const renderTargetProperties = properties.get(renderTarget);
          if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, null);
            useDefaultFramebuffer = false;
          } else if (renderTargetProperties.__webglFramebuffer === void 0) {
            textures.setupRenderTarget(renderTarget);
          } else if (renderTargetProperties.__hasExternalTextures) {
            textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
          }
          const texture = renderTarget.texture;
          if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
            isRenderTarget3D = true;
          }
          const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget) {
            if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
              framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
            } else {
              framebuffer = __webglFramebuffer[activeCubeFace];
            }
            isCube = true;
          } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
            framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
          } else {
            if (Array.isArray(__webglFramebuffer)) {
              framebuffer = __webglFramebuffer[activeMipmapLevel];
            } else {
              framebuffer = __webglFramebuffer;
            }
          }
          _currentViewport.copy(renderTarget.viewport);
          _currentScissor.copy(renderTarget.scissor);
          _currentScissorTest = renderTarget.scissorTest;
        } else {
          _currentViewport.copy(_viewport2).multiplyScalar(_pixelRatio).floor();
          _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
          _currentScissorTest = _scissorTest;
        }
        const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        if (framebufferBound && useDefaultFramebuffer) {
          state.drawBuffers(renderTarget, framebuffer);
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
          const textureProperties = properties.get(renderTarget.texture);
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        } else if (isRenderTarget3D) {
          const textureProperties = properties.get(renderTarget.texture);
          const layer = activeCubeFace || 0;
          _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
        }
        _currentMaterialId = -1;
      };
      this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
          framebuffer = framebuffer[activeCubeFaceIndex];
        }
        if (framebuffer) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          try {
            const texture = renderTarget.texture;
            const textureFormat = texture.format;
            const textureType = texture.type;
            if (!capabilities.textureFormatReadable(textureFormat)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              return;
            }
            if (!capabilities.textureTypeReadable(textureType)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              return;
            }
            if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
              _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
            }
          } finally {
            const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
          }
        }
      };
      this.readRenderTargetPixelsAsync = function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex) {
        return __async(this, null, function* () {
          if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          }
          let framebuffer = properties.get(renderTarget).__webglFramebuffer;
          if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
            framebuffer = framebuffer[activeCubeFaceIndex];
          }
          if (framebuffer) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            try {
              const texture = renderTarget.texture;
              const textureFormat = texture.format;
              const textureType = texture.type;
              if (!capabilities.textureFormatReadable(textureFormat)) {
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
              }
              if (!capabilities.textureTypeReadable(textureType)) {
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
              }
              if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
                const glBuffer = _gl.createBuffer();
                _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
                _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
                _gl.flush();
                const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                yield probeAsync(_gl, sync, 4);
                try {
                  _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                  _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
                } finally {
                  _gl.deleteBuffer(glBuffer);
                  _gl.deleteSync(sync);
                }
                return buffer;
              }
            } finally {
              const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
              state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
            }
          }
        });
      };
      this.copyFramebufferToTexture = function(texture, position = null, level = 0) {
        if (texture.isTexture !== true) {
          console.warn("WebGLRenderer: copyFramebufferToTexture function signature has changed.");
          position = arguments[0] || null;
          texture = arguments[1];
        }
        const levelScale = Math.pow(2, -level);
        const width = Math.floor(texture.image.width * levelScale);
        const height = Math.floor(texture.image.height * levelScale);
        const x2 = position !== null ? position.x : 0;
        const y2 = position !== null ? position.y : 0;
        textures.setTexture2D(texture, 0);
        _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x2, y2, width, height);
        state.unbindTexture();
      };
      this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
        if (srcTexture.isTexture !== true) {
          console.warn("WebGLRenderer: copyTextureToTexture function signature has changed.");
          dstPosition = arguments[0] || null;
          srcTexture = arguments[1];
          dstTexture = arguments[2];
          level = arguments[3] || 0;
          srcRegion = null;
        }
        let width, height, minX, minY;
        let dstX, dstY;
        if (srcRegion !== null) {
          width = srcRegion.max.x - srcRegion.min.x;
          height = srcRegion.max.y - srcRegion.min.y;
          minX = srcRegion.min.x;
          minY = srcRegion.min.y;
        } else {
          width = srcTexture.image.width;
          height = srcTexture.image.height;
          minX = 0;
          minY = 0;
        }
        if (dstPosition !== null) {
          dstX = dstPosition.x;
          dstY = dstPosition.y;
        } else {
          dstX = 0;
          dstY = 0;
        }
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
        const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
        const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
        const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
        const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
        const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
        const image2 = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
        _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image2.width);
        _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image2.height);
        _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
        _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
        if (srcTexture.isDataTexture) {
          _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image2.data);
        } else {
          if (srcTexture.isCompressedTexture) {
            _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image2.width, image2.height, glFormat, image2.data);
          } else {
            _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, glFormat, glType, image2);
          }
        }
        _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
        _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
        _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
        _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
        _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
        state.unbindTexture();
      };
      this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
        if (srcTexture.isTexture !== true) {
          console.warn("WebGLRenderer: copyTextureToTexture3D function signature has changed.");
          srcRegion = arguments[0] || null;
          dstPosition = arguments[1] || null;
          srcTexture = arguments[2];
          dstTexture = arguments[3];
          level = arguments[4] || 0;
        }
        let width, height, depth2, minX, minY, minZ;
        let dstX, dstY, dstZ;
        const image2 = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
        if (srcRegion !== null) {
          width = srcRegion.max.x - srcRegion.min.x;
          height = srcRegion.max.y - srcRegion.min.y;
          depth2 = srcRegion.max.z - srcRegion.min.z;
          minX = srcRegion.min.x;
          minY = srcRegion.min.y;
          minZ = srcRegion.min.z;
        } else {
          width = image2.width;
          height = image2.height;
          depth2 = image2.depth;
          minX = 0;
          minY = 0;
          minZ = 0;
        }
        if (dstPosition !== null) {
          dstX = dstPosition.x;
          dstY = dstPosition.y;
          dstZ = dstPosition.z;
        } else {
          dstX = 0;
          dstY = 0;
          dstZ = 0;
        }
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        let glTarget;
        if (dstTexture.isData3DTexture) {
          textures.setTexture3D(dstTexture, 0);
          glTarget = _gl.TEXTURE_3D;
        } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
          textures.setTexture2DArray(dstTexture, 0);
          glTarget = _gl.TEXTURE_2D_ARRAY;
        } else {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          return;
        }
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
        const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
        const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
        const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
        const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
        const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
        _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image2.width);
        _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image2.height);
        _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
        _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
        _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
        if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
          _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image2.data);
        } else {
          if (dstTexture.isCompressedArrayTexture) {
            _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, image2.data);
          } else {
            _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image2);
          }
        }
        _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
        _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
        _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
        _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
        _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
        state.unbindTexture();
      };
      this.initRenderTarget = function(target) {
        if (properties.get(target).__webglFramebuffer === void 0) {
          textures.setupRenderTarget(target);
        }
      };
      this.initTexture = function(texture) {
        if (texture.isCubeTexture) {
          textures.setTextureCube(texture, 0);
        } else if (texture.isData3DTexture) {
          textures.setTexture3D(texture, 0);
        } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          textures.setTexture2DArray(texture, 0);
        } else {
          textures.setTexture2D(texture, 0);
        }
        state.unbindTexture();
      };
      this.resetState = function() {
        _currentActiveCubeFace = 0;
        _currentActiveMipmapLevel = 0;
        _currentRenderTarget = null;
        state.reset();
        bindingStates.reset();
      };
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    get coordinateSystem() {
      return WebGLCoordinateSystem;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(colorSpace) {
      this._outputColorSpace = colorSpace;
      const gl2 = this.getContext();
      gl2.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? "display-p3" : "srgb";
      gl2.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb";
    }
  };
  var Scene = class extends Object3D {
    constructor() {
      super();
      this.isScene = true;
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.backgroundBlurriness = 0;
      this.backgroundIntensity = 1;
      this.backgroundRotation = new Euler();
      this.environmentIntensity = 1;
      this.environmentRotation = new Euler();
      this.overrideMaterial = null;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.background !== null) this.background = source.background.clone();
      if (source.environment !== null) this.environment = source.environment.clone();
      if (source.fog !== null) this.fog = source.fog.clone();
      this.backgroundBlurriness = source.backgroundBlurriness;
      this.backgroundIntensity = source.backgroundIntensity;
      this.backgroundRotation.copy(source.backgroundRotation);
      this.environmentIntensity = source.environmentIntensity;
      this.environmentRotation.copy(source.environmentRotation);
      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.fog !== null) data.object.fog = this.fog.toJSON();
      if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
      if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
      data.object.backgroundRotation = this.backgroundRotation.toArray();
      if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
      data.object.environmentRotation = this.environmentRotation.toArray();
      return data;
    }
  };
  var InterleavedBuffer = class {
    constructor(array, stride) {
      this.isInterleavedBuffer = true;
      this.array = array;
      this.stride = stride;
      this.count = array !== void 0 ? array.length / stride : 0;
      this.usage = StaticDrawUsage;
      this._updateRange = { offset: 0, count: -1 };
      this.updateRanges = [];
      this.version = 0;
      this.uuid = generateUUID();
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true) this.version++;
    }
    get updateRange() {
      warnOnce("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.");
      return this._updateRange;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    addUpdateRange(start, count) {
      this.updateRanges.push({ start, count });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (let i4 = 0, l4 = this.stride; i4 < l4; i4++) {
        this.array[index1 + i4] = attribute.array[index2 + i4];
      }
      return this;
    }
    set(value, offset2 = 0) {
      this.array.set(value, offset2);
      return this;
    }
    clone(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
      }
      const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
      const ib = new this.constructor(array, this.stride);
      ib.setUsage(this.usage);
      return ib;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    toJSON(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
      }
      return {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  };
  var _vector$6 = /* @__PURE__ */ new Vector3();
  var InterleavedBufferAttribute = class _InterleavedBufferAttribute {
    constructor(interleavedBuffer, itemSize, offset2, normalized = false) {
      this.isInterleavedBufferAttribute = true;
      this.name = "";
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset2;
      this.normalized = normalized;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(value) {
      this.data.needsUpdate = value;
    }
    applyMatrix4(m2) {
      for (let i4 = 0, l4 = this.data.count; i4 < l4; i4++) {
        _vector$6.fromBufferAttribute(this, i4);
        _vector$6.applyMatrix4(m2);
        this.setXYZ(i4, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    applyNormalMatrix(m2) {
      for (let i4 = 0, l4 = this.count; i4 < l4; i4++) {
        _vector$6.fromBufferAttribute(this, i4);
        _vector$6.applyNormalMatrix(m2);
        this.setXYZ(i4, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    transformDirection(m2) {
      for (let i4 = 0, l4 = this.count; i4 < l4; i4++) {
        _vector$6.fromBufferAttribute(this, i4);
        _vector$6.transformDirection(m2);
        this.setXYZ(i4, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    getComponent(index2, component) {
      let value = this.array[index2 * this.data.stride + this.offset + component];
      if (this.normalized) value = denormalize(value, this.array);
      return value;
    }
    setComponent(index2, component, value) {
      if (this.normalized) value = normalize3(value, this.array);
      this.data.array[index2 * this.data.stride + this.offset + component] = value;
      return this;
    }
    setX(index2, x2) {
      if (this.normalized) x2 = normalize3(x2, this.array);
      this.data.array[index2 * this.data.stride + this.offset] = x2;
      return this;
    }
    setY(index2, y2) {
      if (this.normalized) y2 = normalize3(y2, this.array);
      this.data.array[index2 * this.data.stride + this.offset + 1] = y2;
      return this;
    }
    setZ(index2, z2) {
      if (this.normalized) z2 = normalize3(z2, this.array);
      this.data.array[index2 * this.data.stride + this.offset + 2] = z2;
      return this;
    }
    setW(index2, w2) {
      if (this.normalized) w2 = normalize3(w2, this.array);
      this.data.array[index2 * this.data.stride + this.offset + 3] = w2;
      return this;
    }
    getX(index2) {
      let x2 = this.data.array[index2 * this.data.stride + this.offset];
      if (this.normalized) x2 = denormalize(x2, this.array);
      return x2;
    }
    getY(index2) {
      let y2 = this.data.array[index2 * this.data.stride + this.offset + 1];
      if (this.normalized) y2 = denormalize(y2, this.array);
      return y2;
    }
    getZ(index2) {
      let z2 = this.data.array[index2 * this.data.stride + this.offset + 2];
      if (this.normalized) z2 = denormalize(z2, this.array);
      return z2;
    }
    getW(index2) {
      let w2 = this.data.array[index2 * this.data.stride + this.offset + 3];
      if (this.normalized) w2 = denormalize(w2, this.array);
      return w2;
    }
    setXY(index2, x2, y2) {
      index2 = index2 * this.data.stride + this.offset;
      if (this.normalized) {
        x2 = normalize3(x2, this.array);
        y2 = normalize3(y2, this.array);
      }
      this.data.array[index2 + 0] = x2;
      this.data.array[index2 + 1] = y2;
      return this;
    }
    setXYZ(index2, x2, y2, z2) {
      index2 = index2 * this.data.stride + this.offset;
      if (this.normalized) {
        x2 = normalize3(x2, this.array);
        y2 = normalize3(y2, this.array);
        z2 = normalize3(z2, this.array);
      }
      this.data.array[index2 + 0] = x2;
      this.data.array[index2 + 1] = y2;
      this.data.array[index2 + 2] = z2;
      return this;
    }
    setXYZW(index2, x2, y2, z2, w2) {
      index2 = index2 * this.data.stride + this.offset;
      if (this.normalized) {
        x2 = normalize3(x2, this.array);
        y2 = normalize3(y2, this.array);
        z2 = normalize3(z2, this.array);
        w2 = normalize3(w2, this.array);
      }
      this.data.array[index2 + 0] = x2;
      this.data.array[index2 + 1] = y2;
      this.data.array[index2 + 2] = z2;
      this.data.array[index2 + 3] = w2;
      return this;
    }
    clone(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
        const array = [];
        for (let i4 = 0; i4 < this.count; i4++) {
          const index2 = i4 * this.data.stride + this.offset;
          for (let j2 = 0; j2 < this.itemSize; j2++) {
            array.push(this.data.array[index2 + j2]);
          }
        }
        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
        }
        return new _InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
    }
    toJSON(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
        const array = [];
        for (let i4 = 0; i4 < this.count; i4++) {
          const index2 = i4 * this.data.stride + this.offset;
          for (let j2 = 0; j2 < this.itemSize; j2++) {
            array.push(this.data.array[index2 + j2]);
          }
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array,
          normalized: this.normalized
        };
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
        }
        return {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
  };
  var _basePosition = /* @__PURE__ */ new Vector3();
  var _skinIndex = /* @__PURE__ */ new Vector4();
  var _skinWeight = /* @__PURE__ */ new Vector4();
  var _vector3 = /* @__PURE__ */ new Vector3();
  var _matrix4 = /* @__PURE__ */ new Matrix4();
  var _vertex = /* @__PURE__ */ new Vector3();
  var _sphere$4 = /* @__PURE__ */ new Sphere();
  var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
  var _ray$2 = /* @__PURE__ */ new Ray();
  var SkinnedMesh = class extends Mesh {
    constructor(geometry, material) {
      super(geometry, material);
      this.isSkinnedMesh = true;
      this.type = "SkinnedMesh";
      this.bindMode = AttachedBindMode;
      this.bindMatrix = new Matrix4();
      this.bindMatrixInverse = new Matrix4();
      this.boundingBox = null;
      this.boundingSphere = null;
    }
    computeBoundingBox() {
      const geometry = this.geometry;
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      this.boundingBox.makeEmpty();
      const positionAttribute = geometry.getAttribute("position");
      for (let i4 = 0; i4 < positionAttribute.count; i4++) {
        this.getVertexPosition(i4, _vertex);
        this.boundingBox.expandByPoint(_vertex);
      }
    }
    computeBoundingSphere() {
      const geometry = this.geometry;
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      this.boundingSphere.makeEmpty();
      const positionAttribute = geometry.getAttribute("position");
      for (let i4 = 0; i4 < positionAttribute.count; i4++) {
        this.getVertexPosition(i4, _vertex);
        this.boundingSphere.expandByPoint(_vertex);
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.bindMode = source.bindMode;
      this.bindMatrix.copy(source.bindMatrix);
      this.bindMatrixInverse.copy(source.bindMatrixInverse);
      this.skeleton = source.skeleton;
      if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
      if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
      return this;
    }
    raycast(raycaster, intersects) {
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0) return;
      if (this.boundingSphere === null) this.computeBoundingSphere();
      _sphere$4.copy(this.boundingSphere);
      _sphere$4.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
      _inverseMatrix$2.copy(matrixWorld).invert();
      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
      if (this.boundingBox !== null) {
        if (_ray$2.intersectsBox(this.boundingBox) === false) return;
      }
      this._computeIntersections(raycaster, intersects, _ray$2);
    }
    getVertexPosition(index2, target) {
      super.getVertexPosition(index2, target);
      this.applyBoneTransform(index2, target);
      return target;
    }
    bind(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === void 0) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.copy(bindMatrix).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const vector = new Vector4();
      const skinWeight = this.geometry.attributes.skinWeight;
      for (let i4 = 0, l4 = skinWeight.count; i4 < l4; i4++) {
        vector.fromBufferAttribute(skinWeight, i4);
        const scale = 1 / vector.manhattanLength();
        if (scale !== Infinity) {
          vector.multiplyScalar(scale);
        } else {
          vector.set(1, 0, 0, 0);
        }
        skinWeight.setXYZW(i4, vector.x, vector.y, vector.z, vector.w);
      }
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      if (this.bindMode === AttachedBindMode) {
        this.bindMatrixInverse.copy(this.matrixWorld).invert();
      } else if (this.bindMode === DetachedBindMode) {
        this.bindMatrixInverse.copy(this.bindMatrix).invert();
      } else {
        console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
    }
    applyBoneTransform(index2, vector) {
      const skeleton = this.skeleton;
      const geometry = this.geometry;
      _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index2);
      _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index2);
      _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
      vector.set(0, 0, 0);
      for (let i4 = 0; i4 < 4; i4++) {
        const weight = _skinWeight.getComponent(i4);
        if (weight !== 0) {
          const boneIndex = _skinIndex.getComponent(i4);
          _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
          vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
        }
      }
      return vector.applyMatrix4(this.bindMatrixInverse);
    }
  };
  var Bone = class extends Object3D {
    constructor() {
      super();
      this.isBone = true;
      this.type = "Bone";
    }
  };
  var DataTexture = class extends Texture {
    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
      this.isDataTexture = true;
      this.image = { data, width, height };
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
    }
  };
  var _offsetMatrix = /* @__PURE__ */ new Matrix4();
  var _identityMatrix$1 = /* @__PURE__ */ new Matrix4();
  var Skeleton = class _Skeleton {
    constructor(bones = [], boneInverses = []) {
      this.uuid = generateUUID();
      this.bones = bones.slice(0);
      this.boneInverses = boneInverses;
      this.boneMatrices = null;
      this.boneTexture = null;
      this.init();
    }
    init() {
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      this.boneMatrices = new Float32Array(bones.length * 16);
      if (boneInverses.length === 0) {
        this.calculateInverses();
      } else {
        if (bones.length !== boneInverses.length) {
          console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
          this.boneInverses = [];
          for (let i4 = 0, il = this.bones.length; i4 < il; i4++) {
            this.boneInverses.push(new Matrix4());
          }
        }
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let i4 = 0, il = this.bones.length; i4 < il; i4++) {
        const inverse = new Matrix4();
        if (this.bones[i4]) {
          inverse.copy(this.bones[i4].matrixWorld).invert();
        }
        this.boneInverses.push(inverse);
      }
    }
    pose() {
      for (let i4 = 0, il = this.bones.length; i4 < il; i4++) {
        const bone = this.bones[i4];
        if (bone) {
          bone.matrixWorld.copy(this.boneInverses[i4]).invert();
        }
      }
      for (let i4 = 0, il = this.bones.length; i4 < il; i4++) {
        const bone = this.bones[i4];
        if (bone) {
          if (bone.parent && bone.parent.isBone) {
            bone.matrix.copy(bone.parent.matrixWorld).invert();
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    }
    update() {
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      const boneMatrices = this.boneMatrices;
      const boneTexture = this.boneTexture;
      for (let i4 = 0, il = bones.length; i4 < il; i4++) {
        const matrix = bones[i4] ? bones[i4].matrixWorld : _identityMatrix$1;
        _offsetMatrix.multiplyMatrices(matrix, boneInverses[i4]);
        _offsetMatrix.toArray(boneMatrices, i4 * 16);
      }
      if (boneTexture !== null) {
        boneTexture.needsUpdate = true;
      }
    }
    clone() {
      return new _Skeleton(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let size = Math.sqrt(this.bones.length * 4);
      size = Math.ceil(size / 4) * 4;
      size = Math.max(size, 4);
      const boneMatrices = new Float32Array(size * size * 4);
      boneMatrices.set(this.boneMatrices);
      const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
      boneTexture.needsUpdate = true;
      this.boneMatrices = boneMatrices;
      this.boneTexture = boneTexture;
      return this;
    }
    getBoneByName(name) {
      for (let i4 = 0, il = this.bones.length; i4 < il; i4++) {
        const bone = this.bones[i4];
        if (bone.name === name) {
          return bone;
        }
      }
      return void 0;
    }
    dispose() {
      if (this.boneTexture !== null) {
        this.boneTexture.dispose();
        this.boneTexture = null;
      }
    }
    fromJSON(json, bones) {
      this.uuid = json.uuid;
      for (let i4 = 0, l4 = json.bones.length; i4 < l4; i4++) {
        const uuid = json.bones[i4];
        let bone = bones[uuid];
        if (bone === void 0) {
          console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
          bone = new Bone();
        }
        this.bones.push(bone);
        this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i4]));
      }
      this.init();
      return this;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.6,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      data.uuid = this.uuid;
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      for (let i4 = 0, l4 = bones.length; i4 < l4; i4++) {
        const bone = bones[i4];
        data.bones.push(bone.uuid);
        const boneInverse = boneInverses[i4];
        data.boneInverses.push(boneInverse.toArray());
      }
      return data;
    }
  };
  var InstancedBufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized, meshPerAttribute = 1) {
      super(array, itemSize, normalized);
      this.isInstancedBufferAttribute = true;
      this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
      super.copy(source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.meshPerAttribute = this.meshPerAttribute;
      data.isInstancedBufferAttribute = true;
      return data;
    }
  };
  var _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
  var _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
  var _instanceIntersects = [];
  var _box3 = /* @__PURE__ */ new Box3();
  var _identity = /* @__PURE__ */ new Matrix4();
  var _mesh$1 = /* @__PURE__ */ new Mesh();
  var _sphere$3 = /* @__PURE__ */ new Sphere();
  var InstancedMesh = class extends Mesh {
    constructor(geometry, material, count) {
      super(geometry, material);
      this.isInstancedMesh = true;
      this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
      this.instanceColor = null;
      this.morphTexture = null;
      this.count = count;
      this.boundingBox = null;
      this.boundingSphere = null;
      for (let i4 = 0; i4 < count; i4++) {
        this.setMatrixAt(i4, _identity);
      }
    }
    computeBoundingBox() {
      const geometry = this.geometry;
      const count = this.count;
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      this.boundingBox.makeEmpty();
      for (let i4 = 0; i4 < count; i4++) {
        this.getMatrixAt(i4, _instanceLocalMatrix);
        _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
        this.boundingBox.union(_box3);
      }
    }
    computeBoundingSphere() {
      const geometry = this.geometry;
      const count = this.count;
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      if (geometry.boundingSphere === null) {
        geometry.computeBoundingSphere();
      }
      this.boundingSphere.makeEmpty();
      for (let i4 = 0; i4 < count; i4++) {
        this.getMatrixAt(i4, _instanceLocalMatrix);
        _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
        this.boundingSphere.union(_sphere$3);
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.instanceMatrix.copy(source.instanceMatrix);
      if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
      if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
      this.count = source.count;
      if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
      if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
      return this;
    }
    getColorAt(index2, color) {
      color.fromArray(this.instanceColor.array, index2 * 3);
    }
    getMatrixAt(index2, matrix) {
      matrix.fromArray(this.instanceMatrix.array, index2 * 16);
    }
    getMorphAt(index2, object) {
      const objectInfluences = object.morphTargetInfluences;
      const array = this.morphTexture.source.data.data;
      const len = objectInfluences.length + 1;
      const dataIndex = index2 * len + 1;
      for (let i4 = 0; i4 < objectInfluences.length; i4++) {
        objectInfluences[i4] = array[dataIndex + i4];
      }
    }
    raycast(raycaster, intersects) {
      const matrixWorld = this.matrixWorld;
      const raycastTimes = this.count;
      _mesh$1.geometry = this.geometry;
      _mesh$1.material = this.material;
      if (_mesh$1.material === void 0) return;
      if (this.boundingSphere === null) this.computeBoundingSphere();
      _sphere$3.copy(this.boundingSphere);
      _sphere$3.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
      for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
        this.getMatrixAt(instanceId, _instanceLocalMatrix);
        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
        _mesh$1.matrixWorld = _instanceWorldMatrix;
        _mesh$1.raycast(raycaster, _instanceIntersects);
        for (let i4 = 0, l4 = _instanceIntersects.length; i4 < l4; i4++) {
          const intersect = _instanceIntersects[i4];
          intersect.instanceId = instanceId;
          intersect.object = this;
          intersects.push(intersect);
        }
        _instanceIntersects.length = 0;
      }
    }
    setColorAt(index2, color) {
      if (this.instanceColor === null) {
        this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
      }
      color.toArray(this.instanceColor.array, index2 * 3);
    }
    setMatrixAt(index2, matrix) {
      matrix.toArray(this.instanceMatrix.array, index2 * 16);
    }
    setMorphAt(index2, object) {
      const objectInfluences = object.morphTargetInfluences;
      const len = objectInfluences.length + 1;
      if (this.morphTexture === null) {
        this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
      }
      const array = this.morphTexture.source.data.data;
      let morphInfluencesSum = 0;
      for (let i4 = 0; i4 < objectInfluences.length; i4++) {
        morphInfluencesSum += objectInfluences[i4];
      }
      const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      const dataIndex = len * index2;
      array[dataIndex] = morphBaseInfluence;
      array.set(objectInfluences, dataIndex + 1);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
      if (this.morphTexture !== null) {
        this.morphTexture.dispose();
        this.morphTexture = null;
      }
      return this;
    }
  };
  var LineBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isLineBasicMaterial = true;
      this.type = "LineBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.linewidth = 1;
      this.linecap = "round";
      this.linejoin = "round";
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      this.fog = source.fog;
      return this;
    }
  };
  var _vStart = /* @__PURE__ */ new Vector3();
  var _vEnd = /* @__PURE__ */ new Vector3();
  var _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
  var _ray$1 = /* @__PURE__ */ new Ray();
  var _sphere$1 = /* @__PURE__ */ new Sphere();
  var _intersectPointOnRay = /* @__PURE__ */ new Vector3();
  var _intersectPointOnSegment = /* @__PURE__ */ new Vector3();
  var Line = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
      super();
      this.isLine = true;
      this.type = "Line";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
    computeLineDistances() {
      const geometry = this.geometry;
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i4 = 1, l4 = positionAttribute.count; i4 < l4; i4++) {
          _vStart.fromBufferAttribute(positionAttribute, i4 - 1);
          _vEnd.fromBufferAttribute(positionAttribute, i4);
          lineDistances[i4] = lineDistances[i4 - 1];
          lineDistances[i4] += _vStart.distanceTo(_vEnd);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
      return this;
    }
    raycast(raycaster, intersects) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster.params.Line.threshold;
      const drawRange = geometry.drawRange;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$1.copy(geometry.boundingSphere);
      _sphere$1.applyMatrix4(matrixWorld);
      _sphere$1.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
      _inverseMatrix$1.copy(matrixWorld).invert();
      _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      const step = this.isLineSegments ? 2 : 1;
      const index2 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index2 !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index2.count, drawRange.start + drawRange.count);
        for (let i4 = start, l4 = end - 1; i4 < l4; i4 += step) {
          const a3 = index2.getX(i4);
          const b2 = index2.getX(i4 + 1);
          const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a3, b2);
          if (intersect) {
            intersects.push(intersect);
          }
        }
        if (this.isLineLoop) {
          const a3 = index2.getX(end - 1);
          const b2 = index2.getX(start);
          const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a3, b2);
          if (intersect) {
            intersects.push(intersect);
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i4 = start, l4 = end - 1; i4 < l4; i4 += step) {
          const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i4, i4 + 1);
          if (intersect) {
            intersects.push(intersect);
          }
        }
        if (this.isLineLoop) {
          const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start);
          if (intersect) {
            intersects.push(intersect);
          }
        }
      }
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    }
  };
  function checkIntersection(object, raycaster, ray, thresholdSq, a3, b2) {
    const positionAttribute = object.geometry.attributes.position;
    _vStart.fromBufferAttribute(positionAttribute, a3);
    _vEnd.fromBufferAttribute(positionAttribute, b2);
    const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
    if (distSq > thresholdSq) return;
    _intersectPointOnRay.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
    if (distance < raycaster.near || distance > raycaster.far) return;
    return {
      distance,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
      index: a3,
      face: null,
      faceIndex: null,
      object
    };
  }
  var _start = /* @__PURE__ */ new Vector3();
  var _end = /* @__PURE__ */ new Vector3();
  var LineSegments = class extends Line {
    constructor(geometry, material) {
      super(geometry, material);
      this.isLineSegments = true;
      this.type = "LineSegments";
    }
    computeLineDistances() {
      const geometry = this.geometry;
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i4 = 0, l4 = positionAttribute.count; i4 < l4; i4 += 2) {
          _start.fromBufferAttribute(positionAttribute, i4);
          _end.fromBufferAttribute(positionAttribute, i4 + 1);
          lineDistances[i4] = i4 === 0 ? 0 : lineDistances[i4 - 1];
          lineDistances[i4 + 1] = lineDistances[i4] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
      return this;
    }
  };
  var LineLoop = class extends Line {
    constructor(geometry, material) {
      super(geometry, material);
      this.isLineLoop = true;
      this.type = "LineLoop";
    }
  };
  var PointsMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isPointsMaterial = true;
      this.type = "PointsMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      this.fog = source.fog;
      return this;
    }
  };
  var _inverseMatrix = /* @__PURE__ */ new Matrix4();
  var _ray = /* @__PURE__ */ new Ray();
  var _sphere = /* @__PURE__ */ new Sphere();
  var _position$2 = /* @__PURE__ */ new Vector3();
  var Points = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
      super();
      this.isPoints = true;
      this.type = "Points";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
      this.geometry = source.geometry;
      return this;
    }
    raycast(raycaster, intersects) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster.params.Points.threshold;
      const drawRange = geometry.drawRange;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere);
      _sphere.applyMatrix4(matrixWorld);
      _sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere) === false) return;
      _inverseMatrix.copy(matrixWorld).invert();
      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      const index2 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index2 !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index2.count, drawRange.start + drawRange.count);
        for (let i4 = start, il = end; i4 < il; i4++) {
          const a3 = index2.getX(i4);
          _position$2.fromBufferAttribute(positionAttribute, a3);
          testPoint(_position$2, a3, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i4 = start, l4 = end; i4 < l4; i4++) {
          _position$2.fromBufferAttribute(positionAttribute, i4);
          testPoint(_position$2, i4, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    }
  };
  function testPoint(point, index2, localThresholdSq, matrixWorld, raycaster, intersects, object) {
    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far) return;
      intersects.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index: index2,
        face: null,
        object
      });
    }
  }
  var CanvasTexture = class extends Texture {
    constructor(canvas2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      super(canvas2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.isCanvasTexture = true;
      this.needsUpdate = true;
    }
  };
  var RawShaderMaterial = class extends ShaderMaterial {
    constructor(parameters) {
      super(parameters);
      this.isRawShaderMaterial = true;
      this.type = "RawShaderMaterial";
    }
  };
  var MeshStandardMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.isMeshStandardMaterial = true;
      this.defines = { "STANDARD": "" };
      this.type = "MeshStandardMaterial";
      this.color = new Color(16777215);
      this.roughness = 1;
      this.metalness = 0;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.roughnessMap = null;
      this.metalnessMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapRotation = new Euler();
      this.envMapIntensity = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.flatShading = false;
      this.fog = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.defines = { "STANDARD": "" };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapRotation.copy(source.envMapRotation);
      this.envMapIntensity = source.envMapIntensity;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      this.fog = source.fog;
      return this;
    }
  };
  var MeshPhysicalMaterial = class extends MeshStandardMaterial {
    constructor(parameters) {
      super();
      this.isMeshPhysicalMaterial = true;
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.type = "MeshPhysicalMaterial";
      this.anisotropyRotation = 0;
      this.anisotropyMap = null;
      this.clearcoatMap = null;
      this.clearcoatRoughness = 0;
      this.clearcoatRoughnessMap = null;
      this.clearcoatNormalScale = new Vector2(1, 1);
      this.clearcoatNormalMap = null;
      this.ior = 1.5;
      Object.defineProperty(this, "reflectivity", {
        get: function() {
          return clamp3(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function(reflectivity) {
          this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
        }
      });
      this.iridescenceMap = null;
      this.iridescenceIOR = 1.3;
      this.iridescenceThicknessRange = [100, 400];
      this.iridescenceThicknessMap = null;
      this.sheenColor = new Color(0);
      this.sheenColorMap = null;
      this.sheenRoughness = 1;
      this.sheenRoughnessMap = null;
      this.transmissionMap = null;
      this.thickness = 0;
      this.thicknessMap = null;
      this.attenuationDistance = Infinity;
      this.attenuationColor = new Color(1, 1, 1);
      this.specularIntensity = 1;
      this.specularIntensityMap = null;
      this.specularColor = new Color(1, 1, 1);
      this.specularColorMap = null;
      this._anisotropy = 0;
      this._clearcoat = 0;
      this._dispersion = 0;
      this._iridescence = 0;
      this._sheen = 0;
      this._transmission = 0;
      this.setValues(parameters);
    }
    get anisotropy() {
      return this._anisotropy;
    }
    set anisotropy(value) {
      if (this._anisotropy > 0 !== value > 0) {
        this.version++;
      }
      this._anisotropy = value;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(value) {
      if (this._clearcoat > 0 !== value > 0) {
        this.version++;
      }
      this._clearcoat = value;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(value) {
      if (this._iridescence > 0 !== value > 0) {
        this.version++;
      }
      this._iridescence = value;
    }
    get dispersion() {
      return this._dispersion;
    }
    set dispersion(value) {
      if (this._dispersion > 0 !== value > 0) {
        this.version++;
      }
      this._dispersion = value;
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(value) {
      if (this._sheen > 0 !== value > 0) {
        this.version++;
      }
      this._sheen = value;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(value) {
      if (this._transmission > 0 !== value > 0) {
        this.version++;
      }
      this._transmission = value;
    }
    copy(source) {
      super.copy(source);
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.anisotropy = source.anisotropy;
      this.anisotropyRotation = source.anisotropyRotation;
      this.anisotropyMap = source.anisotropyMap;
      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.dispersion = source.dispersion;
      this.ior = source.ior;
      this.iridescence = source.iridescence;
      this.iridescenceMap = source.iridescenceMap;
      this.iridescenceIOR = source.iridescenceIOR;
      this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
      this.iridescenceThicknessMap = source.iridescenceThicknessMap;
      this.sheen = source.sheen;
      this.sheenColor.copy(source.sheenColor);
      this.sheenColorMap = source.sheenColorMap;
      this.sheenRoughness = source.sheenRoughness;
      this.sheenRoughnessMap = source.sheenRoughnessMap;
      this.transmission = source.transmission;
      this.transmissionMap = source.transmissionMap;
      this.thickness = source.thickness;
      this.thicknessMap = source.thicknessMap;
      this.attenuationDistance = source.attenuationDistance;
      this.attenuationColor.copy(source.attenuationColor);
      this.specularIntensity = source.specularIntensity;
      this.specularIntensityMap = source.specularIntensityMap;
      this.specularColor.copy(source.specularColor);
      this.specularColorMap = source.specularColorMap;
      return this;
    }
  };
  function convertArray(array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  }
  function isTypedArray(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  }
  function getKeyframeOrder(times) {
    function compareTime(i4, j2) {
      return times[i4] - times[j2];
    }
    const n4 = times.length;
    const result = new Array(n4);
    for (let i4 = 0; i4 !== n4; ++i4) result[i4] = i4;
    result.sort(compareTime);
    return result;
  }
  function sortedArray(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i4 = 0, dstOffset = 0; dstOffset !== nValues; ++i4) {
      const srcOffset = order[i4] * stride;
      for (let j2 = 0; j2 !== stride; ++j2) {
        result[dstOffset++] = values[srcOffset + j2];
      }
    }
    return result;
  }
  function flattenJSON(jsonKeys, times, values, valuePropertyName) {
    let i4 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i4++];
    }
    if (key === void 0) return;
    let value = key[valuePropertyName];
    if (value === void 0) return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i4++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i4++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i4++];
      } while (key !== void 0);
    }
  }
  var Interpolant = class {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;
      this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;
      this.settings = null;
      this.DefaultSettings_ = {};
    }
    evaluate(t3) {
      const pp = this.parameterPositions;
      let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          let right;
          linear_scan: {
            forward_scan: if (!(t3 < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t3 < t0) break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.copySampleValue_(i1 - 1);
                }
                if (i1 === giveUpAt) break;
                t0 = t1;
                t1 = pp[++i1];
                if (t3 < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
            if (!(t3 >= t0)) {
              const t1global = pp[1];
              if (t3 < t1global) {
                i1 = 2;
                t0 = t1global;
              }
              for (let giveUpAt = i1 - 2; ; ) {
                if (t0 === void 0) {
                  this._cachedIndex = 0;
                  return this.copySampleValue_(0);
                }
                if (i1 === giveUpAt) break;
                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t3 >= t0) {
                  break seek;
                }
              }
              right = i1;
              i1 = 0;
              break linear_scan;
            }
            break validate_interval;
          }
          while (i1 < right) {
            const mid = i1 + right >>> 1;
            if (t3 < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];
          if (t0 === void 0) {
            this._cachedIndex = 0;
            return this.copySampleValue_(0);
          }
          if (t1 === void 0) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.copySampleValue_(i1 - 1);
          }
        }
        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }
      return this.interpolate_(i1, t0, t3, t1);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(index2) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset2 = index2 * stride;
      for (let i4 = 0; i4 !== stride; ++i4) {
        result[i4] = values[offset2 + i4];
      }
      return result;
    }
    // Template methods for derived classes:
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  };
  var CubicInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      this._weightPrev = -0;
      this._offsetPrev = -0;
      this._weightNext = -0;
      this._offsetNext = -0;
      this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
    }
    intervalChanged_(i1, t0, t1) {
      const pp = this.parameterPositions;
      let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
      if (tPrev === void 0) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === void 0) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    }
    interpolate_(i1, t0, t3, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t3 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
      const sP = -wP * ppp + 2 * wP * pp - wP * p2;
      const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
      const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
      const sN = wN * ppp - wN * pp;
      for (let i4 = 0; i4 !== stride; ++i4) {
        result[i4] = sP * values[oP + i4] + s0 * values[o0 + i4] + s1 * values[o1 + i4] + sN * values[oN + i4];
      }
      return result;
    }
  };
  var LinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t3, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t3 - t0) / (t1 - t0), weight0 = 1 - weight1;
      for (let i4 = 0; i4 !== stride; ++i4) {
        result[i4] = values[offset0 + i4] * weight0 + values[offset1 + i4] * weight1;
      }
      return result;
    }
  };
  var DiscreteInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  };
  var KeyframeTrack = class {
    constructor(name, times, values, interpolation) {
      if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
      this.name = name;
      this.times = convertArray(times, this.TimeBufferType);
      this.values = convertArray(values, this.ValueBufferType);
      this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    static toJSON(track) {
      const trackType = track.constructor;
      let json;
      if (trackType.toJSON !== this.toJSON) {
        json = trackType.toJSON(track);
      } else {
        json = {
          "name": track.name,
          "times": convertArray(track.times, Array),
          "values": convertArray(track.values, Array)
        };
        const interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName;
      return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
      let factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === void 0) {
        const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }
        console.warn("THREE.KeyframeTrack:", message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    // move all keyframes either forwards or backwards in time
    shift(timeOffset) {
      if (timeOffset !== 0) {
        const times = this.times;
        for (let i4 = 0, n4 = times.length; i4 !== n4; ++i4) {
          times[i4] += timeOffset;
        }
      }
      return this;
    }
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale(timeScale) {
      if (timeScale !== 1) {
        const times = this.times;
        for (let i4 = 0, n4 = times.length; i4 !== n4; ++i4) {
          times[i4] *= timeScale;
        }
      }
      return this;
    }
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim(startTime, endTime) {
      const times = this.times, nKeys = times.length;
      let from = 0, to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to;
      if (from !== 0 || to !== nKeys) {
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }
        const stride = this.getValueSize();
        this.times = times.slice(from, to);
        this.values = this.values.slice(from * stride, to * stride);
      }
      return this;
    }
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate() {
      let valid = true;
      const valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
        valid = false;
      }
      const times = this.times, values = this.values, nKeys = times.length;
      if (nKeys === 0) {
        console.error("THREE.KeyframeTrack: Track is empty.", this);
        valid = false;
      }
      let prevTime = null;
      for (let i4 = 0; i4 !== nKeys; i4++) {
        const currTime = times[i4];
        if (typeof currTime === "number" && isNaN(currTime)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i4, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, i4, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== void 0) {
        if (isTypedArray(values)) {
          for (let i4 = 0, n4 = values.length; i4 !== n4; ++i4) {
            const value = values[i4];
            if (isNaN(value)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i4, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    }
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize() {
      const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
      let writeIndex = 1;
      for (let i4 = 1; i4 < lastIndex; ++i4) {
        let keep = false;
        const time = times[i4];
        const timeNext = times[i4 + 1];
        if (time !== timeNext && (i4 !== 1 || time !== times[0])) {
          if (!smoothInterpolation) {
            const offset2 = i4 * stride, offsetP = offset2 - stride, offsetN = offset2 + stride;
            for (let j2 = 0; j2 !== stride; ++j2) {
              const value = values[offset2 + j2];
              if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }
        if (keep) {
          if (i4 !== writeIndex) {
            times[writeIndex] = times[i4];
            const readOffset = i4 * stride, writeOffset = writeIndex * stride;
            for (let j2 = 0; j2 !== stride; ++j2) {
              values[writeOffset + j2] = values[readOffset + j2];
            }
          }
          ++writeIndex;
        }
      }
      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
          values[writeOffset + j2] = values[readOffset + j2];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = times.slice(0, writeIndex);
        this.values = values.slice(0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }
      return this;
    }
    clone() {
      const times = this.times.slice();
      const values = this.values.slice();
      const TypedKeyframeTrack = this.constructor;
      const track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  };
  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  var BooleanKeyframeTrack = class extends KeyframeTrack {
    // No interpolation parameter because only InterpolateDiscrete is valid.
    constructor(name, times, values) {
      super(name, times, values);
    }
  };
  BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var ColorKeyframeTrack = class extends KeyframeTrack {
  };
  ColorKeyframeTrack.prototype.ValueTypeName = "color";
  var NumberKeyframeTrack = class extends KeyframeTrack {
  };
  NumberKeyframeTrack.prototype.ValueTypeName = "number";
  var QuaternionLinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t3, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t3 - t0) / (t1 - t0);
      let offset2 = i1 * stride;
      for (let end = offset2 + stride; offset2 !== end; offset2 += 4) {
        Quaternion.slerpFlat(result, 0, values, offset2 - stride, values, offset2, alpha);
      }
      return result;
    }
  };
  var QuaternionKeyframeTrack = class extends KeyframeTrack {
    InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  };
  QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var StringKeyframeTrack = class extends KeyframeTrack {
    // No interpolation parameter because only InterpolateDiscrete is valid.
    constructor(name, times, values) {
      super(name, times, values);
    }
  };
  StringKeyframeTrack.prototype.ValueTypeName = "string";
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var VectorKeyframeTrack = class extends KeyframeTrack {
  };
  VectorKeyframeTrack.prototype.ValueTypeName = "vector";
  var AnimationClip = class {
    constructor(name = "", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
      this.name = name;
      this.tracks = tracks;
      this.duration = duration;
      this.blendMode = blendMode;
      this.uuid = generateUUID();
      if (this.duration < 0) {
        this.resetDuration();
      }
    }
    static parse(json) {
      const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
      for (let i4 = 0, n4 = jsonTracks.length; i4 !== n4; ++i4) {
        tracks.push(parseKeyframeTrack(jsonTracks[i4]).scale(frameTime));
      }
      const clip = new this(json.name, json.duration, tracks, json.blendMode);
      clip.uuid = json.uuid;
      return clip;
    }
    static toJSON(clip) {
      const tracks = [], clipTracks = clip.tracks;
      const json = {
        "name": clip.name,
        "duration": clip.duration,
        "tracks": tracks,
        "uuid": clip.uuid,
        "blendMode": clip.blendMode
      };
      for (let i4 = 0, n4 = clipTracks.length; i4 !== n4; ++i4) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[i4]));
      }
      return json;
    }
    static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
      const numMorphTargets = morphTargetSequence.length;
      const tracks = [];
      for (let i4 = 0; i4 < numMorphTargets; i4++) {
        let times = [];
        let values = [];
        times.push(
          (i4 + numMorphTargets - 1) % numMorphTargets,
          i4,
          (i4 + 1) % numMorphTargets
        );
        values.push(0, 1, 0);
        const order = getKeyframeOrder(times);
        times = sortedArray(times, 1, order);
        values = sortedArray(values, 1, order);
        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }
        tracks.push(
          new NumberKeyframeTrack(
            ".morphTargetInfluences[" + morphTargetSequence[i4].name + "]",
            times,
            values
          ).scale(1 / fps)
        );
      }
      return new this(name, -1, tracks);
    }
    static findByName(objectOrClipArray, name) {
      let clipArray = objectOrClipArray;
      if (!Array.isArray(objectOrClipArray)) {
        const o4 = objectOrClipArray;
        clipArray = o4.geometry && o4.geometry.animations || o4.animations;
      }
      for (let i4 = 0; i4 < clipArray.length; i4++) {
        if (clipArray[i4].name === name) {
          return clipArray[i4];
        }
      }
      return null;
    }
    static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
      const animationToMorphTargets = {};
      const pattern = /^([\w-]*?)([\d]+)$/;
      for (let i4 = 0, il = morphTargets.length; i4 < il; i4++) {
        const morphTarget = morphTargets[i4];
        const parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          const name = parts[1];
          let animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      const clips = [];
      for (const name in animationToMorphTargets) {
        clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
      }
      return clips;
    }
    // parse the animation.hierarchy format
    static parseAnimation(animation, bones) {
      if (!animation) {
        console.error("THREE.AnimationClip: No animation in JSONLoader data.");
        return null;
      }
      const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
        if (animationKeys.length !== 0) {
          const times = [];
          const values = [];
          flattenJSON(animationKeys, times, values, propertyName);
          if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
          }
        }
      };
      const tracks = [];
      const clipName = animation.name || "default";
      const fps = animation.fps || 30;
      const blendMode = animation.blendMode;
      let duration = animation.length || -1;
      const hierarchyTracks = animation.hierarchy || [];
      for (let h4 = 0; h4 < hierarchyTracks.length; h4++) {
        const animationKeys = hierarchyTracks[h4].keys;
        if (!animationKeys || animationKeys.length === 0) continue;
        if (animationKeys[0].morphTargets) {
          const morphTargetNames = {};
          let k2;
          for (k2 = 0; k2 < animationKeys.length; k2++) {
            if (animationKeys[k2].morphTargets) {
              for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
                morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
              }
            }
          }
          for (const morphTargetName in morphTargetNames) {
            const times = [];
            const values = [];
            for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
              const animationKey = animationKeys[k2];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
          }
          duration = morphTargetNames.length * fps;
        } else {
          const boneName = ".bones[" + bones[h4].name + "]";
          addNonemptyTrack(
            VectorKeyframeTrack,
            boneName + ".position",
            animationKeys,
            "pos",
            tracks
          );
          addNonemptyTrack(
            QuaternionKeyframeTrack,
            boneName + ".quaternion",
            animationKeys,
            "rot",
            tracks
          );
          addNonemptyTrack(
            VectorKeyframeTrack,
            boneName + ".scale",
            animationKeys,
            "scl",
            tracks
          );
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      const clip = new this(clipName, duration, tracks, blendMode);
      return clip;
    }
    resetDuration() {
      const tracks = this.tracks;
      let duration = 0;
      for (let i4 = 0, n4 = tracks.length; i4 !== n4; ++i4) {
        const track = this.tracks[i4];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }
      this.duration = duration;
      return this;
    }
    trim() {
      for (let i4 = 0; i4 < this.tracks.length; i4++) {
        this.tracks[i4].trim(0, this.duration);
      }
      return this;
    }
    validate() {
      let valid = true;
      for (let i4 = 0; i4 < this.tracks.length; i4++) {
        valid = valid && this.tracks[i4].validate();
      }
      return valid;
    }
    optimize() {
      for (let i4 = 0; i4 < this.tracks.length; i4++) {
        this.tracks[i4].optimize();
      }
      return this;
    }
    clone() {
      const tracks = [];
      for (let i4 = 0; i4 < this.tracks.length; i4++) {
        tracks.push(this.tracks[i4].clone());
      }
      return new this.constructor(this.name, this.duration, tracks, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  };
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      const times = [], values = [];
      flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  var Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
      if (this.enabled === false) return;
      this.files[key] = file;
    },
    get: function(key) {
      if (this.enabled === false) return;
      return this.files[key];
    },
    remove: function(key) {
      delete this.files[key];
    },
    clear: function() {
      this.files = {};
    }
  };
  var LoadingManager = class {
    constructor(onLoad, onProgress, onError) {
      const scope = this;
      let isLoading = false;
      let itemsLoaded = 0;
      let itemsTotal = 0;
      let urlModifier = void 0;
      const handlers = [];
      this.onStart = void 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== void 0) {
            scope.onStart(url, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== void 0) {
          scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== void 0) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url) {
        if (scope.onError !== void 0) {
          scope.onError(url);
        }
      };
      this.resolveURL = function(url) {
        if (urlModifier) {
          return urlModifier(url);
        }
        return url;
      };
      this.setURLModifier = function(transform2) {
        urlModifier = transform2;
        return this;
      };
      this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
      };
      this.removeHandler = function(regex) {
        const index2 = handlers.indexOf(regex);
        if (index2 !== -1) {
          handlers.splice(index2, 2);
        }
        return this;
      };
      this.getHandler = function(file) {
        for (let i4 = 0, l4 = handlers.length; i4 < l4; i4 += 2) {
          const regex = handlers[i4];
          const loader = handlers[i4 + 1];
          if (regex.global) regex.lastIndex = 0;
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      };
    }
  };
  var DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
  var Loader = class {
    constructor(manager) {
      this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
      this.crossOrigin = "anonymous";
      this.withCredentials = false;
      this.path = "";
      this.resourcePath = "";
      this.requestHeader = {};
    }
    load() {
    }
    loadAsync(url, onProgress) {
      const scope = this;
      return new Promise(function(resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    }
    parse() {
    }
    setCrossOrigin(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    }
    setWithCredentials(value) {
      this.withCredentials = value;
      return this;
    }
    setPath(path) {
      this.path = path;
      return this;
    }
    setResourcePath(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    }
    setRequestHeader(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  };
  Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
  var loading = {};
  var HttpError = class extends Error {
    constructor(message, response) {
      super(message);
      this.response = response;
    }
  };
  var FileLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      if (url === void 0) url = "";
      if (this.path !== void 0) url = this.path + url;
      url = this.manager.resolveURL(url);
      const cached = Cache.get(url);
      if (cached !== void 0) {
        this.manager.itemStart(url);
        setTimeout(() => {
          if (onLoad) onLoad(cached);
          this.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      if (loading[url] !== void 0) {
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        return;
      }
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      const req = new Request(url, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin"
        // An abort controller could be added within a future PR
      });
      const mimeType = this.mimeType;
      const responseType = this.responseType;
      fetch(req).then((response) => {
        if (response.status === 200 || response.status === 0) {
          if (response.status === 0) {
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          }
          if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
            return response;
          }
          const callbacks = loading[url];
          const reader = response.body.getReader();
          const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");
          const total = contentLength ? parseInt(contentLength) : 0;
          const lengthComputable = total !== 0;
          let loaded = 0;
          const stream = new ReadableStream({
            start(controller) {
              readData();
              function readData() {
                reader.read().then(({ done, value }) => {
                  if (done) {
                    controller.close();
                  } else {
                    loaded += value.byteLength;
                    const event2 = new ProgressEvent("progress", { lengthComputable, loaded, total });
                    for (let i4 = 0, il = callbacks.length; i4 < il; i4++) {
                      const callback = callbacks[i4];
                      if (callback.onProgress) callback.onProgress(event2);
                    }
                    controller.enqueue(value);
                    readData();
                  }
                }, (e4) => {
                  controller.error(e4);
                });
              }
            }
          });
          return new Response(stream);
        } else {
          throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
        }
      }).then((response) => {
        switch (responseType) {
          case "arraybuffer":
            return response.arrayBuffer();
          case "blob":
            return response.blob();
          case "document":
            return response.text().then((text2) => {
              const parser = new DOMParser();
              return parser.parseFromString(text2, mimeType);
            });
          case "json":
            return response.json();
          default:
            if (mimeType === void 0) {
              return response.text();
            } else {
              const re2 = /charset="?([^;"\s]*)"?/i;
              const exec = re2.exec(mimeType);
              const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
              const decoder = new TextDecoder(label);
              return response.arrayBuffer().then((ab) => decoder.decode(ab));
            }
        }
      }).then((data) => {
        Cache.add(url, data);
        const callbacks = loading[url];
        delete loading[url];
        for (let i4 = 0, il = callbacks.length; i4 < il; i4++) {
          const callback = callbacks[i4];
          if (callback.onLoad) callback.onLoad(data);
        }
      }).catch((err) => {
        const callbacks = loading[url];
        if (callbacks === void 0) {
          this.manager.itemError(url);
          throw err;
        }
        delete loading[url];
        for (let i4 = 0, il = callbacks.length; i4 < il; i4++) {
          const callback = callbacks[i4];
          if (callback.onError) callback.onError(err);
        }
        this.manager.itemError(url);
      }).finally(() => {
        this.manager.itemEnd(url);
      });
      this.manager.itemStart(url);
    }
    setResponseType(value) {
      this.responseType = value;
      return this;
    }
    setMimeType(value) {
      this.mimeType = value;
      return this;
    }
  };
  var ImageLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      if (this.path !== void 0) url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const image2 = createElementNS("img");
      function onImageLoad() {
        removeEventListeners();
        Cache.add(url, this);
        if (onLoad) onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event2) {
        removeEventListeners();
        if (onError) onError(event2);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      function removeEventListeners() {
        image2.removeEventListener("load", onImageLoad, false);
        image2.removeEventListener("error", onImageError, false);
      }
      image2.addEventListener("load", onImageLoad, false);
      image2.addEventListener("error", onImageError, false);
      if (url.slice(0, 5) !== "data:") {
        if (this.crossOrigin !== void 0) image2.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image2.src = url;
      return image2;
    }
  };
  var TextureLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const texture = new Texture();
      const loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function(image2) {
        texture.image = image2;
        texture.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  };
  var Light = class extends Object3D {
    constructor(color, intensity = 1) {
      super();
      this.isLight = true;
      this.type = "Light";
      this.color = new Color(color);
      this.intensity = intensity;
    }
    dispose() {
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== void 0) data.object.distance = this.distance;
      if (this.angle !== void 0) data.object.angle = this.angle;
      if (this.decay !== void 0) data.object.decay = this.decay;
      if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
      if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
      return data;
    }
  };
  var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
  var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
  var _lookTarget$1 = /* @__PURE__ */ new Vector3();
  var LightShadow = class {
    constructor(camera) {
      this.camera = camera;
      this.bias = 0;
      this.normalBias = 0;
      this.radius = 1;
      this.blurSamples = 8;
      this.mapSize = new Vector2(512, 512);
      this.map = null;
      this.mapPass = null;
      this.matrix = new Matrix4();
      this.autoUpdate = true;
      this.needsUpdate = false;
      this._frustum = new Frustum();
      this._frameExtents = new Vector2(1, 1);
      this._viewportCount = 1;
      this._viewports = [
        new Vector4(0, 0, 1, 1)
      ];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(light) {
      const shadowCamera = this.camera;
      const shadowMatrix = this.matrix;
      _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld$1);
      _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
      shadowCamera.lookAt(_lookTarget$1);
      shadowCamera.updateMatrixWorld();
      _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
      shadowMatrix.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      );
      shadowMatrix.multiply(_projScreenMatrix$1);
    }
    getViewport(viewportIndex) {
      return this._viewports[viewportIndex];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      if (this.map) {
        this.map.dispose();
      }
      if (this.mapPass) {
        this.mapPass.dispose();
      }
    }
    copy(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const object = {};
      if (this.bias !== 0) object.bias = this.bias;
      if (this.normalBias !== 0) object.normalBias = this.normalBias;
      if (this.radius !== 1) object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  };
  var SpotLightShadow = class extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(50, 1, 0.5, 500));
      this.isSpotLightShadow = true;
      this.focus = 1;
    }
    updateMatrices(light) {
      const camera = this.camera;
      const fov2 = RAD2DEG * 2 * light.angle * this.focus;
      const aspect2 = this.mapSize.width / this.mapSize.height;
      const far = light.distance || camera.far;
      if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
        camera.fov = fov2;
        camera.aspect = aspect2;
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      super.updateMatrices(light);
    }
    copy(source) {
      super.copy(source);
      this.focus = source.focus;
      return this;
    }
  };
  var SpotLight = class extends Light {
    constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
      super(color, intensity);
      this.isSpotLight = true;
      this.type = "SpotLight";
      this.position.copy(Object3D.DEFAULT_UP);
      this.updateMatrix();
      this.target = new Object3D();
      this.distance = distance;
      this.angle = angle;
      this.penumbra = penumbra;
      this.decay = decay;
      this.map = null;
      this.shadow = new SpotLightShadow();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(power) {
      this.intensity = power / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
  var _lightPositionWorld = /* @__PURE__ */ new Vector3();
  var _lookTarget = /* @__PURE__ */ new Vector3();
  var PointLightShadow = class extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(90, 1, 0.5, 500));
      this.isPointLightShadow = true;
      this._frameExtents = new Vector2(4, 2);
      this._viewportCount = 6;
      this._viewports = [
        // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction
        // positive X
        new Vector4(2, 1, 1, 1),
        // negative X
        new Vector4(0, 1, 1, 1),
        // positive Z
        new Vector4(3, 1, 1, 1),
        // negative Z
        new Vector4(1, 1, 1, 1),
        // positive Y
        new Vector4(3, 0, 1, 1),
        // negative Y
        new Vector4(1, 0, 1, 1)
      ];
      this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0)
      ];
      this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
      ];
    }
    updateMatrices(light, viewportIndex = 0) {
      const camera = this.camera;
      const shadowMatrix = this.matrix;
      const far = light.distance || camera.far;
      if (far !== camera.far) {
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      camera.position.copy(_lightPositionWorld);
      _lookTarget.copy(camera.position);
      _lookTarget.add(this._cubeDirections[viewportIndex]);
      camera.up.copy(this._cubeUps[viewportIndex]);
      camera.lookAt(_lookTarget);
      camera.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
  };
  var PointLight = class extends Light {
    constructor(color, intensity, distance = 0, decay = 2) {
      super(color, intensity);
      this.isPointLight = true;
      this.type = "PointLight";
      this.distance = distance;
      this.decay = decay;
      this.shadow = new PointLightShadow();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(power) {
      this.intensity = power / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  var DirectionalLightShadow = class extends LightShadow {
    constructor() {
      super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
      this.isDirectionalLightShadow = true;
    }
  };
  var DirectionalLight = class extends Light {
    constructor(color, intensity) {
      super(color, intensity);
      this.isDirectionalLight = true;
      this.type = "DirectionalLight";
      this.position.copy(Object3D.DEFAULT_UP);
      this.updateMatrix();
      this.target = new Object3D();
      this.shadow = new DirectionalLightShadow();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source) {
      super.copy(source);
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  var AmbientLight = class extends Light {
    constructor(color, intensity) {
      super(color, intensity);
      this.isAmbientLight = true;
      this.type = "AmbientLight";
    }
  };
  var LoaderUtils = class {
    static decodeText(array) {
      console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.");
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      }
      let s4 = "";
      for (let i4 = 0, il = array.length; i4 < il; i4++) {
        s4 += String.fromCharCode(array[i4]);
      }
      try {
        return decodeURIComponent(escape(s4));
      } catch (e4) {
        return s4;
      }
    }
    static extractUrlBase(url) {
      const index2 = url.lastIndexOf("/");
      if (index2 === -1) return "./";
      return url.slice(0, index2 + 1);
    }
    static resolveURL(url, path) {
      if (typeof url !== "string" || url === "") return "";
      if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
        path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
      }
      if (/^(https?:)?\/\//i.test(url)) return url;
      if (/^data:.*,.*$/i.test(url)) return url;
      if (/^blob:.*$/i.test(url)) return url;
      return path + url;
    }
  };
  var ImageBitmapLoader = class extends Loader {
    constructor(manager) {
      super(manager);
      this.isImageBitmapLoader = true;
      if (typeof createImageBitmap === "undefined") {
        console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
      }
      if (typeof fetch === "undefined") {
        console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
      }
      this.options = { premultiplyAlpha: "none" };
    }
    setOptions(options) {
      this.options = options;
      return this;
    }
    load(url, onLoad, onProgress, onError) {
      if (url === void 0) url = "";
      if (this.path !== void 0) url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        if (cached.then) {
          cached.then((imageBitmap) => {
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          }).catch((e4) => {
            if (onError) onError(e4);
          });
          return;
        }
        setTimeout(function() {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const fetchOptions = {};
      fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
      fetchOptions.headers = this.requestHeader;
      const promise = fetch(url, fetchOptions).then(function(res) {
        return res.blob();
      }).then(function(blob) {
        return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
      }).then(function(imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad) onLoad(imageBitmap);
        scope.manager.itemEnd(url);
        return imageBitmap;
      }).catch(function(e4) {
        if (onError) onError(e4);
        Cache.remove(url);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      Cache.add(url, promise);
      scope.manager.itemStart(url);
    }
  };
  var Clock = class {
    constructor(autoStart = true) {
      this.autoStart = autoStart;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }
    start() {
      this.startTime = now2();
      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;
    }
    stop() {
      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;
    }
    getElapsedTime() {
      this.getDelta();
      return this.elapsedTime;
    }
    getDelta() {
      let diff = 0;
      if (this.autoStart && !this.running) {
        this.start();
        return 0;
      }
      if (this.running) {
        const newTime = now2();
        diff = (newTime - this.oldTime) / 1e3;
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }
      return diff;
    }
  };
  function now2() {
    return (typeof performance === "undefined" ? Date : performance).now();
  }
  var PropertyMixer = class {
    constructor(binding, typeName, valueSize) {
      this.binding = binding;
      this.valueSize = valueSize;
      let mixFunction, mixFunctionAdditive, setIdentity;
      switch (typeName) {
        case "quaternion":
          mixFunction = this._slerp;
          mixFunctionAdditive = this._slerpAdditive;
          setIdentity = this._setAdditiveIdentityQuaternion;
          this.buffer = new Float64Array(valueSize * 6);
          this._workIndex = 5;
          break;
        case "string":
        case "bool":
          mixFunction = this._select;
          mixFunctionAdditive = this._select;
          setIdentity = this._setAdditiveIdentityOther;
          this.buffer = new Array(valueSize * 5);
          break;
        default:
          mixFunction = this._lerp;
          mixFunctionAdditive = this._lerpAdditive;
          setIdentity = this._setAdditiveIdentityNumeric;
          this.buffer = new Float64Array(valueSize * 5);
      }
      this._mixBufferRegion = mixFunction;
      this._mixBufferRegionAdditive = mixFunctionAdditive;
      this._setIdentity = setIdentity;
      this._origIndex = 3;
      this._addIndex = 4;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      this.useCount = 0;
      this.referenceCount = 0;
    }
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate(accuIndex, weight) {
      const buffer = this.buffer, stride = this.valueSize, offset2 = accuIndex * stride + stride;
      let currentWeight = this.cumulativeWeight;
      if (currentWeight === 0) {
        for (let i4 = 0; i4 !== stride; ++i4) {
          buffer[offset2 + i4] = buffer[i4];
        }
        currentWeight = weight;
      } else {
        currentWeight += weight;
        const mix = weight / currentWeight;
        this._mixBufferRegion(buffer, offset2, 0, mix, stride);
      }
      this.cumulativeWeight = currentWeight;
    }
    // accumulate data in the 'incoming' region into 'add'
    accumulateAdditive(weight) {
      const buffer = this.buffer, stride = this.valueSize, offset2 = stride * this._addIndex;
      if (this.cumulativeWeightAdditive === 0) {
        this._setIdentity();
      }
      this._mixBufferRegionAdditive(buffer, offset2, 0, weight, stride);
      this.cumulativeWeightAdditive += weight;
    }
    // apply the state of 'accu<i>' to the binding when accus differ
    apply(accuIndex) {
      const stride = this.valueSize, buffer = this.buffer, offset2 = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      if (weight < 1) {
        const originalValueOffset = stride * this._origIndex;
        this._mixBufferRegion(
          buffer,
          offset2,
          originalValueOffset,
          1 - weight,
          stride
        );
      }
      if (weightAdditive > 0) {
        this._mixBufferRegionAdditive(buffer, offset2, this._addIndex * stride, 1, stride);
      }
      for (let i4 = stride, e4 = stride + stride; i4 !== e4; ++i4) {
        if (buffer[i4] !== buffer[i4 + stride]) {
          binding.setValue(buffer, offset2);
          break;
        }
      }
    }
    // remember the state of the bound property and copy it to both accus
    saveOriginalState() {
      const binding = this.binding;
      const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
      binding.getValue(buffer, originalValueOffset);
      for (let i4 = stride, e4 = originalValueOffset; i4 !== e4; ++i4) {
        buffer[i4] = buffer[originalValueOffset + i4 % stride];
      }
      this._setIdentity();
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
    }
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState() {
      const originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    }
    _setAdditiveIdentityNumeric() {
      const startIndex = this._addIndex * this.valueSize;
      const endIndex = startIndex + this.valueSize;
      for (let i4 = startIndex; i4 < endIndex; i4++) {
        this.buffer[i4] = 0;
      }
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric();
      this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const startIndex = this._origIndex * this.valueSize;
      const targetIndex = this._addIndex * this.valueSize;
      for (let i4 = 0; i4 < this.valueSize; i4++) {
        this.buffer[targetIndex + i4] = this.buffer[startIndex + i4];
      }
    }
    // mix functions
    _select(buffer, dstOffset, srcOffset, t3, stride) {
      if (t3 >= 0.5) {
        for (let i4 = 0; i4 !== stride; ++i4) {
          buffer[dstOffset + i4] = buffer[srcOffset + i4];
        }
      }
    }
    _slerp(buffer, dstOffset, srcOffset, t3) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t3);
    }
    _slerpAdditive(buffer, dstOffset, srcOffset, t3, stride) {
      const workOffset = this._workIndex * stride;
      Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t3);
    }
    _lerp(buffer, dstOffset, srcOffset, t3, stride) {
      const s4 = 1 - t3;
      for (let i4 = 0; i4 !== stride; ++i4) {
        const j2 = dstOffset + i4;
        buffer[j2] = buffer[j2] * s4 + buffer[srcOffset + i4] * t3;
      }
    }
    _lerpAdditive(buffer, dstOffset, srcOffset, t3, stride) {
      for (let i4 = 0; i4 !== stride; ++i4) {
        const j2 = dstOffset + i4;
        buffer[j2] = buffer[j2] + buffer[srcOffset + i4] * t3;
      }
    }
  };
  var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
  var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
  var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
  var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
  var _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
  var _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
  var _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
  var _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
  var _trackRe = new RegExp(
    "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
  );
  var _supportedObjectNames = ["material", "materials", "bones", "map"];
  var Composite = class {
    constructor(targetGroup, path, optionalParsedPath) {
      const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    getValue(array, offset2) {
      this.bind();
      const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
      if (binding !== void 0) binding.getValue(array, offset2);
    }
    setValue(array, offset2) {
      const bindings = this._bindings;
      for (let i4 = this._targetGroup.nCachedObjects_, n4 = bindings.length; i4 !== n4; ++i4) {
        bindings[i4].setValue(array, offset2);
      }
    }
    bind() {
      const bindings = this._bindings;
      for (let i4 = this._targetGroup.nCachedObjects_, n4 = bindings.length; i4 !== n4; ++i4) {
        bindings[i4].bind();
      }
    }
    unbind() {
      const bindings = this._bindings;
      for (let i4 = this._targetGroup.nCachedObjects_, n4 = bindings.length; i4 !== n4; ++i4) {
        bindings[i4].unbind();
      }
    }
  };
  var PropertyBinding = class _PropertyBinding {
    constructor(rootNode, path, parsedPath) {
      this.path = path;
      this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
      this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
      this.rootNode = rootNode;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
    static create(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new _PropertyBinding(root, path, parsedPath);
      } else {
        return new _PropertyBinding.Composite(root, path, parsedPath);
      }
    }
    /**
     * Replaces spaces with underscores and removes unsupported characters from
     * node names, to ensure compatibility with parseTrackName().
     *
     * @param {string} name Node name to be sanitized.
     * @return {string}
     */
    static sanitizeNodeName(name) {
      return name.replace(/\s/g, "_").replace(_reservedRe, "");
    }
    static parseTrackName(trackName) {
      const matches2 = _trackRe.exec(trackName);
      if (matches2 === null) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      const results = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: matches2[2],
        objectName: matches2[3],
        objectIndex: matches2[4],
        propertyName: matches2[5],
        // required
        propertyIndex: matches2[6]
      };
      const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        const objectName = results.nodeName.substring(lastDot + 1);
        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    }
    static findNode(root, nodeName) {
      if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        const bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== void 0) {
          return bone;
        }
      }
      if (root.children) {
        const searchNodeSubtree = function(children2) {
          for (let i4 = 0; i4 < children2.length; i4++) {
            const childNode = children2[i4];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            const result = searchNodeSubtree(childNode.children);
            if (result) return result;
          }
          return null;
        };
        const subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
    // these are used to "bind" a nonexistent property
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    // Getters
    _getValue_direct(buffer, offset2) {
      buffer[offset2] = this.targetObject[this.propertyName];
    }
    _getValue_array(buffer, offset2) {
      const source = this.resolvedProperty;
      for (let i4 = 0, n4 = source.length; i4 !== n4; ++i4) {
        buffer[offset2++] = source[i4];
      }
    }
    _getValue_arrayElement(buffer, offset2) {
      buffer[offset2] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(buffer, offset2) {
      this.resolvedProperty.toArray(buffer, offset2);
    }
    // Direct
    _setValue_direct(buffer, offset2) {
      this.targetObject[this.propertyName] = buffer[offset2];
    }
    _setValue_direct_setNeedsUpdate(buffer, offset2) {
      this.targetObject[this.propertyName] = buffer[offset2];
      this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset2) {
      this.targetObject[this.propertyName] = buffer[offset2];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // EntireArray
    _setValue_array(buffer, offset2) {
      const dest = this.resolvedProperty;
      for (let i4 = 0, n4 = dest.length; i4 !== n4; ++i4) {
        dest[i4] = buffer[offset2++];
      }
    }
    _setValue_array_setNeedsUpdate(buffer, offset2) {
      const dest = this.resolvedProperty;
      for (let i4 = 0, n4 = dest.length; i4 !== n4; ++i4) {
        dest[i4] = buffer[offset2++];
      }
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset2) {
      const dest = this.resolvedProperty;
      for (let i4 = 0, n4 = dest.length; i4 !== n4; ++i4) {
        dest[i4] = buffer[offset2++];
      }
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // ArrayElement
    _setValue_arrayElement(buffer, offset2) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset2];
    }
    _setValue_arrayElement_setNeedsUpdate(buffer, offset2) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset2];
      this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset2) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset2];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // HasToFromArray
    _setValue_fromArray(buffer, offset2) {
      this.resolvedProperty.fromArray(buffer, offset2);
    }
    _setValue_fromArray_setNeedsUpdate(buffer, offset2) {
      this.resolvedProperty.fromArray(buffer, offset2);
      this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset2) {
      this.resolvedProperty.fromArray(buffer, offset2);
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(targetArray, offset2) {
      this.bind();
      this.getValue(targetArray, offset2);
    }
    _setValue_unbound(sourceArray, offset2) {
      this.bind();
      this.setValue(sourceArray, offset2);
    }
    // create getter / setter pair for a property in the scene graph
    bind() {
      let targetObject = this.node;
      const parsedPath = this.parsedPath;
      const objectName = parsedPath.objectName;
      const propertyName = parsedPath.propertyName;
      let propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
        this.node = targetObject;
      }
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (!targetObject) {
        console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
        return;
      }
      if (objectName) {
        let objectIndex = parsedPath.objectIndex;
        switch (objectName) {
          case "materials":
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case "bones":
            if (!targetObject.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (let i4 = 0; i4 < targetObject.length; i4++) {
              if (targetObject[i4].name === objectIndex) {
                objectIndex = i4;
                break;
              }
            }
            break;
          case "map":
            if ("map" in targetObject) {
              targetObject = targetObject.map;
              break;
            }
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.map) {
              console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
              return;
            }
            targetObject = targetObject.material.map;
            break;
          default:
            if (targetObject[objectName] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== void 0) {
          if (targetObject[objectIndex] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }
      const nodeProperty = targetObject[propertyName];
      if (nodeProperty === void 0) {
        const nodeName = parsedPath.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
        return;
      }
      let versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.needsUpdate !== void 0) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }
      let bindingType = this.BindingType.Direct;
      if (propertyIndex !== void 0) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
    unbind() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  };
  PropertyBinding.Composite = Composite;
  PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  PropertyBinding.prototype.GetterByBindingType = [
    PropertyBinding.prototype._getValue_direct,
    PropertyBinding.prototype._getValue_array,
    PropertyBinding.prototype._getValue_arrayElement,
    PropertyBinding.prototype._getValue_toArray
  ];
  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
    [
      // Direct
      PropertyBinding.prototype._setValue_direct,
      PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
      PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      // EntireArray
      PropertyBinding.prototype._setValue_array,
      PropertyBinding.prototype._setValue_array_setNeedsUpdate,
      PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      // ArrayElement
      PropertyBinding.prototype._setValue_arrayElement,
      PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
      PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      // HasToFromArray
      PropertyBinding.prototype._setValue_fromArray,
      PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
      PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  var AnimationAction = class {
    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
      this._mixer = mixer;
      this._clip = clip;
      this._localRoot = localRoot;
      this.blendMode = blendMode;
      const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
      const interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
      for (let i4 = 0; i4 !== nTracks; ++i4) {
        const interpolant = tracks[i4].createInterpolant(null);
        interpolants[i4] = interpolant;
        interpolant.settings = interpolantSettings;
      }
      this._interpolantSettings = interpolantSettings;
      this._interpolants = interpolants;
      this._propertyBindings = new Array(nTracks);
      this._cacheIndex = null;
      this._byClipCacheIndex = null;
      this._timeScaleInterpolant = null;
      this._weightInterpolant = null;
      this.loop = LoopRepeat;
      this._loopCount = -1;
      this._startTime = null;
      this.time = 0;
      this.timeScale = 1;
      this._effectiveTimeScale = 1;
      this.weight = 1;
      this._effectiveWeight = 1;
      this.repetitions = Infinity;
      this.paused = false;
      this.enabled = true;
      this.clampWhenFinished = false;
      this.zeroSlopeAtStart = true;
      this.zeroSlopeAtEnd = true;
    }
    // State & Scheduling
    play() {
      this._mixer._activateAction(this);
      return this;
    }
    stop() {
      this._mixer._deactivateAction(this);
      return this.reset();
    }
    reset() {
      this.paused = false;
      this.enabled = true;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    // return true when play has been called
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(time) {
      this._startTime = time;
      return this;
    }
    setLoop(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    }
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight(weight) {
      this.weight = weight;
      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    }
    // return the weight considering fading and .enabled
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(duration) {
      return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
      return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);
      if (warp) {
        const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1, startEndRatio, duration);
        this.warp(endStartRatio, 1, duration);
      }
      return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
      const weightInterpolant = this._weightInterpolant;
      if (weightInterpolant !== null) {
        this._weightInterpolant = null;
        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }
      return this;
    }
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    }
    // return the time scale considering warping and .paused
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    }
    syncWith(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    }
    halt(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
      const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
      let interpolant = this._timeScaleInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now3;
      times[1] = now3 + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    }
    stopWarping() {
      const timeScaleInterpolant = this._timeScaleInterpolant;
      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;
        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }
      return this;
    }
    // Object Accessors
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    // Interna
    _update(time, deltaTime, timeDirection, accuIndex) {
      if (!this.enabled) {
        this._updateWeight(time);
        return;
      }
      const startTime = this._startTime;
      if (startTime !== null) {
        const timeRunning = (time - startTime) * timeDirection;
        if (timeRunning < 0 || timeDirection === 0) {
          deltaTime = 0;
        } else {
          this._startTime = null;
          deltaTime = timeDirection * timeRunning;
        }
      }
      deltaTime *= this._updateTimeScale(time);
      const clipTime = this._updateTime(deltaTime);
      const weight = this._updateWeight(time);
      if (weight > 0) {
        const interpolants = this._interpolants;
        const propertyMixers = this._propertyBindings;
        switch (this.blendMode) {
          case AdditiveAnimationBlendMode:
            for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
              interpolants[j2].evaluate(clipTime);
              propertyMixers[j2].accumulateAdditive(weight);
            }
            break;
          case NormalAnimationBlendMode:
          default:
            for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
              interpolants[j2].evaluate(clipTime);
              propertyMixers[j2].accumulate(accuIndex, weight);
            }
        }
      }
    }
    _updateWeight(time) {
      let weight = 0;
      if (this.enabled) {
        weight = this.weight;
        const interpolant = this._weightInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          weight *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopFading();
            if (interpolantValue === 0) {
              this.enabled = false;
            }
          }
        }
      }
      this._effectiveWeight = weight;
      return weight;
    }
    _updateTimeScale(time) {
      let timeScale = 0;
      if (!this.paused) {
        timeScale = this.timeScale;
        const interpolant = this._timeScaleInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          timeScale *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();
            if (timeScale === 0) {
              this.paused = true;
            } else {
              this.timeScale = timeScale;
            }
          }
        }
      }
      this._effectiveTimeScale = timeScale;
      return timeScale;
    }
    _updateTime(deltaTime) {
      const duration = this._clip.duration;
      const loop = this.loop;
      let time = this.time + deltaTime;
      let loopCount = this._loopCount;
      const pingPong = loop === LoopPingPong;
      if (deltaTime === 0) {
        if (loopCount === -1) return time;
        return pingPong && (loopCount & 1) === 1 ? duration - time : time;
      }
      if (loop === LoopOnce) {
        if (loopCount === -1) {
          this._loopCount = 0;
          this._setEndings(true, true, false);
        }
        handle_stop: {
          if (time >= duration) {
            time = duration;
          } else if (time < 0) {
            time = 0;
          } else {
            this.time = time;
            break handle_stop;
          }
          if (this.clampWhenFinished) this.paused = true;
          else this.enabled = false;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        if (loopCount === -1) {
          if (deltaTime >= 0) {
            loopCount = 0;
            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }
        if (time >= duration || time < 0) {
          const loopDelta = Math.floor(time / duration);
          time -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          const pending = this.repetitions - loopCount;
          if (pending <= 0) {
            if (this.clampWhenFinished) this.paused = true;
            else this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            if (pending === 1) {
              const atStart = deltaTime < 0;
              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }
            this._loopCount = loopCount;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta
            });
          }
        } else {
          this.time = time;
        }
        if (pingPong && (loopCount & 1) === 1) {
          return duration - time;
        }
      }
      return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
      const settings = this._interpolantSettings;
      if (pingPong) {
        settings.endingStart = ZeroSlopeEnding;
        settings.endingEnd = ZeroSlopeEnding;
      } else {
        if (atStart) {
          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingStart = WrapAroundEnding;
        }
        if (atEnd) {
          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingEnd = WrapAroundEnding;
        }
      }
    }
    _scheduleFading(duration, weightNow, weightThen) {
      const mixer = this._mixer, now3 = mixer.time;
      let interpolant = this._weightInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now3;
      values[0] = weightNow;
      times[1] = now3 + duration;
      values[1] = weightThen;
      return this;
    }
  };
  var _controlInterpolantsResultBuffer = new Float32Array(1);
  var AnimationMixer = class extends EventDispatcher {
    constructor(root) {
      super();
      this._root = root;
      this._initMemoryManager();
      this._accuIndex = 0;
      this.time = 0;
      this.timeScale = 1;
    }
    _bindAction(action, prototypeAction) {
      const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
      let bindingsByName = bindingsByRoot[rootUuid];
      if (bindingsByName === void 0) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }
      for (let i4 = 0; i4 !== nTracks; ++i4) {
        const track = tracks[i4], trackName = track.name;
        let binding = bindingsByName[trackName];
        if (binding !== void 0) {
          ++binding.referenceCount;
          bindings[i4] = binding;
        } else {
          binding = bindings[i4];
          if (binding !== void 0) {
            if (binding._cacheIndex === null) {
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
            }
            continue;
          }
          const path = prototypeAction && prototypeAction._propertyBindings[i4].binding.parsedPath;
          binding = new PropertyMixer(
            PropertyBinding.create(root, trackName, path),
            track.ValueTypeName,
            track.getValueSize()
          );
          ++binding.referenceCount;
          this._addInactiveBinding(binding, rootUuid, trackName);
          bindings[i4] = binding;
        }
        interpolants[i4].resultBuffer = binding.buffer;
      }
    }
    _activateAction(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
          this._bindAction(
            action,
            actionsForClip && actionsForClip.knownActions[0]
          );
          this._addInactiveAction(action, clipUuid, rootUuid);
        }
        const bindings = action._propertyBindings;
        for (let i4 = 0, n4 = bindings.length; i4 !== n4; ++i4) {
          const binding = bindings[i4];
          if (binding.useCount++ === 0) {
            this._lendBinding(binding);
            binding.saveOriginalState();
          }
        }
        this._lendAction(action);
      }
    }
    _deactivateAction(action) {
      if (this._isActiveAction(action)) {
        const bindings = action._propertyBindings;
        for (let i4 = 0, n4 = bindings.length; i4 !== n4; ++i4) {
          const binding = bindings[i4];
          if (--binding.useCount === 0) {
            binding.restoreOriginalState();
            this._takeBackBinding(binding);
          }
        }
        this._takeBackAction(action);
      }
    }
    // Memory manager
    _initMemoryManager() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      const scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },
          get inUse() {
            return scope._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },
          get inUse() {
            return scope._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },
          get inUse() {
            return scope._nActiveControlInterpolants;
          }
        }
      };
    }
    // Memory management for AnimationAction objects
    _isActiveAction(action) {
      const index2 = action._cacheIndex;
      return index2 !== null && index2 < this._nActiveActions;
    }
    _addInactiveAction(action, clipUuid, rootUuid) {
      const actions = this._actions, actionsByClip = this._actionsByClip;
      let actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip === void 0) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        const knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }
      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    }
    _removeInactiveAction(action) {
      const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];
      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }
      this._removeInactiveBindingsForAction(action);
    }
    _removeInactiveBindingsForAction(action) {
      const bindings = action._propertyBindings;
      for (let i4 = 0, n4 = bindings.length; i4 !== n4; ++i4) {
        const binding = bindings[i4];
        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    }
    _lendAction(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    }
    _takeBackAction(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    }
    // Memory management for PropertyMixer objects
    _addInactiveBinding(binding, rootUuid, trackName) {
      const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
      let bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName === void 0) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }
      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    }
    _removeInactiveBinding(binding) {
      const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];
      if (Object.keys(bindingByName).length === 0) {
        delete bindingsByRoot[rootUuid];
      }
    }
    _lendBinding(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    }
    _takeBackBinding(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    }
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant() {
      const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
      let interpolant = interpolants[lastActiveIndex];
      if (interpolant === void 0) {
        interpolant = new LinearInterpolant(
          new Float32Array(2),
          new Float32Array(2),
          1,
          _controlInterpolantsResultBuffer
        );
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }
      return interpolant;
    }
    _takeBackControlInterpolant(interpolant) {
      const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    }
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction(clip, optionalRoot, blendMode) {
      const root = optionalRoot || this._root, rootUuid = root.uuid;
      let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
      const clipUuid = clipObject !== null ? clipObject.uuid : clip;
      const actionsForClip = this._actionsByClip[clipUuid];
      let prototypeAction = null;
      if (blendMode === void 0) {
        if (clipObject !== null) {
          blendMode = clipObject.blendMode;
        } else {
          blendMode = NormalAnimationBlendMode;
        }
      }
      if (actionsForClip !== void 0) {
        const existingAction = actionsForClip.actionByRoot[rootUuid];
        if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
          return existingAction;
        }
        prototypeAction = actionsForClip.knownActions[0];
        if (clipObject === null)
          clipObject = prototypeAction._clip;
      }
      if (clipObject === null) return null;
      const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
      this._bindAction(newAction, prototypeAction);
      this._addInactiveAction(newAction, clipUuid, rootUuid);
      return newAction;
    }
    // get an existing action
    existingAction(clip, optionalRoot) {
      const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }
      return null;
    }
    // deactivates all previously scheduled actions
    stopAllAction() {
      const actions = this._actions, nActions = this._nActiveActions;
      for (let i4 = nActions - 1; i4 >= 0; --i4) {
        actions[i4].stop();
      }
      return this;
    }
    // advance the time and update apply the animation
    update(deltaTime) {
      deltaTime *= this.timeScale;
      const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
      for (let i4 = 0; i4 !== nActions; ++i4) {
        const action = actions[i4];
        action._update(time, deltaTime, timeDirection, accuIndex);
      }
      const bindings = this._bindings, nBindings = this._nActiveBindings;
      for (let i4 = 0; i4 !== nBindings; ++i4) {
        bindings[i4].apply(accuIndex);
      }
      return this;
    }
    // Allows you to seek to a specific time in an animation.
    setTime(timeInSeconds) {
      this.time = 0;
      for (let i4 = 0; i4 < this._actions.length; i4++) {
        this._actions[i4].time = 0;
      }
      return this.update(timeInSeconds);
    }
    // return this mixer's root target object
    getRoot() {
      return this._root;
    }
    // free all resources specific to a particular clip
    uncacheClip(clip) {
      const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        const actionsToRemove = actionsForClip.knownActions;
        for (let i4 = 0, n4 = actionsToRemove.length; i4 !== n4; ++i4) {
          const action = actionsToRemove[i4];
          this._deactivateAction(action);
          const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          this._removeInactiveBindingsForAction(action);
        }
        delete actionsByClip[clipUuid];
      }
    }
    // free all resources specific to a particular root target object
    uncacheRoot(root) {
      const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
      for (const clipUuid in actionsByClip) {
        const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
        if (action !== void 0) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
      const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName !== void 0) {
        for (const trackName in bindingByName) {
          const binding = bindingByName[trackName];
          binding.restoreOriginalState();
          this._removeInactiveBinding(binding);
        }
      }
    }
    // remove a targeted clip from the cache
    uncacheAction(clip, optionalRoot) {
      const action = this.existingAction(clip, optionalRoot);
      if (action !== null) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
  };
  var Spherical = class {
    constructor(radius = 1, phi = 0, theta = 0) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    }
    // restrict phi to be between EPS and PI-EPS
    makeSafe() {
      const EPS = 1e-6;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
    setFromVector3(v2) {
      return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
    }
    setFromCartesianCoords(x2, y2, z2) {
      this.radius = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x2, z2);
        this.phi = Math.acos(clamp3(y2 / this.radius, -1, 1));
      }
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var GridHelper2 = class extends LineSegments {
    constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
      color1 = new Color(color1);
      color2 = new Color(color2);
      const center = divisions / 2;
      const step = size / divisions;
      const halfSize = size / 2;
      const vertices = [], colors2 = [];
      for (let i4 = 0, j2 = 0, k2 = -halfSize; i4 <= divisions; i4++, k2 += step) {
        vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
        vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
        const color = i4 === center ? color1 : color2;
        color.toArray(colors2, j2);
        j2 += 3;
        color.toArray(colors2, j2);
        j2 += 3;
        color.toArray(colors2, j2);
        j2 += 3;
        color.toArray(colors2, j2);
        j2 += 3;
      }
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
      const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
      super(geometry, material);
      this.type = "GridHelper";
    }
    dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }

  // node_modules/three/examples/jsm/loaders/DRACOLoader.js
  var _taskCache = /* @__PURE__ */ new WeakMap();
  var DRACOLoader = class extends Loader {
    constructor(manager) {
      super(manager);
      this.decoderPath = "";
      this.decoderConfig = {};
      this.decoderBinary = null;
      this.decoderPending = null;
      this.workerLimit = 4;
      this.workerPool = [];
      this.workerNextTaskID = 1;
      this.workerSourceURL = "";
      this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD"
      };
      this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array"
      };
    }
    setDecoderPath(path) {
      this.decoderPath = path;
      return this;
    }
    setDecoderConfig(config3) {
      this.decoderConfig = config3;
      return this;
    }
    setWorkerLimit(workerLimit) {
      this.workerLimit = workerLimit;
      return this;
    }
    load(url, onLoad, onProgress, onError) {
      const loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType("arraybuffer");
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, (buffer) => {
        this.parse(buffer, onLoad, onError);
      }, onProgress, onError);
    }
    parse(buffer, onLoad, onError = () => {
    }) {
      this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace, onError).catch(onError);
    }
    decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError = () => {
    }) {
      const taskConfig = {
        attributeIDs: attributeIDs || this.defaultAttributeIDs,
        attributeTypes: attributeTypes || this.defaultAttributeTypes,
        useUniqueIDs: !!attributeIDs,
        vertexColorSpace
      };
      return this.decodeGeometry(buffer, taskConfig).then(callback).catch(onError);
    }
    decodeGeometry(buffer, taskConfig) {
      const taskKey = JSON.stringify(taskConfig);
      if (_taskCache.has(buffer)) {
        const cachedTask = _taskCache.get(buffer);
        if (cachedTask.key === taskKey) {
          return cachedTask.promise;
        } else if (buffer.byteLength === 0) {
          throw new Error(
            "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
          );
        }
      }
      let worker;
      const taskID = this.workerNextTaskID++;
      const taskCost = buffer.byteLength;
      const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
        worker = _worker;
        return new Promise((resolve, reject) => {
          worker._callbacks[taskID] = { resolve, reject };
          worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
        });
      }).then((message) => this._createGeometry(message.geometry));
      geometryPending.catch(() => true).then(() => {
        if (worker && taskID) {
          this._releaseTask(worker, taskID);
        }
      });
      _taskCache.set(buffer, {
        key: taskKey,
        promise: geometryPending
      });
      return geometryPending;
    }
    _createGeometry(geometryData) {
      const geometry = new BufferGeometry();
      if (geometryData.index) {
        geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
      }
      for (let i4 = 0; i4 < geometryData.attributes.length; i4++) {
        const result = geometryData.attributes[i4];
        const name = result.name;
        const array = result.array;
        const itemSize = result.itemSize;
        const attribute = new BufferAttribute(array, itemSize);
        if (name === "color") {
          this._assignVertexColorSpace(attribute, result.vertexColorSpace);
          attribute.normalized = array instanceof Float32Array === false;
        }
        geometry.setAttribute(name, attribute);
      }
      return geometry;
    }
    _assignVertexColorSpace(attribute, inputColorSpace) {
      if (inputColorSpace !== SRGBColorSpace) return;
      const _color2 = new Color();
      for (let i4 = 0, il = attribute.count; i4 < il; i4++) {
        _color2.fromBufferAttribute(attribute, i4).convertSRGBToLinear();
        attribute.setXYZ(i4, _color2.r, _color2.g, _color2.b);
      }
    }
    _loadLibrary(url, responseType) {
      const loader = new FileLoader(this.manager);
      loader.setPath(this.decoderPath);
      loader.setResponseType(responseType);
      loader.setWithCredentials(this.withCredentials);
      return new Promise((resolve, reject) => {
        loader.load(url, resolve, void 0, reject);
      });
    }
    preload() {
      this._initDecoder();
      return this;
    }
    _initDecoder() {
      if (this.decoderPending) return this.decoderPending;
      const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
      const librariesPending = [];
      if (useJS) {
        librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
      } else {
        librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
        librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
      }
      this.decoderPending = Promise.all(librariesPending).then((libraries) => {
        const jsContent = libraries[0];
        if (!useJS) {
          this.decoderConfig.wasmBinary = libraries[1];
        }
        const fn = DRACOWorker.toString();
        const body2 = [
          "/* draco decoder */",
          jsContent,
          "",
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body2]));
      });
      return this.decoderPending;
    }
    _getWorker(taskID, taskCost) {
      return this._initDecoder().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const worker2 = new Worker(this.workerSourceURL);
          worker2._callbacks = {};
          worker2._taskCosts = {};
          worker2._taskLoad = 0;
          worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
          worker2.onmessage = function(e4) {
            const message = e4.data;
            switch (message.type) {
              case "decode":
                worker2._callbacks[message.id].resolve(message);
                break;
              case "error":
                worker2._callbacks[message.id].reject(message);
                break;
              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
            }
          };
          this.workerPool.push(worker2);
        } else {
          this.workerPool.sort(function(a3, b2) {
            return a3._taskLoad > b2._taskLoad ? -1 : 1;
          });
        }
        const worker = this.workerPool[this.workerPool.length - 1];
        worker._taskCosts[taskID] = taskCost;
        worker._taskLoad += taskCost;
        return worker;
      });
    }
    _releaseTask(worker, taskID) {
      worker._taskLoad -= worker._taskCosts[taskID];
      delete worker._callbacks[taskID];
      delete worker._taskCosts[taskID];
    }
    debug() {
      console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
    }
    dispose() {
      for (let i4 = 0; i4 < this.workerPool.length; ++i4) {
        this.workerPool[i4].terminate();
      }
      this.workerPool.length = 0;
      if (this.workerSourceURL !== "") {
        URL.revokeObjectURL(this.workerSourceURL);
      }
      return this;
    }
  };
  function DRACOWorker() {
    let decoderConfig;
    let decoderPending;
    onmessage = function(e4) {
      const message = e4.data;
      switch (message.type) {
        case "init":
          decoderConfig = message.decoderConfig;
          decoderPending = new Promise(function(resolve) {
            decoderConfig.onModuleLoaded = function(draco) {
              resolve({ draco });
            };
            DracoDecoderModule(decoderConfig);
          });
          break;
        case "decode":
          const buffer = message.buffer;
          const taskConfig = message.taskConfig;
          decoderPending.then((module) => {
            const draco = module.draco;
            const decoder = new draco.Decoder();
            try {
              const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
              const buffers = geometry.attributes.map((attr2) => attr2.array.buffer);
              if (geometry.index) buffers.push(geometry.index.array.buffer);
              self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
            } catch (error) {
              console.error(error);
              self.postMessage({ type: "error", id: message.id, error: error.message });
            } finally {
              draco.destroy(decoder);
            }
          });
          break;
      }
    };
    function decodeGeometry(draco, decoder, array, taskConfig) {
      const attributeIDs = taskConfig.attributeIDs;
      const attributeTypes = taskConfig.attributeTypes;
      let dracoGeometry;
      let decodingStatus;
      const geometryType = decoder.GetEncodedGeometryType(array);
      if (geometryType === draco.TRIANGULAR_MESH) {
        dracoGeometry = new draco.Mesh();
        decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
      } else if (geometryType === draco.POINT_CLOUD) {
        dracoGeometry = new draco.PointCloud();
        decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
      } else {
        throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
      }
      if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
        throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
      }
      const geometry = { index: null, attributes: [] };
      for (const attributeName in attributeIDs) {
        const attributeType = self[attributeTypes[attributeName]];
        let attribute;
        let attributeID;
        if (taskConfig.useUniqueIDs) {
          attributeID = attributeIDs[attributeName];
          attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
        } else {
          attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
          if (attributeID === -1) continue;
          attribute = decoder.GetAttribute(dracoGeometry, attributeID);
        }
        const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
        if (attributeName === "color") {
          attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
        }
        geometry.attributes.push(attributeResult);
      }
      if (geometryType === draco.TRIANGULAR_MESH) {
        geometry.index = decodeIndex(draco, decoder, dracoGeometry);
      }
      draco.destroy(dracoGeometry);
      return geometry;
    }
    function decodeIndex(draco, decoder, dracoGeometry) {
      const numFaces = dracoGeometry.num_faces();
      const numIndices = numFaces * 3;
      const byteLength = numIndices * 4;
      const ptr = draco._malloc(byteLength);
      decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      const index2 = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
      draco._free(ptr);
      return { array: index2, itemSize: 1 };
    }
    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
      const numComponents = attribute.num_components();
      const numPoints = dracoGeometry.num_points();
      const numValues = numPoints * numComponents;
      const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
      const dataType = getDracoDataType(draco, attributeType);
      const ptr = draco._malloc(byteLength);
      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
      const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
      draco._free(ptr);
      return {
        name: attributeName,
        array,
        itemSize: numComponents
      };
    }
    function getDracoDataType(draco, attributeType) {
      switch (attributeType) {
        case Float32Array:
          return draco.DT_FLOAT32;
        case Int8Array:
          return draco.DT_INT8;
        case Int16Array:
          return draco.DT_INT16;
        case Int32Array:
          return draco.DT_INT32;
        case Uint8Array:
          return draco.DT_UINT8;
        case Uint16Array:
          return draco.DT_UINT16;
        case Uint32Array:
          return draco.DT_UINT32;
      }
    }
  }

  // node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
  function toTrianglesDrawMode(geometry, drawMode) {
    if (drawMode === TrianglesDrawMode) {
      console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
      return geometry;
    }
    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
      let index2 = geometry.getIndex();
      if (index2 === null) {
        const indices = [];
        const position = geometry.getAttribute("position");
        if (position !== void 0) {
          for (let i4 = 0; i4 < position.count; i4++) {
            indices.push(i4);
          }
          geometry.setIndex(indices);
          index2 = geometry.getIndex();
        } else {
          console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
          return geometry;
        }
      }
      const numberOfTriangles = index2.count - 2;
      const newIndices = [];
      if (drawMode === TriangleFanDrawMode) {
        for (let i4 = 1; i4 <= numberOfTriangles; i4++) {
          newIndices.push(index2.getX(0));
          newIndices.push(index2.getX(i4));
          newIndices.push(index2.getX(i4 + 1));
        }
      } else {
        for (let i4 = 0; i4 < numberOfTriangles; i4++) {
          if (i4 % 2 === 0) {
            newIndices.push(index2.getX(i4));
            newIndices.push(index2.getX(i4 + 1));
            newIndices.push(index2.getX(i4 + 2));
          } else {
            newIndices.push(index2.getX(i4 + 2));
            newIndices.push(index2.getX(i4 + 1));
            newIndices.push(index2.getX(i4));
          }
        }
      }
      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
      }
      const newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      newGeometry.clearGroups();
      return newGeometry;
    } else {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
      return geometry;
    }
  }

  // node_modules/three/examples/jsm/loaders/GLTFLoader.js
  var GLTFLoader = class extends Loader {
    constructor(manager) {
      super(manager);
      this.dracoLoader = null;
      this.ktx2Loader = null;
      this.meshoptDecoder = null;
      this.pluginCallbacks = [];
      this.register(function(parser) {
        return new GLTFMaterialsClearcoatExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsDispersionExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFTextureBasisUExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFTextureWebPExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFTextureAVIFExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsSheenExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsTransmissionExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsVolumeExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsIorExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsEmissiveStrengthExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsSpecularExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsIridescenceExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsAnisotropyExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsBumpExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFLightsExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMeshoptCompression(parser);
      });
      this.register(function(parser) {
        return new GLTFMeshGpuInstancing(parser);
      });
    }
    load(url, onLoad, onProgress, onError) {
      const scope = this;
      let resourcePath;
      if (this.resourcePath !== "") {
        resourcePath = this.resourcePath;
      } else if (this.path !== "") {
        const relativeUrl = LoaderUtils.extractUrlBase(url);
        resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
      } else {
        resourcePath = LoaderUtils.extractUrlBase(url);
      }
      this.manager.itemStart(url);
      const _onError = function(e4) {
        if (onError) {
          onError(e4);
        } else {
          console.error(e4);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      };
      const loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType("arraybuffer");
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function(data) {
        try {
          scope.parse(data, resourcePath, function(gltf) {
            onLoad(gltf);
            scope.manager.itemEnd(url);
          }, _onError);
        } catch (e4) {
          _onError(e4);
        }
      }, onProgress, _onError);
    }
    setDRACOLoader(dracoLoader2) {
      this.dracoLoader = dracoLoader2;
      return this;
    }
    setDDSLoader() {
      throw new Error(
        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
      );
    }
    setKTX2Loader(ktx2Loader) {
      this.ktx2Loader = ktx2Loader;
      return this;
    }
    setMeshoptDecoder(meshoptDecoder) {
      this.meshoptDecoder = meshoptDecoder;
      return this;
    }
    register(callback) {
      if (this.pluginCallbacks.indexOf(callback) === -1) {
        this.pluginCallbacks.push(callback);
      }
      return this;
    }
    unregister(callback) {
      if (this.pluginCallbacks.indexOf(callback) !== -1) {
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
      }
      return this;
    }
    parse(data, path, onLoad, onError) {
      let json;
      const extensions = {};
      const plugins = {};
      const textDecoder = new TextDecoder();
      if (typeof data === "string") {
        json = JSON.parse(data);
      } else if (data instanceof ArrayBuffer) {
        const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError) onError(error);
            return;
          }
          json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
        } else {
          json = JSON.parse(textDecoder.decode(data));
        }
      } else {
        json = data;
      }
      if (json.asset === void 0 || json.asset.version[0] < 2) {
        if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      const parser = new GLTFParser(json, {
        path: path || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      parser.fileLoader.setRequestHeader(this.requestHeader);
      for (let i4 = 0; i4 < this.pluginCallbacks.length; i4++) {
        const plugin = this.pluginCallbacks[i4](parser);
        if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
        plugins[plugin.name] = plugin;
        extensions[plugin.name] = true;
      }
      if (json.extensionsUsed) {
        for (let i4 = 0; i4 < json.extensionsUsed.length; ++i4) {
          const extensionName = json.extensionsUsed[i4];
          const extensionsRequired = json.extensionsRequired || [];
          switch (extensionName) {
            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension();
              break;
            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;
            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
              extensions[extensionName] = new GLTFTextureTransformExtension();
              break;
            case EXTENSIONS.KHR_MESH_QUANTIZATION:
              extensions[extensionName] = new GLTFMeshQuantizationExtension();
              break;
            default:
              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }
          }
        }
      }
      parser.setExtensions(extensions);
      parser.setPlugins(plugins);
      parser.parse(onLoad, onError);
    }
    parseAsync(data, path) {
      const scope = this;
      return new Promise(function(resolve, reject) {
        scope.parse(data, path, resolve, reject);
      });
    }
  };
  function GLTFRegistry() {
    let objects = {};
    return {
      get: function(key) {
        return objects[key];
      },
      add: function(key, object) {
        objects[key] = object;
      },
      remove: function(key) {
        delete objects[key];
      },
      removeAll: function() {
        objects = {};
      }
    };
  }
  var EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
  };
  var GLTFLightsExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
      this.cache = { refs: {}, uses: {} };
    }
    _markDefs() {
      const parser = this.parser;
      const nodeDefs = this.parser.json.nodes || [];
      for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        const nodeDef = nodeDefs[nodeIndex];
        if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
          parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
        }
      }
    }
    _loadLight(lightIndex) {
      const parser = this.parser;
      const cacheKey = "light:" + lightIndex;
      let dependency = parser.cache.get(cacheKey);
      if (dependency) return dependency;
      const json = parser.json;
      const extensions = json.extensions && json.extensions[this.name] || {};
      const lightDefs = extensions.lights || [];
      const lightDef = lightDefs[lightIndex];
      let lightNode;
      const color = new Color(16777215);
      if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
      const range = lightDef.range !== void 0 ? lightDef.range : 0;
      switch (lightDef.type) {
        case "directional":
          lightNode = new DirectionalLight(color);
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;
        case "point":
          lightNode = new PointLight(color);
          lightNode.distance = range;
          break;
        case "spot":
          lightNode = new SpotLight(color);
          lightNode.distance = range;
          lightDef.spot = lightDef.spot || {};
          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
          lightNode.angle = lightDef.spot.outerConeAngle;
          lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
      }
      lightNode.position.set(0, 0, 0);
      lightNode.decay = 2;
      assignExtrasToUserData(lightNode, lightDef);
      if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
      lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
      dependency = Promise.resolve(lightNode);
      parser.cache.add(cacheKey, dependency);
      return dependency;
    }
    getDependency(type, index2) {
      if (type !== "light") return;
      return this._loadLight(index2);
    }
    createNodeAttachment(nodeIndex) {
      const self2 = this;
      const parser = this.parser;
      const json = parser.json;
      const nodeDef = json.nodes[nodeIndex];
      const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
      const lightIndex = lightDef.light;
      if (lightIndex === void 0) return null;
      return this._loadLight(lightIndex).then(function(light) {
        return parser._getNodeRef(self2.cache, lightIndex, light);
      });
    }
  };
  var GLTFMaterialsUnlitExtension = class {
    constructor() {
      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return MeshBasicMaterial;
    }
    extendParams(materialParams, materialDef, parser) {
      const pending = [];
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      const metallicRoughness = materialDef.pbrMetallicRoughness;
      if (metallicRoughness) {
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          const array = metallicRoughness.baseColorFactor;
          materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
          materialParams.opacity = array[3];
        }
        if (metallicRoughness.baseColorTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
        }
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsEmissiveStrengthExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
      if (emissiveStrength !== void 0) {
        materialParams.emissiveIntensity = emissiveStrength;
      }
      return Promise.resolve();
    }
  };
  var GLTFMaterialsClearcoatExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      if (extension.clearcoatFactor !== void 0) {
        materialParams.clearcoat = extension.clearcoatFactor;
      }
      if (extension.clearcoatTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
      }
      if (extension.clearcoatRoughnessFactor !== void 0) {
        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
      }
      if (extension.clearcoatRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
      }
      if (extension.clearcoatNormalTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
        if (extension.clearcoatNormalTexture.scale !== void 0) {
          const scale = extension.clearcoatNormalTexture.scale;
          materialParams.clearcoatNormalScale = new Vector2(scale, scale);
        }
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsDispersionExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const extension = materialDef.extensions[this.name];
      materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
      return Promise.resolve();
    }
  };
  var GLTFMaterialsIridescenceExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      if (extension.iridescenceFactor !== void 0) {
        materialParams.iridescence = extension.iridescenceFactor;
      }
      if (extension.iridescenceTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
      }
      if (extension.iridescenceIor !== void 0) {
        materialParams.iridescenceIOR = extension.iridescenceIor;
      }
      if (materialParams.iridescenceThicknessRange === void 0) {
        materialParams.iridescenceThicknessRange = [100, 400];
      }
      if (extension.iridescenceThicknessMinimum !== void 0) {
        materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
      }
      if (extension.iridescenceThicknessMaximum !== void 0) {
        materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
      }
      if (extension.iridescenceThicknessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsSheenExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      materialParams.sheenColor = new Color(0, 0, 0);
      materialParams.sheenRoughness = 0;
      materialParams.sheen = 1;
      const extension = materialDef.extensions[this.name];
      if (extension.sheenColorFactor !== void 0) {
        const colorFactor = extension.sheenColorFactor;
        materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
      }
      if (extension.sheenRoughnessFactor !== void 0) {
        materialParams.sheenRoughness = extension.sheenRoughnessFactor;
      }
      if (extension.sheenColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
      }
      if (extension.sheenRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsTransmissionExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      if (extension.transmissionFactor !== void 0) {
        materialParams.transmission = extension.transmissionFactor;
      }
      if (extension.transmissionTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsVolumeExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
      if (extension.thicknessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
      }
      materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
      const colorArray = extension.attenuationColor || [1, 1, 1];
      materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsIorExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_IOR;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const extension = materialDef.extensions[this.name];
      materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
      return Promise.resolve();
    }
  };
  var GLTFMaterialsSpecularExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
      if (extension.specularTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
      }
      const colorArray = extension.specularColorFactor || [1, 1, 1];
      materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
      if (extension.specularColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsBumpExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
      if (extension.bumpTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsAnisotropyExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      if (extension.anisotropyStrength !== void 0) {
        materialParams.anisotropy = extension.anisotropyStrength;
      }
      if (extension.anisotropyRotation !== void 0) {
        materialParams.anisotropyRotation = extension.anisotropyRotation;
      }
      if (extension.anisotropyTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
      }
      return Promise.all(pending);
    }
  };
  var GLTFTextureBasisUExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
    }
    loadTexture(textureIndex) {
      const parser = this.parser;
      const json = parser.json;
      const textureDef = json.textures[textureIndex];
      if (!textureDef.extensions || !textureDef.extensions[this.name]) {
        return null;
      }
      const extension = textureDef.extensions[this.name];
      const loader = parser.options.ktx2Loader;
      if (!loader) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        } else {
          return null;
        }
      }
      return parser.loadTextureImage(textureIndex, extension.source, loader);
    }
  };
  var GLTFTextureWebPExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
      this.isSupported = null;
    }
    loadTexture(textureIndex) {
      const name = this.name;
      const parser = this.parser;
      const json = parser.json;
      const textureDef = json.textures[textureIndex];
      if (!textureDef.extensions || !textureDef.extensions[name]) {
        return null;
      }
      const extension = textureDef.extensions[name];
      const source = json.images[extension.source];
      let loader = parser.textureLoader;
      if (source.uri) {
        const handler = parser.options.manager.getHandler(source.uri);
        if (handler !== null) loader = handler;
      }
      return this.detectSupport().then(function(isSupported) {
        if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
          throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        }
        return parser.loadTexture(textureIndex);
      });
    }
    detectSupport() {
      if (!this.isSupported) {
        this.isSupported = new Promise(function(resolve) {
          const image2 = new Image();
          image2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
          image2.onload = image2.onerror = function() {
            resolve(image2.height === 1);
          };
        });
      }
      return this.isSupported;
    }
  };
  var GLTFTextureAVIFExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
      this.isSupported = null;
    }
    loadTexture(textureIndex) {
      const name = this.name;
      const parser = this.parser;
      const json = parser.json;
      const textureDef = json.textures[textureIndex];
      if (!textureDef.extensions || !textureDef.extensions[name]) {
        return null;
      }
      const extension = textureDef.extensions[name];
      const source = json.images[extension.source];
      let loader = parser.textureLoader;
      if (source.uri) {
        const handler = parser.options.manager.getHandler(source.uri);
        if (handler !== null) loader = handler;
      }
      return this.detectSupport().then(function(isSupported) {
        if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
          throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
        }
        return parser.loadTexture(textureIndex);
      });
    }
    detectSupport() {
      if (!this.isSupported) {
        this.isSupported = new Promise(function(resolve) {
          const image2 = new Image();
          image2.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
          image2.onload = image2.onerror = function() {
            resolve(image2.height === 1);
          };
        });
      }
      return this.isSupported;
    }
  };
  var GLTFMeshoptCompression = class {
    constructor(parser) {
      this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
      this.parser = parser;
    }
    loadBufferView(index2) {
      const json = this.parser.json;
      const bufferView = json.bufferViews[index2];
      if (bufferView.extensions && bufferView.extensions[this.name]) {
        const extensionDef = bufferView.extensions[this.name];
        const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
        const decoder = this.parser.options.meshoptDecoder;
        if (!decoder || !decoder.supported) {
          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          } else {
            return null;
          }
        }
        return buffer.then(function(res) {
          const byteOffset = extensionDef.byteOffset || 0;
          const byteLength = extensionDef.byteLength || 0;
          const count = extensionDef.count;
          const stride = extensionDef.byteStride;
          const source = new Uint8Array(res, byteOffset, byteLength);
          if (decoder.decodeGltfBufferAsync) {
            return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
              return res2.buffer;
            });
          } else {
            return decoder.ready.then(function() {
              const result = new ArrayBuffer(count * stride);
              decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
              return result;
            });
          }
        });
      } else {
        return null;
      }
    }
  };
  var GLTFMeshGpuInstancing = class {
    constructor(parser) {
      this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
      this.parser = parser;
    }
    createNodeMesh(nodeIndex) {
      const json = this.parser.json;
      const nodeDef = json.nodes[nodeIndex];
      if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
        return null;
      }
      const meshDef = json.meshes[nodeDef.mesh];
      for (const primitive of meshDef.primitives) {
        if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
          return null;
        }
      }
      const extensionDef = nodeDef.extensions[this.name];
      const attributesDef = extensionDef.attributes;
      const pending = [];
      const attributes = {};
      for (const key in attributesDef) {
        pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
          attributes[key] = accessor;
          return attributes[key];
        }));
      }
      if (pending.length < 1) {
        return null;
      }
      pending.push(this.parser.createNodeMesh(nodeIndex));
      return Promise.all(pending).then((results) => {
        const nodeObject = results.pop();
        const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
        const count = results[0].count;
        const instancedMeshes = [];
        for (const mesh of meshes) {
          const m2 = new Matrix4();
          const p2 = new Vector3();
          const q2 = new Quaternion();
          const s4 = new Vector3(1, 1, 1);
          const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
          for (let i4 = 0; i4 < count; i4++) {
            if (attributes.TRANSLATION) {
              p2.fromBufferAttribute(attributes.TRANSLATION, i4);
            }
            if (attributes.ROTATION) {
              q2.fromBufferAttribute(attributes.ROTATION, i4);
            }
            if (attributes.SCALE) {
              s4.fromBufferAttribute(attributes.SCALE, i4);
            }
            instancedMesh.setMatrixAt(i4, m2.compose(p2, q2, s4));
          }
          for (const attributeName in attributes) {
            if (attributeName === "_COLOR_0") {
              const attr2 = attributes[attributeName];
              instancedMesh.instanceColor = new InstancedBufferAttribute(attr2.array, attr2.itemSize, attr2.normalized);
            } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
              mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
            }
          }
          Object3D.prototype.copy.call(instancedMesh, mesh);
          this.parser.assignFinalMaterial(instancedMesh);
          instancedMeshes.push(instancedMesh);
        }
        if (nodeObject.isGroup) {
          nodeObject.clear();
          nodeObject.add(...instancedMeshes);
          return nodeObject;
        }
        return instancedMeshes[0];
      });
    }
  };
  var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
  var GLTFBinaryExtension = class {
    constructor(data) {
      this.name = EXTENSIONS.KHR_BINARY_GLTF;
      this.content = null;
      this.body = null;
      const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
      const textDecoder = new TextDecoder();
      this.header = {
        magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
        version: headerView.getUint32(4, true),
        length: headerView.getUint32(8, true)
      };
      if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      } else if (this.header.version < 2) {
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      }
      const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
      const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
      let chunkIndex = 0;
      while (chunkIndex < chunkContentsLength) {
        const chunkLength = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        const chunkType = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
          const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
          this.content = textDecoder.decode(contentArray);
        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
          const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
          this.body = data.slice(byteOffset, byteOffset + chunkLength);
        }
        chunkIndex += chunkLength;
      }
      if (this.content === null) {
        throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    }
  };
  var GLTFDracoMeshCompressionExtension = class {
    constructor(json, dracoLoader2) {
      if (!dracoLoader2) {
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      }
      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
      this.json = json;
      this.dracoLoader = dracoLoader2;
      this.dracoLoader.preload();
    }
    decodePrimitive(primitive, parser) {
      const json = this.json;
      const dracoLoader2 = this.dracoLoader;
      const bufferViewIndex = primitive.extensions[this.name].bufferView;
      const gltfAttributeMap = primitive.extensions[this.name].attributes;
      const threeAttributeMap = {};
      const attributeNormalizedMap = {};
      const attributeTypeMap = {};
      for (const attributeName in gltfAttributeMap) {
        const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
      }
      for (const attributeName in primitive.attributes) {
        const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        if (gltfAttributeMap[attributeName] !== void 0) {
          const accessorDef = json.accessors[primitive.attributes[attributeName]];
          const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
          attributeTypeMap[threeAttributeName] = componentType.name;
          attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
        }
      }
      return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
        return new Promise(function(resolve, reject) {
          dracoLoader2.decodeDracoFile(bufferView, function(geometry) {
            for (const attributeName in geometry.attributes) {
              const attribute = geometry.attributes[attributeName];
              const normalized = attributeNormalizedMap[attributeName];
              if (normalized !== void 0) attribute.normalized = normalized;
            }
            resolve(geometry);
          }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
        });
      });
    }
  };
  var GLTFTextureTransformExtension = class {
    constructor() {
      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(texture, transform2) {
      if ((transform2.texCoord === void 0 || transform2.texCoord === texture.channel) && transform2.offset === void 0 && transform2.rotation === void 0 && transform2.scale === void 0) {
        return texture;
      }
      texture = texture.clone();
      if (transform2.texCoord !== void 0) {
        texture.channel = transform2.texCoord;
      }
      if (transform2.offset !== void 0) {
        texture.offset.fromArray(transform2.offset);
      }
      if (transform2.rotation !== void 0) {
        texture.rotation = transform2.rotation;
      }
      if (transform2.scale !== void 0) {
        texture.repeat.fromArray(transform2.scale);
      }
      texture.needsUpdate = true;
      return texture;
    }
  };
  var GLTFMeshQuantizationExtension = class {
    constructor() {
      this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    }
  };
  var GLTFCubicSplineInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    copySampleValue_(index2) {
      const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset2 = index2 * valueSize * 3 + valueSize;
      for (let i4 = 0; i4 !== valueSize; i4++) {
        result[i4] = values[offset2 + i4];
      }
      return result;
    }
    interpolate_(i1, t0, t3, t1) {
      const result = this.resultBuffer;
      const values = this.sampleValues;
      const stride = this.valueSize;
      const stride2 = stride * 2;
      const stride3 = stride * 3;
      const td = t1 - t0;
      const p2 = (t3 - t0) / td;
      const pp = p2 * p2;
      const ppp = pp * p2;
      const offset1 = i1 * stride3;
      const offset0 = offset1 - stride3;
      const s22 = -2 * ppp + 3 * pp;
      const s32 = ppp - pp;
      const s0 = 1 - s22;
      const s1 = s32 - pp + p2;
      for (let i4 = 0; i4 !== stride; i4++) {
        const p0 = values[offset0 + i4 + stride];
        const m0 = values[offset0 + i4 + stride2] * td;
        const p1 = values[offset1 + i4 + stride];
        const m1 = values[offset1 + i4] * td;
        result[i4] = s0 * p0 + s1 * m0 + s22 * p1 + s32 * m1;
      }
      return result;
    }
  };
  var _q = new Quaternion();
  var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
    interpolate_(i1, t0, t3, t1) {
      const result = super.interpolate_(i1, t0, t3, t1);
      _q.fromArray(result).normalize().toArray(result);
      return result;
    }
  };
  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping
  };
  var WEBGL_TYPE_SIZES = {
    "SCALAR": 1,
    "VEC2": 2,
    "VEC3": 3,
    "VEC4": 4,
    "MAT2": 4,
    "MAT3": 9,
    "MAT4": 16
  };
  var ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  };
  var PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  };
  var INTERPOLATION = {
    CUBICSPLINE: void 0,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete
  };
  var ALPHA_MODES = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === void 0) {
      cache["DefaultMaterial"] = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }
    return cache["DefaultMaterial"];
  }
  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    for (const name in objectDef.extensions) {
      if (knownExtensions[name] === void 0) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== void 0) {
      if (typeof gltfDef.extras === "object") {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
      }
    }
  }
  function addMorphTargets(geometry, targets, parser) {
    let hasMorphPosition = false;
    let hasMorphNormal = false;
    let hasMorphColor = false;
    for (let i4 = 0, il = targets.length; i4 < il; i4++) {
      const target = targets[i4];
      if (target.POSITION !== void 0) hasMorphPosition = true;
      if (target.NORMAL !== void 0) hasMorphNormal = true;
      if (target.COLOR_0 !== void 0) hasMorphColor = true;
      if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
    }
    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
    const pendingPositionAccessors = [];
    const pendingNormalAccessors = [];
    const pendingColorAccessors = [];
    for (let i4 = 0, il = targets.length; i4 < il; i4++) {
      const target = targets[i4];
      if (hasMorphPosition) {
        const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }
      if (hasMorphNormal) {
        const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(pendingAccessor);
      }
      if (hasMorphColor) {
        const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
        pendingColorAccessors.push(pendingAccessor);
      }
    }
    return Promise.all([
      Promise.all(pendingPositionAccessors),
      Promise.all(pendingNormalAccessors),
      Promise.all(pendingColorAccessors)
    ]).then(function(accessors) {
      const morphPositions = accessors[0];
      const morphNormals = accessors[1];
      const morphColors = accessors[2];
      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
      if (hasMorphColor) geometry.morphAttributes.color = morphColors;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== void 0) {
      for (let i4 = 0, il = meshDef.weights.length; i4 < il; i4++) {
        mesh.morphTargetInfluences[i4] = meshDef.weights[i4];
      }
    }
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      const targetNames = meshDef.extras.targetNames;
      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};
        for (let i4 = 0, il = targetNames.length; i4 < il; i4++) {
          mesh.morphTargetDictionary[targetNames[i4]] = i4;
        }
      } else {
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
      }
    }
  }
  function createPrimitiveKey(primitiveDef) {
    let geometryKey;
    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    if (dracoExtension) {
      geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }
    if (primitiveDef.targets !== void 0) {
      for (let i4 = 0, il = primitiveDef.targets.length; i4 < il; i4++) {
        geometryKey += ":" + createAttributesKey(primitiveDef.targets[i4]);
      }
    }
    return geometryKey;
  }
  function createAttributesKey(attributes) {
    let attributesKey = "";
    const keys = Object.keys(attributes).sort();
    for (let i4 = 0, il = keys.length; i4 < il; i4++) {
      attributesKey += keys[i4] + ":" + attributes[keys[i4]] + ";";
    }
    return attributesKey;
  }
  function getNormalizedComponentScale(constructor) {
    switch (constructor) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  function getImageURIMimeType(uri) {
    if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
    if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
    return "image/png";
  }
  var _identityMatrix = new Matrix4();
  var GLTFParser = class {
    constructor(json = {}, options = {}) {
      this.json = json;
      this.extensions = {};
      this.plugins = {};
      this.options = options;
      this.cache = new GLTFRegistry();
      this.associations = /* @__PURE__ */ new Map();
      this.primitiveCache = {};
      this.nodeCache = {};
      this.meshCache = { refs: {}, uses: {} };
      this.cameraCache = { refs: {}, uses: {} };
      this.lightCache = { refs: {}, uses: {} };
      this.sourceCache = {};
      this.textureCache = {};
      this.nodeNamesUsed = {};
      let isSafari = false;
      let isFirefox = false;
      let firefoxVersion = -1;
      if (typeof navigator !== "undefined") {
        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
        isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
        firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
      }
      if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
        this.textureLoader = new TextureLoader(this.options.manager);
      } else {
        this.textureLoader = new ImageBitmapLoader(this.options.manager);
      }
      this.textureLoader.setCrossOrigin(this.options.crossOrigin);
      this.textureLoader.setRequestHeader(this.options.requestHeader);
      this.fileLoader = new FileLoader(this.options.manager);
      this.fileLoader.setResponseType("arraybuffer");
      if (this.options.crossOrigin === "use-credentials") {
        this.fileLoader.setWithCredentials(true);
      }
    }
    setExtensions(extensions) {
      this.extensions = extensions;
    }
    setPlugins(plugins) {
      this.plugins = plugins;
    }
    parse(onLoad, onError) {
      const parser = this;
      const json = this.json;
      const extensions = this.extensions;
      this.cache.removeAll();
      this.nodeCache = {};
      this._invokeAll(function(ext) {
        return ext._markDefs && ext._markDefs();
      });
      Promise.all(this._invokeAll(function(ext) {
        return ext.beforeRoot && ext.beforeRoot();
      })).then(function() {
        return Promise.all([
          parser.getDependencies("scene"),
          parser.getDependencies("animation"),
          parser.getDependencies("camera")
        ]);
      }).then(function(dependencies) {
        const result = {
          scene: dependencies[0][json.scene || 0],
          scenes: dependencies[0],
          animations: dependencies[1],
          cameras: dependencies[2],
          asset: json.asset,
          parser,
          userData: {}
        };
        addUnknownExtensionsToUserData(extensions, result, json);
        assignExtrasToUserData(result, json);
        return Promise.all(parser._invokeAll(function(ext) {
          return ext.afterRoot && ext.afterRoot(result);
        })).then(function() {
          for (const scene of result.scenes) {
            scene.updateMatrixWorld();
          }
          onLoad(result);
        });
      }).catch(onError);
    }
    /**
     * Marks the special nodes/meshes in json for efficient parse.
     */
    _markDefs() {
      const nodeDefs = this.json.nodes || [];
      const skinDefs = this.json.skins || [];
      const meshDefs = this.json.meshes || [];
      for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
        const joints = skinDefs[skinIndex].joints;
        for (let i4 = 0, il = joints.length; i4 < il; i4++) {
          nodeDefs[joints[i4]].isBone = true;
        }
      }
      for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        const nodeDef = nodeDefs[nodeIndex];
        if (nodeDef.mesh !== void 0) {
          this._addNodeRef(this.meshCache, nodeDef.mesh);
          if (nodeDef.skin !== void 0) {
            meshDefs[nodeDef.mesh].isSkinnedMesh = true;
          }
        }
        if (nodeDef.camera !== void 0) {
          this._addNodeRef(this.cameraCache, nodeDef.camera);
        }
      }
    }
    /**
     * Counts references to shared node / Object3D resources. These resources
     * can be reused, or "instantiated", at multiple nodes in the scene
     * hierarchy. Mesh, Camera, and Light instances are instantiated and must
     * be marked. Non-scenegraph resources (like Materials, Geometries, and
     * Textures) can be reused directly and are not marked here.
     *
     * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
     */
    _addNodeRef(cache, index2) {
      if (index2 === void 0) return;
      if (cache.refs[index2] === void 0) {
        cache.refs[index2] = cache.uses[index2] = 0;
      }
      cache.refs[index2]++;
    }
    /** Returns a reference to a shared resource, cloning it if necessary. */
    _getNodeRef(cache, index2, object) {
      if (cache.refs[index2] <= 1) return object;
      const ref2 = object.clone();
      const updateMappings = (original, clone2) => {
        const mappings = this.associations.get(original);
        if (mappings != null) {
          this.associations.set(clone2, mappings);
        }
        for (const [i4, child] of original.children.entries()) {
          updateMappings(child, clone2.children[i4]);
        }
      };
      updateMappings(object, ref2);
      ref2.name += "_instance_" + cache.uses[index2]++;
      return ref2;
    }
    _invokeOne(func) {
      const extensions = Object.values(this.plugins);
      extensions.push(this);
      for (let i4 = 0; i4 < extensions.length; i4++) {
        const result = func(extensions[i4]);
        if (result) return result;
      }
      return null;
    }
    _invokeAll(func) {
      const extensions = Object.values(this.plugins);
      extensions.unshift(this);
      const pending = [];
      for (let i4 = 0; i4 < extensions.length; i4++) {
        const result = func(extensions[i4]);
        if (result) pending.push(result);
      }
      return pending;
    }
    /**
     * Requests the specified dependency asynchronously, with caching.
     * @param {string} type
     * @param {number} index
     * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
     */
    getDependency(type, index2) {
      const cacheKey = type + ":" + index2;
      let dependency = this.cache.get(cacheKey);
      if (!dependency) {
        switch (type) {
          case "scene":
            dependency = this.loadScene(index2);
            break;
          case "node":
            dependency = this._invokeOne(function(ext) {
              return ext.loadNode && ext.loadNode(index2);
            });
            break;
          case "mesh":
            dependency = this._invokeOne(function(ext) {
              return ext.loadMesh && ext.loadMesh(index2);
            });
            break;
          case "accessor":
            dependency = this.loadAccessor(index2);
            break;
          case "bufferView":
            dependency = this._invokeOne(function(ext) {
              return ext.loadBufferView && ext.loadBufferView(index2);
            });
            break;
          case "buffer":
            dependency = this.loadBuffer(index2);
            break;
          case "material":
            dependency = this._invokeOne(function(ext) {
              return ext.loadMaterial && ext.loadMaterial(index2);
            });
            break;
          case "texture":
            dependency = this._invokeOne(function(ext) {
              return ext.loadTexture && ext.loadTexture(index2);
            });
            break;
          case "skin":
            dependency = this.loadSkin(index2);
            break;
          case "animation":
            dependency = this._invokeOne(function(ext) {
              return ext.loadAnimation && ext.loadAnimation(index2);
            });
            break;
          case "camera":
            dependency = this.loadCamera(index2);
            break;
          default:
            dependency = this._invokeOne(function(ext) {
              return ext != this && ext.getDependency && ext.getDependency(type, index2);
            });
            if (!dependency) {
              throw new Error("Unknown type: " + type);
            }
            break;
        }
        this.cache.add(cacheKey, dependency);
      }
      return dependency;
    }
    /**
     * Requests all dependencies of the specified type asynchronously, with caching.
     * @param {string} type
     * @return {Promise<Array<Object>>}
     */
    getDependencies(type) {
      let dependencies = this.cache.get(type);
      if (!dependencies) {
        const parser = this;
        const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
        dependencies = Promise.all(defs.map(function(def, index2) {
          return parser.getDependency(type, index2);
        }));
        this.cache.add(type, dependencies);
      }
      return dependencies;
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferIndex
     * @return {Promise<ArrayBuffer>}
     */
    loadBuffer(bufferIndex) {
      const bufferDef = this.json.buffers[bufferIndex];
      const loader = this.fileLoader;
      if (bufferDef.type && bufferDef.type !== "arraybuffer") {
        throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
      }
      if (bufferDef.uri === void 0 && bufferIndex === 0) {
        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
      }
      const options = this.options;
      return new Promise(function(resolve, reject) {
        loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
          reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
        });
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferViewIndex
     * @return {Promise<ArrayBuffer>}
     */
    loadBufferView(bufferViewIndex) {
      const bufferViewDef = this.json.bufferViews[bufferViewIndex];
      return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
        const byteLength = bufferViewDef.byteLength || 0;
        const byteOffset = bufferViewDef.byteOffset || 0;
        return buffer.slice(byteOffset, byteOffset + byteLength);
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
     * @param {number} accessorIndex
     * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
     */
    loadAccessor(accessorIndex) {
      const parser = this;
      const json = this.json;
      const accessorDef = this.json.accessors[accessorIndex];
      if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
        const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
        const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        const normalized = accessorDef.normalized === true;
        const array = new TypedArray(accessorDef.count * itemSize);
        return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
      }
      const pendingBufferViews = [];
      if (accessorDef.bufferView !== void 0) {
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
      } else {
        pendingBufferViews.push(null);
      }
      if (accessorDef.sparse !== void 0) {
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
      }
      return Promise.all(pendingBufferViews).then(function(bufferViews) {
        const bufferView = bufferViews[0];
        const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
        const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        const elementBytes = TypedArray.BYTES_PER_ELEMENT;
        const itemBytes = elementBytes * itemSize;
        const byteOffset = accessorDef.byteOffset || 0;
        const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
        const normalized = accessorDef.normalized === true;
        let array, bufferAttribute;
        if (byteStride && byteStride !== itemBytes) {
          const ibSlice = Math.floor(byteOffset / byteStride);
          const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
          let ib = parser.cache.get(ibCacheKey);
          if (!ib) {
            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
            ib = new InterleavedBuffer(array, byteStride / elementBytes);
            parser.cache.add(ibCacheKey, ib);
          }
          bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
        } else {
          if (bufferView === null) {
            array = new TypedArray(accessorDef.count * itemSize);
          } else {
            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
          }
          bufferAttribute = new BufferAttribute(array, itemSize, normalized);
        }
        if (accessorDef.sparse !== void 0) {
          const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
          const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
          const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
          const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
          const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
          const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
          if (bufferView !== null) {
            bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
          }
          for (let i4 = 0, il = sparseIndices.length; i4 < il; i4++) {
            const index2 = sparseIndices[i4];
            bufferAttribute.setX(index2, sparseValues[i4 * itemSize]);
            if (itemSize >= 2) bufferAttribute.setY(index2, sparseValues[i4 * itemSize + 1]);
            if (itemSize >= 3) bufferAttribute.setZ(index2, sparseValues[i4 * itemSize + 2]);
            if (itemSize >= 4) bufferAttribute.setW(index2, sparseValues[i4 * itemSize + 3]);
            if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return bufferAttribute;
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
     * @param {number} textureIndex
     * @return {Promise<THREE.Texture|null>}
     */
    loadTexture(textureIndex) {
      const json = this.json;
      const options = this.options;
      const textureDef = json.textures[textureIndex];
      const sourceIndex = textureDef.source;
      const sourceDef = json.images[sourceIndex];
      let loader = this.textureLoader;
      if (sourceDef.uri) {
        const handler = options.manager.getHandler(sourceDef.uri);
        if (handler !== null) loader = handler;
      }
      return this.loadTextureImage(textureIndex, sourceIndex, loader);
    }
    loadTextureImage(textureIndex, sourceIndex, loader) {
      const parser = this;
      const json = this.json;
      const textureDef = json.textures[textureIndex];
      const sourceDef = json.images[sourceIndex];
      const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
      if (this.textureCache[cacheKey]) {
        return this.textureCache[cacheKey];
      }
      const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
        texture.flipY = false;
        texture.name = textureDef.name || sourceDef.name || "";
        if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
          texture.name = sourceDef.uri;
        }
        const samplers = json.samplers || {};
        const sampler = samplers[textureDef.sampler] || {};
        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
        parser.associations.set(texture, { textures: textureIndex });
        return texture;
      }).catch(function() {
        return null;
      });
      this.textureCache[cacheKey] = promise;
      return promise;
    }
    loadImageSource(sourceIndex, loader) {
      const parser = this;
      const json = this.json;
      const options = this.options;
      if (this.sourceCache[sourceIndex] !== void 0) {
        return this.sourceCache[sourceIndex].then((texture) => texture.clone());
      }
      const sourceDef = json.images[sourceIndex];
      const URL2 = self.URL || self.webkitURL;
      let sourceURI = sourceDef.uri || "";
      let isObjectURL = false;
      if (sourceDef.bufferView !== void 0) {
        sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
          isObjectURL = true;
          const blob = new Blob([bufferView], { type: sourceDef.mimeType });
          sourceURI = URL2.createObjectURL(blob);
          return sourceURI;
        });
      } else if (sourceDef.uri === void 0) {
        throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
      }
      const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
        return new Promise(function(resolve, reject) {
          let onLoad = resolve;
          if (loader.isImageBitmapLoader === true) {
            onLoad = function(imageBitmap) {
              const texture = new Texture(imageBitmap);
              texture.needsUpdate = true;
              resolve(texture);
            };
          }
          loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
        });
      }).then(function(texture) {
        if (isObjectURL === true) {
          URL2.revokeObjectURL(sourceURI);
        }
        assignExtrasToUserData(texture, sourceDef);
        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
        return texture;
      }).catch(function(error) {
        console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
        throw error;
      });
      this.sourceCache[sourceIndex] = promise;
      return promise;
    }
    /**
     * Asynchronously assigns a texture to the given material parameters.
     * @param {Object} materialParams
     * @param {string} mapName
     * @param {Object} mapDef
     * @return {Promise<Texture>}
     */
    assignTexture(materialParams, mapName, mapDef, colorSpace) {
      const parser = this;
      return this.getDependency("texture", mapDef.index).then(function(texture) {
        if (!texture) return null;
        if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
          texture = texture.clone();
          texture.channel = mapDef.texCoord;
        }
        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
          const transform2 = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
          if (transform2) {
            const gltfReference = parser.associations.get(texture);
            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform2);
            parser.associations.set(texture, gltfReference);
          }
        }
        if (colorSpace !== void 0) {
          texture.colorSpace = colorSpace;
        }
        materialParams[mapName] = texture;
        return texture;
      });
    }
    /**
     * Assigns final material to a Mesh, Line, or Points instance. The instance
     * already has a material (generated from the glTF material options alone)
     * but reuse of the same glTF material may require multiple threejs materials
     * to accommodate different primitive types, defines, etc. New materials will
     * be created if necessary, and reused from a cache.
     * @param  {Object3D} mesh Mesh, Line, or Points instance.
     */
    assignFinalMaterial(mesh) {
      const geometry = mesh.geometry;
      let material = mesh.material;
      const useDerivativeTangents = geometry.attributes.tangent === void 0;
      const useVertexColors = geometry.attributes.color !== void 0;
      const useFlatShading = geometry.attributes.normal === void 0;
      if (mesh.isPoints) {
        const cacheKey = "PointsMaterial:" + material.uuid;
        let pointsMaterial = this.cache.get(cacheKey);
        if (!pointsMaterial) {
          pointsMaterial = new PointsMaterial();
          Material.prototype.copy.call(pointsMaterial, material);
          pointsMaterial.color.copy(material.color);
          pointsMaterial.map = material.map;
          pointsMaterial.sizeAttenuation = false;
          this.cache.add(cacheKey, pointsMaterial);
        }
        material = pointsMaterial;
      } else if (mesh.isLine) {
        const cacheKey = "LineBasicMaterial:" + material.uuid;
        let lineMaterial = this.cache.get(cacheKey);
        if (!lineMaterial) {
          lineMaterial = new LineBasicMaterial();
          Material.prototype.copy.call(lineMaterial, material);
          lineMaterial.color.copy(material.color);
          lineMaterial.map = material.map;
          this.cache.add(cacheKey, lineMaterial);
        }
        material = lineMaterial;
      }
      if (useDerivativeTangents || useVertexColors || useFlatShading) {
        let cacheKey = "ClonedMaterial:" + material.uuid + ":";
        if (useDerivativeTangents) cacheKey += "derivative-tangents:";
        if (useVertexColors) cacheKey += "vertex-colors:";
        if (useFlatShading) cacheKey += "flat-shading:";
        let cachedMaterial = this.cache.get(cacheKey);
        if (!cachedMaterial) {
          cachedMaterial = material.clone();
          if (useVertexColors) cachedMaterial.vertexColors = true;
          if (useFlatShading) cachedMaterial.flatShading = true;
          if (useDerivativeTangents) {
            if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
            if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
          }
          this.cache.add(cacheKey, cachedMaterial);
          this.associations.set(cachedMaterial, this.associations.get(material));
        }
        material = cachedMaterial;
      }
      mesh.material = material;
    }
    getMaterialType() {
      return MeshStandardMaterial;
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
     * @param {number} materialIndex
     * @return {Promise<Material>}
     */
    loadMaterial(materialIndex) {
      const parser = this;
      const json = this.json;
      const extensions = this.extensions;
      const materialDef = json.materials[materialIndex];
      let materialType;
      const materialParams = {};
      const materialExtensions = materialDef.extensions || {};
      const pending = [];
      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
        const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
        materialType = kmuExtension.getMaterialType();
        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
      } else {
        const metallicRoughness = materialDef.pbrMetallicRoughness || {};
        materialParams.color = new Color(1, 1, 1);
        materialParams.opacity = 1;
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          const array = metallicRoughness.baseColorFactor;
          materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
          materialParams.opacity = array[3];
        }
        if (metallicRoughness.baseColorTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
        }
        materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
        materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
        if (metallicRoughness.metallicRoughnessTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
          pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
        }
        materialType = this._invokeOne(function(ext) {
          return ext.getMaterialType && ext.getMaterialType(materialIndex);
        });
        pending.push(Promise.all(this._invokeAll(function(ext) {
          return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
        })));
      }
      if (materialDef.doubleSided === true) {
        materialParams.side = DoubleSide;
      }
      const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
      if (alphaMode === ALPHA_MODES.BLEND) {
        materialParams.transparent = true;
        materialParams.depthWrite = false;
      } else {
        materialParams.transparent = false;
        if (alphaMode === ALPHA_MODES.MASK) {
          materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
        }
      }
      if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
        materialParams.normalScale = new Vector2(1, 1);
        if (materialDef.normalTexture.scale !== void 0) {
          const scale = materialDef.normalTexture.scale;
          materialParams.normalScale.set(scale, scale);
        }
      }
      if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
        if (materialDef.occlusionTexture.strength !== void 0) {
          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
        }
      }
      if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
        const emissiveFactor = materialDef.emissiveFactor;
        materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
      }
      if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
      }
      return Promise.all(pending).then(function() {
        const material = new materialType(materialParams);
        if (materialDef.name) material.name = materialDef.name;
        assignExtrasToUserData(material, materialDef);
        parser.associations.set(material, { materials: materialIndex });
        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
        return material;
      });
    }
    /** When Object3D instances are targeted by animation, they need unique names. */
    createUniqueName(originalName) {
      const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
      if (sanitizedName in this.nodeNamesUsed) {
        return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
      } else {
        this.nodeNamesUsed[sanitizedName] = 0;
        return sanitizedName;
      }
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
     *
     * Creates BufferGeometries from primitives.
     *
     * @param {Array<GLTF.Primitive>} primitives
     * @return {Promise<Array<BufferGeometry>>}
     */
    loadGeometries(primitives) {
      const parser = this;
      const extensions = this.extensions;
      const cache = this.primitiveCache;
      function createDracoPrimitive(primitive) {
        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
          return addPrimitiveAttributes(geometry, primitive, parser);
        });
      }
      const pending = [];
      for (let i4 = 0, il = primitives.length; i4 < il; i4++) {
        const primitive = primitives[i4];
        const cacheKey = createPrimitiveKey(primitive);
        const cached = cache[cacheKey];
        if (cached) {
          pending.push(cached.promise);
        } else {
          let geometryPromise;
          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
            geometryPromise = createDracoPrimitive(primitive);
          } else {
            geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
          }
          cache[cacheKey] = { primitive, promise: geometryPromise };
          pending.push(geometryPromise);
        }
      }
      return Promise.all(pending);
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
     * @param {number} meshIndex
     * @return {Promise<Group|Mesh|SkinnedMesh>}
     */
    loadMesh(meshIndex) {
      const parser = this;
      const json = this.json;
      const extensions = this.extensions;
      const meshDef = json.meshes[meshIndex];
      const primitives = meshDef.primitives;
      const pending = [];
      for (let i4 = 0, il = primitives.length; i4 < il; i4++) {
        const material = primitives[i4].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i4].material);
        pending.push(material);
      }
      pending.push(parser.loadGeometries(primitives));
      return Promise.all(pending).then(function(results) {
        const materials = results.slice(0, results.length - 1);
        const geometries = results[results.length - 1];
        const meshes = [];
        for (let i4 = 0, il = geometries.length; i4 < il; i4++) {
          const geometry = geometries[i4];
          const primitive = primitives[i4];
          let mesh;
          const material = materials[i4];
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
            mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
            if (mesh.isSkinnedMesh === true) {
              mesh.normalizeSkinWeights();
            }
            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
            }
          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
            mesh = new LineSegments(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
            mesh = new Line(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
            mesh = new LineLoop(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
            mesh = new Points(geometry, material);
          } else {
            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
          }
          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
            updateMorphTargets(mesh, meshDef);
          }
          mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
          assignExtrasToUserData(mesh, meshDef);
          if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
          parser.assignFinalMaterial(mesh);
          meshes.push(mesh);
        }
        for (let i4 = 0, il = meshes.length; i4 < il; i4++) {
          parser.associations.set(meshes[i4], {
            meshes: meshIndex,
            primitives: i4
          });
        }
        if (meshes.length === 1) {
          if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
          return meshes[0];
        }
        const group = new Group();
        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
        parser.associations.set(group, { meshes: meshIndex });
        for (let i4 = 0, il = meshes.length; i4 < il; i4++) {
          group.add(meshes[i4]);
        }
        return group;
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
     * @param {number} cameraIndex
     * @return {Promise<THREE.Camera>}
     */
    loadCamera(cameraIndex) {
      let camera;
      const cameraDef = this.json.cameras[cameraIndex];
      const params = cameraDef[cameraDef.type];
      if (!params) {
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
        return;
      }
      if (cameraDef.type === "perspective") {
        camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
      } else if (cameraDef.type === "orthographic") {
        camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
      }
      if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
      assignExtrasToUserData(camera, cameraDef);
      return Promise.resolve(camera);
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
     * @param {number} skinIndex
     * @return {Promise<Skeleton>}
     */
    loadSkin(skinIndex) {
      const skinDef = this.json.skins[skinIndex];
      const pending = [];
      for (let i4 = 0, il = skinDef.joints.length; i4 < il; i4++) {
        pending.push(this._loadNodeShallow(skinDef.joints[i4]));
      }
      if (skinDef.inverseBindMatrices !== void 0) {
        pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
      } else {
        pending.push(null);
      }
      return Promise.all(pending).then(function(results) {
        const inverseBindMatrices = results.pop();
        const jointNodes = results;
        const bones = [];
        const boneInverses = [];
        for (let i4 = 0, il = jointNodes.length; i4 < il; i4++) {
          const jointNode = jointNodes[i4];
          if (jointNode) {
            bones.push(jointNode);
            const mat = new Matrix4();
            if (inverseBindMatrices !== null) {
              mat.fromArray(inverseBindMatrices.array, i4 * 16);
            }
            boneInverses.push(mat);
          } else {
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i4]);
          }
        }
        return new Skeleton(bones, boneInverses);
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
     * @param {number} animationIndex
     * @return {Promise<AnimationClip>}
     */
    loadAnimation(animationIndex) {
      const json = this.json;
      const parser = this;
      const animationDef = json.animations[animationIndex];
      const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      const pendingNodes = [];
      const pendingInputAccessors = [];
      const pendingOutputAccessors = [];
      const pendingSamplers = [];
      const pendingTargets = [];
      for (let i4 = 0, il = animationDef.channels.length; i4 < il; i4++) {
        const channel = animationDef.channels[i4];
        const sampler = animationDef.samplers[channel.sampler];
        const target = channel.target;
        const name = target.node;
        const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
        const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
        if (target.node === void 0) continue;
        pendingNodes.push(this.getDependency("node", name));
        pendingInputAccessors.push(this.getDependency("accessor", input));
        pendingOutputAccessors.push(this.getDependency("accessor", output));
        pendingSamplers.push(sampler);
        pendingTargets.push(target);
      }
      return Promise.all([
        Promise.all(pendingNodes),
        Promise.all(pendingInputAccessors),
        Promise.all(pendingOutputAccessors),
        Promise.all(pendingSamplers),
        Promise.all(pendingTargets)
      ]).then(function(dependencies) {
        const nodes = dependencies[0];
        const inputAccessors = dependencies[1];
        const outputAccessors = dependencies[2];
        const samplers = dependencies[3];
        const targets = dependencies[4];
        const tracks = [];
        for (let i4 = 0, il = nodes.length; i4 < il; i4++) {
          const node = nodes[i4];
          const inputAccessor = inputAccessors[i4];
          const outputAccessor = outputAccessors[i4];
          const sampler = samplers[i4];
          const target = targets[i4];
          if (node === void 0) continue;
          if (node.updateMatrix) {
            node.updateMatrix();
          }
          const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
          if (createdTracks) {
            for (let k2 = 0; k2 < createdTracks.length; k2++) {
              tracks.push(createdTracks[k2]);
            }
          }
        }
        return new AnimationClip(animationName, void 0, tracks);
      });
    }
    createNodeMesh(nodeIndex) {
      const json = this.json;
      const parser = this;
      const nodeDef = json.nodes[nodeIndex];
      if (nodeDef.mesh === void 0) return null;
      return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
        const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
        if (nodeDef.weights !== void 0) {
          node.traverse(function(o4) {
            if (!o4.isMesh) return;
            for (let i4 = 0, il = nodeDef.weights.length; i4 < il; i4++) {
              o4.morphTargetInfluences[i4] = nodeDef.weights[i4];
            }
          });
        }
        return node;
      });
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
     * @param {number} nodeIndex
     * @return {Promise<Object3D>}
     */
    loadNode(nodeIndex) {
      const json = this.json;
      const parser = this;
      const nodeDef = json.nodes[nodeIndex];
      const nodePending = parser._loadNodeShallow(nodeIndex);
      const childPending = [];
      const childrenDef = nodeDef.children || [];
      for (let i4 = 0, il = childrenDef.length; i4 < il; i4++) {
        childPending.push(parser.getDependency("node", childrenDef[i4]));
      }
      const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
      return Promise.all([
        nodePending,
        Promise.all(childPending),
        skeletonPending
      ]).then(function(results) {
        const node = results[0];
        const children2 = results[1];
        const skeleton = results[2];
        if (skeleton !== null) {
          node.traverse(function(mesh) {
            if (!mesh.isSkinnedMesh) return;
            mesh.bind(skeleton, _identityMatrix);
          });
        }
        for (let i4 = 0, il = children2.length; i4 < il; i4++) {
          node.add(children2[i4]);
        }
        return node;
      });
    }
    // ._loadNodeShallow() parses a single node.
    // skin and child nodes are created and added in .loadNode() (no '_' prefix).
    _loadNodeShallow(nodeIndex) {
      const json = this.json;
      const extensions = this.extensions;
      const parser = this;
      if (this.nodeCache[nodeIndex] !== void 0) {
        return this.nodeCache[nodeIndex];
      }
      const nodeDef = json.nodes[nodeIndex];
      const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
      const pending = [];
      const meshPromise = parser._invokeOne(function(ext) {
        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
      });
      if (meshPromise) {
        pending.push(meshPromise);
      }
      if (nodeDef.camera !== void 0) {
        pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
        }));
      }
      parser._invokeAll(function(ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function(promise) {
        pending.push(promise);
      });
      this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
        let node;
        if (nodeDef.isBone === true) {
          node = new Bone();
        } else if (objects.length > 1) {
          node = new Group();
        } else if (objects.length === 1) {
          node = objects[0];
        } else {
          node = new Object3D();
        }
        if (node !== objects[0]) {
          for (let i4 = 0, il = objects.length; i4 < il; i4++) {
            node.add(objects[i4]);
          }
        }
        if (nodeDef.name) {
          node.userData.name = nodeDef.name;
          node.name = nodeName;
        }
        assignExtrasToUserData(node, nodeDef);
        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
        if (nodeDef.matrix !== void 0) {
          const matrix = new Matrix4();
          matrix.fromArray(nodeDef.matrix);
          node.applyMatrix4(matrix);
        } else {
          if (nodeDef.translation !== void 0) {
            node.position.fromArray(nodeDef.translation);
          }
          if (nodeDef.rotation !== void 0) {
            node.quaternion.fromArray(nodeDef.rotation);
          }
          if (nodeDef.scale !== void 0) {
            node.scale.fromArray(nodeDef.scale);
          }
        }
        if (!parser.associations.has(node)) {
          parser.associations.set(node, {});
        }
        parser.associations.get(node).nodes = nodeIndex;
        return node;
      });
      return this.nodeCache[nodeIndex];
    }
    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
     * @param {number} sceneIndex
     * @return {Promise<Group>}
     */
    loadScene(sceneIndex) {
      const extensions = this.extensions;
      const sceneDef = this.json.scenes[sceneIndex];
      const parser = this;
      const scene = new Group();
      if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
      assignExtrasToUserData(scene, sceneDef);
      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
      const nodeIds = sceneDef.nodes || [];
      const pending = [];
      for (let i4 = 0, il = nodeIds.length; i4 < il; i4++) {
        pending.push(parser.getDependency("node", nodeIds[i4]));
      }
      return Promise.all(pending).then(function(nodes) {
        for (let i4 = 0, il = nodes.length; i4 < il; i4++) {
          scene.add(nodes[i4]);
        }
        const reduceAssociations = (node) => {
          const reducedAssociations = /* @__PURE__ */ new Map();
          for (const [key, value] of parser.associations) {
            if (key instanceof Material || key instanceof Texture) {
              reducedAssociations.set(key, value);
            }
          }
          node.traverse((node2) => {
            const mappings = parser.associations.get(node2);
            if (mappings != null) {
              reducedAssociations.set(node2, mappings);
            }
          });
          return reducedAssociations;
        };
        parser.associations = reduceAssociations(scene);
        return scene;
      });
    }
    _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
      const tracks = [];
      const targetName = node.name ? node.name : node.uuid;
      const targetNames = [];
      if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
        node.traverse(function(object) {
          if (object.morphTargetInfluences) {
            targetNames.push(object.name ? object.name : object.uuid);
          }
        });
      } else {
        targetNames.push(targetName);
      }
      let TypedKeyframeTrack;
      switch (PATH_PROPERTIES[target.path]) {
        case PATH_PROPERTIES.weights:
          TypedKeyframeTrack = NumberKeyframeTrack;
          break;
        case PATH_PROPERTIES.rotation:
          TypedKeyframeTrack = QuaternionKeyframeTrack;
          break;
        case PATH_PROPERTIES.position:
        case PATH_PROPERTIES.scale:
          TypedKeyframeTrack = VectorKeyframeTrack;
          break;
        default:
          switch (outputAccessor.itemSize) {
            case 1:
              TypedKeyframeTrack = NumberKeyframeTrack;
              break;
            case 2:
            case 3:
            default:
              TypedKeyframeTrack = VectorKeyframeTrack;
              break;
          }
          break;
      }
      const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
      const outputArray = this._getArrayFromAccessor(outputAccessor);
      for (let j2 = 0, jl = targetNames.length; j2 < jl; j2++) {
        const track = new TypedKeyframeTrack(
          targetNames[j2] + "." + PATH_PROPERTIES[target.path],
          inputAccessor.array,
          outputArray,
          interpolation
        );
        if (sampler.interpolation === "CUBICSPLINE") {
          this._createCubicSplineTrackInterpolant(track);
        }
        tracks.push(track);
      }
      return tracks;
    }
    _getArrayFromAccessor(accessor) {
      let outputArray = accessor.array;
      if (accessor.normalized) {
        const scale = getNormalizedComponentScale(outputArray.constructor);
        const scaled = new Float32Array(outputArray.length);
        for (let j2 = 0, jl = outputArray.length; j2 < jl; j2++) {
          scaled[j2] = outputArray[j2] * scale;
        }
        outputArray = scaled;
      }
      return outputArray;
    }
    _createCubicSplineTrackInterpolant(track) {
      track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
        const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
        return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
      };
      track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
    }
  };
  function computeBounds(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const box = new Box3();
    if (attributes.POSITION !== void 0) {
      const accessor = parser.json.accessors[attributes.POSITION];
      const min = accessor.min;
      const max = accessor.max;
      if (min !== void 0 && max !== void 0) {
        box.set(
          new Vector3(min[0], min[1], min[2]),
          new Vector3(max[0], max[1], max[2])
        );
        if (accessor.normalized) {
          const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
          box.min.multiplyScalar(boxScale);
          box.max.multiplyScalar(boxScale);
        }
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else {
      return;
    }
    const targets = primitiveDef.targets;
    if (targets !== void 0) {
      const maxDisplacement = new Vector3();
      const vector = new Vector3();
      for (let i4 = 0, il = targets.length; i4 < il; i4++) {
        const target = targets[i4];
        if (target.POSITION !== void 0) {
          const accessor = parser.json.accessors[target.POSITION];
          const min = accessor.min;
          const max = accessor.max;
          if (min !== void 0 && max !== void 0) {
            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
            if (accessor.normalized) {
              const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
              vector.multiplyScalar(boxScale);
            }
            maxDisplacement.max(vector);
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
      }
      box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    const sphere = new Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
        geometry.setAttribute(attributeName, accessor);
      });
    }
    for (const gltfAttributeName in attributes) {
      const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
      if (threeAttributeName in geometry.attributes) continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== void 0 && !geometry.index) {
      const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
        geometry.setIndex(accessor2);
      });
      pending.push(accessor);
    }
    if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
      console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function() {
      return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }

  // assets/scripts/utils/3d.js
  var gltfLoader = new GLTFLoader();
  var dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath("https://unpkg.com/three@0.165.0/examples/jsm/libs/draco/gltf/");
  gltfLoader.setDRACOLoader(dracoLoader);

  // node_modules/three/examples/jsm/controls/OrbitControls.js
  var _changeEvent = { type: "change" };
  var _startEvent = { type: "start" };
  var _endEvent = { type: "end" };
  var _ray2 = new Ray();
  var _plane = new Plane();
  var TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
  var OrbitControls = class extends EventDispatcher {
    constructor(object, domElement) {
      super();
      this.object = object;
      this.domElement = domElement;
      this.domElement.style.touchAction = "none";
      this.enabled = true;
      this.target = new Vector3();
      this.cursor = new Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minZoom = 0;
      this.maxZoom = Infinity;
      this.minTargetRadius = 0;
      this.maxTargetRadius = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.minAzimuthAngle = -Infinity;
      this.maxAzimuthAngle = Infinity;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.enableZoom = true;
      this.zoomSpeed = 1;
      this.enableRotate = true;
      this.rotateSpeed = 1;
      this.enablePan = true;
      this.panSpeed = 1;
      this.screenSpacePanning = true;
      this.keyPanSpeed = 7;
      this.zoomToCursor = false;
      this.autoRotate = false;
      this.autoRotateSpeed = 2;
      this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
      this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
      this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.zoom0 = this.object.zoom;
      this._domElementKeyEvents = null;
      this.getPolarAngle = function() {
        return spherical.phi;
      };
      this.getAzimuthalAngle = function() {
        return spherical.theta;
      };
      this.getDistance = function() {
        return this.object.position.distanceTo(this.target);
      };
      this.listenToKeyEvents = function(domElement2) {
        domElement2.addEventListener("keydown", onKeyDown);
        this._domElementKeyEvents = domElement2;
      };
      this.stopListenToKeyEvents = function() {
        this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        this._domElementKeyEvents = null;
      };
      this.saveState = function() {
        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
      };
      this.reset = function() {
        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(_changeEvent);
        scope.update();
        state = STATE.NONE;
      };
      this.update = function() {
        const offset2 = new Vector3();
        const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
        const quatInverse = quat.clone().invert();
        const lastPosition = new Vector3();
        const lastQuaternion = new Quaternion();
        const lastTargetPosition = new Vector3();
        const twoPI = 2 * Math.PI;
        return function update(deltaTime = null) {
          const position = scope.object.position;
          offset2.copy(position).sub(scope.target);
          offset2.applyQuaternion(quat);
          spherical.setFromVector3(offset2);
          if (scope.autoRotate && state === STATE.NONE) {
            rotateLeft(getAutoRotationAngle(deltaTime));
          }
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          let min = scope.minAzimuthAngle;
          let max = scope.maxAzimuthAngle;
          if (isFinite(min) && isFinite(max)) {
            if (min < -Math.PI) min += twoPI;
            else if (min > Math.PI) min -= twoPI;
            if (max < -Math.PI) max += twoPI;
            else if (max > Math.PI) max -= twoPI;
            if (min <= max) {
              spherical.theta = Math.max(min, Math.min(max, spherical.theta));
            } else {
              spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
            }
          }
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          if (scope.enableDamping === true) {
            scope.target.addScaledVector(panOffset, scope.dampingFactor);
          } else {
            scope.target.add(panOffset);
          }
          scope.target.sub(scope.cursor);
          scope.target.clampLength(scope.minTargetRadius, scope.maxTargetRadius);
          scope.target.add(scope.cursor);
          let zoomChanged = false;
          if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {
            spherical.radius = clampDistance(spherical.radius);
          } else {
            const prevRadius = spherical.radius;
            spherical.radius = clampDistance(spherical.radius * scale);
            zoomChanged = prevRadius != spherical.radius;
          }
          offset2.setFromSpherical(spherical);
          offset2.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset2);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping === true) {
            sphericalDelta.theta *= 1 - scope.dampingFactor;
            sphericalDelta.phi *= 1 - scope.dampingFactor;
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          if (scope.zoomToCursor && performCursorZoom) {
            let newRadius = null;
            if (scope.object.isPerspectiveCamera) {
              const prevRadius = offset2.length();
              newRadius = clampDistance(prevRadius * scale);
              const radiusDelta = prevRadius - newRadius;
              scope.object.position.addScaledVector(dollyDirection, radiusDelta);
              scope.object.updateMatrixWorld();
              zoomChanged = !!radiusDelta;
            } else if (scope.object.isOrthographicCamera) {
              const mouseBefore = new Vector3(mouse.x, mouse.y, 0);
              mouseBefore.unproject(scope.object);
              const prevZoom = scope.object.zoom;
              scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));
              scope.object.updateProjectionMatrix();
              zoomChanged = prevZoom !== scope.object.zoom;
              const mouseAfter = new Vector3(mouse.x, mouse.y, 0);
              mouseAfter.unproject(scope.object);
              scope.object.position.sub(mouseAfter).add(mouseBefore);
              scope.object.updateMatrixWorld();
              newRadius = offset2.length();
            } else {
              console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
              scope.zoomToCursor = false;
            }
            if (newRadius !== null) {
              if (this.screenSpacePanning) {
                scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);
              } else {
                _ray2.origin.copy(scope.object.position);
                _ray2.direction.set(0, 0, -1).transformDirection(scope.object.matrix);
                if (Math.abs(scope.object.up.dot(_ray2.direction)) < TILT_LIMIT) {
                  object.lookAt(scope.target);
                } else {
                  _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);
                  _ray2.intersectPlane(_plane, scope.target);
                }
              }
            }
          } else if (scope.object.isOrthographicCamera) {
            const prevZoom = scope.object.zoom;
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));
            if (prevZoom !== scope.object.zoom) {
              scope.object.updateProjectionMatrix();
              zoomChanged = true;
            }
          }
          scale = 1;
          performCursorZoom = false;
          if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS || lastTargetPosition.distanceToSquared(scope.target) > EPS) {
            scope.dispatchEvent(_changeEvent);
            lastPosition.copy(scope.object.position);
            lastQuaternion.copy(scope.object.quaternion);
            lastTargetPosition.copy(scope.target);
            return true;
          }
          return false;
        };
      }();
      this.dispose = function() {
        scope.domElement.removeEventListener("contextmenu", onContextMenu);
        scope.domElement.removeEventListener("pointerdown", onPointerDown);
        scope.domElement.removeEventListener("pointercancel", onPointerUp);
        scope.domElement.removeEventListener("wheel", onMouseWheel);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
        const document3 = scope.domElement.getRootNode();
        document3.removeEventListener("keydown", interceptControlDown, { capture: true });
        if (scope._domElementKeyEvents !== null) {
          scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
          scope._domElementKeyEvents = null;
        }
      };
      const scope = this;
      const STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      let state = STATE.NONE;
      const EPS = 1e-6;
      const spherical = new Spherical();
      const sphericalDelta = new Spherical();
      let scale = 1;
      const panOffset = new Vector3();
      const rotateStart = new Vector2();
      const rotateEnd = new Vector2();
      const rotateDelta = new Vector2();
      const panStart = new Vector2();
      const panEnd = new Vector2();
      const panDelta = new Vector2();
      const dollyStart = new Vector2();
      const dollyEnd = new Vector2();
      const dollyDelta = new Vector2();
      const dollyDirection = new Vector3();
      const mouse = new Vector2();
      let performCursorZoom = false;
      const pointers = [];
      const pointerPositions = {};
      let controlActive = false;
      function getAutoRotationAngle(deltaTime) {
        if (deltaTime !== null) {
          return 2 * Math.PI / 60 * scope.autoRotateSpeed * deltaTime;
        } else {
          return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
        }
      }
      function getZoomScale(delta) {
        const normalizedDelta = Math.abs(delta * 0.01);
        return Math.pow(0.95, scope.zoomSpeed * normalizedDelta);
      }
      function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
      }
      function rotateUp(angle) {
        sphericalDelta.phi -= angle;
      }
      const panLeft = function() {
        const v2 = new Vector3();
        return function panLeft2(distance, objectMatrix) {
          v2.setFromMatrixColumn(objectMatrix, 0);
          v2.multiplyScalar(-distance);
          panOffset.add(v2);
        };
      }();
      const panUp = function() {
        const v2 = new Vector3();
        return function panUp2(distance, objectMatrix) {
          if (scope.screenSpacePanning === true) {
            v2.setFromMatrixColumn(objectMatrix, 1);
          } else {
            v2.setFromMatrixColumn(objectMatrix, 0);
            v2.crossVectors(scope.object.up, v2);
          }
          v2.multiplyScalar(distance);
          panOffset.add(v2);
        };
      }();
      const pan = function() {
        const offset2 = new Vector3();
        return function pan2(deltaX, deltaY) {
          const element = scope.domElement;
          if (scope.object.isPerspectiveCamera) {
            const position = scope.object.position;
            offset2.copy(position).sub(scope.target);
            let targetDistance = offset2.length();
            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
            panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
            panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
          } else if (scope.object.isOrthographicCamera) {
            panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
            scope.enablePan = false;
          }
        };
      }();
      function dollyOut(dollyScale) {
        if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
          scale /= dollyScale;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function dollyIn(dollyScale) {
        if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
          scale *= dollyScale;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function updateZoomParameters(x2, y2) {
        if (!scope.zoomToCursor) {
          return;
        }
        performCursorZoom = true;
        const rect = scope.domElement.getBoundingClientRect();
        const dx = x2 - rect.left;
        const dy = y2 - rect.top;
        const w2 = rect.width;
        const h4 = rect.height;
        mouse.x = dx / w2 * 2 - 1;
        mouse.y = -(dy / h4) * 2 + 1;
        dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();
      }
      function clampDistance(dist) {
        return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));
      }
      function handleMouseDownRotate(event2) {
        rotateStart.set(event2.clientX, event2.clientY);
      }
      function handleMouseDownDolly(event2) {
        updateZoomParameters(event2.clientX, event2.clientX);
        dollyStart.set(event2.clientX, event2.clientY);
      }
      function handleMouseDownPan(event2) {
        panStart.set(event2.clientX, event2.clientY);
      }
      function handleMouseMoveRotate(event2) {
        rotateEnd.set(event2.clientX, event2.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        const element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
        scope.update();
      }
      function handleMouseMoveDolly(event2) {
        dollyEnd.set(event2.clientX, event2.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);
        if (dollyDelta.y > 0) {
          dollyOut(getZoomScale(dollyDelta.y));
        } else if (dollyDelta.y < 0) {
          dollyIn(getZoomScale(dollyDelta.y));
        }
        dollyStart.copy(dollyEnd);
        scope.update();
      }
      function handleMouseMovePan(event2) {
        panEnd.set(event2.clientX, event2.clientY);
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
      }
      function handleMouseWheel(event2) {
        updateZoomParameters(event2.clientX, event2.clientY);
        if (event2.deltaY < 0) {
          dollyIn(getZoomScale(event2.deltaY));
        } else if (event2.deltaY > 0) {
          dollyOut(getZoomScale(event2.deltaY));
        }
        scope.update();
      }
      function handleKeyDown(event2) {
        let needsUpdate = false;
        switch (event2.code) {
          case scope.keys.UP:
            if (event2.ctrlKey || event2.metaKey || event2.shiftKey) {
              rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
            } else {
              pan(0, scope.keyPanSpeed);
            }
            needsUpdate = true;
            break;
          case scope.keys.BOTTOM:
            if (event2.ctrlKey || event2.metaKey || event2.shiftKey) {
              rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
            } else {
              pan(0, -scope.keyPanSpeed);
            }
            needsUpdate = true;
            break;
          case scope.keys.LEFT:
            if (event2.ctrlKey || event2.metaKey || event2.shiftKey) {
              rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
            } else {
              pan(scope.keyPanSpeed, 0);
            }
            needsUpdate = true;
            break;
          case scope.keys.RIGHT:
            if (event2.ctrlKey || event2.metaKey || event2.shiftKey) {
              rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
            } else {
              pan(-scope.keyPanSpeed, 0);
            }
            needsUpdate = true;
            break;
        }
        if (needsUpdate) {
          event2.preventDefault();
          scope.update();
        }
      }
      function handleTouchStartRotate(event2) {
        if (pointers.length === 1) {
          rotateStart.set(event2.pageX, event2.pageY);
        } else {
          const position = getSecondPointerPosition(event2);
          const x2 = 0.5 * (event2.pageX + position.x);
          const y2 = 0.5 * (event2.pageY + position.y);
          rotateStart.set(x2, y2);
        }
      }
      function handleTouchStartPan(event2) {
        if (pointers.length === 1) {
          panStart.set(event2.pageX, event2.pageY);
        } else {
          const position = getSecondPointerPosition(event2);
          const x2 = 0.5 * (event2.pageX + position.x);
          const y2 = 0.5 * (event2.pageY + position.y);
          panStart.set(x2, y2);
        }
      }
      function handleTouchStartDolly(event2) {
        const position = getSecondPointerPosition(event2);
        const dx = event2.pageX - position.x;
        const dy = event2.pageY - position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
      }
      function handleTouchStartDollyPan(event2) {
        if (scope.enableZoom) handleTouchStartDolly(event2);
        if (scope.enablePan) handleTouchStartPan(event2);
      }
      function handleTouchStartDollyRotate(event2) {
        if (scope.enableZoom) handleTouchStartDolly(event2);
        if (scope.enableRotate) handleTouchStartRotate(event2);
      }
      function handleTouchMoveRotate(event2) {
        if (pointers.length == 1) {
          rotateEnd.set(event2.pageX, event2.pageY);
        } else {
          const position = getSecondPointerPosition(event2);
          const x2 = 0.5 * (event2.pageX + position.x);
          const y2 = 0.5 * (event2.pageY + position.y);
          rotateEnd.set(x2, y2);
        }
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        const element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
      }
      function handleTouchMovePan(event2) {
        if (pointers.length === 1) {
          panEnd.set(event2.pageX, event2.pageY);
        } else {
          const position = getSecondPointerPosition(event2);
          const x2 = 0.5 * (event2.pageX + position.x);
          const y2 = 0.5 * (event2.pageY + position.y);
          panEnd.set(x2, y2);
        }
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
      }
      function handleTouchMoveDolly(event2) {
        const position = getSecondPointerPosition(event2);
        const dx = event2.pageX - position.x;
        const dy = event2.pageY - position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
        dollyOut(dollyDelta.y);
        dollyStart.copy(dollyEnd);
        const centerX = (event2.pageX + position.x) * 0.5;
        const centerY = (event2.pageY + position.y) * 0.5;
        updateZoomParameters(centerX, centerY);
      }
      function handleTouchMoveDollyPan(event2) {
        if (scope.enableZoom) handleTouchMoveDolly(event2);
        if (scope.enablePan) handleTouchMovePan(event2);
      }
      function handleTouchMoveDollyRotate(event2) {
        if (scope.enableZoom) handleTouchMoveDolly(event2);
        if (scope.enableRotate) handleTouchMoveRotate(event2);
      }
      function onPointerDown(event2) {
        if (scope.enabled === false) return;
        if (pointers.length === 0) {
          scope.domElement.setPointerCapture(event2.pointerId);
          scope.domElement.addEventListener("pointermove", onPointerMove);
          scope.domElement.addEventListener("pointerup", onPointerUp);
        }
        if (isTrackingPointer(event2)) return;
        addPointer(event2);
        if (event2.pointerType === "touch") {
          onTouchStart2(event2);
        } else {
          onMouseDown(event2);
        }
      }
      function onPointerMove(event2) {
        if (scope.enabled === false) return;
        if (event2.pointerType === "touch") {
          onTouchMove2(event2);
        } else {
          onMouseMove(event2);
        }
      }
      function onPointerUp(event2) {
        removePointer(event2);
        switch (pointers.length) {
          case 0:
            scope.domElement.releasePointerCapture(event2.pointerId);
            scope.domElement.removeEventListener("pointermove", onPointerMove);
            scope.domElement.removeEventListener("pointerup", onPointerUp);
            scope.dispatchEvent(_endEvent);
            state = STATE.NONE;
            break;
          case 1:
            const pointerId = pointers[0];
            const position = pointerPositions[pointerId];
            onTouchStart2({ pointerId, pageX: position.x, pageY: position.y });
            break;
        }
      }
      function onMouseDown(event2) {
        let mouseAction;
        switch (event2.button) {
          case 0:
            mouseAction = scope.mouseButtons.LEFT;
            break;
          case 1:
            mouseAction = scope.mouseButtons.MIDDLE;
            break;
          case 2:
            mouseAction = scope.mouseButtons.RIGHT;
            break;
          default:
            mouseAction = -1;
        }
        switch (mouseAction) {
          case MOUSE.DOLLY:
            if (scope.enableZoom === false) return;
            handleMouseDownDolly(event2);
            state = STATE.DOLLY;
            break;
          case MOUSE.ROTATE:
            if (event2.ctrlKey || event2.metaKey || event2.shiftKey) {
              if (scope.enablePan === false) return;
              handleMouseDownPan(event2);
              state = STATE.PAN;
            } else {
              if (scope.enableRotate === false) return;
              handleMouseDownRotate(event2);
              state = STATE.ROTATE;
            }
            break;
          case MOUSE.PAN:
            if (event2.ctrlKey || event2.metaKey || event2.shiftKey) {
              if (scope.enableRotate === false) return;
              handleMouseDownRotate(event2);
              state = STATE.ROTATE;
            } else {
              if (scope.enablePan === false) return;
              handleMouseDownPan(event2);
              state = STATE.PAN;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }
      function onMouseMove(event2) {
        switch (state) {
          case STATE.ROTATE:
            if (scope.enableRotate === false) return;
            handleMouseMoveRotate(event2);
            break;
          case STATE.DOLLY:
            if (scope.enableZoom === false) return;
            handleMouseMoveDolly(event2);
            break;
          case STATE.PAN:
            if (scope.enablePan === false) return;
            handleMouseMovePan(event2);
            break;
        }
      }
      function onMouseWheel(event2) {
        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;
        event2.preventDefault();
        scope.dispatchEvent(_startEvent);
        handleMouseWheel(customWheelEvent(event2));
        scope.dispatchEvent(_endEvent);
      }
      function customWheelEvent(event2) {
        const mode = event2.deltaMode;
        const newEvent = {
          clientX: event2.clientX,
          clientY: event2.clientY,
          deltaY: event2.deltaY
        };
        switch (mode) {
          case 1:
            newEvent.deltaY *= 16;
            break;
          case 2:
            newEvent.deltaY *= 100;
            break;
        }
        if (event2.ctrlKey && !controlActive) {
          newEvent.deltaY *= 10;
        }
        return newEvent;
      }
      function interceptControlDown(event2) {
        if (event2.key === "Control") {
          controlActive = true;
          const document3 = scope.domElement.getRootNode();
          document3.addEventListener("keyup", interceptControlUp, { passive: true, capture: true });
        }
      }
      function interceptControlUp(event2) {
        if (event2.key === "Control") {
          controlActive = false;
          const document3 = scope.domElement.getRootNode();
          document3.removeEventListener("keyup", interceptControlUp, { passive: true, capture: true });
        }
      }
      function onKeyDown(event2) {
        if (scope.enabled === false || scope.enablePan === false) return;
        handleKeyDown(event2);
      }
      function onTouchStart2(event2) {
        trackPointer(event2);
        switch (pointers.length) {
          case 1:
            switch (scope.touches.ONE) {
              case TOUCH.ROTATE:
                if (scope.enableRotate === false) return;
                handleTouchStartRotate(event2);
                state = STATE.TOUCH_ROTATE;
                break;
              case TOUCH.PAN:
                if (scope.enablePan === false) return;
                handleTouchStartPan(event2);
                state = STATE.TOUCH_PAN;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          case 2:
            switch (scope.touches.TWO) {
              case TOUCH.DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false) return;
                handleTouchStartDollyPan(event2);
                state = STATE.TOUCH_DOLLY_PAN;
                break;
              case TOUCH.DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false) return;
                handleTouchStartDollyRotate(event2);
                state = STATE.TOUCH_DOLLY_ROTATE;
                break;
              default:
                state = STATE.NONE;
            }
            break;
          default:
            state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }
      function onTouchMove2(event2) {
        trackPointer(event2);
        switch (state) {
          case STATE.TOUCH_ROTATE:
            if (scope.enableRotate === false) return;
            handleTouchMoveRotate(event2);
            scope.update();
            break;
          case STATE.TOUCH_PAN:
            if (scope.enablePan === false) return;
            handleTouchMovePan(event2);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false) return;
            handleTouchMoveDollyPan(event2);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false) return;
            handleTouchMoveDollyRotate(event2);
            scope.update();
            break;
          default:
            state = STATE.NONE;
        }
      }
      function onContextMenu(event2) {
        if (scope.enabled === false) return;
        event2.preventDefault();
      }
      function addPointer(event2) {
        pointers.push(event2.pointerId);
      }
      function removePointer(event2) {
        delete pointerPositions[event2.pointerId];
        for (let i4 = 0; i4 < pointers.length; i4++) {
          if (pointers[i4] == event2.pointerId) {
            pointers.splice(i4, 1);
            return;
          }
        }
      }
      function isTrackingPointer(event2) {
        for (let i4 = 0; i4 < pointers.length; i4++) {
          if (pointers[i4] == event2.pointerId) return true;
        }
        return false;
      }
      function trackPointer(event2) {
        let position = pointerPositions[event2.pointerId];
        if (position === void 0) {
          position = new Vector2();
          pointerPositions[event2.pointerId] = position;
        }
        position.set(event2.pageX, event2.pageY);
      }
      function getSecondPointerPosition(event2) {
        const pointerId = event2.pointerId === pointers[0] ? pointers[1] : pointers[0];
        return pointerPositions[pointerId];
      }
      scope.domElement.addEventListener("contextmenu", onContextMenu);
      scope.domElement.addEventListener("pointerdown", onPointerDown);
      scope.domElement.addEventListener("pointercancel", onPointerUp);
      scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      const document2 = scope.domElement.getRootNode();
      document2.addEventListener("keydown", interceptControlDown, { passive: true, capture: true });
      this.update();
    }
  };

  // node_modules/three/examples/jsm/utils/SkeletonUtils.js
  function clone(source) {
    const sourceLookup = /* @__PURE__ */ new Map();
    const cloneLookup = /* @__PURE__ */ new Map();
    const clone2 = source.clone();
    parallelTraverse(source, clone2, function(sourceNode, clonedNode) {
      sourceLookup.set(clonedNode, sourceNode);
      cloneLookup.set(sourceNode, clonedNode);
    });
    clone2.traverse(function(node) {
      if (!node.isSkinnedMesh) return;
      const clonedMesh = node;
      const sourceMesh = sourceLookup.get(node);
      const sourceBones = sourceMesh.skeleton.bones;
      clonedMesh.skeleton = sourceMesh.skeleton.clone();
      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
      clonedMesh.skeleton.bones = sourceBones.map(function(bone) {
        return cloneLookup.get(bone);
      });
      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
    });
    return clone2;
  }
  function parallelTraverse(a3, b2, callback) {
    callback(a3, b2);
    for (let i4 = 0; i4 < a3.children.length; i4++) {
      parallelTraverse(a3.children[i4], b2.children[i4], callback);
    }
  }

  // assets/scripts/modules/LostScene.js
  var walkSpeed = 0.845;
  var walkDistance = 17;
  var Character = class {
    constructor(modelPath, x2, callback, initialProgress = 0) {
      this.wrapper = new Object3D();
      this.wrapper.position.x = x2;
      this.direction = Math.round(Math.random()) * 2 - 1;
      this.wrapper.rotation.y = this.direction == 1 ? Math.PI : 0;
      this.load(modelPath).then(() => {
        if (this.destroyed) return;
        this.setScene(modelPath);
        this.animate(initialProgress, callback);
      });
    }
    animate(progress, callback = () => {
    }) {
      this.tw = gsapWithCSS.fromTo(this.wrapper.position, { z: walkDistance * this.direction }, { z: walkDistance * -this.direction, duration: walkDistance / walkSpeed, ease: "none", onComplete: callback });
      this.tw.progress(progress);
    }
    setScene(src) {
      this.scene = clone(models[src].glb.scene);
      this.mixer = new AnimationMixer(this.scene);
      let animation = models[src].glb.animations.find((item) => item.name == "walking");
      if (animation) {
        this.clip = this.mixer.clipAction(animation);
        this.clip.play();
      }
      this.scene.scale.set(1, 1, 1);
      this.wrapper.add(this.scene);
    }
    load(src) {
      return new Promise((resolve, reject) => {
        if (!models[src]) {
          models[src] = {
            glb: null,
            usdz: null,
            isLoaded: false,
            onLoad: resolve
          };
        } else {
          if (!models[src].isLoaded) {
            models[src].onLoad = resolve;
          } else {
            resolve();
          }
          return;
        }
        gltfLoader.load(src, (gltf) => {
          models[src].glb = gltf;
          models[src].isLoaded = true;
          if (gltf.animations.length) {
            models[src].mixer = new AnimationMixer(gltf.scene);
            gltf.scene.traverse(function(obj) {
              obj.frustumCulled = false;
            });
            models[src].animations = [];
            for (let i4 = 0; i4 < gltf.animations.length; i4++) {
              let name = gltf.animations[i4].name;
              if (models[src].animations[gltf.animations[i4].name]) name += i4;
              models[src].animations[name] = models[src].mixer.clipAction(gltf.animations[i4]);
            }
          }
          models[src].onLoad();
        });
      });
    }
    destroy() {
      var _a, _b;
      this.destroyed = true;
      (_b = (_a = this.tw) == null ? void 0 : _a.kill) == null ? void 0 : _b.call(_a);
    }
  };
  var LostScene_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.modelsQty = 12;
      this.rowsQty = Math.max(this.modelsQty + 1, 20);
      this.rowsUsed = [];
      this.modelsUsed = [];
      this.canvas = this.el;
      this.models = shuffle3(this.getData("models").split(","));
      this.characters = [];
      this.resize();
      this.resizeBind = this.resize.bind(this);
      window.addEventListener("resize", this.resizeBind);
    }
    init() {
      if (!SUPPORT_WEBGL) return;
      this.initRenderer();
      this.initScene();
      this.render();
    }
    initRenderer() {
      this.renderer = new WebGLRenderer({
        canvas: this.canvas,
        alpha: true,
        antialias: true,
        preserveDrawingBuffer: true
        // for screenshots
      });
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = PCFSoftShadowMap;
      this.renderer.outputEncoding = SRGBColorSpace;
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      this.clock = new Clock();
      this.previousTime = 0;
    }
    initScene() {
      this.scene = new Scene();
      const ambientLight = new AmbientLight(16777215, 6);
      this.scene.add(ambientLight);
      this.aspect = this.sizes.width / this.sizes.height;
      this.setFrustumSize();
      this.camera = new OrthographicCamera(
        this.frustumSize * this.aspect / -2,
        this.frustumSize * this.aspect / 2,
        this.frustumSize / 2,
        this.frustumSize / -2,
        0,
        40
      );
      this.camera.position.set(10, 7, 10);
      this.scene.add(this.camera);
      this.controls = new OrbitControls(this.camera, this.canvas);
      this.controls.target.set(0, 0, 0);
      this.controls.enableDamping = true;
      this.controls.enablePan = false;
      this.controls.maxPolarAngle = this.controls.minPolarAngle = this.controls.getPolarAngle();
      this.wrapper = new Group();
      this.wrapper.position.set(0, 0, 0);
      this.scene.add(this.wrapper);
      const gridHelper = new GridHelper2(100, 100, 13421772, 13421772);
      this.wrapper.add(gridHelper);
      for (let i4 = 0; i4 < this.modelsQty; i4++) {
        this.spawn(Math.random());
      }
    }
    setFrustumSize() {
      this.frustumSize = this.aspect > 16 / 9 ? (1 - (this.aspect - 16 / 9) * 0.2) * 10 : 10;
    }
    pickRow() {
      let row;
      while (!row || this.rowsUsed.includes(row)) {
        row = Math.floor(Math.random() * this.rowsQty - this.rowsQty / 2);
      }
      this.rowsUsed.push(row);
      return row;
    }
    pickModel() {
      let model;
      while (!model || this.modelsUsed.includes(model)) {
        model = this.models[Math.floor(Math.random() * this.models.length)];
      }
      this.modelsUsed.push(model);
      return model;
    }
    spawn(progress = 0) {
      const row = this.pickRow();
      const model = this.pickModel();
      const instance = new Character(model, row, () => {
        instance.destroy();
        this.wrapper.remove(instance.wrapper);
        this.characters.splice(this.characters.indexOf(instance), 1);
        this.rowsUsed.splice(this.rowsUsed.indexOf(row), 1);
        this.modelsUsed.splice(this.modelsUsed.indexOf(model), 1);
        this.spawn();
      }, progress);
      this.wrapper.add(instance.wrapper);
      this.characters.push(instance);
    }
    resize() {
      this.BCR = this.el.getBoundingClientRect();
      this.sizes = {
        width: this.BCR.width,
        height: this.BCR.height
      };
      this.renderer && this.renderer.setSize(this.sizes.width, this.sizes.height);
      if (this.camera) {
        this.aspect = this.sizes.width / this.sizes.height;
        this.setFrustumSize();
        this.camera.left = this.frustumSize * this.aspect / -2;
        this.camera.right = this.frustumSize * this.aspect / 2;
        this.camera.top = this.frustumSize / 2;
        this.camera.bottom = this.frustumSize / -2;
        this.camera.updateProjectionMatrix();
      }
      if (this.renderer) {
        this.renderer.setSize(this.sizes.width, this.sizes.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      }
    }
    render() {
      var _a, _b;
      const elapsedTime = this.clock.getElapsedTime();
      this.deltaTime = elapsedTime - this.previousTime;
      this.previousTime = elapsedTime;
      this.controls.update();
      this.renderer.render(this.scene, this.camera);
      for (let character of this.characters) {
        (_b = (_a = character.mixer) == null ? void 0 : _a.setTime) == null ? void 0 : _b.call(_a, elapsedTime);
      }
      this.wrapper.rotation.set(0, this.wrapper.rotation.y + 1e-3 * this.deltaTime / (1 / 60), 0);
      this.raf = window.requestAnimationFrame(this.render.bind(this));
    }
    destroy() {
      var _a;
      for (let character of this.characters) {
        (_a = character.destroy) == null ? void 0 : _a.call(character);
      }
      window.removeEventListener("resize", this.resizeBind);
      window.cancelAnimationFrame(this.raf);
      this.scene = this.renderer = null;
    }
  };

  // node_modules/vue/dist/vue.esm-bundler.js
  var vue_esm_bundler_exports = {};
  __export(vue_esm_bundler_exports, {
    compile: () => compileToFunction
  });
  var runtimeDom = __toESM(require_runtime_dom());
  var import_runtime_dom = __toESM(require_runtime_dom());
  __reExport(vue_esm_bundler_exports, __toESM(require_runtime_dom()));
  var import_compiler_dom = __toESM(require_compiler_dom());
  var import_shared = __toESM(require_shared());
  function initDev() {
    {
      (0, import_runtime_dom.initCustomFormatter)();
    }
  }
  if (true) {
    initDev();
  }
  var compileCache = /* @__PURE__ */ Object.create(null);
  function compileToFunction(template2, options) {
    if (!(0, import_shared.isString)(template2)) {
      if (template2.nodeType) {
        template2 = template2.innerHTML;
      } else {
        (0, import_runtime_dom.warn)(`invalid template option: `, template2);
        return import_shared.NOOP;
      }
    }
    const key = template2;
    const cached = compileCache[key];
    if (cached) {
      return cached;
    }
    if (template2[0] === "#") {
      const el = document.querySelector(template2);
      if (!el) {
        (0, import_runtime_dom.warn)(`Template element not found or is empty: ${template2}`);
      }
      template2 = el ? el.innerHTML : ``;
    }
    const { code } = (0, import_compiler_dom.compile)(template2, (0, import_shared.extend)({
      hoistStatic: true,
      onError: true ? onError : void 0,
      onWarn: true ? (e4) => onError(e4, true) : import_shared.NOOP
    }, options));
    function onError(err, asWarning = false) {
      const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
      const codeFrame = err.loc && (0, import_shared.generateCodeFrame)(template2, err.loc.start.offset, err.loc.end.offset);
      (0, import_runtime_dom.warn)(codeFrame ? `${message}
${codeFrame}` : message);
    }
    const render6 = new Function("Vue", code)(runtimeDom);
    render6._rc = true;
    return compileCache[key] = render6;
  }
  (0, import_runtime_dom.registerRuntimeCompiler)(compileToFunction);

  // assets/scripts/vue/components/LisaStep.js
  var LisaStep_default = {
    delimiters: ["{(", ")}"],
    props: {
      step: {
        type: Object,
        required: true
      },
      stepSlug: {
        type: String,
        required: true
      },
      showStepContent: {
        type: Boolean,
        required: true
      },
      muted: {
        type: Boolean,
        required: true
      },
      locale: {
        type: String,
        required: true
      }
    },
    data() {
      return {
        lisaUserData,
        sentenceSlug: null
      };
    },
    computed: {
      sentence() {
        if (this.step.dialog.useContext) {
          const { list } = this.step.dialog;
          let usableSentences = {};
          if (this.hasContext) {
            const contextSentences = {};
            for (let ctxId of Object.keys(list.context)) {
              let usableCtxSentence = ctxId + "." + lisaWeatherContext.tod + "." + lisaWeatherContext.weatherIdent;
              if (list.context[ctxId][usableCtxSentence])
                contextSentences[usableCtxSentence] = list.context[ctxId][usableCtxSentence];
            }
            Object.assign(usableSentences, contextSentences);
          }
          Object.assign(usableSentences, list.generic);
          const dialogSlugs = Object.keys(usableSentences);
          let pickedDialog = dialogSlugs[Math.floor(dialogSlugs.length * Math.random())];
          let sentence = usableSentences[pickedDialog];
          if (this.hasContext && Math.random() > 0.5 && list[lisaWeatherContext.weatherIdent] && Object.keys(list[lisaWeatherContext.weatherIdent]).length) {
            let weatherSentences = list[lisaWeatherContext.weatherIdent];
            let weatherSentencesKeys = Object.keys(weatherSentences);
            pickedDialog = weatherSentencesKeys[Math.floor(Math.random() * weatherSentencesKeys.length)];
            sentence = weatherSentences[pickedDialog];
          }
          this.sentenceSlug = pickedDialog;
          return sentence;
        } else if (this.step.dialog.key) {
          const { key, keyMode, list } = this.step.dialog;
          if (keyMode == "random") {
            const dialogSlugs = Object.keys(list[lisaUserData[key].value]);
            const pickedDialog = dialogSlugs[Math.floor(dialogSlugs.length * Math.random())];
            this.sentenceSlug = pickedDialog;
            return list[lisaUserData[key].value][pickedDialog];
          } else if (keyMode == "concat") {
            const dialogSlugs = Object.keys(list);
            const pickedDialog = dialogSlugs[Math.floor(dialogSlugs.length * Math.random())];
            const concatDialog = pickedDialog + "." + lisaUserData[key].value;
            this.sentenceSlug = concatDialog;
            return list[pickedDialog][concatDialog];
          } else {
            return "Error: Unknown keyMode";
          }
        } else if (this.step.dialog.list) {
          let { list } = this.step.dialog;
          if (this.lisaUserData["special"] && this.step.dialog[this.lisaUserData["special"]]) list = this.step.dialog[this.lisaUserData["special"]];
          const dialogSlugs = Object.keys(list);
          const pickedDialog = dialogSlugs[Math.floor(dialogSlugs.length * Math.random())];
          this.sentenceSlug = pickedDialog;
          return list[pickedDialog];
        } else {
          console.warn("No dialog list given");
          console.log(this.step.dialog);
        }
      },
      hasContext() {
        return Object.keys(lisaWeatherContext).length > 0;
      },
      slotGiven() {
        return this.$slots.default;
      },
      availableChoices() {
        if (!this.step.choices) return false;
        if (this.step.choices.key) {
          return this.step.choices.value[lisaUserData[this.step.choices.key].value];
        } else {
          return this.step.choices;
        }
      }
    },
    methods: {
      skip() {
        this.$refs.dialog.skip();
      },
      next() {
        this.$emit("next");
      },
      choose(e4) {
        const el = e4.target;
        const { key, value, target, href } = el.dataset;
        const label = el.innerText;
        if (key && value) {
          lisaUserData[key] = { label, value };
        }
        if (target) this.$emit("goToStep", target);
        if (href) this.$emit("navigateTo", href);
      },
      completeIntro() {
        this.$emit("stepIntroUpdate", true);
      },
      copyToClipboard(e4) {
        e4.preventDefault();
        e4.stopPropagation();
        copyToClipboard(e4.target);
      }
    },
    watch: {
      sentenceSlug() {
        this.$nextTick(() => {
          if (!this.muted)
            this.$emit("playAudio", "/assets/lisa/" + this.locale + "/" + this.sentenceSlug + ".mp3");
          this.$emit("stepIntroUpdate", false);
        });
      }
    }
  };

  // assets/scripts/vue/components/LisaDialog.js
  gsapWithCSS.registerPlugin(SplitText);
  var LisaDialog_default = {
    delimiters: ["{(", ")}"],
    props: {
      sentence: {
        type: [String],
        required: true
      }
    },
    data() {
      return {};
    },
    mounted() {
      this.splitText();
      this.animate();
    },
    methods: {
      splitText() {
        this.split = new SplitText(this.$refs.output, { type: "chars, words", tag: "div" });
      },
      animate() {
        this.tw = gsapWithCSS.timeline({ onComplete: () => {
          this.showContentAfterCta = true;
          this.$emit("completed");
          this.tw.kill();
        } });
        this.tw.from(this.split.chars, { rotationX: 90, force3D: true, stagger: 0.01, duration: 0.05 }, 0);
        this.tw.add(() => {
        }, "+=1.5");
      },
      skip() {
        if (this.tw) {
          this.tw.progress(1);
        }
      }
    },
    watch: {
      sentence(newValue) {
        this.showContentAfterCta = false;
        this.$nextTick(() => {
          this.splitText();
          this.animate();
        });
      }
    },
    template: `
        <div>
            <span ref="output" v-html="sentence"></span>
        </div>
    `
  };

  // assets/scripts/vue/components/LisaForm.js
  var import_vue_filepond = __toESM(require_vue_filepond(), 1);
  var import_filepond_plugin_file_validate_type = __toESM(require_filepond_plugin_file_validate_type(), 1);
  var import_filepond_plugin_file_validate_size = __toESM(require_filepond_plugin_file_validate_size(), 1);

  // node_modules/vue-demi/lib/index.mjs
  var lib_exports = {};
  __export(lib_exports, {
    Vue: () => vue_runtime_esm_bundler_exports,
    Vue2: () => Vue2,
    compile: () => compile2,
    del: () => del,
    install: () => install,
    isVue2: () => isVue2,
    isVue3: () => isVue3,
    set: () => set
  });

  // node_modules/vue/dist/vue.runtime.esm-bundler.js
  var vue_runtime_esm_bundler_exports = {};
  __export(vue_runtime_esm_bundler_exports, {
    compile: () => compile2
  });
  var import_runtime_dom2 = __toESM(require_runtime_dom());
  __reExport(vue_runtime_esm_bundler_exports, __toESM(require_runtime_dom()));
  function initDev2() {
    {
      (0, import_runtime_dom2.initCustomFormatter)();
    }
  }
  if (true) {
    initDev2();
  }
  var compile2 = () => {
    if (true) {
      (0, import_runtime_dom2.warn)(
        `Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        /* should not happen */
      );
    }
  };

  // node_modules/vue-demi/lib/index.mjs
  __reExport(lib_exports, vue_runtime_esm_bundler_exports);
  var isVue2 = false;
  var isVue3 = true;
  var Vue2 = void 0;
  function install() {
  }
  function set(target, key, val) {
    if (Array.isArray(target)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    target[key] = val;
    return val;
  }
  function del(target, key) {
    if (Array.isArray(target)) {
      target.splice(key, 1);
      return;
    }
    delete target[key];
  }

  // node_modules/vue-recaptcha/dist/vue-recaptcha.es.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var defer = function defer2() {
    var state = false;
    var callbacks = [];
    var resolve = function resolve2() {
      if (state) {
        return;
      }
      state = true;
      for (var i4 = 0, len = callbacks.length; i4 < len; i4++) {
        callbacks[i4]();
      }
    };
    var then = function then2(cb) {
      if (!state) {
        callbacks.push(cb);
        return;
      }
      cb();
    };
    var deferred = {
      resolved: function resolved() {
        return state;
      },
      resolve,
      promise: {
        then
      }
    };
    return deferred;
  };
  var ownProp = Object.prototype.hasOwnProperty;
  function createRecaptcha() {
    var deferred = defer();
    return {
      notify: function notify() {
        deferred.resolve();
      },
      wait: function wait() {
        return deferred.promise;
      },
      render: function render6(ele, options, cb) {
        this.wait().then(function() {
          cb(window.grecaptcha.render(ele, options));
        });
      },
      reset: function reset(widgetId) {
        if (typeof widgetId === "undefined") {
          return;
        }
        this.assertLoaded();
        this.wait().then(function() {
          return window.grecaptcha.reset(widgetId);
        });
      },
      execute: function execute(widgetId) {
        if (typeof widgetId === "undefined") {
          return;
        }
        this.assertLoaded();
        this.wait().then(function() {
          return window.grecaptcha.execute(widgetId);
        });
      },
      checkRecaptchaLoad: function checkRecaptchaLoad() {
        if (ownProp.call(window, "grecaptcha") && ownProp.call(window.grecaptcha, "render")) {
          this.notify();
        }
      },
      assertLoaded: function assertLoaded() {
        if (!deferred.resolved()) {
          throw new Error("ReCAPTCHA has not been loaded");
        }
      }
    };
  }
  var recaptcha = createRecaptcha();
  if (typeof window !== "undefined") {
    window.vueRecaptchaApiLoaded = recaptcha.notify;
  }
  var Recaptcha = (0, lib_exports.defineComponent)({
    name: "VueRecaptcha",
    props: {
      sitekey: {
        type: String,
        required: true
      },
      theme: {
        type: String
      },
      badge: {
        type: String
      },
      type: {
        type: String
      },
      size: {
        type: String
      },
      tabindex: {
        type: String
      },
      loadRecaptchaScript: {
        type: Boolean,
        "default": true
      },
      recaptchaScriptId: {
        type: String,
        "default": "__RECAPTCHA_SCRIPT"
      },
      recaptchaHost: {
        type: String,
        "default": "www.google.com"
      },
      language: {
        type: String,
        "default": ""
      }
    },
    emits: ["render", "verify", "expired", "error"],
    setup: function setup(props, _ref) {
      var slots = _ref.slots, emit = _ref.emit;
      var root = (0, lib_exports.ref)(null);
      var widgetId = (0, lib_exports.ref)(null);
      var emitVerify = function emitVerify2(response) {
        emit("verify", response);
      };
      var emitExpired = function emitExpired2() {
        emit("expired");
      };
      var emitError = function emitError2() {
        emit("error");
      };
      (0, lib_exports.onMounted)(function() {
        recaptcha.checkRecaptchaLoad();
        if (props.loadRecaptchaScript) {
          if (!document.getElementById(props.recaptchaScriptId)) {
            var script = document.createElement("script");
            script.id = props.recaptchaScriptId;
            script.src = "https://" + props.recaptchaHost + "/recaptcha/api.js?onload=vueRecaptchaApiLoaded&render=explicit&hl=" + props.language;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
          }
        }
        var opts = _extends({}, props, {
          callback: emitVerify,
          "expired-callback": emitExpired,
          "error-callback": emitError
        });
        var $root = root.value;
        var container = slots["default"] ? $root.children[0] : $root;
        recaptcha.render(container, opts, function(id) {
          widgetId.value = id;
          emit("render", id);
        });
      });
      return {
        root,
        widgetId,
        reset: function reset() {
          recaptcha.reset(widgetId.value);
        },
        execute: function execute() {
          recaptcha.execute(widgetId.value);
        }
      };
    },
    render: function render3() {
      var defaultSlot = this.$slots["default"];
      var defaultContent;
      if (typeof defaultSlot === "function") {
        defaultContent = defaultSlot();
      } else {
        defaultContent = defaultSlot;
      }
      return (0, lib_exports.h)("div", {
        ref: "root"
      }, defaultContent);
    }
  });

  // assets/scripts/vue/components/LisaForm.js
  var FilePond = import_vue_filepond.default.default(import_filepond_plugin_file_validate_type.default, import_filepond_plugin_file_validate_size.default);
  var LisaForm_default = {
    delimiters: ["{(", ")}"],
    components: {
      FilePond,
      VueRecaptcha: Recaptcha
    },
    data() {
      return {
        lisaUserData,
        endpoints: {
          "goal": "/api/"
        },
        loading: false,
        errors: []
      };
    },
    methods: {
      onCaptchaVerified: function(response) {
        this.formData.append("g-recaptcha-response", response);
        this.sendData();
        this.$refs.recaptcha.reset();
      },
      onCaptchaError: function() {
        console.error("An error occured");
        this.loading = false;
        this.$refs.recaptcha.reset();
      },
      onCaptchaExpired: function() {
        console.error("Captcha expired");
        this.loading = false;
        this.$refs.recaptcha.reset();
      },
      submit(e4) {
        this.formAction = this.getEndpoint(this.lisaUserData.goal.value);
        this.formData = new FormData(e4.target);
        this.loading = true;
        this.$refs.recaptcha.execute();
      },
      getEndpoint(slug) {
        switch (slug) {
          case "rfp":
            return "/api/rfp-enquiries";
          case "job":
            return "/api/job-enquiries";
          case "internship":
            return "/api/internship-enquiries";
          case "quickwork":
          default:
            return "/api/general-enquiries";
        }
      },
      sendData() {
        this.errors = [];
        let formObject = {};
        this.formData.forEach((value, key) => {
          if (formObject[key]) {
            formObject[key] += "|" + value;
          } else {
            formObject[key] = value;
          }
        });
        this.formDataJSON = JSON.stringify(formObject);
        fetch(this.formAction, {
          body: this.formDataJSON,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          }
        }).then((response) => {
          return response.json();
        }).then((response) => {
          var _a, _b;
          if (!response.success) {
            if (Array.isArray(response)) {
              for (let error of response) {
                this.errors.push(error == null ? void 0 : error.message);
              }
            } else {
              this.errors.push(response == null ? void 0 : response.message);
            }
            (_a = this.$refs.recaptcha) == null ? void 0 : _a.reset();
          } else {
            (_b = this.$refs.recaptcha) == null ? void 0 : _b.reset();
            if (window.gtag) {
              gtag("event", "submit_form", {
                "event_category": "lisa",
                "event_label": this.formAction
              });
            }
            this.$emit("success");
          }
        }).catch(() => {
        }).finally(() => {
          this.loading = false;
        });
      }
    }
  };

  // assets/scripts/vue/components/LisaDisclaimer.js
  var LisaDisclaimer_default = {
    data() {
      return {
        position: {
          x: 0,
          y: 0
        },
        speed: {
          x: Math.random() < 0.5 ? -2 : 2,
          y: Math.random() < 0.5 ? -2 : 2
        },
        boundings: null,
        labelBoundings: null
      };
    },
    mounted() {
      this.setBoundings();
      this.render();
      window.addEventListener("resize", this.setBoundings);
    },
    methods: {
      setBoundings() {
        gsapWithCSS.set(this.$refs.label, { clearProps: "all" });
        this.boundings = this.$el.getBoundingClientRect();
        this.labelBoundings = this.$refs.label.getBoundingClientRect();
      },
      render() {
        this.position.x += this.speed.x;
        this.position.y += this.speed.y;
        if (this.labelBoundings.left + this.position.x < 0 && this.speed.x < 0) this.speed.x *= -1;
        if (this.labelBoundings.right - this.labelBoundings.width - this.position.x < 0 && this.speed.x > 0) this.speed.x *= -1;
        if (this.labelBoundings.top + this.position.y < this.boundings.top && this.speed.y < 0) this.speed.y *= -1;
        if (this.labelBoundings.bottom - this.labelBoundings.height - this.position.y < this.boundings.top && this.speed.y > 0) this.speed.y *= -1;
        gsapWithCSS.set(this.$refs.label, { x: this.position.x, y: this.position.y, force3D: true });
        this.raf = requestAnimationFrame(this.render);
      }
    },
    unmounted() {
      cancelAnimationFrame(this.raf);
      window.removeEventListener("resize", this.setBoundings);
    },
    template: `
        <div class="c-lisa_disclaimer">
            <div ref="label"><span class="c-lisa_disclaimer_click-cta">CLICK</span> ANYWHERE TO INITIATE <br>[<span class="c-lisa_disclaimer_procedure">CONTACT PROCEDURE</span>]</div>
        </div>
    `
  };

  // assets/scripts/vue/components/LisaVisualizer.js
  var import_colormap = __toESM(require_colormap(), 1);
  var colors = (0, import_colormap.default)({
    //colormap: 'jet',
    colormap: [
      { index: 0, rgb: [49, 46, 251] },
      { index: 0.4, rgb: [49, 46, 251] },
      { index: 0.5, rgb: [255, 255, 255] },
      // {index:0.7,rgb:[244,87,77]},
      { index: 1, rgb: [255, 255, 255] }
    ],
    nshades: 255,
    format: "rgba"
  });
  var LisaVisualizer_default = {
    delimiters: ["{(", ")}"],
    data() {
      return {
        fpsCap: 30
      };
    },
    mounted() {
      this.audio = this.$parent.$refs.audio;
      this.audioCtx = new AudioContext();
      this.analyser = this.audioCtx.createAnalyser();
      this.stream = this.audioCtx.createMediaElementSource(this.audio);
      this.analyser.fftSize = 2048;
      this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);
      this.stream.connect(this.analyser);
      this.analyser.connect(this.audioCtx.destination);
      this.ctx2d = this.$refs.canvas.getContext("2d");
      this.resize();
      this.fpsInterval = 1e3 / this.fpsCap;
      this.then = window.performance.now();
      this.startTime = this.then;
      this.render();
      window.addEventListener("resize", this.resize);
    },
    unmounted() {
      window.removeEventListener("resize", this.resize);
      cancelAnimationFrame(this.raf);
      this.audioCtx.close();
    },
    methods: {
      resize() {
        if (this.ctx2d.canvas.width == window.innerWidth) return;
        this.ctx2d.canvas.width = window.innerWidth;
        this.ctx2d.canvas.height = Math.ceil(this.analyser.fftSize / 2 * 0.85);
      },
      render(newtime) {
        this.now = newtime;
        this.elapsed = this.now - this.then;
        if (this.elapsed > this.fpsInterval) {
          this.then = this.now - this.elapsed % this.fpsInterval;
          this.analyser.getByteFrequencyData(this.frequencyData);
          const width = 4;
          const ctxWidth = this.ctx2d.canvas.width;
          const ctxHeight = this.ctx2d.canvas.height;
          let leftData = this.ctx2d.getImageData(width, 0, ctxWidth / 2, ctxHeight);
          rightData = this.ctx2d.getImageData(ctxWidth / 2, 0, ctxWidth / 2 - width, ctxHeight);
          this.ctx2d.clearRect(0, 0, ctxWidth, ctxHeight);
          this.ctx2d.putImageData(leftData, 0, 0);
          this.ctx2d.putImageData(rightData, ctxWidth / 2 + width, 0);
          this.ctx2d.clearRect(ctxWidth / 2 - width / 2, 0, width, ctxHeight);
          const x2 = ctxWidth / 2;
          for (let y2 = 0; y2 < this.frequencyData.length; y2++) {
            let color = colors[this.frequencyData[ctxHeight - y2]] || colors[import_colormap.default.length - 1];
            this.ctx2d.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${map(this.frequencyData[ctxHeight - y2], 0, 256, 0, 1)})`;
            this.ctx2d.fillRect(x2, y2 - ctxHeight / 2, width / 2, 1);
            color = colors[this.frequencyData[y2]] || colors[import_colormap.default.length - 1];
            this.ctx2d.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${map(this.frequencyData[y2], 0, 256, 0, 1)})`;
            this.ctx2d.fillRect(x2, y2 + ctxHeight / 2, width / 2, 1);
          }
        }
        this.raf = requestAnimationFrame(this.render);
      }
    },
    template: `
        <div class="c-lisa_visualizer">
            <canvas ref="canvas"></canvas>
        </div>
    `
  };

  // assets/scripts/modules/Lisa.js
  var import_core3 = __toESM(require_barba_umd(), 1);
  var lisaUserData = (0, vue_runtime_esm_bundler_exports.reactive)({});
  var lisaWeatherContext = (0, vue_runtime_esm_bundler_exports.reactive)({});
  var Lisa_default = class extends _default {
    constructor(m2) {
      super(m2);
    }
    init() {
      const that = this;
      fetch("/api/weather-forecast").then((response) => response.json()).then((data) => {
        Object.assign(lisaWeatherContext, data);
      });
      this.app = (0, vue_esm_bundler_exports.createApp)({
        delimiters: ["{(", ")}"],
        components: {
          LisaVisualizer: LisaVisualizer_default,
          LisaDisclaimer: LisaDisclaimer_default,
          LisaStep: __spreadProps(__spreadValues({}, LisaStep_default), {
            components: {
              LisaDialog: LisaDialog_default,
              LisaForm: __spreadProps(__spreadValues({}, LisaForm_default), {
                template: document.getElementById("lisa-template-form")
              })
            },
            template: document.getElementById("lisa-template-step")
          })
        },
        data() {
          return {
            showDebug: false,
            showAudioDisclaimer: true,
            muted: false,
            speaking: false,
            stepIntroDone: false,
            lisaContent: JSON.parse(that.getData("content")),
            lisaWeatherContext,
            lisaUserData,
            introNextStep: null,
            currentStepSlug: "intro",
            history: []
          };
        },
        mounted() {
          let mutedStored = localStorage.getItem("lisa-muted");
          if (mutedStored == "true") this.muted = true;
          if (!this.muted && this.$refs.audio) {
            this.$refs.audio.play().then(() => {
              this.showAudioDisclaimer = false;
            }).catch((error) => {
              console.error(error);
              this.showAudioDisclaimer = true;
            });
          } else {
            this.showAudioDisclaimer = false;
          }
          this.history.push(this.currentStepSlug);
          this.computeURLParams();
          that.el.addEventListener("click", this.skip);
        },
        computed: {
          currentStep() {
            return this.lisaContent[this.currentStepSlug];
          },
          canGoBack() {
            return this.history.length > 2 && this.currentStepSlug != "confirmation";
          },
          showStepContent() {
            return (!this.muted && !this.speaking || this.muted) && this.stepIntroDone;
          },
          progress() {
            return this.currentStep.progress || 0;
          }
        },
        methods: {
          computeURLParams() {
            this.URLParams = new URL(document.location.toString()).searchParams;
            const keys = Array.from(this.URLParams.keys());
            if (keys.includes("data")) {
              const data = this.URLParams.get("data").split(";").map((item) => {
                let [key, value] = item.split(",");
                return { key, value };
              });
              data.forEach((item) => {
                Object.values(this.lisaContent).find((step) => {
                  const { choices } = step;
                  if (!choices) return false;
                  const getLabelFromChoiceObject = (choice) => {
                    if (!choice.modelUpdate) return false;
                    if (choice.modelUpdate.key == item.key && choice.modelUpdate.value == item.value) {
                      item.label = choice.label;
                      return true;
                    }
                  };
                  if (Array.isArray(choices)) {
                    return choices.find(getLabelFromChoiceObject);
                  } else {
                    if (choices.key) {
                      const keyValue = data.find((obj) => obj.key == choices.key);
                      if (keyValue) {
                        let keyChoices = choices.value[keyValue.value];
                        if (keyChoices) {
                          keyChoices = Object.values(keyChoices);
                          return keyChoices.find(getLabelFromChoiceObject);
                        }
                      }
                    }
                  }
                });
              });
              for (let entry of data) {
                const { key, value, label } = entry;
                lisaUserData[key] = { value, label };
              }
            }
            if (keys.includes("step")) {
              this.introNextStep = this.URLParams.get("step");
            }
            if (keys.includes("special")) {
              this.lisaUserData["special"] = this.URLParams.get("special");
            }
          },
          // ==========================================================================
          // NAVIGATION METHODS
          // ==========================================================================
          next() {
            let next2 = this.currentStep.next;
            if (this.currentStepSlug == "intro" && this.introNextStep && this.lisaContent[this.introNextStep]) {
              this.history.push("greeting");
              next2 = this.introNextStep;
              this.introNextStep = null;
              history.pushState("", document.title, window.location.pathname + window.location.search);
            }
            if (next2) {
              this.goToStep(next2);
            }
          },
          back() {
            if (this.history.length == 1) return;
            requestAnimationFrame(() => {
              this.history.pop();
              this.goToStep(this.history.pop());
            });
          },
          goToStep(slug) {
            if (!this.lisaContent[slug]) throw "Step does not exist";
            this.currentStepSlug = slug;
            this.history.push(this.currentStepSlug);
          },
          navigateTo(href) {
            import_core3.default.go(href);
          },
          // ==========================================================================
          // SENTENCE METHODS
          // ==========================================================================
          playAudio(src) {
            this.$refs.visualizer.audioCtx.resume();
            if (src) this.$refs.audio.src = src;
            this.$refs.audio.currentTime = 0;
            this.$refs.audio.play();
          },
          skip(e4) {
            if (e4.target == this.$refs.backbtn) {
              if (this.speaking) {
                this.stepIntroDone = false;
                this.$refs.audio.pause();
              }
              return;
            } else if (this.showAudioDisclaimer) {
              this.acceptAudio();
            } else if (this.speaking) {
              this.$refs.audio.pause();
              this.$refs.step.skip();
              this.stepIntroDone = true;
            }
          },
          sentenceEnded() {
            this.speaking = false;
          },
          updateStepIntro(value) {
            this.stepIntroDone = value;
          },
          // ==========================================================================
          // GLOBAL AUDIO METHODS
          // ==========================================================================
          acceptAudio() {
            requestAnimationFrame(() => {
              var _a, _b, _c;
              (_c = (_b = (_a = this.$refs.visualizer) == null ? void 0 : _a.audioCtx) == null ? void 0 : _b.resume) == null ? void 0 : _c.call(_b);
              this.showAudioDisclaimer = false;
              this.muted = false;
              this.playAudio();
            });
          },
          // refuseAudio() {
          //     requestAnimationFrame(() => {
          //         this.showAudioDisclaimer = false;
          //         this.sentenceEnded();
          //         this.muted = true;
          //     })
          // },
          muteToggle() {
            this.muted = !this.muted;
            this.$refs.audio.muted = this.muted;
            if (this.muted) {
              this.$refs.audio.pause();
            }
          }
        },
        watch: {
          muted() {
            localStorage.setItem("lisa-muted", this.muted);
          },
          currentStepSlug() {
            this.stepIntroDone = false;
            setTimeout(() => {
              document.documentElement.scrollTop = 0;
            }, 300);
            if (this.currentStepSlug == "greeting") {
              for (const key in lisaUserData) {
                delete lisaUserData[key];
              }
              this.history.splice(this.history.indexOf("greeting") + 1);
            }
            if (this.currentStepSlug == "greeting" || this.currentStepSlug == "confirmation") {
              window.confirmPageChange = false;
            } else {
              requestAnimationFrame(() => {
                window.confirmPageChange = {
                  message: that.getData("confirm-quit-label")
                };
              });
            }
          },
          showStepContent() {
            if (this.muted) this.sentenceEnded();
            if (this.currentStep.next) {
              this.next();
            }
          }
        }
      });
      this.app.mount(this.el);
    }
    destroy() {
      window.confirmPageChange = false;
      this.app && this.app.unmount();
    }
  };

  // assets/scripts/modules/ModelViewer.js
  var ModelViewer_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.canvas = this.el;
      this.autoplayAnimations = true;
      this.defaultAnimation = false;
      this.currentModel = this.getData("file") ? this.getData("file") : false;
      this.resize();
      this.resizeBind = this.resize.bind(this);
      window.addEventListener("resize", this.resizeBind);
    }
    init() {
      if (!SUPPORT_WEBGL) return;
      this.initRenderer();
      this.initScene();
      this.initLoaders();
      this.render();
      this.currentModel && this.loadModel();
    }
    initRenderer() {
      this.renderer = new WebGLRenderer({
        canvas: this.canvas,
        alpha: true,
        antialias: true,
        preserveDrawingBuffer: true
        // for screenshots
      });
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = PCFSoftShadowMap;
      this.renderer.outputEncoding = SRGBColorSpace;
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      this.clock = new Clock();
      this.previousTime = 0;
    }
    initScene() {
      this.scene = new Scene();
      const ambientLight = new AmbientLight(16777215, 6);
      this.scene.add(ambientLight);
      this.camera = new PerspectiveCamera(30, this.sizes.width / this.sizes.height, 0.01, 100);
      this.camera.position.set(1, 1, 1);
      this.scene.add(this.camera);
      this.controls = new OrbitControls(this.camera, this.canvas);
      this.controls.target.set(0, 0.25, 0);
      this.controls.enableDamping = true;
      this.wrapper = new Group();
      this.wrapper.position.set(0, 0, 0);
      this.scene.add(this.wrapper);
    }
    initLoaders() {
      this.supportsQuickLook = false;
      const a3 = document.createElement("a");
      if (a3.relList.supports("ar")) {
        this.supportsQuickLook = true;
      }
    }
    resize() {
      this.BCR = this.el.getBoundingClientRect();
      this.sizes = {
        width: this.BCR.width,
        height: this.BCR.height
      };
      this.renderer && this.renderer.setSize(this.sizes.width, this.sizes.height);
      if (this.camera) {
        this.camera.aspect = this.sizes.width / this.sizes.height;
        this.camera.updateProjectionMatrix();
      }
      if (this.renderer) {
        this.renderer.setSize(this.sizes.width, this.sizes.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      }
    }
    render() {
      const elapsedTime = this.clock.getElapsedTime();
      this.deltaTime = elapsedTime - this.previousTime;
      this.previousTime = elapsedTime;
      this.controls.update();
      this.renderer.render(this.scene, this.camera);
      if (this.currentModel && models[this.currentModel] && models[this.currentModel].mixer) models[this.currentModel].mixer.setTime(elapsedTime);
      this.raf = window.requestAnimationFrame(this.render.bind(this));
    }
    loadModel(src = this.currentModel) {
      return new Promise((resolve, reject) => {
        if (!models[src]) {
          models[src] = {
            glb: null,
            usdz: null,
            isLoaded: false,
            onLoad: () => {
            }
          };
        } else {
          resolve();
          return;
        }
        gltfLoader.load(src, (gltf) => {
          models[src].glb = gltf;
          models[src].isLoaded = true;
          if (gltf.animations.length) {
            models[src].mixer = new AnimationMixer(gltf.scene);
            gltf.scene.traverse(function(obj) {
              obj.frustumCulled = false;
            });
            models[src].animations = [];
            for (let i4 = 0; i4 < gltf.animations.length; i4++) {
              let name = gltf.animations[i4].name;
              if (models[src].animations[gltf.animations[i4].name]) name += i4;
              models[src].animations[name] = models[src].mixer.clipAction(gltf.animations[i4]);
            }
          }
          gltf.scene.scale.set(1, 1, 1);
          gltf.scene.visible = src === this.currentModel;
          this.wrapper.add(gltf.scene);
          models[src].onLoad();
          resolve();
        });
      });
    }
    setModel(src) {
      if (!SUPPORT_WEBGL) return;
      window.cancelAnimationFrame(this.raf);
      this.wrapper.clear();
      this.el.dispatchEvent(new CustomEvent("hideUsdz"));
      this.currentModel = src;
      let prevAnimationKey;
      const handleAnimation = () => {
        if (this.currentModel !== src) return;
        for (let id of Object.keys(models[this.currentModel].animations)) {
          if (models[src].animations[id].isRunning()) prevAnimationKey = id;
          models[src].animations[id].stop();
        }
        if (this.autoplayAnimations) {
          if (this.defaultAnimation && models[src].animations[this.defaultAnimation]) {
            models[src].animations[this.defaultAnimation].play();
          } else {
            let newAnimationKey;
            let rand = Math.random();
            while (!newAnimationKey || newAnimationKey == "idle-1" && rand > 0.33 || newAnimationKey == "walking" && rand > 0.5 || newAnimationKey == "idle-2" || newAnimationKey == prevAnimationKey) {
              newAnimationKey = Object.keys(models[src].animations)[Math.floor(Math.random() * Object.keys(models[src].animations).length)];
              rand = Math.random();
            }
            models[src].animations[newAnimationKey].play();
          }
        }
      };
      const showModel = () => {
        if (this.currentModel === src) {
          handleAnimation();
          models[src].glb.scene.visible = true;
          this.supportsQuickLook && models[src].usdz && this.el.dispatchEvent(new CustomEvent("usdzReady", { detail: { usdz: models[src].usdz } }));
          this.render();
        }
      };
      if (this.currentModel == false) {
        this.render();
        return;
      } else if (!models[src]) {
        this.loadModel(src);
        models[src].onLoad = showModel;
      } else if (!models[src].isLoaded) {
        models[src].onLoad = () => {
          if (!this.wrapper.children.includes(models[src].glb.scene)) {
            this.wrapper.add(models[src].glb.scene);
          }
          showModel();
        };
      } else if (!this.wrapper.children.includes(models[src].glb.scene)) {
        this.wrapper.add(models[src].glb.scene);
        showModel();
      } else {
        showModel();
      }
    }
    setDefaultAnimation(value) {
      this.defaultAnimation = value;
    }
    destroy() {
      window.removeEventListener("resize", this.resizeBind);
      window.cancelAnimationFrame(this.raf);
      this.scene = this.renderer = null;
    }
  };

  // assets/scripts/modules/NewsletterModal.js
  var NewsletterModal_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.formSuccessMessage = this.getData("success");
      this.formErrorMessage = this.getData("error");
      this.$form = this.$("form")[0];
      this.$input = this.$("input")[0];
      this.$feedback = this.$("feedback")[0];
      this.events = {
        click: {
          "close": "hide"
        },
        submit: {
          "form": "onSubmit"
        }
      };
    }
    init() {
      this.focusTrap = createFocusTrap(this.el, {
        onDeactivate: this.hide.bind(this),
        clickOutsideDeactivates: true,
        initialFocus: this.$input
      });
    }
    /**
    * Show the newsletter modal
    */
    show() {
      this.el.classList.add("is-opened");
      this.focusTrap.activate();
      this.call("scrollTo", { target: this.el, options: { offset: -80 } }, "Scroll");
    }
    /**
    * Hide the newsletter modal
    */
    hide() {
      this.el.classList.remove("is-opened");
      this.call("close", null, "NewsletterToggler");
      this.focusTrap.deactivate();
      this.$form.reset();
    }
    /**
    * Handle form submission
    */
    onSubmit(e4) {
      e4.preventDefault();
      this.clearStates();
      this.$form.classList.add("is-loading");
      const formTarget = e4.target;
      const formAction = formTarget.action;
      let formObject = {};
      const formData = new FormData(formTarget);
      formData.forEach((value, key) => formObject[key] = value);
      const formDataJSON = JSON.stringify(formObject);
      fetch(formAction, {
        body: formDataJSON,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        }
      }).then((response) => {
        if (response.status !== 200 && response.status !== 202) {
          this.$form.classList.add("is-error");
          this.$feedback.innerHTML = this.formErrorMessage;
        }
        return response.json();
      }).then((response) => {
        if (!response.success) {
          this.$form.classList.add("is-error");
          this.$feedback.innerHTML = this.formErrorMessage;
        } else {
          this.$form.classList.add("is-success");
          this.$feedback.innerHTML = this.formSuccessMessage;
          setTimeout(() => {
            this.hide();
          }, 3e3);
        }
      }).catch(() => {
      }).finally(() => {
        this.$form.classList.remove("is-loading");
      });
    }
    /**
    * Clear form states
    */
    clearStates() {
      this.$form.classList.remove("is-loading", "is-error", "is-success");
      this.$feedback.innerHTML = "";
    }
    /**
    * Destroy
    */
    destroy() {
      super.destroy();
      this.focusTrap.deactivate();
    }
  };

  // assets/scripts/modules/NewsletterToggler.js
  var NewsletterToggler_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.events = {
        "click": "onClick"
      };
    }
    init() {
    }
    onClick(e4) {
      this.show();
    }
    show() {
      this.el.setAttribute("aria-expanded", "true");
      this.call("show", null, "NewsletterModal");
    }
    close() {
      this.el.setAttribute("aria-expanded", "false");
    }
  };

  // assets/scripts/modules/Rail.js
  var SPEED = 1;
  var Rail_default = class extends _default {
    constructor(m2) {
      super(m2);
    }
    init() {
      this.delta = SPEED;
      this.reversed = this.getData("reversed") != null;
      this.viewportSensitive = this.getData("viewport-sensitive") != null;
      this.originalHTML = this.el.innerHTML;
      this.compute();
      this.renderBind = this.render.bind(this);
      if (!this.viewportSensitive) this.render();
      this.checkResizeBind = this.checkResize.bind(this);
      window.addEventListener("resize", this.checkResizeBind);
    }
    checkResize() {
      if (!this.resizeTick) {
        this.resizeTick = true;
        requestAnimationFrame(() => {
          if (this.viewportWidth != window.innerWidth)
            this.compute();
          this.resizeTick = false;
        });
      }
    }
    compute() {
      this.el.innerHTML = this.originalHTML;
      this.viewportWidth = window.innerWidth;
      this.$outer = this.$("outer")[0];
      this.contentWidth = this.$outer.children[0].getBoundingClientRect().width;
      if (!this.contentWidth) {
        console.error("[Rail] content is empty");
        return false;
      }
      if (this.contentWidth < this.viewportWidth) {
        const duplicatesNeeded = Math.floor(this.viewportWidth / this.contentWidth);
        for (let i4 = 0; i4 <= duplicatesNeeded; i4++) {
          const node = this.$outer.children[0].cloneNode(true);
          this.$outer.appendChild(node);
        }
      }
      this.el.appendChild(this.$outer.cloneNode(true));
      this.currentOffset = 0;
      this.$outer = this.$("outer");
    }
    render() {
      if (window.scroll.velocity) {
        this.delta = SPEED * (window.scroll.velocity > 0 ? 1 : -1);
        this.delta += window.scroll.velocity * 0.2;
        if (this.reversed) this.delta *= -1;
      }
      this.currentOffset += this.delta;
      if (this.delta > 0) {
        if (this.currentOffset >= 0) this.currentOffset -= this.contentWidth;
      } else {
        if (this.currentOffset < -this.contentWidth) this.currentOffset += this.contentWidth;
      }
      gsapWithCSS.set(this.$outer, { x: this.currentOffset, force3D: true });
    }
    inview(e4) {
      const { target, way } = e4;
      if (target == this.el) {
        if (!this.active && way == "enter") {
          gsapWithCSS.ticker.add(this.renderBind);
          this.active = true;
        } else if (this.active && way == "leave") {
          gsapWithCSS.ticker.remove(this.renderBind);
          this.active = false;
        }
      }
    }
    destroy() {
      gsapWithCSS.ticker.remove(this.renderBind);
      window.removeEventListener("resize", this.checkResizeBind);
    }
  };

  // assets/scripts/utils/TheRing.js
  function computeEnvmap(renderer, texture) {
    texture.mapping = EquirectangularReflectionMapping;
    const pmremGenerator = new PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    const pmrem = pmremGenerator.fromEquirectangular(texture).texture;
    texture.dispose();
    pmremGenerator.dispose();
    return pmrem;
  }
  var BLUR_DPR = 0.5;
  var _baseFOV, _diamondsFront, _events, _uniforms, _dt, _et, _viewport, _scene, _renderer, _orbitCamera, _debugCamera, _renderCamera, _camera, _controls, _mouse, _lerpedMouse, _rt, _brt, _brt1, _brt2, _quad, _diamondsBack, _glowMaterial, _brt1Quad, _brt2Quad, _cameraSpherical, _launchSpherical, _scrollProgress, _TheRing_instances, updateCamera_fn, render_fn, generateNoise_fn;
  var TheRing = class {
    constructor(wrapper) {
      __privateAdd(this, _TheRing_instances);
      __privateAdd(this, _baseFOV, 45);
      __privateAdd(this, _diamondsFront);
      __privateAdd(this, _events);
      __privateAdd(this, _uniforms);
      __privateAdd(this, _dt);
      __privateAdd(this, _et);
      __privateAdd(this, _viewport);
      __privateAdd(this, _scene);
      __privateAdd(this, _renderer);
      __privateAdd(this, _orbitCamera);
      __privateAdd(this, _debugCamera);
      __privateAdd(this, _renderCamera);
      __privateAdd(this, _camera);
      __privateAdd(this, _controls);
      __privateAdd(this, _mouse);
      __privateAdd(this, _lerpedMouse);
      __privateAdd(this, _rt);
      __privateAdd(this, _brt);
      __privateAdd(this, _brt1);
      __privateAdd(this, _brt2);
      __privateAdd(this, _quad);
      __privateAdd(this, _diamondsBack);
      __privateAdd(this, _glowMaterial);
      __privateAdd(this, _brt1Quad);
      __privateAdd(this, _brt2Quad);
      __privateAdd(this, _cameraSpherical);
      __privateAdd(this, _launchSpherical);
      __privateAdd(this, _scrollProgress);
      this.$wrapper = wrapper;
      __privateSet(this, _events, /* @__PURE__ */ new Map());
      __privateSet(this, _uniforms, {
        uTime: { value: 0 },
        uNoise: { value: null },
        uNoiseIntensity: { value: 0.3 },
        uResolution: { value: new Vector2(1, 1) },
        uGlobalLuminosity: { value: 1 }
      });
      __privateMethod(this, _TheRing_instances, generateNoise_fn).call(this);
      __privateSet(this, _dt, 0);
      __privateSet(this, _et, 0);
      __privateSet(this, _scrollProgress, 0);
      this.ringPosition = new Vector3();
      __privateSet(this, _viewport, { width: 375, height: 610, ratio: 1, dpr: 1 });
      __privateSet(this, _scene, new Scene());
      __privateGet(this, _scene).background = new Color(0);
      __privateSet(this, _renderer, new WebGLRenderer({
        alpha: false
      }));
      __privateGet(this, _renderer).toneMapping = AgXToneMapping;
      __privateSet(this, _orbitCamera, new PerspectiveCamera(45, 1, 0.1, 10));
      __privateGet(this, _orbitCamera).position.setFromSpherical(new Spherical(0.66, Math.PI / 2, 0));
      __privateGet(this, _scene).add(__privateGet(this, _orbitCamera));
      __privateSet(this, _camera, new PerspectiveCamera(45, 1, 0.1, 10));
      __privateGet(this, _orbitCamera).add(__privateGet(this, _camera));
      {
      }
      __privateSet(this, _renderCamera, __privateGet(this, _camera));
      __privateSet(this, _controls, new OrbitControls(__privateGet(this, _orbitCamera), __privateGet(this, _renderer).domElement));
      __privateGet(this, _controls).minDistance = 0.5;
      __privateGet(this, _controls).autoRotate = true;
      __privateGet(this, _controls).enableDamping = true;
      __privateGet(this, _controls).enablePan = false;
      __privateGet(this, _controls).enableZoom = false;
      this.$wrapper.prepend(__privateGet(this, _renderer).domElement);
      this.trigonometricCameraPosition = { theta: 0, phi: 0, radius: 0 };
      this.ringRotation = { theta: 0, phi: 0 };
      __privateSet(this, _mouse, new Vector2(0, 0));
      __privateSet(this, _lerpedMouse, new Vector2(0, 0));
      this.parallaxIntensity = 1;
      __privateSet(this, _rt, new WebGLRenderTarget(__privateGet(this, _viewport).width, __privateGet(this, _viewport).height, {
        samples: 1
      }));
      __privateSet(this, _brt, new WebGLRenderTarget(
        __privateGet(this, _viewport).width * BLUR_DPR,
        __privateGet(this, _viewport).height * BLUR_DPR,
        { samples: 1 }
      ));
      __privateSet(this, _brt1, new WebGLRenderTarget(
        __privateGet(this, _viewport).width * BLUR_DPR,
        __privateGet(this, _viewport).height * BLUR_DPR,
        { samples: 1 }
      ));
      __privateSet(this, _brt2, new WebGLRenderTarget(
        __privateGet(this, _viewport).width * BLUR_DPR,
        __privateGet(this, _viewport).height * BLUR_DPR,
        { samples: 1 }
      ));
      __privateGet(this, _brt).filter = NearestFilter;
      __privateGet(this, _brt1).filter = NearestFilter;
      __privateGet(this, _brt2).filter = NearestFilter;
      __privateSet(this, _quad, new Mesh(
        new BufferGeometry().setAttribute(
          "position",
          new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)
        ).setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2))
      ));
      __privateGet(this, _quad).material = new RawShaderMaterial({
        vertexShader: (
          /* glsl */
          `
        precision highp float;
        attribute vec3 position;
        attribute vec2 uv;

        varying vec2 vUv;

        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.);
        }
      `
        ),
        fragmentShader: (
          /* glsl */
          `
        precision highp float;
        varying vec2 vUv;

        uniform sampler2D uScene, uBlured, uNoise;
        uniform vec2 uResolution;
        uniform float uTime, uNoiseIntensity;

        #define PI 3.14159265

        float avg(vec3 c) { return (c.x + c.y + c.z) / 3.; }

        void main() {
          vec3 color = texture2D(uScene, vUv).rgb * 2.;
          vec4 glow = vec4(0.);

          vec3 noise = (texture2D(uNoise, vUv / 256. * uResolution + floor(uTime * 10000.) * .04).rgb - .5);
          // vec2 poisson = vec2(cos(noise.x), sin(noise.x)) / uResolution * 50.;

          glow += texture2D(uBlured, vUv);

          // color += glow.rgb * .3;
          color += vec3(glow.r * .4, glow.g * .25, glow.b * .1) * .5;
          // color = glow.rgb;
          color *= 1. + mix(vec3(avg(noise)), noise, .5) * uNoiseIntensity;

          gl_FragColor = vec4(color, 1.);
        }
      `
        ),
        uniforms: {
          uTime: __privateGet(this, _uniforms).uTime,
          uResolution: __privateGet(this, _uniforms).uResolution,
          uScene: { value: __privateGet(this, _rt).texture },
          uBlured: { value: __privateGet(this, _brt2).texture },
          uNoise: __privateGet(this, _uniforms).uNoise,
          uNoiseIntensity: __privateGet(this, _uniforms).uNoiseIntensity
        }
      });
      __privateSet(this, _diamondsBack, new RawShaderMaterial({
        vertexShader: (
          /* glsl */
          `
        precision highp float;
        uniform mat4 projectionMatrix;
        uniform mat4 modelViewMatrix;
        uniform mat4 normalMatrix;

        attribute vec3 position;
        attribute vec3 normal;
        attribute vec2 uv;
        attribute vec2 uv1;

        varying vec2 vUv;
        varying vec2 vUv1;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vViewPosition;

        uniform float uBackSide;

        void main() {
          vUv = uv;
          vUv1 = uv1;
          vPosition = position;
          vNormal = vec3(normalMatrix * vec4(normal, 1.));
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.);
          mvPosition.xyz *= 1. + mvPosition.xyz * .001 * uBackSide;
          vViewPosition = mvPosition.xyz;
          gl_Position = projectionMatrix * mvPosition;
        }
      `
        ),
        fragmentShader: (
          /* glsl */
          `
        precision highp float;
        varying vec2 vUv;
        varying vec2 vUv1;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vViewPosition;

        uniform sampler2D uReflexion, uNoise;
        uniform float uOpacity, uLuminosity, uBackSide, uGlobalLuminosity;

        #define PI 3.14159265

        void main() {
          float frontSide = 1. - uBackSide;
          vec3 color = vec3(0.);
          vec2 dUv = abs(vUv - .5) * .1 + fract(atan(vPosition.x, vPosition.y) * .1) + vUv1 * frontSide + abs(vNormal.xy) * .01;
          float t = 0.;
          float r = .0005 + length(vNormal.xy) * .00001;
          color.r += texture2D(uReflexion, dUv + vec2(cos(t), sin(t)) * r).r;
          t += PI * 2. / 3.;
          color.g += texture2D(uReflexion, dUv + vec2(cos(t), sin(t)) * r).g;
          t += PI * 2. / 3.;
          color.b += texture2D(uReflexion, dUv + vec2(cos(t), sin(t)) * r).b;

          color += smoothstep(.0, 1., texture2D(uReflexion, reflect(normalize(vViewPosition), normalize(vNormal) * .2).rg).r) * .4;

          color *= 1. + (texture2D(uNoise, vPosition.xy * .3 + vUv1 * frontSide - abs(vNormal.xy) * .001).r - .5) * .3;
          color += smoothstep(.5, 1., color) * .2;
          // color = .15 + color * .3 * vec3(1.2, .9, .6);
          color = .05 + color * .3 * vec3(1.2, 1.1, 1.05);

          gl_FragColor = vec4(color * uLuminosity * uGlobalLuminosity, uOpacity);
        }
      `
        ),
        uniforms: {
          uNoise: __privateGet(this, _uniforms).uNoise,
          uGlobalLuminosity: __privateGet(this, _uniforms).uGlobalLuminosity,
          uReflexion: { value: null },
          uOpacity: { value: 1 },
          uBackSide: { value: 1 },
          uLuminosity: { value: 3 }
        },
        transparent: true,
        side: 1
      }));
      __privateSet(this, _glowMaterial, new RawShaderMaterial({
        vertexShader: (
          /* glsl */
          `
        precision highp float;

        attribute vec3 position;
        attribute vec2 uv;

        varying vec2 vUv;

        uniform float uBackSide;

        void main() {
          vUv = uv;
          gl_Position = vec4(position, 1.);
        }
      `
        ),
        fragmentShader: (
          /* glsl */
          `
        precision highp float;
        varying vec2 vUv;

        uniform sampler2D uDiffuse, uLast, uNoise;
        uniform vec2 uResolution;

        #define WEIGHT_1 0.1945946
        #define WEIGHT_2 0.1216216
        #define WEIGHT_3 0.054054
        #define WEIGHT_4 0.016216

        #define PI 3.14159265

        void main() {
          vec2 offset = 5. / uResolution;

          vec3 color = vec3(0.);
          #ifdef HORIZONTAL
            color += texture2D(uDiffuse, vUv + vec2(offset.x * 1., 0.)).rgb * WEIGHT_1;
            color += texture2D(uDiffuse, vUv - vec2(offset.x * 1., 0.)).rgb * WEIGHT_1;

            color += texture2D(uDiffuse, vUv + vec2(offset.x * 2., 0.)).rgb * WEIGHT_2;
            color += texture2D(uDiffuse, vUv - vec2(offset.x * 2., 0.)).rgb * WEIGHT_2;

            color += texture2D(uDiffuse, vUv + vec2(offset.x * 3., 0.)).rgb * WEIGHT_3;
            color += texture2D(uDiffuse, vUv - vec2(offset.x * 3., 0.)).rgb * WEIGHT_3;

            color += texture2D(uDiffuse, vUv + vec2(offset.x * 4., 0.)).rgb * WEIGHT_4;
            color += texture2D(uDiffuse, vUv - vec2(offset.x * 4., 0.)).rgb * WEIGHT_4;
          #else
            color += texture2D(uDiffuse, vUv + vec2(0., offset.y * 1.)).rgb * WEIGHT_1;
            color += texture2D(uDiffuse, vUv - vec2(0., offset.y * 1.)).rgb * WEIGHT_1;

            color += texture2D(uDiffuse, vUv + vec2(0., offset.y * 2.)).rgb * WEIGHT_2;
            color += texture2D(uDiffuse, vUv - vec2(0., offset.y * 2.)).rgb * WEIGHT_2;

            color += texture2D(uDiffuse, vUv + vec2(0., offset.y * 3.)).rgb * WEIGHT_3;
            color += texture2D(uDiffuse, vUv - vec2(0., offset.y * 3.)).rgb * WEIGHT_3;

            color += texture2D(uDiffuse, vUv + vec2(0., offset.y * 4.)).rgb * WEIGHT_4;
            color += texture2D(uDiffuse, vUv - vec2(0., offset.y * 4.)).rgb * WEIGHT_4;

            color = mix(color, texture2D(uLast, vUv).rgb, .3);
          #endif
          gl_FragColor = vec4(smoothstep(.0, .3, length(color)) * color * 2., 1.);
          // gl_FragColor = texture2D(uDiffuse, vUv);
        }
      `
        ),
        uniforms: {
          uNoise: __privateGet(this, _uniforms).uNoise,
          uDiffuse: { value: null },
          uLast: { value: null },
          uResolution: __privateGet(this, _uniforms).uResolution
        },
        // transparent: true,
        side: 0
      }));
      __privateSet(this, _brt1Quad, new Mesh(new PlaneGeometry(2, 2), __privateGet(this, _glowMaterial)));
      __privateSet(this, _brt2Quad, new Mesh(new PlaneGeometry(2, 2), __privateGet(this, _glowMaterial).clone()));
      __privateGet(this, _brt1Quad).material.uniforms.uDiffuse.value = __privateGet(this, _brt).texture;
      __privateGet(this, _brt1Quad).material.uniforms.uLast.value = __privateGet(this, _brt1).texture;
      __privateGet(this, _brt2Quad).material.uniforms.uDiffuse.value = __privateGet(this, _brt1).texture;
      __privateGet(this, _brt2Quad).material.uniforms.uResolution = __privateGet(this, _uniforms).uResolution;
      __privateGet(this, _brt2Quad).material.defines.HORIZONTAL = 1;
      __privateSet(this, _diamondsFront, __privateGet(this, _diamondsBack).clone());
      __privateGet(this, _diamondsFront).side = 0;
      __privateGet(this, _diamondsFront).uniforms.uOpacity.value = 0.92;
      __privateGet(this, _diamondsFront).uniforms.uLuminosity.value = 1.2;
      __privateGet(this, _diamondsFront).uniforms.uBackSide.value = 0;
      __privateGet(this, _diamondsFront).uniforms.uGlobalLuminosity = __privateGet(this, _uniforms).uGlobalLuminosity;
    }
    on(name, callback) {
      if (!__privateGet(this, _events).has(name)) __privateGet(this, _events).set(name, []);
      __privateGet(this, _events).get(name).push(callback);
    }
    emit(name) {
      if (__privateGet(this, _events).has(name)) __privateGet(this, _events).get(name).forEach((callback) => callback());
    }
    load(baseUrl) {
      return __async(this, null, function* () {
        const textureLoader = new TextureLoader();
        const [model, envmap] = yield Promise.all([
          new Promise(
            (resolve) => gltfLoader.load(`${baseUrl}ring.compressed.glb`, (model2) => resolve(model2))
          ),
          textureLoader.load(`${baseUrl}studio_blur_small.jpg`)
        ]);
        this.model = model.scene;
        this.model.traverse((o4) => {
          if (o4.isMesh && o4.material.name === "diamond") {
            if (__privateGet(this, _diamondsBack).uniforms.uReflexion.value === null) {
              __privateGet(this, _diamondsBack).uniforms.uReflexion.value = o4.material.map;
              __privateGet(this, _diamondsFront).uniforms.uReflexion.value = o4.material.map;
            }
            o4.material = __privateGet(this, _diamondsBack);
            const front = o4.clone();
            front.material = __privateGet(this, _diamondsFront);
            o4.parent.add(front);
          }
        });
        __privateGet(this, _scene).add(this.model);
        __privateGet(this, _scene).environment = computeEnvmap(__privateGet(this, _renderer), envmap);
        __privateGet(this, _scene).environmentIntensity = 1.8;
        this.emit("load");
      });
    }
    tick(et) {
      et /= 1e3;
      __privateSet(this, _dt, Math.min(et - __privateGet(this, _et), 0.01));
      __privateSet(this, _et, et);
      __privateMethod(this, _TheRing_instances, render_fn).call(this);
      __privateGet(this, _uniforms).uTime.value = et / 1e3;
      __privateGet(this, _lerpedMouse).lerp(__privateGet(this, _mouse), __privateGet(this, _dt));
      if (this.model) {
        this.model.position.copy(this.ringPosition);
        this.model.rotation.set(0, 0, 0);
        this.model.rotateY(this.ringRotation.theta);
        this.model.rotateX(this.ringRotation.phi);
      }
    }
    mousemove(x2, y2) {
      __privateGet(this, _mouse).x = x2 * 2 - 1;
      __privateGet(this, _mouse).y = -y2 * 2 + 1;
    }
    resize(width, height) {
      __privateGet(this, _viewport).width = width;
      __privateGet(this, _viewport).height = height;
      __privateGet(this, _viewport).ratio = width / height;
      __privateGet(this, _viewport).dpr = Math.min(width < 1024 ? 2 : 1.5, window.devicePixelRatio);
      __privateGet(this, _uniforms).uResolution.value.set(__privateGet(this, _viewport).width, __privateGet(this, _viewport).height);
      __privateGet(this, _renderer).setSize(width, height);
      __privateGet(this, _renderer).setPixelRatio(__privateGet(this, _viewport).dpr);
      __privateMethod(this, _TheRing_instances, updateCamera_fn).call(this);
      __privateGet(this, _rt).setSize(
        __privateGet(this, _viewport).width * __privateGet(this, _viewport).dpr,
        __privateGet(this, _viewport).height * __privateGet(this, _viewport).dpr
      );
      __privateGet(this, _brt1).setSize(__privateGet(this, _viewport).width * BLUR_DPR, __privateGet(this, _viewport).height * BLUR_DPR);
      __privateGet(this, _brt1).setSize(__privateGet(this, _viewport).width * BLUR_DPR, __privateGet(this, _viewport).height * BLUR_DPR);
      __privateGet(this, _brt2).setSize(__privateGet(this, _viewport).width * BLUR_DPR, __privateGet(this, _viewport).height * BLUR_DPR);
    }
    launch() {
      const duration = 4;
      __privateSet(this, _launchSpherical, new Spherical(0, 0, 0));
      gsapWithCSS.from(__privateGet(this, _launchSpherical), {
        radius: 0.5,
        phi: -0.4,
        theta: 1.2,
        ease: "power4.out",
        duration
      });
      gsapWithCSS.from(this.model.position, {
        y: -0.05,
        ease: "power4.out",
        duration
      });
    }
    destroy() {
      __privateSet(this, _scene, __privateSet(this, _renderer, null));
    }
    get fov() {
      return __privateGet(this, _baseFOV);
    }
    set fov(value) {
      __privateSet(this, _baseFOV, value);
      __privateMethod(this, _TheRing_instances, updateCamera_fn).call(this);
    }
    get luminosity() {
      return __privateGet(this, _scene).environmentIntensity;
    }
    set luminosity(value) {
      __privateGet(this, _uniforms).uGlobalLuminosity.value = __privateGet(this, _scene).environmentIntensity = value;
    }
    get noise() {
      return __privateGet(this, _uniforms).uNoiseIntensity.value;
    }
    set noise(value) {
      __privateGet(this, _uniforms).uNoiseIntensity.value = value;
    }
    get scrollProgress() {
      return __privateGet(this, _scrollProgress);
    }
    set scrollProgress(value) {
      __privateSet(this, _scrollProgress, value);
    }
    set autoRotate(value) {
      __privateGet(this, _controls).autoRotateSpeed = value;
    }
    get renderer() {
      return __privateGet(this, _renderer);
    }
  };
  _baseFOV = new WeakMap();
  _diamondsFront = new WeakMap();
  _events = new WeakMap();
  _uniforms = new WeakMap();
  _dt = new WeakMap();
  _et = new WeakMap();
  _viewport = new WeakMap();
  _scene = new WeakMap();
  _renderer = new WeakMap();
  _orbitCamera = new WeakMap();
  _debugCamera = new WeakMap();
  _renderCamera = new WeakMap();
  _camera = new WeakMap();
  _controls = new WeakMap();
  _mouse = new WeakMap();
  _lerpedMouse = new WeakMap();
  _rt = new WeakMap();
  _brt = new WeakMap();
  _brt1 = new WeakMap();
  _brt2 = new WeakMap();
  _quad = new WeakMap();
  _diamondsBack = new WeakMap();
  _glowMaterial = new WeakMap();
  _brt1Quad = new WeakMap();
  _brt2Quad = new WeakMap();
  _cameraSpherical = new WeakMap();
  _launchSpherical = new WeakMap();
  _scrollProgress = new WeakMap();
  _TheRing_instances = new WeakSet();
  updateCamera_fn = function() {
    __privateGet(this, _renderCamera).aspect = __privateGet(this, _viewport).ratio;
    __privateGet(this, _renderCamera).fov = __privateGet(this, _baseFOV) / Math.min(1, __privateGet(this, _viewport).ratio * 1.5);
    __privateGet(this, _renderCamera).updateProjectionMatrix();
  };
  render_fn = function() {
    __privateSet(this, _cameraSpherical, new Spherical().setFromVector3(__privateGet(this, _orbitCamera).position));
    if (__privateGet(this, _cameraSpherical)) {
      if (__privateGet(this, _launchSpherical)) {
        for (let axis of ["radius", "phi", "theta"])
          __privateGet(this, _cameraSpherical)[axis] += __privateGet(this, _launchSpherical)[axis];
      }
      __privateGet(this, _cameraSpherical).radius += gsapWithCSS.utils.mapRange(0, 1, 0, 0.5, __privateGet(this, _scrollProgress));
      __privateGet(this, _cameraSpherical).phi += gsapWithCSS.utils.mapRange(0, 1, -Math.PI / 2, Math.PI / 2, __privateGet(this, _scrollProgress));
      __privateGet(this, _cameraSpherical).phi = Math.min(Math.max(0.1, __privateGet(this, _cameraSpherical).phi), Math.PI - 0.1);
      __privateGet(this, _camera).position.copy(__privateGet(this, _orbitCamera).worldToLocal(new Vector3().setFromSpherical(__privateGet(this, _cameraSpherical))));
      __privateGet(this, _camera).lookAt(0, 0, 0);
    }
    __privateGet(this, _controls).update();
    __privateGet(this, _renderer).setRenderTarget(__privateGet(this, _rt));
    __privateGet(this, _renderer).clear();
    __privateGet(this, _renderer).render(__privateGet(this, _scene), __privateGet(this, _renderCamera));
    __privateGet(this, _renderer).setRenderTarget(__privateGet(this, _brt));
    __privateGet(this, _renderer).clear();
    __privateGet(this, _renderer).render(__privateGet(this, _scene), __privateGet(this, _renderCamera));
    __privateGet(this, _renderer).setRenderTarget(__privateGet(this, _brt1));
    __privateGet(this, _renderer).clear();
    __privateGet(this, _renderer).render(__privateGet(this, _brt1Quad), __privateGet(this, _renderCamera));
    __privateGet(this, _renderer).setRenderTarget(__privateGet(this, _brt2));
    __privateGet(this, _renderer).clear();
    __privateGet(this, _renderer).render(__privateGet(this, _brt2Quad), __privateGet(this, _renderCamera));
    __privateGet(this, _renderer).setRenderTarget(null);
    __privateGet(this, _renderer).clear();
    __privateGet(this, _renderer).render(__privateGet(this, _quad), __privateGet(this, _renderCamera));
  };
  generateNoise_fn = function(size = 256) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = canvas2.height = size;
    const ctx = canvas2.getContext("2d");
    const image2 = ctx.getImageData(0, 0, size, size);
    image2.data.forEach((_2, i4) => {
      image2.data[i4] = Math.round(Math.random() * 255);
    });
    ctx.putImageData(image2, 0, 0);
    const texture = new CanvasTexture(canvas2);
    texture.wrapS = texture.wrapT = RepeatWrapping;
    texture.magFilter = texture.minFilter = NearestFilter;
    __privateGet(this, _uniforms).uNoise.value = texture;
  };

  // assets/scripts/modules/Ring.js
  var import_bezier_easing = __toESM(require_src(), 1);
  var EASE = (0, import_bezier_easing.default)(0.4, 0, 1, 1);
  var Ring_default = class extends _default {
    constructor(m2) {
      super(m2);
    }
    init() {
      this.ring = new TheRing(this.el);
      this.ring.load("/assets/3d/");
      this.renderBind = this.render.bind(this);
      gsapWithCSS.ticker.add(this.renderBind);
      this.checkResizeBind = this.checkResize.bind(this);
      window.addEventListener("resize", this.checkResizeBind);
      this.onResize();
      requestAnimationFrame(() => {
        this.onResize();
      });
    }
    ///////////////
    // Rendering
    ///////////////
    render(time, deltaTime, frame) {
      var _a, _b;
      (_b = (_a = this.ring) == null ? void 0 : _a.tick) == null ? void 0 : _b.call(_a, time * 1e4);
    }
    ///////////////
    // Callback
    ///////////////
    checkResize() {
      if (!this.resizeTick) {
        this.resizeTick = true;
        requestAnimationFrame(() => {
          this.onResize();
          this.resizeTick = false;
        });
      }
    }
    onResize() {
      const { width, height, top, left } = this.el.getBoundingClientRect();
      this.BCR = { width, height, top, left };
      this.ring.resize(this.BCR.width, this.BCR.height);
    }
    onScrollProgress(progress) {
      this.ring.scrollProgress = EASE(progress);
      let autoRotate = gsapWithCSS.utils.mapRange(0.5, 1, 2, 20, EASE(progress));
      autoRotate = Math.max(2, Math.min(20, autoRotate));
      this.ring.autoRotate = autoRotate;
    }
    //////////////
    // Methods
    /////////////
    launch() {
      this.ring.launch();
    }
    /////////////
    // Destroy
    /////////////
    destroy() {
      var _a, _b;
      super.destroy();
      (_b = (_a = this.ring) == null ? void 0 : _a.destroy) == null ? void 0 : _b.call(_a);
      gsapWithCSS.ticker.remove(this.renderBind);
      window.removeEventListener("resize", this.checkResizeBind);
    }
  };

  // node_modules/@studio-freight/lenis/dist/lenis.modern.mjs
  function t2() {
    return t2 = Object.assign ? Object.assign.bind() : function(t3) {
      for (var e4 = 1; e4 < arguments.length; e4++) {
        var i4 = arguments[e4];
        for (var s4 in i4) Object.prototype.hasOwnProperty.call(i4, s4) && (t3[s4] = i4[s4]);
      }
      return t3;
    }, t2.apply(this, arguments);
  }
  function e2(t3, e4, i4) {
    return Math.max(t3, Math.min(e4, i4));
  }
  var i2 = class {
    advance(t3) {
      var i4;
      if (!this.isRunning) return;
      let s4 = false;
      if (this.lerp) this.value = (o4 = this.value, n4 = this.to, (1 - (l4 = 1 - Math.exp(-60 * this.lerp * t3))) * o4 + l4 * n4), Math.round(this.value) === this.to && (this.value = this.to, s4 = true);
      else {
        this.currentTime += t3;
        const i5 = e2(0, this.currentTime / this.duration, 1);
        s4 = i5 >= 1;
        const o5 = s4 ? 1 : this.easing(i5);
        this.value = this.from + (this.to - this.from) * o5;
      }
      var o4, n4, l4;
      null == (i4 = this.onUpdate) || i4.call(this, this.value, s4), s4 && this.stop();
    }
    stop() {
      this.isRunning = false;
    }
    fromTo(t3, e4, { lerp: i4 = 0.1, duration: s4 = 1, easing: o4 = (t4) => t4, onStart: n4, onUpdate: l4 }) {
      this.from = this.value = t3, this.to = e4, this.lerp = i4, this.duration = s4, this.easing = o4, this.currentTime = 0, this.isRunning = true, null == n4 || n4(), this.onUpdate = l4;
    }
  };
  var s2 = class {
    constructor({ wrapper: t3, content: e4, autoResize: i4 = true } = {}) {
      if (this.resize = () => {
        this.onWrapperResize(), this.onContentResize();
      }, this.onWrapperResize = () => {
        this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);
      }, this.onContentResize = () => {
        this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth;
      }, this.wrapper = t3, this.content = e4, i4) {
        const t4 = /* @__PURE__ */ function(t5, e5) {
          let i5;
          return function() {
            let e6 = arguments, s4 = this;
            clearTimeout(i5), i5 = setTimeout(function() {
              t5.apply(s4, e6);
            }, 250);
          };
        }(this.resize);
        this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(t4), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(t4), this.contentResizeObserver.observe(this.content);
      }
      this.resize();
    }
    destroy() {
      var t3, e4;
      null == (t3 = this.wrapperResizeObserver) || t3.disconnect(), null == (e4 = this.contentResizeObserver) || e4.disconnect();
    }
    get limit() {
      return { x: this.scrollWidth - this.width, y: this.scrollHeight - this.height };
    }
  };
  var o2 = class {
    constructor() {
      this.events = {};
    }
    emit(t3, ...e4) {
      let i4 = this.events[t3] || [];
      for (let t4 = 0, s4 = i4.length; t4 < s4; t4++) i4[t4](...e4);
    }
    on(t3, e4) {
      var i4;
      return (null == (i4 = this.events[t3]) ? void 0 : i4.push(e4)) || (this.events[t3] = [e4]), () => {
        var i5;
        this.events[t3] = null == (i5 = this.events[t3]) ? void 0 : i5.filter((t4) => e4 !== t4);
      };
    }
    off(t3, e4) {
      var i4;
      this.events[t3] = null == (i4 = this.events[t3]) ? void 0 : i4.filter((t4) => e4 !== t4);
    }
    destroy() {
      this.events = {};
    }
  };
  var n2 = class {
    constructor(t3, { wheelMultiplier: i4 = 1, touchMultiplier: s4 = 2, normalizeWheel: n4 = false }) {
      this.onTouchStart = (t4) => {
        const { clientX: e4, clientY: i5 } = t4.targetTouches ? t4.targetTouches[0] : t4;
        this.touchStart.x = e4, this.touchStart.y = i5, this.lastDelta = { x: 0, y: 0 };
      }, this.onTouchMove = (t4) => {
        const { clientX: e4, clientY: i5 } = t4.targetTouches ? t4.targetTouches[0] : t4, s5 = -(e4 - this.touchStart.x) * this.touchMultiplier, o4 = -(i5 - this.touchStart.y) * this.touchMultiplier;
        this.touchStart.x = e4, this.touchStart.y = i5, this.lastDelta = { x: s5, y: o4 }, this.emitter.emit("scroll", { deltaX: s5, deltaY: o4, event: t4 });
      }, this.onTouchEnd = (t4) => {
        this.emitter.emit("scroll", { deltaX: this.lastDelta.x, deltaY: this.lastDelta.y, event: t4 });
      }, this.onWheel = (t4) => {
        let { deltaX: i5, deltaY: s5 } = t4;
        this.normalizeWheel && (i5 = e2(-100, i5, 100), s5 = e2(-100, s5, 100)), i5 *= this.wheelMultiplier, s5 *= this.wheelMultiplier, this.emitter.emit("scroll", { deltaX: i5, deltaY: s5, event: t4 });
      }, this.element = t3, this.wheelMultiplier = i4, this.touchMultiplier = s4, this.normalizeWheel = n4, this.touchStart = { x: null, y: null }, this.emitter = new o2(), this.element.addEventListener("wheel", this.onWheel, { passive: false }), this.element.addEventListener("touchstart", this.onTouchStart, { passive: false }), this.element.addEventListener("touchmove", this.onTouchMove, { passive: false }), this.element.addEventListener("touchend", this.onTouchEnd, { passive: false });
    }
    on(t3, e4) {
      return this.emitter.on(t3, e4);
    }
    destroy() {
      this.emitter.destroy(), this.element.removeEventListener("wheel", this.onWheel, { passive: false }), this.element.removeEventListener("touchstart", this.onTouchStart, { passive: false }), this.element.removeEventListener("touchmove", this.onTouchMove, { passive: false }), this.element.removeEventListener("touchend", this.onTouchEnd, { passive: false });
    }
  };
  var l2 = class {
    constructor({ wrapper: e4 = window, content: l4 = document.documentElement, wheelEventsTarget: r3 = e4, eventsTarget: h4 = r3, smoothWheel: a3 = true, smoothTouch: c3 = false, syncTouch: u2 = false, syncTouchLerp: p2 = 0.1, __iosNoInertiaSyncTouchLerp: d2 = 0.4, touchInertiaMultiplier: m2 = 35, duration: v2, easing: g2 = (t3) => Math.min(1, 1.001 - Math.pow(2, -10 * t3)), lerp: S2 = !v2 && 0.1, infinite: w2 = false, orientation: f2 = "vertical", gestureOrientation: y2 = "vertical", touchMultiplier: T2 = 1, wheelMultiplier: z2 = 1, normalizeWheel: _2 = false, autoResize: M2 = true } = {}) {
      this.onVirtualScroll = ({ deltaX: e5, deltaY: i4, event: s4 }) => {
        if (s4.ctrlKey) return;
        const o4 = s4.type.includes("touch"), n4 = s4.type.includes("wheel");
        if ("both" === this.options.gestureOrientation && 0 === e5 && 0 === i4 || "vertical" === this.options.gestureOrientation && 0 === i4 || "horizontal" === this.options.gestureOrientation && 0 === e5 || o4 && "vertical" === this.options.gestureOrientation && 0 === this.scroll && !this.options.infinite && i4 <= 0) return;
        let l5 = s4.composedPath();
        if (l5 = l5.slice(0, l5.indexOf(this.rootElement)), l5.find((t3) => {
          var e6;
          return (null == t3.hasAttribute ? void 0 : t3.hasAttribute("data-lenis-prevent")) || o4 && (null == t3.hasAttribute ? void 0 : t3.hasAttribute("data-lenis-prevent-touch")) || n4 && (null == t3.hasAttribute ? void 0 : t3.hasAttribute("data-lenis-prevent-wheel")) || (null == (e6 = t3.classList) ? void 0 : e6.contains("lenis"));
        })) return;
        if (this.isStopped || this.isLocked) return void s4.preventDefault();
        if (this.isSmooth = (this.options.smoothTouch || this.options.syncTouch) && o4 || this.options.smoothWheel && n4, !this.isSmooth) return this.isScrolling = false, void this.animate.stop();
        s4.preventDefault();
        let r4 = i4;
        "both" === this.options.gestureOrientation ? r4 = Math.abs(i4) > Math.abs(e5) ? i4 : e5 : "horizontal" === this.options.gestureOrientation && (r4 = e5);
        const h5 = o4 && this.options.syncTouch, a4 = o4 && "touchend" === s4.type && Math.abs(r4) > 1;
        a4 && (r4 = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + r4, t2({ programmatic: false }, h5 && { lerp: a4 ? this.syncTouchLerp : this.options.__iosNoInertiaSyncTouchLerp }));
      }, this.onNativeScroll = () => {
        if (!this.__preventNextScrollEvent && !this.isScrolling) {
          const t3 = this.animatedScroll;
          this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t3), this.emit();
        }
      }, window.lenisVersion = "1.0.29", e4 !== document.documentElement && e4 !== document.body || (e4 = window), this.options = { wrapper: e4, content: l4, wheelEventsTarget: r3, eventsTarget: h4, smoothWheel: a3, smoothTouch: c3, syncTouch: u2, syncTouchLerp: p2, __iosNoInertiaSyncTouchLerp: d2, touchInertiaMultiplier: m2, duration: v2, easing: g2, lerp: S2, infinite: w2, gestureOrientation: y2, orientation: f2, touchMultiplier: T2, wheelMultiplier: z2, normalizeWheel: _2, autoResize: M2 }, this.animate = new i2(), this.emitter = new o2(), this.dimensions = new s2({ wrapper: e4, content: l4, autoResize: M2 }), this.toggleClass("lenis", true), this.velocity = 0, this.isLocked = false, this.isStopped = false, this.isSmooth = u2 || a3 || c3, this.isScrolling = false, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, { passive: false }), this.virtualScroll = new n2(h4, { touchMultiplier: T2, wheelMultiplier: z2, normalizeWheel: _2 }), this.virtualScroll.on("scroll", this.onVirtualScroll);
    }
    destroy() {
      this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, { passive: false }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClass("lenis", false), this.toggleClass("lenis-smooth", false), this.toggleClass("lenis-scrolling", false), this.toggleClass("lenis-stopped", false), this.toggleClass("lenis-locked", false);
    }
    on(t3, e4) {
      return this.emitter.on(t3, e4);
    }
    off(t3, e4) {
      return this.emitter.off(t3, e4);
    }
    setScroll(t3) {
      this.isHorizontal ? this.rootElement.scrollLeft = t3 : this.rootElement.scrollTop = t3;
    }
    resize() {
      this.dimensions.resize();
    }
    emit() {
      this.emitter.emit("scroll", this);
    }
    reset() {
      this.isLocked = false, this.isScrolling = false, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop();
    }
    start() {
      this.isStopped = false, this.reset();
    }
    stop() {
      this.isStopped = true, this.animate.stop(), this.reset();
    }
    raf(t3) {
      const e4 = t3 - (this.time || t3);
      this.time = t3, this.animate.advance(1e-3 * e4);
    }
    scrollTo(t3, { offset: i4 = 0, immediate: s4 = false, lock: o4 = false, duration: n4 = this.options.duration, easing: l4 = this.options.easing, lerp: r3 = !n4 && this.options.lerp, onComplete: h4 = null, force: a3 = false, programmatic: c3 = true } = {}) {
      if (!this.isStopped && !this.isLocked || a3) {
        if (["top", "left", "start"].includes(t3)) t3 = 0;
        else if (["bottom", "right", "end"].includes(t3)) t3 = this.limit;
        else {
          var u2;
          let e4;
          if ("string" == typeof t3 ? e4 = document.querySelector(t3) : null != (u2 = t3) && u2.nodeType && (e4 = t3), e4) {
            if (this.options.wrapper !== window) {
              const t4 = this.options.wrapper.getBoundingClientRect();
              i4 -= this.isHorizontal ? t4.left : t4.top;
            }
            const s5 = e4.getBoundingClientRect();
            t3 = (this.isHorizontal ? s5.left : s5.top) + this.animatedScroll;
          }
        }
        if ("number" == typeof t3) {
          if (t3 += i4, t3 = Math.round(t3), this.options.infinite ? c3 && (this.targetScroll = this.animatedScroll = this.scroll) : t3 = e2(0, t3, this.limit), s4) return this.animatedScroll = this.targetScroll = t3, this.setScroll(this.scroll), this.reset(), void (null == h4 || h4(this));
          if (!c3) {
            if (t3 === this.targetScroll) return;
            this.targetScroll = t3;
          }
          this.animate.fromTo(this.animatedScroll, t3, { duration: n4, easing: l4, lerp: r3, onStart: () => {
            o4 && (this.isLocked = true), this.isScrolling = true;
          }, onUpdate: (t4, e4) => {
            this.isScrolling = true, this.velocity = t4 - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t4, this.setScroll(this.scroll), c3 && (this.targetScroll = t4), e4 || this.emit(), e4 && (this.reset(), this.emit(), null == h4 || h4(this), this.__preventNextScrollEvent = true, requestAnimationFrame(() => {
              delete this.__preventNextScrollEvent;
            }));
          } });
        }
      }
    }
    get rootElement() {
      return this.options.wrapper === window ? document.documentElement : this.options.wrapper;
    }
    get limit() {
      return this.dimensions.limit[this.isHorizontal ? "x" : "y"];
    }
    get isHorizontal() {
      return "horizontal" === this.options.orientation;
    }
    get actualScroll() {
      return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;
    }
    get scroll() {
      return this.options.infinite ? (this.animatedScroll % (t3 = this.limit) + t3) % t3 : this.animatedScroll;
      var t3;
    }
    get progress() {
      return 0 === this.limit ? 1 : this.scroll / this.limit;
    }
    get isSmooth() {
      return this.__isSmooth;
    }
    set isSmooth(t3) {
      this.__isSmooth !== t3 && (this.__isSmooth = t3, this.toggleClass("lenis-smooth", t3));
    }
    get isScrolling() {
      return this.__isScrolling;
    }
    set isScrolling(t3) {
      this.__isScrolling !== t3 && (this.__isScrolling = t3, this.toggleClass("lenis-scrolling", t3));
    }
    get isStopped() {
      return this.__isStopped;
    }
    set isStopped(t3) {
      this.__isStopped !== t3 && (this.__isStopped = t3, this.toggleClass("lenis-stopped", t3));
    }
    get isLocked() {
      return this.__isLocked;
    }
    set isLocked(t3) {
      this.__isLocked !== t3 && (this.__isLocked = t3, this.toggleClass("lenis-locked", t3));
    }
    get className() {
      let t3 = "lenis";
      return this.isStopped && (t3 += " lenis-stopped"), this.isLocked && (t3 += " lenis-locked"), this.isScrolling && (t3 += " lenis-scrolling"), this.isSmooth && (t3 += " lenis-smooth"), t3;
    }
    toggleClass(t3, e4) {
      this.rootElement.classList.toggle(t3, e4), this.emitter.emit("className change", this);
    }
  };

  // node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs
  function s3() {
    return s3 = Object.assign ? Object.assign.bind() : function(t3) {
      for (var s4 = 1; s4 < arguments.length; s4++) {
        var e4 = arguments[s4];
        for (var i4 in e4) Object.prototype.hasOwnProperty.call(e4, i4) && (t3[i4] = e4[i4]);
      }
      return t3;
    }, s3.apply(this, arguments);
  }
  var e3 = class {
    constructor({ scrollElements: t3, rootMargin: s4 = "-1px -1px -1px -1px", IORaf: e4 }) {
      this.scrollElements = void 0, this.rootMargin = void 0, this.IORaf = void 0, this.observer = void 0, this.scrollElements = t3, this.rootMargin = s4, this.IORaf = e4, this._init();
    }
    _init() {
      this.observer = new IntersectionObserver((t3) => {
        t3.forEach((t4) => {
          const s4 = this.scrollElements.find((s5) => s5.$el === t4.target);
          t4.isIntersecting ? (s4 && (s4.isAlreadyIntersected = true), this._setInview(t4)) : s4 && s4.isAlreadyIntersected && this._setOutOfView(t4);
        });
      }, { rootMargin: this.rootMargin });
      for (const t3 of this.scrollElements) this.observe(t3.$el);
    }
    destroy() {
      this.observer.disconnect();
    }
    observe(t3) {
      t3 && this.observer.observe(t3);
    }
    unobserve(t3) {
      t3 && this.observer.unobserve(t3);
    }
    _setInview(t3) {
      const s4 = this.scrollElements.find((s5) => s5.$el === t3.target);
      this.IORaf && (null == s4 || s4.setInteractivityOn()), !this.IORaf && (null == s4 || s4.setInview());
    }
    _setOutOfView(t3) {
      const s4 = this.scrollElements.find((s5) => s5.$el === t3.target);
      this.IORaf && (null == s4 || s4.setInteractivityOff()), !this.IORaf && (null == s4 || s4.setOutOfView()), null != s4 && s4.attributes.scrollRepeat || this.IORaf || this.unobserve(t3.target);
    }
  };
  function i3(t3, s4, e4, i4, r3) {
    return e4 + ((r3 - t3) / (s4 - t3) * (i4 - e4) || 0);
  }
  function r2(t3, s4) {
    return t3.reduce((t4, e4) => Math.abs(e4 - s4) < Math.abs(t4 - s4) ? e4 : t4);
  }
  var l3 = class {
    constructor({ $el: t3, id: s4, modularInstance: e4, subscribeElementUpdateFn: i4, unsubscribeElementUpdateFn: r3, needRaf: l4, scrollOrientation: n4 }) {
      var o4, a3, c3, h4, d2;
      this.$el = void 0, this.id = void 0, this.needRaf = void 0, this.attributes = void 0, this.scrollOrientation = void 0, this.isAlreadyIntersected = void 0, this.intersection = void 0, this.metrics = void 0, this.currentScroll = void 0, this.translateValue = void 0, this.progress = void 0, this.lastProgress = void 0, this.modularInstance = void 0, this.progressModularModules = void 0, this.isInview = void 0, this.isInteractive = void 0, this.isInFold = void 0, this.isFirstResize = void 0, this.subscribeElementUpdateFn = void 0, this.unsubscribeElementUpdateFn = void 0, this.$el = t3, this.id = s4, this.needRaf = l4, this.scrollOrientation = n4, this.modularInstance = e4, this.subscribeElementUpdateFn = i4, this.unsubscribeElementUpdateFn = r3, this.attributes = { scrollClass: null != (o4 = this.$el.dataset.scrollClass) ? o4 : "is-inview", scrollOffset: null != (a3 = this.$el.dataset.scrollOffset) ? a3 : "0,0", scrollPosition: null != (c3 = this.$el.dataset.scrollPosition) ? c3 : "start,end", scrollModuleProgress: null != this.$el.dataset.scrollModuleProgress, scrollCssProgress: null != this.$el.dataset.scrollCssProgress, scrollEventProgress: null != (h4 = this.$el.dataset.scrollEventProgress) ? h4 : null, scrollSpeed: null != this.$el.dataset.scrollSpeed ? parseFloat(this.$el.dataset.scrollSpeed) : null, scrollRepeat: null != this.$el.dataset.scrollRepeat, scrollCall: null != (d2 = this.$el.dataset.scrollCall) ? d2 : null, scrollCallSelf: null != this.$el.dataset.scrollCallSelf, scrollIgnoreFold: null != this.$el.dataset.scrollIgnoreFold, scrollEnableTouchSpeed: null != this.$el.dataset.scrollEnableTouchSpeed }, this.intersection = { start: 0, end: 0 }, this.metrics = { offsetStart: 0, offsetEnd: 0, bcr: {} }, this.currentScroll = "vertical" === this.scrollOrientation ? window.scrollY : window.scrollX, this.translateValue = 0, this.progress = 0, this.lastProgress = null, this.progressModularModules = [], this.isInview = false, this.isInteractive = false, this.isAlreadyIntersected = false, this.isInFold = false, this.isFirstResize = true, this._init();
    }
    _init() {
      this.needRaf && (this.modularInstance && this.attributes.scrollModuleProgress && this._getProgressModularModules(), this._resize());
    }
    onResize({ currentScroll: t3 }) {
      this.currentScroll = t3, this._resize();
    }
    onRender({ currentScroll: t3, smooth: s4 }) {
      const e4 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth;
      if (this.currentScroll = t3, this._computeProgress(), this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed)) if (this.attributes.scrollEnableTouchSpeed || s4) {
        if (this.isInFold) {
          const t4 = Math.max(0, this.progress);
          this.translateValue = t4 * e4 * this.attributes.scrollSpeed * -1;
        } else {
          const t4 = i3(0, 1, -1, 1, this.progress);
          this.translateValue = t4 * e4 * this.attributes.scrollSpeed * -1;
        }
        this.$el.style.transform = "vertical" === this.scrollOrientation ? `translate3d(0, ${this.translateValue}px, 0)` : `translate3d(${this.translateValue}px, 0, 0)`;
      } else this.translateValue && (this.$el.style.transform = "translate3d(0, 0, 0)"), this.translateValue = 0;
    }
    setInview() {
      if (this.isInview) return;
      this.isInview = true, this.$el.classList.add(this.attributes.scrollClass);
      const t3 = this._getScrollCallFrom();
      this.attributes.scrollCall && this._dispatchCall("enter", t3);
    }
    setOutOfView() {
      if (!this.isInview || !this.attributes.scrollRepeat) return;
      this.isInview = false, this.$el.classList.remove(this.attributes.scrollClass);
      const t3 = this._getScrollCallFrom();
      this.attributes.scrollCall && this._dispatchCall("leave", t3);
    }
    setInteractivityOn() {
      this.isInteractive || (this.isInteractive = true, this.subscribeElementUpdateFn(this));
    }
    setInteractivityOff() {
      this.isInteractive && (this.isInteractive = false, this.unsubscribeElementUpdateFn(this), null != this.lastProgress && this._computeProgress(r2([0, 1], this.lastProgress)));
    }
    _resize() {
      this.metrics.bcr = this.$el.getBoundingClientRect(), this._computeMetrics(), this._computeIntersection(), this.isFirstResize && (this.isFirstResize = false, this.isInFold && this.setInview());
    }
    _computeMetrics() {
      const { top: t3, left: s4, height: e4, width: i4 } = this.metrics.bcr, r3 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth, l4 = "vertical" === this.scrollOrientation ? e4 : i4;
      this.metrics.offsetStart = this.currentScroll + ("vertical" === this.scrollOrientation ? t3 : s4) - this.translateValue, this.metrics.offsetEnd = this.metrics.offsetStart + l4, this.isInFold = this.metrics.offsetStart < r3 && !this.attributes.scrollIgnoreFold;
    }
    _computeIntersection() {
      const t3 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth, s4 = "vertical" === this.scrollOrientation ? this.metrics.bcr.height : this.metrics.bcr.width, e4 = this.attributes.scrollOffset.split(","), i4 = null != e4[0] ? e4[0].trim() : "0", r3 = null != e4[1] ? e4[1].trim() : "0", l4 = this.attributes.scrollPosition.split(",");
      let n4 = null != l4[0] ? l4[0].trim() : "start";
      const o4 = null != l4[1] ? l4[1].trim() : "end", a3 = i4.includes("%") ? t3 * parseInt(i4.replace("%", "").trim()) * 0.01 : parseInt(i4), c3 = r3.includes("%") ? t3 * parseInt(r3.replace("%", "").trim()) * 0.01 : parseInt(r3);
      switch (this.isInFold && (n4 = "fold"), n4) {
        case "start":
        default:
          this.intersection.start = this.metrics.offsetStart - t3 + a3;
          break;
        case "middle":
          this.intersection.start = this.metrics.offsetStart - t3 + a3 + 0.5 * s4;
          break;
        case "end":
          this.intersection.start = this.metrics.offsetStart - t3 + a3 + s4;
          break;
        case "fold":
          this.intersection.start = 0;
      }
      switch (o4) {
        case "start":
          this.intersection.end = this.metrics.offsetStart - c3;
          break;
        case "middle":
          this.intersection.end = this.metrics.offsetStart - c3 + 0.5 * s4;
          break;
        default:
          this.intersection.end = this.metrics.offsetStart - c3 + s4;
      }
      if (this.intersection.end <= this.intersection.start) switch (o4) {
        case "start":
        default:
          this.intersection.end = this.intersection.start + 1;
          break;
        case "middle":
          this.intersection.end = this.intersection.start + 0.5 * s4;
          break;
        case "end":
          this.intersection.end = this.intersection.start + s4;
      }
    }
    _computeProgress(t3) {
      const s4 = null != t3 ? t3 : (e4 = i3(this.intersection.start, this.intersection.end, 0, 1, this.currentScroll)) < 0 ? 0 : e4 > 1 ? 1 : e4;
      var e4;
      if (this.progress = s4, s4 != this.lastProgress) {
        if (this.lastProgress = s4, this.attributes.scrollCssProgress && this._setCssProgress(s4), this.attributes.scrollEventProgress && this._setCustomEventProgress(s4), this.attributes.scrollModuleProgress) for (const t4 of this.progressModularModules) this.modularInstance && this.modularInstance.call("onScrollProgress", s4, t4.moduleName, t4.moduleId);
        s4 > 0 && s4 < 1 && this.setInview(), 0 === s4 && this.setOutOfView(), 1 === s4 && this.setOutOfView();
      }
    }
    _setCssProgress(t3 = 0) {
      this.$el.style.setProperty("--progress", t3.toString());
    }
    _setCustomEventProgress(t3 = 0) {
      const s4 = this.attributes.scrollEventProgress;
      if (!s4) return;
      const e4 = new CustomEvent(s4, { detail: { target: this.$el, progress: t3 } });
      window.dispatchEvent(e4);
    }
    _getProgressModularModules() {
      if (!this.modularInstance) return;
      const t3 = Object.keys(this.$el.dataset).filter((t4) => t4.includes("module")), s4 = Object.entries(this.modularInstance.modules);
      if (t3.length) for (const e4 of t3) {
        const t4 = this.$el.dataset[e4];
        if (!t4) return;
        for (const e5 of s4) {
          const [s5, i4] = e5;
          t4 in i4 && this.progressModularModules.push({ moduleName: s5, moduleId: t4 });
        }
      }
    }
    _getScrollCallFrom() {
      const t3 = r2([this.intersection.start, this.intersection.end], this.currentScroll);
      return this.intersection.start === t3 ? "start" : "end";
    }
    _dispatchCall(t3, s4) {
      var e4, i4;
      const r3 = null == (e4 = this.attributes.scrollCall) ? void 0 : e4.split(","), l4 = null == (i4 = this.attributes) ? void 0 : i4.scrollCallSelf;
      if (r3 && r3.length > 1) {
        var n4;
        const [e5, i5, o4] = r3;
        let a3;
        a3 = l4 ? this.$el.dataset[`module${i5.trim()}`] : o4, this.modularInstance && this.modularInstance.call(e5.trim(), { target: this.$el, way: t3, from: s4 }, i5.trim(), null == (n4 = a3) ? void 0 : n4.trim());
      } else if (r3) {
        const [e5] = r3, i5 = new CustomEvent(e5, { detail: { target: this.$el, way: t3, from: s4 } });
        window.dispatchEvent(i5);
      }
    }
  };
  var n3 = ["scrollOffset", "scrollPosition", "scrollModuleProgress", "scrollCssProgress", "scrollEventProgress", "scrollSpeed"];
  var o3 = class {
    constructor({ $el: t3, modularInstance: s4, triggerRootMargin: e4, rafRootMargin: i4, scrollOrientation: r3 }) {
      this.$scrollContainer = void 0, this.modularInstance = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.scrollElements = void 0, this.triggeredScrollElements = void 0, this.RAFScrollElements = void 0, this.scrollElementsToUpdate = void 0, this.IOTriggerInstance = void 0, this.IORafInstance = void 0, this.scrollOrientation = void 0, t3 ? (this.$scrollContainer = t3, this.modularInstance = s4, this.scrollOrientation = r3, this.triggerRootMargin = null != e4 ? e4 : "-1px -1px -1px -1px", this.rafRootMargin = null != i4 ? i4 : "100% 100% 100% 100%", this.scrollElements = [], this.triggeredScrollElements = [], this.RAFScrollElements = [], this.scrollElementsToUpdate = [], this._init()) : console.error("Please provide a DOM Element as scrollContainer");
    }
    _init() {
      const t3 = this.$scrollContainer.querySelectorAll("[data-scroll]"), s4 = Array.from(t3);
      this._subscribeScrollElements(s4), this.IOTriggerInstance = new e3({ scrollElements: [...this.triggeredScrollElements], rootMargin: this.triggerRootMargin, IORaf: false }), this.IORafInstance = new e3({ scrollElements: [...this.RAFScrollElements], rootMargin: this.rafRootMargin, IORaf: true });
    }
    destroy() {
      this.IOTriggerInstance.destroy(), this.IORafInstance.destroy(), this._unsubscribeAllScrollElements();
    }
    onResize({ currentScroll: t3 }) {
      for (const s4 of this.RAFScrollElements) s4.onResize({ currentScroll: t3 });
    }
    onRender({ currentScroll: t3, smooth: s4 }) {
      for (const e4 of this.scrollElementsToUpdate) e4.onRender({ currentScroll: t3, smooth: s4 });
    }
    removeScrollElements(t3) {
      const s4 = t3.querySelectorAll("[data-scroll]");
      if (s4.length) {
        for (let t4 = 0; t4 < this.triggeredScrollElements.length; t4++) {
          const e4 = this.triggeredScrollElements[t4];
          Array.from(s4).indexOf(e4.$el) > -1 && (this.IOTriggerInstance.unobserve(e4.$el), this.triggeredScrollElements.splice(t4, 1));
        }
        for (let t4 = 0; t4 < this.RAFScrollElements.length; t4++) {
          const e4 = this.RAFScrollElements[t4];
          Array.from(s4).indexOf(e4.$el) > -1 && (this.IORafInstance.unobserve(e4.$el), this.RAFScrollElements.splice(t4, 1));
        }
        s4.forEach((t4) => {
          const s5 = this.scrollElementsToUpdate.find((s6) => s6.$el === t4), e4 = this.scrollElements.find((s6) => s6.$el === t4);
          s5 && this._unsubscribeElementUpdate(s5), e4 && (this.scrollElements = this.scrollElements.filter((t5) => t5.id != e4.id));
        });
      }
    }
    addScrollElements(t3) {
      const s4 = t3.querySelectorAll("[data-scroll]"), e4 = [];
      this.scrollElements.forEach((t4) => {
        e4.push(t4.id);
      });
      const i4 = Math.max(...e4) + 1, r3 = Array.from(s4);
      this._subscribeScrollElements(r3, i4, true);
    }
    _subscribeScrollElements(t3, s4 = 0, e4 = false) {
      for (let i4 = 0; i4 < t3.length; i4++) {
        const r3 = t3[i4], n4 = this._checkRafNeeded(r3), o4 = new l3({ $el: r3, id: s4 + i4, scrollOrientation: this.scrollOrientation, modularInstance: this.modularInstance, subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this), unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this), needRaf: n4 });
        this.scrollElements.push(o4), n4 ? (this.RAFScrollElements.push(o4), e4 && (this.IORafInstance.scrollElements.push(o4), this.IORafInstance.observe(o4.$el))) : (this.triggeredScrollElements.push(o4), e4 && (this.IOTriggerInstance.scrollElements.push(o4), this.IOTriggerInstance.observe(o4.$el)));
      }
    }
    _unsubscribeAllScrollElements() {
      this.scrollElements = [], this.RAFScrollElements = [], this.triggeredScrollElements = [], this.scrollElementsToUpdate = [];
    }
    _subscribeElementUpdate(t3) {
      this.scrollElementsToUpdate.push(t3);
    }
    _unsubscribeElementUpdate(t3) {
      this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter((s4) => s4.id != t3.id);
    }
    _checkRafNeeded(t3) {
      let s4 = [...n3];
      const e4 = (t4) => {
        s4 = s4.filter((s5) => s5 != t4);
      };
      if (t3.dataset.scrollOffset) {
        if ("0,0" != t3.dataset.scrollOffset.split(",").map((t4) => t4.replace("%", "").trim()).join(",")) return true;
        e4("scrollOffset");
      } else e4("scrollOffset");
      if (t3.dataset.scrollPosition) {
        if ("top,bottom" != t3.dataset.scrollPosition.trim()) return true;
        e4("scrollPosition");
      } else e4("scrollPosition");
      if (t3.dataset.scrollSpeed && !isNaN(parseFloat(t3.dataset.scrollSpeed))) return true;
      e4("scrollSpeed");
      for (const e5 of s4) if (e5 in t3.dataset) return true;
      return false;
    }
  };
  var a2 = class {
    constructor({ resizeElements: t3, resizeCallback: s4 = () => {
    } }) {
      this.$resizeElements = void 0, this.isFirstObserve = void 0, this.observer = void 0, this.resizeCallback = void 0, this.$resizeElements = t3, this.resizeCallback = s4, this.isFirstObserve = true, this._init();
    }
    _init() {
      this.observer = new ResizeObserver((t3) => {
        var s4;
        !this.isFirstObserve && (null == (s4 = this.resizeCallback) || s4.call(this)), this.isFirstObserve = false;
      });
      for (const t3 of this.$resizeElements) this.observer.observe(t3);
    }
    destroy() {
      this.observer.disconnect();
    }
  };
  var c2 = { wrapper: window, content: document.documentElement, eventsTarget: window, lerp: 0.1, duration: 0.75, orientation: "vertical", gestureOrientation: "vertical", smoothWheel: true, smoothTouch: false, syncTouch: false, syncTouchLerp: 0.1, touchInertiaMultiplier: 35, wheelMultiplier: 1, touchMultiplier: 2, normalizeWheel: false, autoResize: true, easing: (t3) => Math.min(1, 1.001 - Math.pow(2, -10 * t3)) };
  var h3 = class {
    constructor({ lenisOptions: t3 = {}, modularInstance: e4, triggerRootMargin: i4, rafRootMargin: r3, autoResize: l4 = true, autoStart: n4 = true, scrollCallback: o4 = () => {
    }, initCustomTicker: a3, destroyCustomTicker: h4 } = {}) {
      this.rafPlaying = void 0, this.lenisInstance = void 0, this.coreInstance = void 0, this.lenisOptions = void 0, this.modularInstance = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.rafInstance = void 0, this.autoResize = void 0, this.autoStart = void 0, this.ROInstance = void 0, this.initCustomTicker = void 0, this.destroyCustomTicker = void 0, this._onRenderBind = void 0, this._onResizeBind = void 0, this._onScrollToBind = void 0, this.lenisOptions = s3({}, c2, t3), Object.assign(this, { lenisOptions: t3, modularInstance: e4, triggerRootMargin: i4, rafRootMargin: r3, autoResize: l4, autoStart: n4, scrollCallback: o4, initCustomTicker: a3, destroyCustomTicker: h4 }), this._onRenderBind = this._onRender.bind(this), this._onScrollToBind = this._onScrollTo.bind(this), this._onResizeBind = this._onResize.bind(this), this.rafPlaying = false, this._init();
    }
    _init() {
      var s4;
      this.lenisInstance = new l2({ wrapper: this.lenisOptions.wrapper, content: this.lenisOptions.content, eventsTarget: this.lenisOptions.eventsTarget, lerp: this.lenisOptions.lerp, duration: this.lenisOptions.duration, orientation: this.lenisOptions.orientation, gestureOrientation: this.lenisOptions.gestureOrientation, smoothWheel: this.lenisOptions.smoothWheel, smoothTouch: this.lenisOptions.smoothTouch, syncTouch: this.lenisOptions.syncTouch, syncTouchLerp: this.lenisOptions.syncTouchLerp, touchInertiaMultiplier: this.lenisOptions.touchInertiaMultiplier, wheelMultiplier: this.lenisOptions.wheelMultiplier, touchMultiplier: this.lenisOptions.touchMultiplier, normalizeWheel: this.lenisOptions.normalizeWheel, easing: this.lenisOptions.easing }), null == (s4 = this.lenisInstance) || s4.on("scroll", this.scrollCallback), document.documentElement.setAttribute("data-scroll-orientation", this.lenisInstance.options.orientation), requestAnimationFrame(() => {
        this.coreInstance = new o3({ $el: this.lenisInstance.rootElement, modularInstance: this.modularInstance, triggerRootMargin: this.triggerRootMargin, rafRootMargin: this.rafRootMargin, scrollOrientation: this.lenisInstance.options.orientation }), this._bindEvents(), this.initCustomTicker && !this.destroyCustomTicker ? console.warn("initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.") : !this.initCustomTicker && this.destroyCustomTicker && console.warn("destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble."), this.autoStart && this.start();
      });
    }
    destroy() {
      var t3;
      this.stop(), this._unbindEvents(), this.lenisInstance.destroy(), null == (t3 = this.coreInstance) || t3.destroy(), requestAnimationFrame(() => {
        var t4;
        null == (t4 = this.coreInstance) || t4.destroy();
      });
    }
    _bindEvents() {
      this._bindScrollToEvents(), this.autoResize && ("ResizeObserver" in window ? this.ROInstance = new a2({ resizeElements: [document.body], resizeCallback: this._onResizeBind }) : window.addEventListener("resize", this._onResizeBind));
    }
    _unbindEvents() {
      this._unbindScrollToEvents(), this.autoResize && ("ResizeObserver" in window ? this.ROInstance && this.ROInstance.destroy() : window.removeEventListener("resize", this._onResizeBind));
    }
    _bindScrollToEvents(t3) {
      const s4 = t3 || this.lenisInstance.rootElement, e4 = null == s4 ? void 0 : s4.querySelectorAll("[data-scroll-to]");
      (null == e4 ? void 0 : e4.length) && e4.forEach((t4) => {
        t4.addEventListener("click", this._onScrollToBind, false);
      });
    }
    _unbindScrollToEvents(t3) {
      const s4 = t3 || this.lenisInstance.rootElement, e4 = null == s4 ? void 0 : s4.querySelectorAll("[data-scroll-to]");
      (null == e4 ? void 0 : e4.length) && e4.forEach((t4) => {
        t4.removeEventListener("click", this._onScrollToBind, false);
      });
    }
    _onResize() {
      requestAnimationFrame(() => {
        var t3;
        null == (t3 = this.coreInstance) || t3.onResize({ currentScroll: this.lenisInstance.scroll });
      });
    }
    _onRender() {
      var t3, s4;
      null == (t3 = this.lenisInstance) || t3.raf(Date.now()), null == (s4 = this.coreInstance) || s4.onRender({ currentScroll: this.lenisInstance.scroll, smooth: this.lenisInstance.isSmooth });
    }
    _onScrollTo(t3) {
      var s4;
      t3.preventDefault();
      const e4 = null != (s4 = t3.currentTarget) ? s4 : null;
      if (!e4) return;
      const i4 = e4.getAttribute("data-scroll-to-href") || e4.getAttribute("href"), r3 = e4.getAttribute("data-scroll-to-offset") || 0, l4 = e4.getAttribute("data-scroll-to-duration") || this.lenisOptions.duration || c2.duration;
      i4 && this.scrollTo(i4, { offset: "string" == typeof r3 ? parseInt(r3) : r3, duration: "string" == typeof l4 ? parseInt(l4) : l4 });
    }
    start() {
      var t3;
      this.rafPlaying || (null == (t3 = this.lenisInstance) || t3.start(), this.rafPlaying = true, this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf());
    }
    stop() {
      var t3;
      this.rafPlaying && (null == (t3 = this.lenisInstance) || t3.stop(), this.rafPlaying = false, this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance));
    }
    removeScrollElements(t3) {
      var s4;
      t3 ? (this._unbindScrollToEvents(t3), null == (s4 = this.coreInstance) || s4.removeScrollElements(t3)) : console.error("Please provide a DOM Element as $oldContainer");
    }
    addScrollElements(t3) {
      var s4;
      t3 ? (null == (s4 = this.coreInstance) || s4.addScrollElements(t3), requestAnimationFrame(() => {
        this._bindScrollToEvents(t3);
      })) : console.error("Please provide a DOM Element as $newContainer");
    }
    resize() {
      this._onResizeBind();
    }
    scrollTo(t3, s4) {
      var e4;
      null == (e4 = this.lenisInstance) || e4.scrollTo(t3, { offset: null == s4 ? void 0 : s4.offset, lerp: null == s4 ? void 0 : s4.lerp, duration: null == s4 ? void 0 : s4.duration, immediate: null == s4 ? void 0 : s4.immediate, lock: null == s4 ? void 0 : s4.lock, force: null == s4 ? void 0 : s4.force, easing: null == s4 ? void 0 : s4.easing, onComplete: null == s4 ? void 0 : s4.onComplete });
    }
    _raf() {
      this._onRenderBind(), this.rafInstance = requestAnimationFrame(() => this._raf());
    }
  };

  // assets/scripts/modules/Scroll.js
  var Scroll_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.onScrollBind = this.onScroll.bind(this);
      this.scrollDirection = 1;
      this.lastProgress = 0;
      this.lastDirectionChange = 0;
    }
    ///////////////
    // Lifecyle
    ///////////////
    init() {
      var _a, _b;
      if (html2.scrollTop < 80) {
        html2.classList.add("is-top");
      } else {
        html2.classList.remove("is-top");
      }
      this.locomotiveScroll = new h3({
        lenisOptions: {
          // duration: 1,
          // smooth: false,
        },
        scrollCallback: this.onScrollBind,
        modularInstance: this,
        initCustomTicker: (render6) => {
          gsapWithCSS.ticker.add(render6);
        },
        destroyCustomTicker: (render6) => {
          gsapWithCSS.ticker.remove(render6);
        }
      });
      (_b = (_a = this.locomotiveScroll.lenisInstance) == null ? void 0 : _a.options) == null ? void 0 : _b.content.addEventListener("wheel", (event2) => {
        const targets = event2.composedPath();
        targets.find((target) => {
          if (target.id === "cc-main") {
            event2.stopPropagation();
            return true;
          }
        });
      });
      this.locomotiveScroll.start();
    }
    destroy() {
      var _a;
      (_a = this.locomotiveScroll) == null ? void 0 : _a.destroy();
      html2.classList.remove("is-scrolling-up");
    }
    ///////////////
    // Events
    ///////////////
    // bindEvents() {
    //     window.addEventListener("resize", this.onResizeBind)
    // }
    // unbindEvents() {
    //     window.removeEventListener("resize", this.onResizeBind)
    // }
    ///////////////
    // Callbacks
    ///////////////
    onScroll({ scroll: scroll2, limit, velocity, direction, progress }) {
      if (progress > this.lastProgress) {
        if (this.scrollDirection != 1) {
          this.lastDirectionChange = scroll2;
          this.scrollDirection = 1;
          html2.style.setProperty("--scroll-direction", this.scrollDirection);
          html2.classList.remove("is-scrolling-up");
        }
      } else {
        if (this.scrollDirection != -1) {
          this.lastDirectionChange = scroll2;
          this.scrollDirection = -1;
          html2.style.setProperty("--scroll-direction", this.scrollDirection);
          html2.classList.add("is-scrolling-up");
        }
      }
      if (scroll2 < 80) {
        html2.classList.add("is-top");
      } else {
        html2.classList.remove("is-top");
      }
      window.scroll = { scroll: scroll2, limit, velocity, direction: this.scrollDirection, progress };
      this.lastProgress = progress;
    }
    // onResize() {
    //     console.log(this.locomotiveScroll);
    //     this.locomotiveScroll?.resize()
    // }
    scrollTo(params) {
      var _a;
      const { target, options } = params;
      (_a = this.locomotiveScroll) == null ? void 0 : _a.scrollTo(target, options);
    }
    ///////////////
    // Methods
    ///////////////
    /**
     * Lazy load the related image.
     *
     * @see ../utils/image.js
     *
     * It is recommended to wrap your `<img>` into an element with the
     * CSS class name `.c-lazy`. The CSS class name modifier `.-lazy-loaded`
     * will be applied on both the image and the parent wrapper.
     *
     * ```html
     * <div class="c-lazy o-ratio u-4:3">
     *     <img data-scroll data-scroll-call="lazyLoad, Scroll, main" data-src="http://picsum.photos/640/480?v=1" alt="" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" />
     * </div>
     * ```
     *
     * @param {LocomotiveScroll} args - The Locomotive Scroll instance.
     */
    lazyLoad(args) {
      lazyLoadImage(args.target, null, () => {
        if (args.target.dataset.depixelate != void 0)
          animDepixelate(args.target);
      });
    }
  };

  // assets/scripts/modules/TeamCanvas.js
  var TeamCanvas_default = class extends ModelViewer_default {
    constructor(m2) {
      super(m2);
      this.defaultAnimation = "idle-1";
      this.models = this.getData("models").split(",");
    }
    init() {
      super.init();
      let clickStartTime;
      let clickStartPos;
      this.onClickStart = (e4) => {
        clickStartTime = Date.now();
        clickStartPos = {
          x: e4.touches ? e4.touches[0].screenX : e4.screenX,
          y: e4.touches ? e4.touches[0].screenY : e4.screenY
        };
        this.interacting = true;
      };
      this.onClickEnd = (e4) => {
        this.interacting = false;
        const deltaTime = Date.now() - clickStartTime;
        const clickEndPos = {
          x: e4.changedTouches ? e4.changedTouches[0].screenX : e4.screenX,
          y: e4.changedTouches ? e4.changedTouches[0].screenY : e4.screenY
        };
        let deltaPos = Math.abs(Math.sqrt(Math.pow(clickStartPos.x - clickEndPos.x, 2) + Math.pow(clickStartPos.y - clickEndPos.y, 2)));
        if (deltaTime < 250 && deltaPos < 10) {
          this.setModel(this.models[Math.floor(this.models.length * Math.random())]);
        }
      };
      this.el.addEventListener("pointerdown", this.onClickStart);
      this.el.addEventListener("pointerup", this.onClickEnd);
    }
    onInview(e4) {
      if (e4.target == this.el && e4.way == "enter") {
        this.setModel(this.models[Math.floor(this.models.length * Math.random())]);
      }
    }
    render() {
      super.render();
      if (!this.interacting) this.wrapper.rotation.set(0, this.wrapper.rotation.y + 0.02 * this.deltaTime / (1 / 60), 0);
    }
    initScene() {
      super.initScene();
      this.camera.position.set(1, 3, 5);
      this.controls.target.set(0, 0.9, 0);
      this.wrapper.scale.set(1.2, 1.2, 1.2);
      this.controls.maxPolarAngle = Math.PI * 0.6;
      this.controls.minPolarAngle = Math.PI * 0.3;
      this.controls.enableZoom = false;
      this.controls.enablePan = false;
      this.controls.touches = {};
      this.el.style.touchAction = "";
    }
    destroy() {
      this.el.removeEventListener("pointerdown", this.onClickStart);
      this.el.removeEventListener("pointerup", this.onClickEnd);
      super.destroy();
    }
  };

  // assets/scripts/modules/TeamList.js
  var TeamList_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.events = {
        click: {
          item: "onItemClick"
        }
      };
      this.$items = this.$("item");
    }
    init() {
      this.touchStartBind = () => {
        this.isTouch = true;
      };
      this.el.addEventListener("touchstart", this.touchStartBind, { once: true });
      this.leave = (e4) => {
        if (this.isTouch) return;
        this.call("setModel", false, "TeamListCanvas");
      };
      this.enter = (e4) => {
        if (this.isTouch) return;
        const infos = JSON.parse(this.getData("infos", e4.currentTarget));
        this.call("setModel", infos.model, "TeamListCanvas");
      };
      for (let item of this.$items) {
        item.addEventListener("focusout", this.leave);
        item.addEventListener("mouseleave", this.leave);
        item.addEventListener("mouseenter", this.enter);
        item.addEventListener("focusin", (e4) => {
          if (e4.target.classList.contains("focus-visible")) {
            this.enter(e4);
          }
        });
      }
      requestAnimationFrame(() => {
        this.checkUrl();
      });
    }
    checkUrl() {
      const url = new URL(window.location.href);
      const teamMemberId = url.searchParams.get("teamMember");
      const anim = url.searchParams.get("anim");
      if (anim) {
        this.call("setDefaultAnimation", anim, "TeamModalCanvas");
      }
      if (teamMemberId) {
        const teamMemberItem = Array.from(this.$items).map((item) => {
          let infos = JSON.parse(this.getData("infos", item));
          infos.listEl = item;
          return infos;
        }).find((item) => item.id == teamMemberId);
        teamMemberItem && this.call("show", teamMemberItem, "TeamModal");
        teamMemberItem && this.call("scrollTo", { target: teamMemberItem.listEl, options: {
          offset: -window.innerHeight / 2
        } }, "Scroll");
      }
    }
    onItemClick(e4) {
      let item = e4.curTarget;
      this.call("setModel", false, "TeamListCanvas");
      this.call("show", JSON.parse(this.getData("infos", item)), "TeamModal");
    }
    destroy() {
      this.el.removeEventListener("touchstart", this.touchStartBind);
      for (let item of this.$items) {
        item.removeEventListener("focusout", this.leave);
        item.removeEventListener("mouseleave", this.leave);
        item.removeEventListener("mouseenter", this.enter);
        item.removeEventListener("focusin", this.enter);
      }
    }
  };

  // assets/scripts/modules/TeamListCanvas.js
  var TeamListCanvas_default = class extends ModelViewer_default {
    constructor(m2) {
      super(m2);
      this.defaultAnimation = "walking";
    }
    init() {
      super.init();
    }
    render() {
      super.render();
      this.wrapper.rotation.set(0, this.wrapper.rotation.y + 0.02 * this.deltaTime / (1 / 60), 0);
    }
    initScene() {
      super.initScene();
      this.camera.position.set(1, 3, 5);
      this.controls.target.set(0, 0.75, 0);
      this.wrapper.scale.set(0.75, 0.75, 0.75);
    }
  };

  // node_modules/mustache/mustache.mjs
  var objectToString = Object.prototype.toString;
  var isArray2 = Array.isArray || function isArrayPolyfill(object) {
    return objectToString.call(object) === "[object Array]";
  };
  function isFunction(object) {
    return typeof object === "function";
  }
  function typeStr(obj) {
    return isArray2(obj) ? "array" : typeof obj;
  }
  function escapeRegExp(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function hasProperty(obj, propName) {
    return obj != null && typeof obj === "object" && propName in obj;
  }
  function primitiveHasOwnProperty(primitive, propName) {
    return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
  }
  var regExpTest = RegExp.prototype.test;
  function testRegExp(re2, string) {
    return regExpTest.call(re2, string);
  }
  var nonSpaceRe = /\S/;
  function isWhitespace(string) {
    return !testRegExp(nonSpaceRe, string);
  }
  var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;",
    "`": "&#x60;",
    "=": "&#x3D;"
  };
  function escapeHtml(string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s4) {
      return entityMap[s4];
    });
  }
  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;
  function parseTemplate(template2, tags) {
    if (!template2)
      return [];
    var lineHasNonSpace = false;
    var sections = [];
    var tokens = [];
    var spaces = [];
    var hasTag = false;
    var nonSpace = false;
    var indentation = "";
    var tagIndex = 0;
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }
      hasTag = false;
      nonSpace = false;
    }
    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags(tagsToCompile) {
      if (typeof tagsToCompile === "string")
        tagsToCompile = tagsToCompile.split(spaceRe, 2);
      if (!isArray2(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error("Invalid tags: " + tagsToCompile);
      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
      closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
    }
    compileTags(tags || mustache.tags);
    var scanner = new Scanner(template2);
    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;
      value = scanner.scanUntil(openingTagRe);
      if (value) {
        for (var i4 = 0, valueLength = value.length; i4 < valueLength; ++i4) {
          chr = value.charAt(i4);
          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
            indentation += chr;
          } else {
            nonSpace = true;
            lineHasNonSpace = true;
            indentation += " ";
          }
          tokens.push(["text", chr, start, start + 1]);
          start += 1;
          if (chr === "\n") {
            stripSpace();
            indentation = "";
            tagIndex = 0;
            lineHasNonSpace = false;
          }
        }
      }
      if (!scanner.scan(openingTagRe))
        break;
      hasTag = true;
      type = scanner.scan(tagRe) || "name";
      scanner.scan(whiteRe);
      if (type === "=") {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === "{") {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = "&";
      } else {
        value = scanner.scanUntil(closingTagRe);
      }
      if (!scanner.scan(closingTagRe))
        throw new Error("Unclosed tag at " + scanner.pos);
      if (type == ">") {
        token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
      } else {
        token = [type, value, start, scanner.pos];
      }
      tagIndex++;
      tokens.push(token);
      if (type === "#" || type === "^") {
        sections.push(token);
      } else if (type === "/") {
        openSection = sections.pop();
        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);
        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === "name" || type === "{" || type === "&") {
        nonSpace = true;
      } else if (type === "=") {
        compileTags(value);
      }
    }
    stripSpace();
    openSection = sections.pop();
    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
    return nestTokens(squashTokens(tokens));
  }
  function squashTokens(tokens) {
    var squashedTokens = [];
    var token, lastToken;
    for (var i4 = 0, numTokens = tokens.length; i4 < numTokens; ++i4) {
      token = tokens[i4];
      if (token) {
        if (token[0] === "text" && lastToken && lastToken[0] === "text") {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }
    return squashedTokens;
  }
  function nestTokens(tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];
    var token, section;
    for (var i4 = 0, numTokens = tokens.length; i4 < numTokens; ++i4) {
      token = tokens[i4];
      switch (token[0]) {
        case "#":
        case "^":
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case "/":
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }
    return nestedTokens;
  }
  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }
  Scanner.prototype.eos = function eos() {
    return this.tail === "";
  };
  Scanner.prototype.scan = function scan(re2) {
    var match = this.tail.match(re2);
    if (!match || match.index !== 0)
      return "";
    var string = match[0];
    this.tail = this.tail.substring(string.length);
    this.pos += string.length;
    return string;
  };
  Scanner.prototype.scanUntil = function scanUntil(re2) {
    var index2 = this.tail.search(re2), match;
    switch (index2) {
      case -1:
        match = this.tail;
        this.tail = "";
        break;
      case 0:
        match = "";
        break;
      default:
        match = this.tail.substring(0, index2);
        this.tail = this.tail.substring(index2);
    }
    this.pos += match.length;
    return match;
  };
  function Context2(view, parentContext) {
    this.view = view;
    this.cache = { ".": this.view };
    this.parent = parentContext;
  }
  Context2.prototype.push = function push(view) {
    return new Context2(view, this);
  };
  Context2.prototype.lookup = function lookup(name) {
    var cache = this.cache;
    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context3 = this, intermediateValue, names, index2, lookupHit = false;
      while (context3) {
        if (name.indexOf(".") > 0) {
          intermediateValue = context3.view;
          names = name.split(".");
          index2 = 0;
          while (intermediateValue != null && index2 < names.length) {
            if (index2 === names.length - 1)
              lookupHit = hasProperty(intermediateValue, names[index2]) || primitiveHasOwnProperty(intermediateValue, names[index2]);
            intermediateValue = intermediateValue[names[index2++]];
          }
        } else {
          intermediateValue = context3.view[name];
          lookupHit = hasProperty(context3.view, name);
        }
        if (lookupHit) {
          value = intermediateValue;
          break;
        }
        context3 = context3.parent;
      }
      cache[name] = value;
    }
    if (isFunction(value))
      value = value.call(this.view);
    return value;
  };
  function Writer() {
    this.templateCache = {
      _cache: {},
      set: function set2(key, value) {
        this._cache[key] = value;
      },
      get: function get(key) {
        return this._cache[key];
      },
      clear: function clear() {
        this._cache = {};
      }
    };
  }
  Writer.prototype.clearCache = function clearCache() {
    if (typeof this.templateCache !== "undefined") {
      this.templateCache.clear();
    }
  };
  Writer.prototype.parse = function parse(template2, tags) {
    var cache = this.templateCache;
    var cacheKey = template2 + ":" + (tags || mustache.tags).join(":");
    var isCacheEnabled = typeof cache !== "undefined";
    var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
    if (tokens == void 0) {
      tokens = parseTemplate(template2, tags);
      isCacheEnabled && cache.set(cacheKey, tokens);
    }
    return tokens;
  };
  Writer.prototype.render = function render4(template2, view, partials, config3) {
    var tags = this.getConfigTags(config3);
    var tokens = this.parse(template2, tags);
    var context3 = view instanceof Context2 ? view : new Context2(view, void 0);
    return this.renderTokens(tokens, context3, partials, template2, config3);
  };
  Writer.prototype.renderTokens = function renderTokens(tokens, context3, partials, originalTemplate, config3) {
    var buffer = "";
    var token, symbol, value;
    for (var i4 = 0, numTokens = tokens.length; i4 < numTokens; ++i4) {
      value = void 0;
      token = tokens[i4];
      symbol = token[0];
      if (symbol === "#") value = this.renderSection(token, context3, partials, originalTemplate, config3);
      else if (symbol === "^") value = this.renderInverted(token, context3, partials, originalTemplate, config3);
      else if (symbol === ">") value = this.renderPartial(token, context3, partials, config3);
      else if (symbol === "&") value = this.unescapedValue(token, context3);
      else if (symbol === "name") value = this.escapedValue(token, context3, config3);
      else if (symbol === "text") value = this.rawValue(token);
      if (value !== void 0)
        buffer += value;
    }
    return buffer;
  };
  Writer.prototype.renderSection = function renderSection(token, context3, partials, originalTemplate, config3) {
    var self2 = this;
    var buffer = "";
    var value = context3.lookup(token[1]);
    function subRender(template2) {
      return self2.render(template2, context3, partials, config3);
    }
    if (!value) return;
    if (isArray2(value)) {
      for (var j2 = 0, valueLength = value.length; j2 < valueLength; ++j2) {
        buffer += this.renderTokens(token[4], context3.push(value[j2]), partials, originalTemplate, config3);
      }
    } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
      buffer += this.renderTokens(token[4], context3.push(value), partials, originalTemplate, config3);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== "string")
        throw new Error("Cannot use higher-order sections without the original template");
      value = value.call(context3.view, originalTemplate.slice(token[3], token[5]), subRender);
      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context3, partials, originalTemplate, config3);
    }
    return buffer;
  };
  Writer.prototype.renderInverted = function renderInverted(token, context3, partials, originalTemplate, config3) {
    var value = context3.lookup(token[1]);
    if (!value || isArray2(value) && value.length === 0)
      return this.renderTokens(token[4], context3, partials, originalTemplate, config3);
  };
  Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
    var filteredIndentation = indentation.replace(/[^ \t]/g, "");
    var partialByNl = partial.split("\n");
    for (var i4 = 0; i4 < partialByNl.length; i4++) {
      if (partialByNl[i4].length && (i4 > 0 || !lineHasNonSpace)) {
        partialByNl[i4] = filteredIndentation + partialByNl[i4];
      }
    }
    return partialByNl.join("\n");
  };
  Writer.prototype.renderPartial = function renderPartial(token, context3, partials, config3) {
    if (!partials) return;
    var tags = this.getConfigTags(config3);
    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null) {
      var lineHasNonSpace = token[6];
      var tagIndex = token[5];
      var indentation = token[4];
      var indentedValue = value;
      if (tagIndex == 0 && indentation) {
        indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
      }
      var tokens = this.parse(indentedValue, tags);
      return this.renderTokens(tokens, context3, partials, indentedValue, config3);
    }
  };
  Writer.prototype.unescapedValue = function unescapedValue(token, context3) {
    var value = context3.lookup(token[1]);
    if (value != null)
      return value;
  };
  Writer.prototype.escapedValue = function escapedValue(token, context3, config3) {
    var escape2 = this.getConfigEscape(config3) || mustache.escape;
    var value = context3.lookup(token[1]);
    if (value != null)
      return typeof value === "number" && escape2 === mustache.escape ? String(value) : escape2(value);
  };
  Writer.prototype.rawValue = function rawValue(token) {
    return token[1];
  };
  Writer.prototype.getConfigTags = function getConfigTags(config3) {
    if (isArray2(config3)) {
      return config3;
    } else if (config3 && typeof config3 === "object") {
      return config3.tags;
    } else {
      return void 0;
    }
  };
  Writer.prototype.getConfigEscape = function getConfigEscape(config3) {
    if (config3 && typeof config3 === "object" && !isArray2(config3)) {
      return config3.escape;
    } else {
      return void 0;
    }
  };
  var mustache = {
    name: "mustache.js",
    version: "4.2.0",
    tags: ["{{", "}}"],
    clearCache: void 0,
    escape: void 0,
    parse: void 0,
    render: void 0,
    Scanner: void 0,
    Context: void 0,
    Writer: void 0,
    /**
     * Allows a user to override the default caching strategy, by providing an
     * object with set, get and clear methods. This can also be used to disable
     * the cache by setting it to the literal `undefined`.
     */
    set templateCache(cache) {
      defaultWriter.templateCache = cache;
    },
    /**
     * Gets the default or overridden caching object from the default writer.
     */
    get templateCache() {
      return defaultWriter.templateCache;
    }
  };
  var defaultWriter = new Writer();
  mustache.clearCache = function clearCache2() {
    return defaultWriter.clearCache();
  };
  mustache.parse = function parse2(template2, tags) {
    return defaultWriter.parse(template2, tags);
  };
  mustache.render = function render5(template2, view, partials, config3) {
    if (typeof template2 !== "string") {
      throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template2) + '" was given as the first argument for mustache#render(template, view, partials)');
    }
    return defaultWriter.render(template2, view, partials, config3);
  };
  mustache.escape = escapeHtml;
  mustache.Scanner = Scanner;
  mustache.Context = Context2;
  mustache.Writer = Writer;
  var mustache_default = mustache;

  // assets/scripts/modules/TeamModal.js
  var template = `
    <div class="c-team-modal_title || c-heading -h1">
        {{fancy-name}}
    </div>

    <div class="c-team-modal_infos">
        <dl class="c-team-modal_specs">
            {{# hasProjects }}
            <dt>{{ labels.projects }}</dt>
            <dd>
                <ul>
                    {{# projects }}
                    <li><a href="{{ url }}">{{ title }}</a></li>
                    {{/ projects }}
                </ul>
            </dd>
            {{/ hasProjects }}
            <dt>{{ labels.role }}</dt>
            <dd>{{ position }}</dd>
            <dt>{{ labels.since }}</dt>
            <dd>{{ arrival-year }}</dd>
        </dl>
    </div>
`;
  var TeamModal_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$infos = this.$("infos")[0];
      this.$canvas = this.$("canvas")[0];
      this.$dropdown = this.$("dropdown")[0];
      this.$dropdownLabel = this.$("dropdown-label")[0];
      this.members = Array.from(this.$("member"));
      this.labels = {
        "role": this.getData("role-label"),
        "since": this.getData("since-label"),
        "projects": this.getData("projects-label")
      };
      this.events = {
        click: {
          "member": "setMemberByEl",
          "close": "hide"
        },
        change: {
          "dropdown": "setMemberByDropdown"
        }
      };
    }
    init() {
      this.usdzReadyBind = (e4) => {
        if (!this.quickLookBtn) {
          this.quickLookBtn = document.createElement("a");
          this.quickLookBtn.rel = "ar";
          this.quickLookBtn.download = "asset.usdz";
          this.quickLookBtn.classList.add("c-team-modal_ar-btn");
          this.quickLookBtn.innerHTML = `<img src="https://threejs.org/examples/files/arkit.png">`;
          this.el.appendChild(this.quickLookBtn);
        }
        this.quickLookBtn.style.display = "";
        this.quickLookBtn.href = e4.detail.usdz;
      };
      this.hideUsdz = () => {
        if (this.quickLookBtn) this.quickLookBtn.style.display = "none";
      };
      this.$canvas.addEventListener("usdzReady", this.usdzReadyBind);
      this.$canvas.addEventListener("hideUsdz", this.hideUsdz);
      window.addEventListener("keydown", this.onKeyDown = (e4) => {
        if (e4.keyCode === 27 && this.el.classList.contains("-active")) {
          this.hide();
        }
      });
      this.focusTrap = createFocusTrap(this.el);
    }
    show(memberInfos) {
      memberInfos && this.setMember(memberInfos);
      this.el.classList.add("-active");
      this.call("resize", null, "TeamModalCanvas");
      this.focusTrap.activate();
      if (window.gtag) {
        gtag("event", "click", {
          "event_category": "team_modal",
          "event_label": "open"
        });
      }
    }
    hide() {
      this.updateUrl(false);
      this.el.classList.remove("-active");
      this.focusTrap.deactivate();
      this.call("setModel", false, "TeamModalCanvas");
      this.call("setDefaultAnimation", false, "TeamModalCanvas");
    }
    updateUrl(id) {
      const newURL = new URL(window.location.href);
      if (id)
        newURL.searchParams.set("teamMember", id);
      else {
        newURL.searchParams.delete("teamMember");
        newURL.searchParams.delete("anim");
      }
      history.replaceState(
        null,
        null,
        newURL.toString()
      );
    }
    setMember(infos) {
      this.updateUrl(infos.id);
      if (!infos["fancy-name"]) infos["fancy-name"] = infos.name;
      infos["hasProjects"] = infos["projects"] && infos["projects"].length > 0;
      infos["labels"] = this.labels;
      this.$infos.innerHTML = mustache_default.render(template, infos);
      this.$dropdown.value = infos.id;
      this.$dropdownLabel.innerText = infos["fancy-name"] || infos["name"];
      let oldMember = this.members.find((item) => item.classList.contains("-active"));
      oldMember && oldMember.classList.remove("-active");
      let newMember = this.members.find((item) => item.dataset.teamModalId == infos.id);
      newMember && newMember.classList.add("-active");
      this.call("setModel", infos.model, "TeamModalCanvas");
    }
    setMemberByEl(e4) {
      const infos = JSON.parse(this.getData("infos", e4.currentTarget));
      this.setMember(infos);
    }
    setMemberByDropdown(e4) {
      let dropdown = e4.curTarget;
      this.setMember(JSON.parse(dropdown.options[dropdown.selectedIndex].dataset.teamModalInfos));
    }
    destroy() {
      super.destroy();
      this.$canvas.removeEventListener("usdzReady", this.usdzReadyBind);
      this.$canvas.removeEventListener("hideUsdz", this.hideUsdz);
      this.focusTrap.deactivate();
    }
  };

  // assets/scripts/modules/TeamModalCanvas.js
  var TeamModalCanvas_default = class extends ModelViewer_default {
    constructor(m2) {
      super(m2);
    }
    init() {
      super.init();
      let clickStartTime;
      let clickStartPos;
      this.onClickStart = (e4) => {
        clickStartTime = Date.now();
        clickStartPos = {
          x: e4.touches ? e4.touches[0].screenX : e4.screenX,
          y: e4.touches ? e4.touches[0].screenY : e4.screenY
        };
      };
      this.onClickEnd = (e4) => {
        const deltaTime = Date.now() - clickStartTime;
        const clickEndPos = {
          x: e4.changedTouches ? e4.changedTouches[0].screenX : e4.screenX,
          y: e4.changedTouches ? e4.changedTouches[0].screenY : e4.screenY
        };
        let deltaPos = Math.abs(Math.sqrt(Math.pow(clickStartPos.x - clickEndPos.x, 2) + Math.pow(clickStartPos.y - clickEndPos.y, 2)));
        if (deltaTime < 250 && deltaPos < 10) {
          this.setModel(this.currentModel);
          if (window.gtag) {
            gtag("event", "click", {
              "event_category": "team_modal",
              "event_label": "change_dance"
            });
          }
        }
      };
      this.el.addEventListener("pointerdown", this.onClickStart);
      this.el.addEventListener("pointerup", this.onClickEnd);
    }
    initRenderer() {
      super.initRenderer();
    }
    initScene() {
      super.initScene();
      this.camera.position.set(-2, 2, 2.9);
      this.controls.target.set(0, 0.9, 0);
      this.controls.zoomSpeed = 0.5;
      this.controls.minDistance = 1;
      this.controls.maxDistance = 5;
      this.controls.maxPolarAngle = Math.PI * 0.6;
      this.controls.minPolarAngle = Math.PI * 0.3;
      var minPan = new Vector3(-1, -1, -1);
      var maxPan = new Vector3(1, 2, 1);
      var _v = new Vector3();
      this.onControlsChange = () => {
        _v.copy(this.controls.target);
        this.controls.target.clamp(minPan, maxPan);
        _v.sub(this.controls.target);
        this.camera.position.sub(_v);
      };
      this.controls.addEventListener("change", this.onControlsChange);
    }
    render() {
      super.render();
    }
    destroy() {
      this.controls.removeEventListener("change", this.onControlsChange);
      this.el.removeEventListener("pointerdown", this.onClickStart);
      this.el.removeEventListener("pointerup", this.onClickEnd);
      super.destroy();
    }
  };

  // assets/scripts/modules/VideoInview.js
  var VideoInview_default = class extends _default {
    constructor(m2) {
      super(m2);
    }
    init() {
      const script = this.el.querySelector("script");
      if (script) {
        const newScript = document.createElement("script");
        newScript.textContent = script.textContent;
        script.remove();
        this.el.appendChild(newScript);
      }
    }
    toggle(e4) {
      if (e4.target != this.el) return;
      if (e4.way === "enter") {
        if (this.el.paused) {
          this.timeout = setTimeout(() => {
            this.el.play();
          }, 200);
        }
      } else {
        if (!this.el.paused) {
          clearTimeout(this.timeout);
          this.el.pause();
        }
      }
    }
  };

  // assets/scripts/modules/VideoModal.js
  var VideoModal_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.events = {
        click: {
          close: "hide"
        }
      };
      this.inner = this.$("inner")[0];
    }
    init() {
      this.focusTrap = createFocusTrap(this.el, {
        onDeactivate: this.hide.bind(this),
        clickOutsideDeactivates: true
      });
    }
    toggle(e4) {
      if (this.el.classList.contains("is-active")) {
        this.hide();
      } else {
        this.show(e4);
      }
    }
    show(e4) {
      if (this.emptyTimeout) clearTimeout(this.emptyTimeout);
      this.appendDelay = setTimeout(() => {
        switch (e4.platform) {
          case "youtube":
            this.videoUrl = `https://www.youtube-nocookie.com/embed/${e4.id}?&autoplay=1`;
            this.inner.innerHTML = `<iframe src="${this.videoUrl}" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>`;
            break;
          case "vimeo":
            this.videoUrl = `https://player.vimeo.com/video/${e4.id}?dnt=1&autoplay=1&loop=1&autopause=0`;
            this.inner.innerHTML = `<iframe src="${this.videoUrl}" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>`;
            break;
          default:
            break;
        }
        requestAnimationFrame(() => {
          var _a;
          (_a = this.focusTrap) == null ? void 0 : _a.activate();
        });
      }, 500);
      this.el.classList.add("is-active");
    }
    hide() {
      var _a;
      clearTimeout(this.appendDelay);
      this.el.classList.remove("is-active");
      (_a = this.focusTrap) == null ? void 0 : _a.deactivate();
      this.emptyTimeout = setTimeout(() => {
        this.inner.innerHTML = "";
      }, 250);
    }
    destroy() {
      super.destroy();
    }
  };

  // assets/scripts/modules/VideoModalToggler.js
  var VideoModalToggler_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.events = {
        click: "onClick"
      };
    }
    init() {
    }
    onClick() {
      const id = this.getData("id");
      const platform = this.getData("platform");
      if (window.gtag) {
        gtag("event", "click", {
          "event_category": "video_modal",
          "event_label": `open`,
          "value": id
        });
      }
      this.call("toggle", { id, platform }, "VideoModal");
    }
  };

  // assets/scripts/modules/WorkFilters.js
  var import_core4 = __toESM(require_barba_umd(), 1);
  var WorkFilters_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$select = this.$("select")[0];
      this.$content = this.$("content")[0];
      this.$toggler = this.$("toggler")[0];
      this.$togglerOpenLabel = this.$("toggler-open-label")[0];
      this.$togglerCloseLabel = this.$("toggler-close-label")[0];
      this.$currentCategoryName = this.$("currentCategoryName")[0];
      this.$currentCategoryQty = this.$("currentCategoryQty")[0];
      this.events = {
        click: {
          "toggler": "toggle",
          "category-button": "onCategoryClick"
        },
        change: {
          "select": "onSelectChange"
        }
      };
    }
    init() {
      this.focusTrap = createFocusTrap(this.el, {
        onDeactivate: this.hide.bind(this),
        clickOutsideDeactivates: true
      });
    }
    toggle() {
      if (this.isOpened()) {
        this.hide();
      } else {
        this.show();
      }
    }
    isOpened() {
      return this.el.classList.contains("is-opened");
    }
    show() {
      this.el.classList.add("is-opened");
      this.$toggler.setAttribute("aria-expanded", "true");
      this.$togglerOpenLabel.classList.add("-hidden");
      this.$togglerCloseLabel.classList.remove("-hidden");
      this.focusTrap.activate();
    }
    hide() {
      this.el.classList.remove("is-opened");
      this.$toggler.setAttribute("aria-expanded", "false");
      this.$togglerOpenLabel.classList.remove("-hidden");
      this.$togglerCloseLabel.classList.add("-hidden");
      this.focusTrap.deactivate();
    }
    onSelectChange(e4) {
      const dropdown = e4.curTarget;
      this.filterByEl(dropdown.options[dropdown.selectedIndex]);
    }
    onCategoryClick(e4) {
      this.filterByEl(e4.curTarget);
      this.hide();
    }
    filterByEl(el) {
      const data = JSON.parse(el.dataset.workFiltersData);
      this.$select.value = data.slug;
      this.$currentCategoryName.innerText = data.name;
      this.$currentCategoryQty.innerText = (data.qty + "").padStart(2, "0");
      const href = window.location.pathname + "?category=" + data.slug;
      const trigger2 = document.createElement("a");
      trigger2.href = href;
      trigger2.setAttribute("data-load-transition", "work-list");
      import_core4.default.go(href, trigger2);
    }
    destroy() {
      super.destroy();
      this.focusTrap.deactivate();
    }
  };

  // assets/scripts/modules/WorkGallery.js
  var WorkGallery_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.slides = Array.from(this.$("slide"));
      this.count = 0;
    }
    init() {
      this.el.addEventListener("mouseenter", () => {
        this.compute();
        clearInterval(this.interval);
        this.changeSlide();
        this.interval = setInterval(this.changeSlide.bind(this), 500);
      });
      this.el.addEventListener("mouseleave", () => {
        clearInterval(this.interval);
      });
    }
    changeSlide() {
      this.count++;
      gsapWithCSS.set(this.slides, { opacity: 0 });
      gsapWithCSS.set(this.slides[this.count % this.slides.length], { opacity: 1 });
    }
    compute() {
      this.BCR = this.el.getBoundingClientRect();
    }
  };

  // assets/scripts/modules/WorkListItem.js
  var WorkListItem_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$toggler = this.$("toggler")[0];
      this.$content = this.$("content")[0];
      this.$contentInner = this.$("content-inner")[0];
      this.list = this.getData("list");
      this.animationOpenDuration = 0.5;
      this.animationCloseDuration = 0.3;
      this.$preview = this.$("preview")[0];
      this.$previewTarget = this.$("preview-target")[0];
      this.images = Array.from(this.$("image"));
      this.events = {
        click: {
          toggler: "toggle"
        }
      };
      this.compute();
    }
    init() {
      this.computeBind = this.compute.bind(this);
      window.addEventListener("resize", this.computeBind);
      this.touchStartBind = () => {
        this.isTouch = true;
      };
      this.el.addEventListener("touchstart", this.touchStartBind, { once: true });
      this.enter = (e4) => {
        if (this.isTouch) return;
        if (!this.$preview) return;
        const img = this.$preview.querySelector("img");
        if (!this.$preview.classList.contains("-loaded")) {
          lazyLoadImage(img, null, () => {
            animDepixelate(img);
          });
        } else {
          animDepixelate(img);
        }
      };
      this.el.addEventListener("mouseenter", this.enter);
      this.el.addEventListener("focusin", this.enter);
    }
    /**
     * Toggler
     *
     * @param item {node}
     */
    toggle(e4) {
      if (this.isOpened()) {
        this.close();
      } else {
        this.open();
      }
    }
    isOpened() {
      return this.el.classList.contains("is-opened");
    }
    compute() {
      this.isMobile = window.innerWidth < 700;
      this.canHover = window.matchMedia("(hover: hover)").matches;
      this.canAnimatePreview = this.canHover && !this.isMobile;
    }
    /**
     * open
     *
     * @param parentNode item {node}
     */
    open() {
      const previousActiveItem = {
        el: document.body.querySelector("[data-module-work-list-item].is-opened")
      };
      if (previousActiveItem.el) {
        previousActiveItem.content = this.$("content", previousActiveItem.el)[0];
        previousActiveItem.contentBCR = previousActiveItem.content.getBoundingClientRect();
      }
      this.call("close", this.list, "WorkListItem");
      this.$toggler.setAttribute("aria-expanded", "true");
      if (this.getData("label-close", this.$toggler)) this.$toggler.children[0].innerText = this.getData("label-close", this.$toggler);
      this.el.classList.add("is-opened");
      gsapWithCSS.set(this.$content, { display: "block" });
      const headerHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--header-height")) * parseFloat(getComputedStyle(document.documentElement).fontSize);
      const innerBCR = this.$contentInner.getBoundingClientRect();
      let offset2 = -headerHeight;
      if (this.el.previousElementSibling != previousActiveItem.el && previousActiveItem.contentBCR && previousActiveItem.contentBCR.top < innerBCR.top) offset2 -= previousActiveItem.contentBCR.height;
      this.call("scrollTo", { target: this.el.previousElementSibling ? this.el.previousElementSibling : this.el, options: { offset: offset2, duration: this.animationOpenDuration } }, "Scroll");
      for (let image2 of [...this.images, this.$previewTarget]) {
        if (!image2) continue;
        let img = image2.querySelector("img");
        lazyLoadImage(img, null, () => {
          if (this.canAnimatePreview) {
            if (image2.dataset.workListItem != "preview-target")
              animDepixelate(img);
          } else {
            animDepixelate(img);
          }
        });
      }
      if (this.tw && this.tw.kill) this.tw.kill();
      gsapWithCSS.set(this.$preview, { clearProps: "all" });
      if (this.canAnimatePreview) {
        gsapWithCSS.set(this.$preview, { opacity: 1 });
        gsapWithCSS.set(this.$previewTarget, { opacity: 0 });
      }
      const previewBCR = this.$preview.getBoundingClientRect();
      const previewTargetBCR = this.$previewTarget.getBoundingClientRect();
      const previewOffset = {
        top: previewTargetBCR.top - previewBCR.top + previewBCR.height / 2,
        left: previewTargetBCR.left - previewBCR.left,
        scale: previewTargetBCR.width / previewBCR.width
      };
      this.tw = gsapWithCSS.timeline({
        onComplete: () => {
          if (this.canAnimatePreview) {
            gsapWithCSS.set([this.$preview, this.$previewTarget], { clearProps: "all" });
            gsapWithCSS.set(this.$preview, { opacity: 0 });
          }
        }
      });
      if (this.canAnimatePreview) {
        this.tw.to(this.$preview, {
          duration: this.animationOpenDuration,
          x: previewOffset.left,
          y: previewOffset.top,
          scale: previewOffset.scale,
          ease: "power4.out",
          force3D: true
        }, 0);
      }
      this.tw.fromTo(this.$content, { opacity: 0 }, {
        duration: this.animationOpenDuration * 2 / 3,
        opacity: 1
      }, this.animationOpenDuration * 1 / 3);
      this.tw.to(this.$content, {
        duration: this.animationOpenDuration,
        height: innerBCR.height
      }, 0);
      if (window.gtag) {
        gtag("event", "click", {
          "event_category": "work_accordions",
          "event_label": "open"
        });
      }
    }
    /**
     * Close
     *
     * @param
     */
    close(list = void 0) {
      if (list && list != this.list || !this.el.classList.contains("is-opened")) return;
      this.$toggler.setAttribute("aria-expanded", "false");
      if (this.getData("label-open", this.$toggler)) this.$toggler.children[0].innerText = this.getData("label-open", this.$toggler);
      this.el.classList.remove("is-opened");
      if (this.tw && this.tw.kill) this.tw.kill();
      gsapWithCSS.set(this.$preview, { clearProps: "all" }, 0);
      if (this.canAnimatePreview)
        gsapWithCSS.set(this.$previewTarget, { opacity: 0 });
      const previewBCR = this.$preview.getBoundingClientRect();
      const previewTargetBCR = this.$previewTarget.getBoundingClientRect();
      const previewOffset = {
        top: previewTargetBCR.top - previewBCR.top + previewBCR.height / 2,
        left: previewTargetBCR.left - previewBCR.left,
        scale: previewTargetBCR.width / previewBCR.width
      };
      this.tw = gsapWithCSS.timeline({
        onComplete: () => {
          gsapWithCSS.set(this.$content, { clearProps: "display" });
          if (this.canAnimatePreview)
            gsapWithCSS.set([this.$preview, this.$previewTarget], { clearProps: "all" });
        }
      });
      if (this.canAnimatePreview) {
        this.tw.from(this.$preview, {
          duration: this.animationCloseDuration,
          x: previewOffset.left,
          y: previewOffset.top,
          scale: previewOffset.scale,
          ease: "power4.out",
          force3D: true
        }, 0);
      }
      this.tw.to(this.$content, {
        duration: this.animationCloseDuration,
        height: 0,
        opacity: 0
      }, 0);
    }
    inview(e4) {
      if (e4.target == this.el) {
        if (!this.canAnimatePreview && this.isMobile && !this.$preview.classList.contains("-loaded")) {
          let img = this.$preview.querySelector("img");
          lazyLoadImage(img, null, () => {
            if (this.canAnimatePreview) {
              if (image.dataset.workListItem != "preview-target")
                animDepixelate(img);
            } else {
              animDepixelate(img);
            }
          });
        }
      }
    }
    destroy() {
      window.removeEventListener("resize", this.computeBind);
      this.el.removeEventListener("mouseenter", this.enter);
      this.el.removeEventListener("focusin", this.enter);
    }
  };

  // assets/scripts/modules/WorkNext.js
  var import_core5 = __toESM(require_barba_umd(), 1);
  var WorkNext_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$link = this.$("link")[0];
      this.$image = this.$("image")[0];
    }
    init() {
      const href = this.$link.href;
      if (!import_core5.default.cache.has(href)) {
        import_core5.default.cache.set(
          href,
          import_core5.default.request(
            href,
            import_core5.default.timeout,
            import_core5.default["onRequestError"].bind(import_core5.default, "barba")
            // tslint:disable-line:no-string-literal
          ).catch((error) => {
            console.error(error);
          }),
          "prefetch"
        );
      } else {
        import_core5.default.cache.update(href, { action: "prefetch" });
      }
      this.timeline = gsapWithCSS.timeline({
        onComplete: () => {
          console.log("onComplete");
          this.call("manualGo", this.$link, "Load");
        }
      });
      this.timeline.from(this.$image, {
        y: "100%",
        // ease: 'linear.none',
        duration: 0.75
      }, 0.25);
      this.timeline.add(() => {
      }, 1);
      this.timeline.pause();
    }
    onScrollProgress(progress) {
      var _a;
      (_a = this.timeline) == null ? void 0 : _a.progress(progress);
    }
  };

  // assets/scripts/modules/WorkSingleHero.js
  var WorkSingleHero_default = class extends _default {
    constructor(m2) {
      super(m2);
      this.$gridBottom = this.$("grid-bottom")[0];
      this.$title = this.$("title")[0];
    }
    init() {
      this.compute();
      this.checkResizeBind = this.checkResize.bind(this);
      window.addEventListener("resize", this.checkResizeBind);
    }
    checkResize() {
      if (!this.resizeTick) {
        this.resizeTick = true;
        requestAnimationFrame(() => {
          this.compute();
          this.resizeTick = false;
        });
      }
    }
    compute() {
      this.$gridBottom.style.setProperty("--first-row-size", "");
      const gridBottomBCR = this.$gridBottom.getBoundingClientRect();
      const titleBCR = this.$title.getBoundingClientRect();
      this.$gridBottom.style.setProperty("--first-row-size", `max(${titleBCR.height}px, calc(${gridBottomBCR.height}px - var(--second-row-size) - var(--grid-gutter) * 2))`);
    }
    destroy() {
      window.removeEventListener("resize", this.checkResizeBind);
    }
  };

  // assets/scripts/globals.js
  var import_svg4everybody = __toESM(require_svg4everybody(), 1);
  function globals_default() {
    (0, import_svg4everybody.default)();
    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
    window.isMobile = isMobile;
    if (window.isMobile) {
      html2.classList.add("is-mobile");
    }
    const isDebug2 = html2.dataset.debug == "true" ? true : false;
    window.isDebug = isDebug2;
    if (window.isDebug) {
      html2.classList.add("is-debug");
    }
    let viewportWidth = window.innerWidth;
    html2.style.setProperty(
      "--vh",
      `${window.innerHeight * 0.01}px`
    );
    window.addEventListener("resize", () => {
      if (window.innerWidth != viewportWidth && window.matchMedia("(hover: none)")) {
        viewportWidth = window.innerWidth;
        html2.style.setProperty(
          "--vh",
          `${window.innerHeight * 0.01}px`
        );
      }
    });
  }

  // assets/scripts/preloader.js
  gsapWithCSS.registerPlugin(SplitText);
  function animatePreloader() {
    const preloader = document.getElementById("preloader");
    const head = document.getElementById("preloaderHead");
    const content = document.getElementById("preloaderContent");
    const logo = document.getElementById("preloaderLogo");
    const STAGGER = 0.01;
    const VISIBLE_DURATION = 0.5;
    const CHARACTERS = "!@#$%&+=qertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM\\/{}][-_()<>?".split("");
    const tl = gsapWithCSS.timeline({
      onComplete: () => {
        setTimeout(() => {
          preloader.remove();
        }, 1e3);
      }
    });
    if (sessionStorage.getItem("locomotive.quickpreload") == "true") {
      let logoChildren = shuffle3(Array.from(logo.children));
      tl.set(logoChildren, { opacity: 0, stagger: 0.025 }, 0);
      tl.add(window.preloaderPromiseResolve, 0.1);
    } else {
      sessionStorage.setItem("locomotive.quickpreload", "true");
      gsapWithCSS.set([content], { clearProps: "display" });
      const contentBlocksSplits = [];
      for (let el of content.children) {
        contentBlocksSplits.push(new SplitText(el, { type: "chars, lines" }));
      }
      let logoChildren = shuffle3(Array.from(logo.children));
      tl.set(logoChildren, { opacity: 0, stagger: 0.05 }, 0.25);
      for (let block = 0; block < contentBlocksSplits.length; block++) {
        const split = contentBlocksSplits[block];
        for (let i4 = 0; i4 < split.chars.length; i4++) {
          const char = split.chars[i4];
          tl.set(char, {
            opacity: 0
          }, 0);
          tl.set(char, {
            opacity: 1
          }, block * 0.25 + i4 * STAGGER);
          tl.add(() => {
            const original = char.innerText;
            for (let j2 = 0; j2 < 5; j2++) {
              setTimeout(() => {
                char.innerText = CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];
              }, j2 * 16);
            }
            setTimeout(() => {
              char.innerText = original;
            }, 5 * 16);
          }, block * 0.25 + i4 * STAGGER);
          let disappearDelay = block * 0.25 + i4 * STAGGER + VISIBLE_DURATION;
          if (char.parentNode == split.lines[split.lines.length - 1]) {
            disappearDelay = block * 0.25 + i4 * STAGGER + VISIBLE_DURATION + 1;
          }
          tl.add(() => {
            for (let j2 = 0; j2 < 5; j2++) {
              setTimeout(() => {
                char.innerText = CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];
              }, j2 * 16);
            }
            setTimeout(() => {
              gsapWithCSS.set(char, { opacity: 0 });
              if (char.parentNode == split.lines[split.lines.length - 1])
                window.preloaderPromiseResolve();
            }, 5 * 16);
          }, disappearDelay);
        }
      }
    }
  }

  // assets/scripts/app.js
  var app = new main_esm_default({
    modules: modules_exports
  });
  window.onload = (event2) => {
    const $style = document.getElementById("main-css");
    if ($style) {
      if ($style.isLoaded) {
        init4();
      } else {
        $style.addEventListener("load", (event3) => {
          init4();
        });
      }
    } else {
      console.warn('The "main-css" stylesheet not found');
    }
  };
  function init4() {
    html2.classList.remove("has-no-js");
    globals_default();
    app.init(app);
    window.preloaderEnterPromise.then(() => {
      animatePreloader();
    });
    window.preloaderPromise.then(() => {
      html2.classList.add("is-loaded");
      html2.classList.add("is-ready");
      html2.classList.remove("is-first-loading");
      html2.classList.remove("is-loading");
    });
  }
})();
/*! Bundled license information:

filepond/dist/filepond.js:
  (*!
   * FilePond 4.30.4
   * Licensed under MIT, https://opensource.org/licenses/MIT/
   * Please visit https://pqina.nl/filepond/ for details.
   *)

vue-filepond/dist/vue-filepond.js:
  (*!
   * vue-filepond v7.0.3
   * A handy FilePond adapter component for Vue
   * 
   * Copyright (c) 2022 PQINA
   * https://pqina.nl/filepond
   * 
   * Licensed under the MIT license.
   *)

filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.js:
  (*!
   * FilePondPluginFileValidateType 1.2.8
   * Licensed under MIT, https://opensource.org/licenses/MIT/
   * Please visit https://pqina.nl/filepond/ for details.
   *)

filepond-plugin-file-validate-size/dist/filepond-plugin-file-validate-size.js:
  (*!
   * FilePondPluginFileValidateSize 2.2.7
   * Licensed under MIT, https://opensource.org/licenses/MIT/
   * Please visit https://pqina.nl/filepond/ for details.
   *)

svg4everybody/dist/svg4everybody.js:
  (*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody *)

vanilla-cookieconsent/dist/cookieconsent.esm.js:
  (*!
  * CookieConsent 3.0.0-rc.17
  * https://github.com/orestbida/cookieconsent/tree/v3.0-beta
  * Author Orest Bida
  * Released under the MIT License
  *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.11.3
   * https://greensock.com
   *
   * @license Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.11.3
   * https://greensock.com
   *
   * Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/utils/strings.js:
  (*!
   * strings: 3.11.3
   * https://greensock.com
   *
   * Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/SplitText.js:
  (*!
   * SplitText: 3.11.3
   * https://greensock.com
   *
   * @license Copyright 2008-2022, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.0.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.0.0
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2024 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
//# sourceMappingURL=app.js.map
